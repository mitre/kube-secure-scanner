{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Secure CINC Auditor Kubernetes Container Scanning","text":"<p>This project provides a comprehensive platform for securely scanning Kubernetes containers through multiple methodologies, leveraging CINC Auditor (open source InSpec) with security-focused RBAC configurations. It enables secure container compliance scanning across both standard and distroless containers in any Kubernetes environment.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"#project-overview","title":"Project Overview","text":"<p>Our solution offers three distinct technical approaches for container scanning:</p> <ol> <li>Kubernetes API Approach (Enterprise Recommended): Direct API-based scanning through the Kubernetes API using the train-k8s-container plugin. This is our recommended enterprise solution with future distroless support in development, offering the most scalable and seamless integration. Once distroless support is implemented, this will be a universal solution for all container types.</li> <li>Debug Container Approach: Ephemeral debug container with chroot-based scanning for distroless containers, ideal for environments with ephemeral container support.</li> <li>Sidecar Container Approach: CINC Auditor sidecar container with shared process namespace for any container type, offering universal compatibility across Kubernetes versions.</li> </ol> <p>These approaches can be deployed via: - Self-contained shell scripts for direct management and testing - Modular Helm charts for declarative, enterprise deployment - CI/CD integration with GitHub Actions and GitLab CI for both minikube-based and existing Kubernetes clusters</p> <p>The platform works in both local minikube environments and existing production Kubernetes clusters, with specialized security controls that address the fundamental challenges of privileged container scanning:</p> <ol> <li>Least Privilege Access - Restrict scanning to specific containers only</li> <li>Dynamic Access Control - Create temporary, targeted access for scanning</li> <li>CI/CD Integration - Ready-to-use scripts and templates for pipeline integration</li> <li>Threshold Validation - Integration with MITRE SAF CLI for compliance validation</li> <li>Distroless Support - Specialized approach for scanning distroless containers</li> <li>Modular Deployment - Supporting both script-based and Helm-based approaches</li> </ol>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#security-focused-design","title":"Security-Focused Design","text":"<ul> <li>No permanent elevated privileges</li> <li>No shared access between scans</li> <li>Time-limited token generation (default: 15 minutes)</li> <li>Fine-grained RBAC controls</li> <li>Namespace isolation</li> </ul>"},{"location":"#flexibility","title":"Flexibility","text":"<ul> <li>Support for label-based scanning</li> <li>Support for named resource restrictions</li> <li>Multiple deployment methods (scripts or Helm)</li> <li>Configurable threshold validation</li> <li>Modular Helm chart structure</li> </ul>"},{"location":"#ease-of-use","title":"Ease of Use","text":"<ul> <li>Comprehensive documentation</li> <li>Ready-to-use scripts</li> <li>Helm chart deployment</li> <li>Example profiles and configurations</li> <li>GitHub Actions and GitLab CI integration</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Quickstart Guide</li> <li>Security Considerations</li> <li>Executive Summary</li> <li>Approach Decision Matrix</li> <li>Security Risk Analysis</li> <li>Enterprise Integration Analysis</li> </ul>"},{"location":"#scanning-approaches","title":"Scanning Approaches","text":"<ul> <li>Kubernetes API Approach (Enterprise Recommended)</li> <li>Debug Container Approach</li> <li>Sidecar Container Approach</li> <li>Direct Commands Reference</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>GitLab CI with Services</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"debugging-distroless/","title":"Debugging Distroless Containers","text":"<p>This guide explains how to \"shell into\" a distroless container for debugging purposes, even though distroless containers don't include a shell by design.</p>"},{"location":"debugging-distroless/#the-challenge-with-distroless-containers","title":"The Challenge with Distroless Containers","text":"<p>Distroless containers intentionally don't include shells, package managers, or other debugging tools. This is excellent for security but presents challenges when you need to:</p> <ul> <li>Debug running applications</li> <li>Troubleshoot issues</li> <li>Inspect the container's filesystem</li> <li>Analyze running processes</li> </ul>"},{"location":"debugging-distroless/#solution-kubernetes-ephemeral-containers","title":"Solution: Kubernetes Ephemeral Containers","text":"<p>Kubernetes provides a feature called \"ephemeral containers\" that allows you to attach a debugging container to a running pod without modifying the pod specification.</p>"},{"location":"debugging-distroless/#debugging-a-distroless-container","title":"Debugging a Distroless Container","text":""},{"location":"debugging-distroless/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster v1.18+ (ephemeral containers are beta in v1.23+)</li> <li>kubectl v1.18+</li> <li>Appropriate permissions to create ephemeral containers</li> </ul>"},{"location":"debugging-distroless/#basic-approach","title":"Basic Approach","text":"<pre><code># Shell into a distroless container using kubectl debug\nkubectl debug -it &lt;pod-name&gt; --image=busybox:latest --target=&lt;container-name&gt;\n</code></pre> <p>This command: 1. Creates a new ephemeral container using the busybox image 2. Attaches it to the specified pod 3. Targets the specified container within the pod 4. Opens an interactive terminal session</p>"},{"location":"debugging-distroless/#step-by-step-example","title":"Step-by-Step Example","text":"<ol> <li>First, identify your distroless pod and container</li> </ol> <pre><code># List all pods\nkubectl get pods -n &lt;namespace&gt;\n\n# Describe the pod to find container names\nkubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;\n</code></pre> <ol> <li>Try to shell into the container directly (this will fail for distroless)</li> </ol> <pre><code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -c &lt;container-name&gt; -- /bin/sh\n# This will fail with something like: \"OCI runtime exec failed: exec failed: container_linux.go:380: \n# starting container process caused: exec: \"/bin/sh\": stat /bin/sh: no such file or directory\"\n</code></pre> <ol> <li>Use kubectl debug to attach a debugging container</li> </ol> <pre><code>kubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; \\\n  --image=busybox:latest \\\n  --target=&lt;container-name&gt; \\\n  --share-processes\n</code></pre> <p>Important: This command does NOT drop you into the distroless container's shell (since it doesn't have one). Instead, it launches a new debug container with its own shell and binaries, which runs alongside your distroless container in the same pod. You'll be in the shell of this debug container, not the distroless container itself.</p> <ol> <li>Access the distroless container's filesystem</li> </ol> <p>Once inside the debug container, you can access the target container's filesystem:</p> <pre><code># Find the process IDs of the target container\nps aux\n\n# Look for the main process of your application\n# For example, if your app is a Java application:\nps aux | grep java\n\n# Once you have the PID, you can access the container's filesystem\nls -la /proc/&lt;PID&gt;/root/\n\n# Change directory to explore the target container's filesystem\ncd /proc/&lt;PID&gt;/root/\n</code></pre>"},{"location":"debugging-distroless/#advanced-debugging-with-additional-tools","title":"Advanced Debugging with Additional Tools","text":"<p>You might need more advanced debugging tools. In that case, use a more feature-rich debug image:</p> <pre><code># Using a debug image with more tools\nkubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; \\\n  --image=nicolaka/netshoot \\\n  --target=&lt;container-name&gt;\n</code></pre> <p>Popular debug images include: - <code>busybox:latest</code> - Minimal utilities - <code>alpine:latest</code> - Lightweight with package manager - <code>nicolaka/netshoot</code> - Network troubleshooting tools - <code>ubuntu:latest</code> - Full featured OS for debugging</p>"},{"location":"debugging-distroless/#example-debug-a-spring-boot-distroless-application","title":"Example: Debug a Spring Boot Distroless Application","text":"<pre><code># Find the pod running the Spring application\nkubectl get pods -n production | grep spring-app\n\n# Try to shell in directly (will fail)\nkubectl exec -it spring-app-pod-abc123 -n production -c app -- /bin/sh\n# Error: OCI runtime exec failed: exec failed: container_linux.go:380: ...\n\n# Attach debug container\nkubectl debug -it spring-app-pod-abc123 -n production \\\n  --image=eclipse-temurin:17 \\\n  --target=app \\\n  --share-processes\n\n# Inside the debug container, find Java process\nps aux | grep java\n\n# Example output: \n# 1 user  3213200 ... java -jar /app/spring-boot-app.jar\n\n# Access filesystem and explore\ncd /proc/1/root/\nls -la\n\n# Check application logs\ncat /proc/1/root/logs/application.log\n\n# Check config files\ncat /proc/1/root/app/application.properties\n</code></pre>"},{"location":"debugging-distroless/#security-considerations","title":"Security Considerations","text":"<p>Remember that adding a debug container temporarily increases the attack surface of your pod. Best practices:</p> <ol> <li>Use ephemeral debugging only when needed</li> <li>Apply RBAC restrictions to limit who can create ephemeral containers</li> <li>Choose the minimal debug image needed for your task</li> <li>Avoid leaving debug containers running longer than necessary</li> </ol>"},{"location":"debugging-distroless/#notes-for-cicd-environments","title":"Notes for CI/CD Environments","text":"<p>When using ephemeral containers in CI/CD pipelines for security scanning:</p> <ol> <li>Create appropriate service accounts with limited permissions</li> <li>Use the minimal debug image needed for scanning</li> <li>Make sure to properly clean up ephemeral containers after scanning</li> <li>Consider using specialized InSpec profiles for distroless containers</li> <li>Focus scans on filesystem analysis rather than command execution</li> </ol>"},{"location":"debugging-distroless/#troubleshooting","title":"Troubleshooting","text":""},{"location":"debugging-distroless/#ephemeral-containers-are-disabled-for-this-cluster","title":"\"ephemeral containers are disabled for this cluster\"","text":"<p>Your Kubernetes cluster doesn't have the feature enabled. Check Kubernetes version and feature gates.</p>"},{"location":"debugging-distroless/#permission-denied","title":"Permission denied","text":"<p>You need RBAC permissions for pods/ephemeralcontainers. Ensure your service account has the right privileges.</p>"},{"location":"debugging-distroless/#cant-access-filesystem","title":"Can't access filesystem","text":"<p>Make sure you're using the correct process ID. Use <code>ps aux</code> to identify the main process in the target container.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"direct-commands/","title":"Helper Scripts vs. Direct Commands","text":"<p>This document explains how to use both our helper scripts and the equivalent direct commands for container scanning operations.</p>"},{"location":"direct-commands/#understanding-the-two-approaches","title":"Understanding the Two Approaches","text":"<p>Our container scanning solution can be used in two ways:</p> <ol> <li>Helper Scripts: Easy-to-use wrapper scripts that handle the complexity</li> <li>Direct Commands: Using the underlying tools directly for more control</li> </ol>"},{"location":"direct-commands/#container-scanning-with-helper-scripts-vs-direct-commands","title":"Container Scanning with Helper Scripts vs. Direct Commands","text":""},{"location":"direct-commands/#setup-minikube-for-testing","title":"Setup Minikube for Testing","text":"Helper Script Direct Commands <code>./scripts/setup-minikube.sh --nodes=2 --with-distroless</code> <code>bash&lt;br&gt;minikube start --nodes=2&lt;br&gt;kubectl create namespace inspec-test&lt;br&gt;kubectl -n inspec-test create serviceaccount inspec-scanner&lt;br&gt;# Create RBAC manually with kubectl apply&lt;br&gt;</code>"},{"location":"direct-commands/#creating-scanning-infrastructure","title":"Creating Scanning Infrastructure","text":""},{"location":"direct-commands/#with-helper-scripts","title":"With Helper Scripts","text":"<pre><code># Install all components with a single script\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"direct-commands/#with-direct-commands","title":"With Direct Commands","text":"<pre><code># Install each component separately\nkubectl create namespace inspec-test\n\n# Create the service account\nkubectl -n inspec-test create serviceaccount inspec-scanner\n\n# Create the role\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\nEOF\n\n# Create the role binding\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-scanner\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n\n# Create a test pod\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: inspec-target\n  namespace: inspec-test\n  labels:\n    app: inspec-target\n    scan-target: \"true\"\nspec:\n  containers:\n  - name: busybox\n    image: busybox:latest\n    command: [\"sleep\", \"infinity\"]\nEOF\n</code></pre>"},{"location":"direct-commands/#creating-authentication","title":"Creating Authentication","text":""},{"location":"direct-commands/#with-helper-scripts_1","title":"With Helper Scripts","text":"<pre><code># Generate kubeconfig automatically\n./scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n</code></pre>"},{"location":"direct-commands/#with-direct-commands_1","title":"With Direct Commands","text":"<pre><code># Generate token\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=60m)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create kubeconfig manually\ncat &gt; ./kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: inspec-scanner\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: inspec-scanner\n  user:\n    token: ${TOKEN}\nEOF\n\nchmod 600 ./kubeconfig.yaml\n</code></pre>"},{"location":"direct-commands/#running-a-standard-container-scan","title":"Running a Standard Container Scan","text":""},{"location":"direct-commands/#with-helper-scripts_2","title":"With Helper Scripts","text":"<pre><code># One-line scan with automatic RBAC, token, and threshold validation\n./scripts/scan-container.sh inspec-test inspec-target busybox ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"direct-commands/#with-direct-commands_2","title":"With Direct Commands","text":"<pre><code># Run CINC Auditor directly\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"direct-commands/#scanning-distroless-containers","title":"Scanning Distroless Containers","text":""},{"location":"direct-commands/#with-helper-scripts_3","title":"With Helper Scripts","text":"<pre><code># One-line scan of distroless container with ephemeral debug container\n./scripts/scan-distroless-container.sh inspec-test distroless-target distroless ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"direct-commands/#with-direct-commands_3","title":"With Direct Commands","text":"<pre><code># Create debug container manually\nkubectl debug -n inspec-test distroless-target \\\n  --image=docker.io/cincproject/auditor:latest \\\n  --target=distroless \\\n  --container=debug-container \\\n  -- sleep 300 &amp;\n\n# Wait for debug container to be ready\nsleep 10\n\n# Run scan against debug container\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/distroless-target/debug-container \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"direct-commands/#using-helm-for-deployment","title":"Using Helm for Deployment","text":""},{"location":"direct-commands/#with-helper-scripts_4","title":"With Helper Scripts","text":"<pre><code># Install everything with a single command\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"direct-commands/#with-direct-commands_4","title":"With Direct Commands","text":"<pre><code># Install each chart separately\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"direct-commands/#saf-cli-integration","title":"SAF CLI Integration","text":""},{"location":"direct-commands/#with-helper-scripts_5","title":"With Helper Scripts","text":"<pre><code># Threshold validation is built into the scan scripts\n./scripts/scan-container.sh inspec-test inspec-target busybox ./examples/cinc-profiles/container-baseline ./threshold.yml\n</code></pre>"},{"location":"direct-commands/#with-direct-commands_5","title":"With Direct Commands","text":"<pre><code># Run scan and get results\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Generate summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Apply threshold validation\nsaf threshold -i scan-results.json -t threshold.yml\nTHRESHOLD_RESULT=$?\n\nif [ $THRESHOLD_RESULT -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\n  exit $THRESHOLD_RESULT\nfi\n</code></pre>"},{"location":"direct-commands/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"direct-commands/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Run container scan\n  run: |\n    # Helper script method\n    ./scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"direct-commands/#gitlab-ci","title":"GitLab CI","text":"<pre><code>run_scan:\n  stage: scan\n  script:\n    # Helper script method\n    ./scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"direct-commands/#which-method-to-choose","title":"Which Method to Choose?","text":""},{"location":"direct-commands/#use-helper-scripts-when","title":"Use Helper Scripts When:","text":"<ul> <li>You want a simpler, more streamlined experience</li> <li>You're new to Kubernetes or CINC Auditor</li> <li>You need to quickly implement scanning in CI/CD</li> <li>You want automatic cleanup of temporary resources</li> </ul>"},{"location":"direct-commands/#use-direct-commands-when","title":"Use Direct Commands When:","text":"<ul> <li>You need more control over the process</li> <li>You're integrating with existing automation</li> <li>You want to understand what's happening \"under the hood\"</li> <li>You need to customize the scanning process</li> </ul>"},{"location":"direct-commands/#known-limitations","title":"Known Limitations","text":""},{"location":"direct-commands/#helper-scripts","title":"Helper Scripts:","text":"<ul> <li>Less flexibility for advanced use cases</li> <li>Dependencies between scripts might not be immediately obvious</li> <li>Limited customization of RBAC without modifying the scripts</li> </ul>"},{"location":"direct-commands/#direct-commands","title":"Direct Commands:","text":"<ul> <li>More complex to implement</li> <li>Requires deeper understanding of Kubernetes and CINC Auditor</li> <li>Manual cleanup of resources required</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"distroless-containers/","title":"Scanning Distroless Containers","text":"<p>This document outlines the approach for scanning distroless containers using CINC Auditor with Kubernetes ephemeral containers.</p>"},{"location":"distroless-containers/#what-are-distroless-containers","title":"What are Distroless Containers?","text":"<p>Distroless containers are minimalist container images that contain only the application and its runtime dependencies. They do not include:</p> <ul> <li>Shell</li> <li>Package managers</li> <li>Standard Linux utilities</li> <li>Debugging tools</li> </ul> <p>These containers are designed for improved security by reducing the attack surface, but they present challenges for traditional container scanning approaches.</p>"},{"location":"distroless-containers/#the-challenge-with-distroless-containers","title":"The Challenge with Distroless Containers","text":"<p>The train-k8s-container transport plugin that CINC Auditor uses relies on the ability to execute commands within the target container. It typically does this by:</p> <ol> <li>Using <code>kubectl exec</code> to run commands inside the container</li> <li>Assuming the presence of a shell (like <code>/bin/sh</code>) in the container</li> <li>Executing tests that often rely on standard Linux utilities</li> </ol> <p>In distroless containers, these requirements are not met, making traditional scanning impossible.</p>"},{"location":"distroless-containers/#solution-using-ephemeral-containers","title":"Solution: Using Ephemeral Containers","text":"<p>Kubernetes ephemeral containers feature provides a solution:</p> <p>\"Ephemeral containers are temporary containers that run within a pod's namespace. They allow you to run utilities in a pod's namespace without modifying the original pod specification.\"</p> <p>We can leverage ephemeral containers to:</p> <ol> <li>Create a temporary debug container attached to the distroless container's pod</li> <li>Share filesystem and process namespaces with the target distroless container</li> <li>Execute CINC Auditor tests from the debug container</li> <li>Access the distroless container's filesystem through the debug container</li> </ol>"},{"location":"distroless-containers/#key-understanding-points","title":"Key Understanding Points","text":"<p>Important: It's critical to understand how this approach works and its limitations:</p> <ol> <li> <p>Non-intrusive Approach: The ephemeral debug container (using Alpine/Busybox) doesn't actually modify the distroless container itself. The distroless container remains distroless - we're not adding anything to it or changing its security properties.</p> </li> <li> <p>Filesystem Access: The ephemeral container can access the distroless container's filesystem through the proc filesystem (typically via <code>/proc/[pid]/root/</code>). This gives us read access to the files without modifying the distroless container.</p> </li> <li> <p>Limited Resource Usage: Standard InSpec profiles like the RHEL9 STIG baseline wouldn't work as-is because they rely on commands and utilities that don't exist in distroless containers. Many InSpec resources that rely on command execution wouldn't function properly.</p> </li> <li> <p>Focus on Filesystem Analysis: For distroless scanning, we need specialized profiles focusing primarily on:</p> </li> <li>File existence and permissions</li> <li>File content analysis</li> <li>Configuration validation</li> <li> <p>Binary verification</p> </li> <li> <p>External Analysis: This approach is similar to how security teams might audit a read-only filesystem - we're examining the state without executing commands within the actual target.</p> </li> </ol> <p>This understanding is crucial for developing effective scanning strategies for distroless containers and setting appropriate expectations for what can be validated in these environments.</p>"},{"location":"distroless-containers/#approaches-for-scanning-distroless-containers","title":"Approaches for Scanning Distroless Containers","text":"<p>There are two main approaches we can take to scan distroless containers:</p>"},{"location":"distroless-containers/#approach-1-modify-the-train-k8s-container-plugin","title":"Approach 1: Modify the train-k8s-container Plugin","text":"<p>This approach involves forking and modifying the train-k8s-container plugin to work with ephemeral containers:</p> <ul> <li>Detect if a target container is distroless</li> <li>Support connection through ephemeral containers</li> <li>Access the target container's filesystem via the ephemeral container</li> </ul> <p>Key files to modify: - <code>lib/train/k8s/container/kubectl_exec_client.rb</code> - Add ephemeral container creation and connection - <code>lib/train/k8s/container/connection.rb</code> - Add distroless detection and alternative connection path</p>"},{"location":"distroless-containers/#approach-2-direct-chroot-scanning-alternative","title":"Approach 2: Direct Chroot Scanning (Alternative)","text":"<p>A more direct approach would be to use a chroot-based method:</p> <ol> <li>Create an ephemeral debug container with CINC Auditor pre-installed (requires full Ruby environment)</li> <li>Use chroot to make the distroless container's filesystem appear as the root filesystem</li> <li>Run CINC Auditor locally within the chroot environment</li> </ol> <p>This approach has different technical characteristics: - More direct but less elegant approach - Avoids modifying the train-k8s-container plugin but introduces complexity elsewhere - Standard InSpec profiles work without path modifications, but requires specialized container setup - More of a \"hammer\" approach than a scalable enterprise solution</p> <p>Note: This approach requires: - The debug container to run with elevated privileges (to use chroot) - A full Ruby environment with all CINC Auditor dependencies - A specialized container image based on something like the CINC Auditor Docker image</p>"},{"location":"distroless-containers/#user-experience-considerations","title":"User Experience Considerations","text":"<p>When choosing between these approaches, it's important to consider the end-user experience:</p>"},{"location":"distroless-containers/#approach-1-modified-plugin-transparent-to-users","title":"Approach 1: Modified Plugin (Transparent to Users)","text":"<p>User Experience Benefits: - Users run the exact same commands for both regular and distroless containers - No additional knowledge required by teams - Scales easily across many teams - Teams don't need to understand the underlying mechanics - Consistent experience regardless of container type</p> <p>Adoption Considerations: - Easier organizational adoption due to consistent workflow - Lower training burden - Better for multi-team environments</p>"},{"location":"distroless-containers/#approach-2-chroot-approach-requires-more-user-awareness","title":"Approach 2: Chroot Approach (Requires More User Awareness)","text":"<p>User Experience Challenges: - Requires specialized debug containers - May require different commands or workflows for distroless vs. regular containers - More complexity visible to end users - Potentially more friction for wide adoption - Teams need to understand more about the underlying mechanism</p> <p>Recommendation: Approach 1 (plugin modification) is clearly the better choice for a true enterprise-grade solution. While Approach 2 might work as a proof-of-concept or in very limited scenarios, it doesn't offer the transparency, consistency, or scalability needed for organization-wide adoption. For a solution that multiple teams will rely on regularly, the investment in modifying the transport plugin is well justified by the significantly improved user experience and adoption potential.</p>"},{"location":"distroless-containers/#required-changes-to-our-scripts","title":"Required Changes to Our Scripts","text":"<p>Regardless of which approach we choose, our scanning scripts need to be updated to:</p> <pre><code># Detect if container is distroless\nif ! kubectl exec -n ${NAMESPACE} ${POD_NAME} -c ${CONTAINER_NAME} -- /bin/sh -c \"echo test\" &amp;&gt;/dev/null; then\n  echo \"Detected distroless container, using ephemeral container approach\"\n  # Use Debug Container Approach\nelse\n  # Use Kubernetes API Approach\nfi\n</code></pre>"},{"location":"distroless-containers/#3-rbac-updates","title":"3. RBAC Updates","text":"<p>Additional RBAC permissions would be needed:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role-distroless\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"get\", \"create\", \"update\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre>"},{"location":"distroless-containers/#implementation-plan","title":"Implementation Plan","text":""},{"location":"distroless-containers/#1-enhanced-scanning-script","title":"1. Enhanced Scanning Script","text":"<p>Create a new script <code>scan-distroless-container.sh</code> that:</p> <pre><code>#!/bin/bash\n# scan-distroless-container.sh - Script to scan distroless containers using ephemeral debug containers\n# Usage: ./scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n\nset -e\n\n# Input validation and variable setup\n\n# Create ephemeral container\nDEBUG_CONTAINER_NAME=\"debug-scanner-${RUN_ID}\"\nkubectl debug -it ${POD_NAME} -n ${NAMESPACE} --image=alpine:latest --target=${CONTAINER_NAME} --container=${DEBUG_CONTAINER_NAME} -- sleep 3600 &amp;\nEPHEMERAL_PID=$!\n\n# Wait for ephemeral container to be ready\nsleep 5\n\n# Run CINC Auditor scan using ephemeral container\n# This would require a modified transport plugin or custom transport approach\n\n# Process results with SAF-CLI (same as our current approach)\n\n# Clean up ephemeral container\nkill ${EPHEMERAL_PID}\n</code></pre>"},{"location":"distroless-containers/#2-ephemeral-container-image","title":"2. Ephemeral Container Image","text":"<p>Create a specialized debug container image with:</p> <ul> <li>CINC Auditor pre-installed</li> <li>Required utilities for scanning</li> <li>Minimal size for quick deployment</li> </ul>"},{"location":"distroless-containers/#3-fork-and-modify-train-k8s-container","title":"3. Fork and Modify train-k8s-container","text":"<p>Create a fork of the train-k8s-container plugin with:</p> <pre><code># Pseudocode for the modified transport\nmodule Train::Kubernetes::Container\n  class Connection &lt; Train::Plugins::Transport::BaseConnection\n    def initialize(options)\n      @target_container = options[:target_container]\n      @namespace = options[:namespace]\n      @pod = options[:pod]\n\n      if distroless?(@namespace, @pod, @target_container)\n        setup_ephemeral_container\n        # Connect through ephemeral container\n      else\n        # Standard connection\n      end\n    end\n\n    def distroless?(namespace, pod, container)\n      # Check if shell exists in container\n      cmd = [\"kubectl\", \"exec\", \"-n\", namespace, pod, \"-c\", container, \"--\", \"/bin/sh\", \"-c\", \"echo test\"]\n      begin\n        result = Train::Extras::CommandWrapper.run(cmd.join(\" \"))\n        return false # Container has shell\n      rescue\n        return true # Container is likely distroless\n      end\n    end\n\n    def setup_ephemeral_container\n      # Create ephemeral container for debugging\n    end\n  end\nend\n</code></pre>"},{"location":"distroless-containers/#testing-and-validation","title":"Testing and Validation","text":"<ol> <li>Create test distroless containers:</li> <li>Use Google's distroless images</li> <li> <p>Create test pods with these containers</p> </li> <li> <p>Test scanning capabilities:</p> </li> <li>Validate filesystem access</li> <li>Verify command execution through ephemeral containers</li> <li> <p>Ensure results are properly collected</p> </li> <li> <p>Test RBAC restrictions:</p> </li> <li>Verify proper permissions for ephemeral container creation</li> <li>Ensure secure access control</li> </ol>"},{"location":"distroless-containers/#future-work","title":"Future Work","text":"<ol> <li>Support for different distroless base images</li> <li>Performance optimizations for ephemeral container approach</li> <li>Integration with CI/CD pipelines for distroless scanning</li> <li>Comprehensive documentation on distroless container scanning</li> </ol>"},{"location":"distroless-containers/#workflow-diagrams","title":"Workflow Diagrams","text":"<p>To better understand the approaches for scanning distroless containers, refer to the Workflow Diagrams document, which includes:</p> <ul> <li>Kubernetes API Approach workflow</li> <li>Debug Container Approach workflow</li> <li>Sidecar Container Approach workflow</li> <li>CI/CD integration with scanner services</li> </ul> <p>These visual representations help clarify the differences between approaches and their integration points.</p>"},{"location":"distroless-containers/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>For implementing distroless container scanning in GitLab CI pipelines, see:</p> <ul> <li>Standard GitLab CI Integration</li> <li>GitLab Pipeline Examples for reference implementations</li> </ul> <p>Our GitLab CI example with services includes a dedicated job for distroless container scanning using specialized service containers, making it easier to integrate into existing pipelines.</p>"},{"location":"distroless-containers/#security-and-compliance-considerations","title":"Security and Compliance Considerations","text":""},{"location":"distroless-containers/#container-security-best-practices","title":"Container Security Best Practices","text":"<p>When implementing container scanning for distroless containers, it's important to adhere to security best practices:</p> <ol> <li>Minimize Attack Surface: Distroless containers already provide security benefits by reducing the attack surface. Our scanning approaches are designed to preserve these benefits:</li> <li>The Debug Container Approach uses temporary debug containers that are removed after scanning</li> <li>The Sidecar Container Approach maintains isolation between containers while enabling scanning</li> <li> <p>The Kubernetes API Approach (with future distroless support) will maintain complete container isolation</p> </li> <li> <p>Principle of Least Privilege: All scanning approaches implement least-privilege RBAC permissions:</p> </li> <li>Limited to specific namespaces</li> <li>Time-bound credentials</li> <li>Restricted API access</li> <li> <p>Specific pod targeting</p> </li> <li> <p>Container Isolation: Following Docker's best practice of \"one application per container\":</p> </li> <li>The Kubernetes API Approach best preserves this principle</li> <li>Debug Container Approach temporarily breaks this principle but is removed after scanning</li> <li>Sidecar Container Approach introduces a second process but maintains namespace boundaries</li> </ol>"},{"location":"distroless-containers/#alignment-with-security-frameworks","title":"Alignment with Security Frameworks","text":"<p>Our container scanning approaches align with key security frameworks and guidance:</p> Security Framework Alignment Notes NIST SP 800-190 High Follows container security principles for access control, isolation, and minimizing attack surface CIS Docker Benchmark High Adheres to container security configurations and least-privilege access CIS Kubernetes Benchmark High Follows recommended RBAC and namespace isolation practices NSA/CISA Kubernetes Hardening Guidelines High Implements recommended scanning practices and security controls MITRE ATT&amp;CK for Containers Medium-High Helps mitigate techniques in the MITRE ATT&amp;CK for Containers matrix"},{"location":"distroless-containers/#mitre-attck-considerations","title":"MITRE ATT&amp;CK Considerations","text":"<p>Our scanning approaches help mitigate several container-specific attack techniques identified in the MITRE ATT&amp;CK framework:</p> <ul> <li>T1610 - Deploy Container: Prevents unauthorized container deployment through least-privilege RBAC</li> <li>T1613 - Container and Resource Discovery: Limits visibility of container resources</li> <li>T1543.005 - Create or Modify System Process: Container Service: Prevents modification of container configurations</li> </ul>"},{"location":"distroless-containers/#references","title":"References","text":"<ul> <li>Kubernetes Ephemeral Containers Documentation</li> <li>Google Distroless Container Images</li> <li>InSpec train-k8s-container transport</li> <li>CINC Project Docker Images</li> <li>NIST SP 800-190: Application Container Security Guide</li> <li>NSA/CISA Kubernetes Hardening Guidance</li> <li>CIS Docker Benchmark</li> <li>MITRE ATT&amp;CK for Containers</li> <li>Docker Best Practices</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"plugin-modifications/","title":"Modifying train-k8s-container for Distroless Support","text":"<p>STRATEGIC PRIORITY: Enhancing the train-k8s-container plugin to support distroless containers through the Kubernetes API Approach represents our highest strategic priority for enterprise container scanning. This is the recommended approach for production environments and is essential for comprehensive security compliance.</p> <p>This document outlines the changes needed in the CINC Auditor train-k8s-container plugin to support scanning distroless containers using Kubernetes ephemeral containers.</p>"},{"location":"plugin-modifications/#current-plugin-architecture","title":"Current Plugin Architecture","text":"<p>The train-k8s-container plugin works by:</p> <ol> <li>Creating a connection to a Kubernetes cluster via kubeconfig</li> <li>Using <code>kubectl exec</code> to execute commands in the target container</li> <li>Running CINC Auditor controls that rely on command execution</li> </ol> <p>Key files in the plugin that would need modification:</p> <ol> <li><code>lib/train/k8s/container/connection.rb</code> - Main connection class</li> <li><code>lib/train/k8s/container/kubectl_exec_client.rb</code> - Handles command execution</li> <li><code>lib/train/transport/k8s_container.rb</code> - Transport entry point</li> </ol>"},{"location":"plugin-modifications/#required-modifications","title":"Required Modifications","text":""},{"location":"plugin-modifications/#1-distroless-detection","title":"1. Distroless Detection","text":"<p>Add capability to detect distroless containers by attempting to execute a simple shell command and checking for failure:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef distroless?(namespace, pod, container)\n  cmd = [\"kubectl\", \"exec\", \"-n\", namespace, pod, \"-c\", container, \"--\", \"/bin/sh\", \"-c\", \"echo test\"]\n  begin\n    result = Train::Extras::CommandWrapper.run(cmd.join(\" \"), nil)\n    return false # Container has shell\n  rescue Train::Errors::CommandExecutionError\n    return true # Container is likely distroless\n  end\nend\n</code></pre>"},{"location":"plugin-modifications/#2-ephemeral-container-creation","title":"2. Ephemeral Container Creation","text":"<p>Add functionality to create and connect to an ephemeral container:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef setup_ephemeral_container(namespace, pod, target_container)\n  debug_container_name = \"inspec-debug-#{SecureRandom.hex(4)}\"\n  debug_image = \"alpine:latest\" # or a custom image with needed tools\n\n  # Create ephemeral container\n  cmd = [\n    \"kubectl\", \"debug\", pod, \n    \"-n\", namespace, \n    \"--image=#{debug_image}\", \n    \"--target=#{target_container}\", \n    \"--container=#{debug_container_name}\", \n    \"--quiet\", \"-it\", \"--\", \"sleep\", \"3600\"\n  ]\n\n  # Run in background\n  pid = Process.spawn(cmd.join(\" \"), [:out, :err] =&gt; \"/dev/null\")\n  Process.detach(pid)\n\n  # Wait for ephemeral container to be ready\n  sleep 5\n\n  # Return ephemeral container info\n  {\n    name: debug_container_name,\n    pid: pid\n  }\nend\n</code></pre>"},{"location":"plugin-modifications/#3-connection-strategy-switching","title":"3. Connection Strategy Switching","text":"<p>Modify the connection logic to choose between standard and ephemeral container approaches:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef initialize(options)\n  @options = options\n  @namespace = options[:namespace]\n  @pod = options[:pod]\n  @container = options[:container]\n\n  # Detect if container is distroless\n  if distroless?(@namespace, @pod, @container)\n    @ephemeral = setup_ephemeral_container(@namespace, @pod, @container)\n    @container = @ephemeral[:name] # Use ephemeral container for commands\n    @using_ephemeral = true\n  else\n    @using_ephemeral = false\n  end\n\n  # Initialize kubernetes client\n  @k8s_client = KubectlExecClient.new(\n    namespace: @namespace,\n    pod: @pod,\n    container: @container,\n    kubeconfig: @options[:kubeconfig]\n  )\nend\n\ndef close\n  # Clean up ephemeral container if used\n  if @using_ephemeral &amp;&amp; @ephemeral[:pid]\n    Process.kill('TERM', @ephemeral[:pid])\n  end\nend\n</code></pre>"},{"location":"plugin-modifications/#4-file-access-for-distroless-containers","title":"4. File Access for Distroless Containers","text":"<p>Modify file access methods to work through the ephemeral container:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef file(path)\n  if @using_ephemeral\n    # For distroless containers, access target container filesystem via /proc\n    # First, get the process ID of the target container's entrypoint\n    target_pid_cmd = \"ps -ef | grep #{@options[:container]} | grep -v grep | awk '{print $2}' | head -1\"\n    target_pid = @k8s_client.run_command(target_pid_cmd).stdout.strip\n\n    # Access target container's filesystem via /proc\n    modified_path = \"/proc/#{target_pid}/root#{path}\"\n    Train::File::Local.new(self, modified_path)\n  else\n    # Standard file access\n    Train::File::Remote.new(self, path)\n  end\nend\n</code></pre>"},{"location":"plugin-modifications/#5-command-execution-handling","title":"5. Command Execution Handling","text":"<p>Update command execution to handle the distroless case:</p> <pre><code># in lib/train/k8s/container/kubectl_exec_client.rb\n\ndef run_command(command)\n  if @connection.using_ephemeral?\n    # In ephemeral container, we might need to modify commands to access the target container\n    # This depends on how exactly we want to interact with the target container\n    modified_command = command\n    super(modified_command)\n  else\n    # Standard command execution\n    super(command)\n  end\nend\n</code></pre>"},{"location":"plugin-modifications/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Fork the Repository: Create a fork of the train-k8s-container plugin</li> <li>Create Branch: Create a feature branch for distroless support</li> <li>Implement Changes: Make the modifications outlined above</li> <li>Add Tests: Create tests for distroless container detection and scanning</li> <li>Document: Document the new capabilities and how to use them</li> <li>Submit PR: Consider submitting a pull request to the upstream repository</li> </ol>"},{"location":"plugin-modifications/#integration-with-our-project","title":"Integration with Our Project","text":"<p>After modifying the plugin, we would need to:</p> <ol> <li>Update our Gemfile to point to our fork of the plugin</li> <li>Update our scan-container.sh script to handle the new capabilities</li> <li>Create documentation on how to scan distroless containers</li> <li>Update our Helm chart to include the new plugin version</li> <li>Test with various distroless container types</li> </ol>"},{"location":"plugin-modifications/#strategic-implementation-path","title":"Strategic Implementation Path","text":"<p>This enhancement represents our primary strategic focus for several reasons:</p> <ol> <li>Consistent User Experience: Users will use identical commands for all container types</li> <li>Maximum Security Compliance: The Kubernetes API Approach maintains all security boundaries</li> <li>Enterprise Scalability: One solution for all container types simplifies deployment</li> <li>Simplified CI/CD Integration: CI/CD pipelines can use a single approach for all workloads</li> <li>Unified Documentation: Streamlined documentation and training</li> </ol> <p>Once completed, this enhancement will eliminate the need for interim approaches like the Debug Container Approach and Sidecar Container Approach, providing a single, comprehensive solution for all container scanning needs.</p>"},{"location":"plugin-modifications/#example-usage","title":"Example Usage","text":"<p>With the modified plugin, the command to scan a distroless container would remain the same:</p> <pre><code>cinc-auditor exec my-profile -t k8s-container://namespace/pod/container\n</code></pre> <p>The plugin would automatically: 1. Detect the container is distroless 2. Create an ephemeral container 3. Execute the scan through the ephemeral container 4. Clean up the ephemeral container when done</p>"},{"location":"plugin-modifications/#potential-limitations","title":"Potential Limitations","text":"<ol> <li>Permissions: Requires permissions to create ephemeral containers</li> <li>Kubernetes Version: Requires Kubernetes v1.18+ for ephemeral containers</li> <li>Image Compatibility: The debug image must have required tools</li> <li>Process Isolation: May have issues with certain container runtimes</li> </ol>"},{"location":"plugin-modifications/#references","title":"References","text":"<ol> <li>train-k8s-container repository</li> <li>Kubernetes Ephemeral Containers</li> <li>Debugging with Ephemeral Containers</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"saf-cli-integration/","title":"SAF CLI Integration","text":"<p>This guide covers the integration of MITRE's Security Automation Framework (SAF) CLI with our CINC Auditor container scanning solution.</p>"},{"location":"saf-cli-integration/#overview","title":"Overview","text":"<p>The SAF CLI provides powerful capabilities for processing InSpec/CINC Auditor results, including:</p> <ol> <li>Generating human-readable summaries</li> <li>Creating compliance threshold validation</li> <li>Visualizing results</li> <li>Producing standardized reports</li> </ol>"},{"location":"saf-cli-integration/#installation","title":"Installation","text":"<p>SAF CLI requires Node.js and can be installed via npm:</p> <pre><code># Install SAF-CLI globally\nnpm install -g @mitre/saf\n\n# Verify installation\nsaf --version\n</code></pre>"},{"location":"saf-cli-integration/#using-saf-cli-with-scan-results","title":"Using SAF CLI with Scan Results","text":""},{"location":"saf-cli-integration/#basic-usage","title":"Basic Usage","text":"<p>After running a CINC Auditor scan, the JSON output can be processed with SAF CLI:</p> <pre><code># Run CINC Auditor scan with JSON output\ncinc-auditor exec my-profile -t k8s-container://namespace/pod/container --reporter json:results.json\n\n# Generate a summary in markdown format\nsaf summary --input results.json --output-md summary.md\n\n# Check against thresholds\nsaf threshold -i results.json -t threshold.yml\n</code></pre>"},{"location":"saf-cli-integration/#threshold-validation","title":"Threshold Validation","text":"<p>Thresholds are defined using YAML or JSON files with the following structure:</p> <pre><code># threshold.yml example\ncompliance:\n  min: 70   # Minimum compliance score (0-100)\nfailed:\n  critical:\n    max: 0  # Maximum critical failures allowed\n  high:\n    max: 2  # Maximum high failures allowed\nskipped:\n  total:\n    max: 5  # Maximum skipped controls allowed\nerror:\n  total:\n    max: 0  # Maximum error controls allowed\n</code></pre> <p>To validate against a threshold file:</p> <pre><code>saf threshold -i results.json -t threshold.yml\n</code></pre> <p>The command returns: - Exit code 0 if all thresholds are met - Non-zero exit code if any threshold is not met</p>"},{"location":"saf-cli-integration/#report-generation","title":"Report Generation","text":"<p>SAF CLI can generate various report formats:</p> <pre><code># Generate HTML report\nsaf view -i results.json --output report.html\n\n# Generate JSON summary\nsaf summary --input results.json --output summary.json\n\n# Generate markdown summary\nsaf summary --input results.json --output-md summary.md\n</code></pre>"},{"location":"saf-cli-integration/#integration-in-cicd-pipelines","title":"Integration in CI/CD Pipelines","text":""},{"location":"saf-cli-integration/#threshold-as-quality-gate","title":"Threshold as Quality Gate","text":"<p>Use threshold validation as a quality gate in CI/CD pipelines:</p> <pre><code># Run validation\nsaf threshold -i results.json -t threshold.yml\nTHRESHOLD_RESULT=$?\n\n# Fail the pipeline if thresholds not met\nif [ $THRESHOLD_RESULT -ne 0 ]; then\n  echo \"Security scan failed to meet threshold requirements\"\n  exit $THRESHOLD_RESULT\nfi\n</code></pre>"},{"location":"saf-cli-integration/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>See the GitHub workflow examples in <code>/github-workflows/</code> for complete implementation examples.</p>"},{"location":"saf-cli-integration/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>See the GitLab CI examples in <code>/gitlab-examples/</code> for complete implementation examples.</p>"},{"location":"saf-cli-integration/#advanced-threshold-configuration","title":"Advanced Threshold Configuration","text":"<p>You can create complex threshold rules based on your compliance requirements:</p>"},{"location":"saf-cli-integration/#basic-compliance-score","title":"Basic Compliance Score","text":"<p>Only validate overall compliance score:</p> <pre><code>compliance:\n  min: 80  # At least 80% compliance required\n</code></pre>"},{"location":"saf-cli-integration/#no-critical-failures","title":"No Critical Failures","text":"<p>Allow failures at lower impact levels, but no critical ones:</p> <pre><code>failed:\n  critical:\n    max: 0  # No critical failures allowed\n</code></pre>"},{"location":"saf-cli-integration/#production-environment","title":"Production Environment","text":"<p>Strict validation for production environments:</p> <pre><code>compliance:\n  min: 95  # At least 95% compliance required\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\n  high:\n    max: 0  # No high failures allowed\nskipped:\n  total:\n    max: 0  # No skipped controls allowed\nerror:\n  total:\n    max: 0  # No error controls allowed\n</code></pre>"},{"location":"saf-cli-integration/#development-environment","title":"Development Environment","text":"<p>More lenient validation for development environments:</p> <pre><code>compliance:\n  min: 70  # At least 70% compliance\nfailed:\n  critical:\n    max: 0  # No critical failures\n  high:\n    max: 3  # Up to 3 high failures allowed\n</code></pre>"},{"location":"saf-cli-integration/#helm-chart-integration","title":"Helm Chart Integration","text":"<p>Our Helm chart includes SAF CLI integration with configurable threshold settings. See the <code>values.yaml</code> file for all available options.</p> <p>Example usage with custom threshold file:</p> <pre><code># Create a threshold.yml file\ncat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: 85\nfailed:\n  critical:\n    max: 0\nEOF\n\n# Install the Helm chart with custom threshold\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.safCli.thresholdFilePath=/path/to/threshold.yml\n</code></pre>"},{"location":"saf-cli-integration/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>SAF CLI not installed: Ensure Node.js is installed and run <code>npm install -g @mitre/saf</code></li> <li>Invalid JSON format: Verify the InSpec/CINC output is valid JSON</li> <li>Threshold validation fails: Run with debug for more details: <code>saf threshold -i results.json -t threshold.yml --debug</code></li> <li>Node.js version compatibility: SAF CLI requires Node.js 12+</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"sidecar-container-approach/","title":"CINC Auditor Sidecar Container Approach","text":"<p>This document outlines an alternative approach for container scanning using a CINC Auditor sidecar container. This approach is particularly useful for scanning distroless containers and can be an alternative to the ephemeral container approach.</p>"},{"location":"sidecar-container-approach/#overview","title":"Overview","text":"<p>The sidecar container approach involves deploying a CINC Auditor container alongside the target container within the same pod. This allows the CINC Auditor container to access the target container's filesystem through the shared process namespace.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Deploy Pod with Sidecar]\n\n    subgraph \"Target Pod\"\n    C1[Target Container]\n    C2[CINC Auditor Sidecar]\n    end\n\n    B --&gt; D[Mount Shared Volume]\n    D --&gt; E[Share Process Namespace]\n    E --&gt; F[Run CINC Auditor in Sidecar]\n    F --&gt; G[Access Target Filesystem via /proc]\n    G --&gt; H[Execute Compliance Controls]\n    H --&gt; I[Write Results to Shared Volume]\n    I --&gt; J[Container or Scheduler Retrieves Results]\n    J --&gt; K[Generate Reports]\n    K --&gt; L[Validate Against Thresholds]\n    L --&gt; M[End]\n\n    C1 --- C2\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C1 fill:#fbb,stroke:#333,stroke-width:2px\n    style C2 fill:#bbf,stroke:#333,stroke-width:2px\n    style F fill:#bbf,stroke:#333,stroke-width:2px\n    style L fill:#bfb,stroke:#333,stroke-width:2px\n    style M fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"sidecar-container-approach/#key-components","title":"Key Components","text":"<ol> <li>Target Container: The container to be scanned, which could be a regular container or a distroless container.</li> <li>CINC Auditor Sidecar: A container with CINC Auditor pre-installed, deployed in the same pod.</li> <li>Shared Process Namespace: Enables the sidecar to access the target container's filesystem through /proc.</li> <li>Shared Volume: Optional component to make it easier to retrieve scan results.</li> </ol>"},{"location":"sidecar-container-approach/#implementation","title":"Implementation","text":""},{"location":"sidecar-container-approach/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with support for shared process namespaces (v1.17+)</li> <li>RBAC permissions to create pods with shared process namespaces</li> <li>A CINC Auditor container image</li> </ul>"},{"location":"sidecar-container-approach/#pod-definition","title":"Pod Definition","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-with-scanner\n  namespace: inspec-test\nspec:\n  shareProcessNamespace: true  # Enable shared process namespace\n  containers:\n  - name: app\n    image: your-app-image:latest\n    # Application container configuration\n    volumeMounts:\n    - name: shared-results\n      mountPath: /results\n\n  - name: cinc-scanner\n    image: cinc-auditor:latest\n    command: \n    - \"/bin/sh\"\n    - \"-c\"\n    - |\n      # Wait for the main container to start\n      sleep 5\n\n      # Find the main process of the target container\n      TARGET_PID=$(ps aux | grep -v grep | grep -m 1 \"app process identifier\" | awk '{print $2}')\n\n      # Run CINC Auditor against the target filesystem\n      cd /\n      cinc-auditor exec /opt/profiles/container-baseline \\\n        -b os=linux \\\n        --target=/proc/$TARGET_PID/root \\\n        --reporter json:/results/scan-results.json\n\n      # Indicate completion\n      touch /results/scan-complete\n\n      # Keep the container running to allow result retrieval\n      sleep 3600\n    volumeMounts:\n    - name: shared-results\n      mountPath: /results\n    - name: profiles\n      mountPath: /opt/profiles\n\n  volumes:\n  - name: shared-results\n    emptyDir: {}\n  - name: profiles\n    configMap:\n      name: inspec-profiles\n</code></pre>"},{"location":"sidecar-container-approach/#retrieving-results","title":"Retrieving Results","text":"<p>Results can be retrieved in several ways:</p> <ol> <li>Kubernetes API: Retrieve the results from the shared volume using the API</li> <li>kubectl cp: Copy results from the pod to the local filesystem</li> <li>Result Collection Container: Add a third container to the pod that processes and uploads the results</li> </ol> <p>Example:</p> <pre><code># Wait for scan to complete\nkubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\n\n# Check if scan is complete\nkubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls -la /results\n\n# Copy results if scan-complete file exists\nkubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\n\n# Process results with SAF CLI\nsaf summary --input ./scan-results.json --output-md ./summary.md\n</code></pre>"},{"location":"sidecar-container-approach/#advantages-over-other-approaches","title":"Advantages Over Other Approaches","text":"<ol> <li>No Modifications to Train-k8s-container Plugin: Works with standard CINC Auditor installations.</li> <li>Deployed Alongside Application: Can be included in application deployment pipelines.</li> <li>Works with Any Container Type: Effective for both standard and distroless containers.</li> <li>No Need for Ephemeral Containers: Works with older Kubernetes clusters.</li> <li>Simpler Implementation: Requires less custom code than the transport plugin modification approach.</li> </ol>"},{"location":"sidecar-container-approach/#limitations","title":"Limitations","text":"<ol> <li>Pod Modification Required: The target pod must be defined with the sidecar and shared process namespace.</li> <li>Security Implications: Sharing process namespaces has security implications that should be considered.</li> <li>Not Suitable for Existing Pods: The approach requires creating a new pod with the sidecar, not modifying existing pods.</li> <li>More Resource Intensive: Running an additional container consumes more resources than other approaches.</li> </ol>"},{"location":"sidecar-container-approach/#example-implementation","title":"Example Implementation","text":""},{"location":"sidecar-container-approach/#step-1-create-a-configmap-with-inspec-profiles","title":"Step 1: Create a ConfigMap with InSpec Profiles","text":"<pre><code>kubectl create configmap inspec-profiles --from-file=container-baseline=/path/to/profiles/container-baseline -n inspec-test\n</code></pre>"},{"location":"sidecar-container-approach/#step-2-deploy-the-pod-with-sidecar","title":"Step 2: Deploy the Pod with Sidecar","text":"<pre><code>kubectl apply -f sidecar-scanner-pod.yaml -n inspec-test\n</code></pre>"},{"location":"sidecar-container-approach/#step-3-wait-for-the-scan-to-complete","title":"Step 3: Wait for the Scan to Complete","text":"<pre><code>kubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\nuntil kubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls /results/scan-complete 2&gt;/dev/null; do\n  echo \"Waiting for scan to complete...\"\n  sleep 5\ndone\n</code></pre>"},{"location":"sidecar-container-approach/#step-4-retrieve-and-process-results","title":"Step 4: Retrieve and Process Results","text":"<pre><code>kubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\nsaf summary --input ./scan-results.json --output-md ./summary.md\n</code></pre>"},{"location":"sidecar-container-approach/#cicd-integration","title":"CI/CD Integration","text":"<p>For CI/CD environments, the sidecar approach can be integrated as follows:</p> <ol> <li>Build Stage: Build and push the application container.</li> <li>Test Stage: Deploy the application with the CINC Auditor sidecar.</li> <li>Scan Stage: Wait for the scan to complete and retrieve results.</li> <li>Validation Stage: Process results against thresholds.</li> <li>Cleanup Stage: Remove the test pod.</li> </ol> <p>Example GitLab CI configuration:</p> <pre><code>stages:\n  - build\n  - test\n  - scan\n  - validate\n  - cleanup\n\nbuild:\n  stage: build\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n\ndeploy_with_sidecar:\n  stage: test\n  script:\n    - envsubst &lt; sidecar-scanner-pod.yaml | kubectl apply -f -\n\nscan:\n  stage: scan\n  script:\n    - kubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\n    - |\n      until kubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls /results/scan-complete 2&gt;/dev/null; do\n        echo \"Waiting for scan to complete...\"\n        sleep 5\n      done\n    - kubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\n\nvalidate:\n  stage: validate\n  script:\n    - saf threshold -i ./scan-results.json -t threshold.yml\n    - saf summary --input ./scan-results.json --output-md ./summary.md\n\ncleanup:\n  stage: cleanup\n  script:\n    - kubectl delete pod app-with-scanner -n inspec-test\n</code></pre>"},{"location":"sidecar-container-approach/#security-considerations","title":"Security Considerations","text":"<p>When implementing the sidecar container approach, consider the following security implications:</p> <ol> <li>Shared Process Namespace: All containers in the pod can see each other's processes, which could be a security concern.</li> <li>Temporary Deployments: For production environments, consider using this approach only for temporary test deployments.</li> <li>RBAC Restrictions: Implement strict RBAC to limit which users/systems can deploy pods with shared process namespaces.</li> <li>Resource Isolation: Ensure the sidecar container has appropriate resource limits.</li> </ol>"},{"location":"sidecar-container-approach/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements to this approach:</p> <ol> <li>Automated Sidecar Injection: Use a mutating webhook to automatically inject the scanner sidecar.</li> <li>Results Aggregation: Implement a results collector that aggregates results from multiple scanned pods.</li> <li>Optimized CINC Image: Create a minimal CINC Auditor image specifically designed for sidecars.</li> <li>Integration with Helm: Add support for this approach in our Helm charts.</li> </ol>"},{"location":"sidecar-container-approach/#references","title":"References","text":"<ul> <li>Kubernetes Shared Process Namespace Documentation</li> <li>CINC Auditor Documentation</li> <li>Sidecar Container Pattern</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"thresholds/","title":"Using SAF-CLI Thresholds","text":"<p>This guide provides detailed information on using MITRE's SAF-CLI thresholds for quality gates in security scanning.</p>"},{"location":"thresholds/#what-are-thresholds","title":"What are Thresholds?","text":"<p>In the context of security scanning, thresholds define the minimum acceptable compliance level for your containerized applications. They allow you to:</p> <ul> <li>Set minimum passing scores</li> <li>Define acceptable failure counts for different severity levels</li> <li>Control how many skipped or error controls are permitted</li> <li>Implement quality gates in CI/CD pipelines</li> </ul>"},{"location":"thresholds/#threshold-configuration","title":"Threshold Configuration","text":"<p>Thresholds are defined in YAML or JSON files with a standardized structure. Here's an example:</p> <pre><code># Example threshold.yml\ncompliance:\n  min: 85  # Minimum overall compliance percentage (0-100)\n\nfailed:\n  critical:\n    max: 0  # Maximum number of critical-impact failures allowed\n  high:\n    max: 1  # Maximum number of high-impact failures allowed\n  medium:\n    max: 3  # Maximum number of medium-impact failures allowed\n  low:\n    max: 5  # Maximum number of low-impact failures allowed\n\nskipped:\n  total:\n    max: 2  # Maximum number of skipped controls allowed\n\nerror:\n  total:\n    max: 0  # Maximum number of error controls allowed\n</code></pre>"},{"location":"thresholds/#threshold-configuration-options","title":"Threshold Configuration Options","text":""},{"location":"thresholds/#compliance-score","title":"Compliance Score","text":"<p>The <code>compliance</code> section sets the minimum overall compliance percentage required:</p> <pre><code>compliance:\n  min: 85  # Minimum overall compliance percentage (0-100)\n</code></pre>"},{"location":"thresholds/#failed-controls-by-impact","title":"Failed Controls by Impact","text":"<p>The <code>failed</code> section lets you set maximum failure counts by impact level:</p> <pre><code>failed:\n  critical:\n    max: 0  # No critical failures allowed\n  high: \n    max: 2  # Up to 2 high-impact failures allowed\n  medium:\n    max: 5  # Up to 5 medium-impact failures allowed\n  low:\n    max: 10  # Up to 10 low-impact failures allowed\n</code></pre>"},{"location":"thresholds/#skipped-controls","title":"Skipped Controls","text":"<p>The <code>skipped</code> section sets limits on skipped controls:</p> <pre><code>skipped:\n  total:\n    max: 5  # Up to 5 skipped controls allowed\n</code></pre>"},{"location":"thresholds/#error-controls","title":"Error Controls","text":"<p>The <code>error</code> section defines how many error controls are acceptable:</p> <pre><code>error:\n  total:\n    max: 0  # No error controls allowed\n</code></pre>"},{"location":"thresholds/#using-thresholds-in-practice","title":"Using Thresholds in Practice","text":""},{"location":"thresholds/#command-line-usage","title":"Command Line Usage","text":"<p>To validate scan results against a threshold file:</p> <pre><code># Usage\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre> <p>The command returns: - Exit code 0 if all thresholds are met - Non-zero exit code if any threshold is not met</p>"},{"location":"thresholds/#in-our-scripts","title":"In Our Scripts","text":"<p>Our <code>scan-container.sh</code> script supports threshold files:</p> <pre><code># Using default threshold (70% compliance)\n./scan-container.sh my-namespace my-pod my-container my-profile\n\n# Using custom threshold file\n./scan-container.sh my-namespace my-pod my-container my-profile ./path/to/threshold.yml\n</code></pre>"},{"location":"thresholds/#in-helm-chart","title":"In Helm Chart","text":"<p>Our Helm chart supports thresholds via <code>values.yaml</code>:</p> <pre><code>safCli:\n  enabled: true\n  thresholdConfig:\n    compliance:\n      min: 70\n    failed:\n      critical:\n        max: 0\n    # ... other threshold settings\n</code></pre> <p>You can also use an external threshold file:</p> <pre><code>safCli:\n  enabled: true\n  thresholdFilePath: \"/path/to/threshold.yml\"\n</code></pre>"},{"location":"thresholds/#threshold-examples-for-different-environments","title":"Threshold Examples for Different Environments","text":""},{"location":"thresholds/#development-environment","title":"Development Environment","text":"<p>More lenient thresholds for development:</p> <pre><code>compliance:\n  min: 70\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 3\n  medium:\n    max: 5\n</code></pre>"},{"location":"thresholds/#staging-environment","title":"Staging Environment","text":"<p>Moderate thresholds for staging:</p> <pre><code>compliance:\n  min: 85\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 1\n  medium:\n    max: 3\n</code></pre>"},{"location":"thresholds/#production-environment","title":"Production Environment","text":"<p>Strict thresholds for production:</p> <pre><code>compliance:\n  min: 95\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\n  medium:\n    max: 1\nskipped:\n  total:\n    max: 0\nerror:\n  total:\n    max: 0\n</code></pre>"},{"location":"thresholds/#integration-with-cicd","title":"Integration with CI/CD","text":""},{"location":"thresholds/#github-actions","title":"GitHub Actions","text":"<p>In GitHub workflows, use thresholds as quality gates:</p> <pre><code>- name: Run security scan\n  run: |\n    # Run scan and get results in JSON\n    cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n      --reporter json:scan-results.json\n\n    # Check against thresholds\n    saf threshold -i scan-results.json -t threshold.yml\n    if [ $? -ne 0 ]; then\n      echo \"Security scan failed to meet threshold requirements\"\n      exit 1\n    fi\n</code></pre>"},{"location":"thresholds/#gitlab-ci","title":"GitLab CI","text":"<p>In GitLab pipelines, implement thresholds as:</p> <pre><code>run_scan:\n  stage: scan\n  script:\n    # Run scan with CINC Auditor\n    cinc-auditor exec ${PROFILE_PATH} \\\n      -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n      --reporter json:scan-results.json\n\n    # Check against thresholds\n    saf threshold -i scan-results.json -t threshold.yml\n    if [ $? -ne 0 ]; then\n      echo \"Security scan failed to meet threshold requirements\"\n      exit 1\n    fi\n</code></pre>"},{"location":"thresholds/#troubleshooting","title":"Troubleshooting","text":""},{"location":"thresholds/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Threshold failing but not sure why: Examine your scan results JSON file to understand which controls are failing and compare with your threshold requirements:    <pre><code># For example, using jq to see failed controls\njq '.profiles[0].controls[] | select(.status==\"failed\")' scan-results.json\n</code></pre></p> </li> <li> <p>JSON parsing errors: Make sure your threshold file is valid YAML or JSON.</p> </li> <li> <p>Unexpected failures: Check if your compliance percentage calculation is as expected. The calculation is:    <pre><code>compliance_percentage = (passed_controls / total_controls) * 100\n</code></pre></p> </li> <li> <p>Missing impact levels: If controls don't have impact/severity levels defined, they might be ignored in threshold calculations.</p> </li> </ol>"},{"location":"thresholds/#best-practices","title":"Best Practices","text":"<ol> <li>Start lenient: Begin with lenient thresholds and gradually tighten them</li> <li>Different environments: Use different thresholds for development, staging, and production</li> <li>Critical first: Always enforce zero critical failures, even in development</li> <li>Document exceptions: Document any reasons for allowed failures</li> <li>Regularly review: Review and update thresholds as your security posture matures</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"configuration/","title":"Kubeconfig Generation and Management","text":"<p>This guide covers creating and managing secure kubeconfig files for InSpec container scanning.</p>"},{"location":"configuration/#basic-kubeconfig-structure","title":"Basic Kubeconfig Structure","text":"<p>A kubeconfig file for InSpec scanning contains:</p> <ol> <li>Cluster configuration: Server address and certificate authority</li> <li>User authentication: Service account token</li> <li>Context: Binding a cluster and user with a namespace</li> </ol>"},{"location":"configuration/#creating-a-secure-kubeconfig","title":"Creating a Secure Kubeconfig","text":""},{"location":"configuration/#manual-generation","title":"Manual Generation","text":"<pre><code>TOKEN=$(kubectl create token inspec-scanner -n inspec-test)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\ncat &lt;&lt; EOF &gt; secure-kubeconfig.yaml\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n</code></pre>"},{"location":"configuration/#using-kubectl-tools","title":"Using kubectl Tools","text":"<pre><code># Create a new kubeconfig file\nKUBECONFIG=new-config.yaml kubectl config set-cluster scanner-cluster \\\n  --server=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}') \\\n  --certificate-authority-data=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}') \\\n  --embed-certs=true\n\n# Set the user with token\nKUBECONFIG=new-config.yaml kubectl config set-credentials scanner-user \\\n  --token=$(kubectl create token inspec-scanner -n inspec-test)\n\n# Set the context\nKUBECONFIG=new-config.yaml kubectl config set-context scanner-context \\\n  --cluster=scanner-cluster \\\n  --namespace=inspec-test \\\n  --user=scanner-user\n\n# Use the context\nKUBECONFIG=new-config.yaml kubectl config use-context scanner-context\n</code></pre>"},{"location":"configuration/#dynamic-configuration-in-cicd","title":"Dynamic Configuration in CI/CD","text":"<p>For CI/CD pipelines, you can generate configurations dynamically:</p> <pre><code>#!/bin/bash\n# generate-kubeconfig.sh\nNAMESPACE=$1\nSA_NAME=$2\nOUTPUT_FILE=${3:-\"./kubeconfig.yaml\"}\n\n# Get cluster information\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create token\nTOKEN=$(kubectl create token ${SA_NAME} -n ${NAMESPACE})\n\n# Generate kubeconfig\ncat &gt; ${OUTPUT_FILE} &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: ${NAMESPACE}\n    user: ${SA_NAME}\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: ${SA_NAME}\n  user:\n    token: ${TOKEN}\nEOF\n\necho \"Generated kubeconfig at ${OUTPUT_FILE}\"\n</code></pre> <p>Usage: <pre><code>./generate-kubeconfig.sh inspec-test inspec-scanner ./my-kubeconfig.yaml\n</code></pre></p>"},{"location":"configuration/#security-considerations","title":"Security Considerations","text":""},{"location":"configuration/#file-permissions","title":"File Permissions","text":"<p>Always set restrictive permissions on kubeconfig files:</p> <pre><code>chmod 600 kubeconfig.yaml\n</code></pre>"},{"location":"configuration/#token-expiration","title":"Token Expiration","text":"<p>Remember that tokens expire, which will invalidate the kubeconfig:</p> <pre><code># Create a kubeconfig with a short-lived token (5 minutes)\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=5m)\n# ... create kubeconfig ...\n\n# After token expiration, kubeconfig must be regenerated\n</code></pre>"},{"location":"configuration/#namespace-limitation","title":"Namespace Limitation","text":"<p>The kubeconfig sets a default namespace, but doesn't restrict access to that namespace. Access control still relies on the RBAC configuration.</p>"},{"location":"configuration/#multiple-environments","title":"Multiple Environments","text":"<p>For different environments (dev, test, prod), create separate kubeconfig files:</p> <pre><code># Development\n./generate-kubeconfig.sh dev-namespace inspec-scanner ./kubeconfig-dev.yaml\n\n# Production\n./generate-kubeconfig.sh prod-namespace inspec-scanner ./kubeconfig-prod.yaml\n</code></pre>"},{"location":"configuration/#testing-a-kubeconfig","title":"Testing a Kubeconfig","text":"<p>Verify your kubeconfig works correctly:</p> <pre><code># Check basic access\nKUBECONFIG=./kubeconfig.yaml kubectl get pods\n\n# Check specific permissions\nKUBECONFIG=./kubeconfig.yaml kubectl auth can-i create pods/exec --resource-name=inspec-target\n</code></pre>"},{"location":"configuration/#references","title":"References","text":"<ul> <li>Kubernetes Configure Access to Multiple Clusters</li> <li>Kubernetes Authentication</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"contributing/code-snippets/","title":"Using Code Snippets","text":"<p>This guide explains how to use the Material for MkDocs code snippet inclusion feature to embed code examples in your documentation.</p>"},{"location":"contributing/code-snippets/#overview","title":"Overview","text":"<p>Our documentation uses Material for MkDocs with the PyMdown Extensions to provide advanced code block functionality, including:</p> <ul> <li>Code syntax highlighting</li> <li>Line numbers and line highlighting</li> <li>Code block annotations</li> <li>Code copying button</li> <li>Code file inclusion</li> </ul>"},{"location":"contributing/code-snippets/#including-code-files","title":"Including Code Files","text":"<p>To include code from existing files in the repository:</p> <p><pre><code>```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>This will render as:\n\n```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre></p>"},{"location":"contributing/code-snippets/#highlighting-specific-lines","title":"Highlighting Specific Lines","text":"<p>You can highlight specific lines in the code:</p> <p><pre><code>```yaml hl_lines=\"3-5 8\"\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>## Adding Line Numbers\n\nLine numbers are automatically added to code blocks, but you can disable them if needed:\n\n```markdown\n```yaml linenums=\"1\"\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>## Adding Annotations\n\nYou can add annotations to specific lines in code blocks:\n\n```markdown\n```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre></p> <ol> <li>This line defines the workflow name</li> <li>These are the events that trigger the workflow <pre><code>## Using Tabs for Multiple Code Examples\n\nYou can group related code examples in tabs:\n\n```markdown\n=== \"GitHub Workflow\"\n    ```yaml\n    name: CI/CD Pipeline with CINC Auditor Scanning\n\n    on:\n      workflow_dispatch:\n        inputs:\n          image_tag:\n            description: 'Tag for the container image'\n            required: true\n            default: 'latest'\n          scan_namespace:\n            description: 'Kubernetes namespace for scanning'\n            required: true\n            default: 'app-scan'\n          threshold:\n            description: 'Minimum passing score (0-100)'\n            required: true\n            default: '70'\n\n    jobs:\n      build-deploy-scan:\n        name: Build, Deploy and Scan Container\n        runs-on: ubuntu-latest\n\n        steps:\n          - name: Checkout code\n            uses: actions/checkout@v4\n\n          - name: Set up Docker Buildx\n            uses: docker/setup-buildx-action@v3\n\n          - name: Define test application\n            run: |\n              # Create a simple application for testing\n              mkdir -p ./app\n\n              # Create a minimal Dockerfile\n              cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n              FROM alpine:latest\n\n              # Add some packages to test vulnerability scanning\n              RUN apk add --no-cache bash curl wget\n\n              # Add a sample script\n              COPY hello.sh /hello.sh\n              RUN chmod +x /hello.sh\n\n              # Set CMD\n              CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n              EOF\n\n              # Create a simple script file\n              cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n              #!/bin/bash\n              echo \"Hello from test container! The time is $(date)\"\n              echo \"Running as user: $(whoami)\"\n              echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n              EOF\n\n          - name: Set up Minikube\n            uses: medyagh/setup-minikube@master\n            with:\n              driver: docker\n              start-args: --nodes=2\n\n          - name: Build container image\n            run: |\n              # Configure to use minikube's Docker daemon\n              eval $(minikube docker-env)\n\n              # Build the image\n              docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n              # List images to confirm\n              docker images | grep test-app\n\n          - name: Create Kubernetes deployment\n            run: |\n              # Create namespace\n              kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n              # Create deployment\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: apps/v1\n              kind: Deployment\n              metadata:\n                name: test-app\n                namespace: ${{ github.event.inputs.scan_namespace }}\n                labels:\n                  app: test-app\n              spec:\n                replicas: 1\n                selector:\n                  matchLabels:\n                    app: test-app\n                template:\n                  metadata:\n                    labels:\n                      app: test-app\n                      security-scan: \"enabled\"\n                  spec:\n                    containers:\n                    - name: app\n                      image: test-app:${{ github.event.inputs.image_tag }}\n                      imagePullPolicy: Never\n              EOF\n\n              # Wait for deployment to be ready\n              kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n              # Get pod name\n              POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n              echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n              # Show pods\n              kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n          - name: Set up CINC Auditor\n            run: |\n              # Install CINC Auditor\n              curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n              # Install train-k8s-container plugin\n              cinc-auditor plugin install train-k8s-container\n\n              # Create a custom profile for application scanning\n              mkdir -p ./app-scan-profile\n\n              # Create profile files\n              cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n              name: app-scan-profile\n              title: Custom Application Container Scan\n              maintainer: Security Team\n              copyright: Security Team\n              license: Apache-2.0\n              summary: A custom profile for scanning containerized applications\n              version: 0.1.0\n              supports:\n                platform: os\n              EOF\n\n              mkdir -p ./app-scan-profile/controls\n\n              cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n              control 'container-1.1' do\n                impact 0.7\n                title 'Ensure container is not running as root'\n                desc 'Containers should not run as root when possible'\n\n                describe command('whoami') do\n                  its('stdout') { should_not cmp 'root' }\n                end\n              end\n\n              control 'container-1.2' do\n                impact 0.5\n                title 'Check container OS version'\n                desc 'Verify the container OS version'\n\n                describe file('/etc/os-release') do\n                  it { should exist }\n                  its('content') { should include 'Alpine' }\n                end\n              end\n\n              control 'container-1.3' do\n                impact 0.3\n                title 'Check for unnecessary packages'\n                desc 'Container should not have unnecessary packages'\n\n                describe package('curl') do\n                  it { should be_installed }\n                end\n\n                describe package('wget') do\n                  it { should be_installed }\n                end\n              end\n\n              control 'container-1.4' do\n                impact 0.7\n                title 'Check for sensitive files'\n                desc 'Container should not have sensitive files'\n\n                describe file('/etc/shadow') do\n                  it { should exist }\n                  it { should_not be_readable.by('others') }\n                end\n              end\n              EOF\n\n          - name: Setup secure scanning infrastructure\n            run: |\n              # Create a unique ID for this run\n              RUN_ID=$(date +%s)\n              echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n              # Create service account\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: v1\n              kind: ServiceAccount\n              metadata:\n                name: cinc-scanner-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              EOF\n\n              # Create role with label-based access\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: rbac.authorization.k8s.io/v1\n              kind: Role\n              metadata:\n                name: cinc-scanner-role-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              rules:\n              - apiGroups: [\"\"]\n                resources: [\"pods\"]\n                verbs: [\"get\", \"list\"]\n              - apiGroups: [\"\"]\n                resources: [\"pods/exec\"]\n                verbs: [\"create\"]\n                # No resourceNames restriction - use label selector in code\n              - apiGroups: [\"\"]\n                resources: [\"pods/log\"]\n                verbs: [\"get\"]\n                # No resourceNames restriction - use label selector in code\n              EOF\n\n              # Create rolebinding\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: rbac.authorization.k8s.io/v1\n              kind: RoleBinding\n              metadata:\n                name: cinc-scanner-binding-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              subjects:\n              - kind: ServiceAccount\n                name: cinc-scanner-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              roleRef:\n                kind: Role\n                name: cinc-scanner-role-${RUN_ID}\n                apiGroup: rbac.authorization.k8s.io\n              EOF\n\n          - name: Setup SAF-CLI\n            run: |\n              # Install Node.js (should already be installed on GitHub runners)\n              node --version || echo \"Node.js not installed\"\n\n              # Install SAF-CLI globally\n              npm install -g @mitre/saf\n\n              # Verify installation\n              saf --version\n\n          - name: Run security scan with CINC Auditor\n            run: |\n              # Generate token\n              TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n              SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n              CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n              # Create kubeconfig\n              cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n              apiVersion: v1\n              kind: Config\n              preferences: {}\n              clusters:\n              - cluster:\n                  server: ${SERVER}\n                  certificate-authority-data: ${CA_DATA}\n                name: scanner-cluster\n              contexts:\n              - context:\n                  cluster: scanner-cluster\n                  namespace: ${{ github.event.inputs.scan_namespace }}\n                  user: scanner-user\n                name: scanner-context\n              current-context: scanner-context\n              users:\n              - name: scanner-user\n                user:\n                  token: ${TOKEN}\n              EOF\n\n              chmod 600 scan-kubeconfig.yaml\n\n              # Verify we can access the pod with our labels\n              POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n              if [ -z \"$POD_NAME\" ]; then\n                echo \"Error: No pod found with security-scan=enabled label\"\n                exit 1\n              fi\n              echo \"Found pod to scan: ${POD_NAME}\"\n\n              # Run the CINC Auditor scan\n              KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n                -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n                --reporter cli json:scan-results.json\n\n              SCAN_EXIT_CODE=$?\n              echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n              # Also run a standard profile for comparison\n              echo \"Running standard DevSec Linux Baseline for comparison:\"\n              KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n                -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n                --reporter cli json:baseline-results.json || true\n\n          - name: Generate scan summary with SAF-CLI\n            run: |\n              # Create summary report with SAF-CLI\n              echo \"Generating scan summary with SAF-CLI:\"\n              saf summary --input scan-results.json --output-md scan-summary.md\n\n              # Display the summary in the logs\n              cat scan-summary.md\n\n              # Create a proper threshold file\n              cat &gt; threshold.yml &lt;&lt; EOF\n    compliance:\n      min: ${{ github.event.inputs.threshold }}\n    failed:\n      critical:\n        max: 0  # No critical failures allowed\n    EOF\n\n              # Apply threshold check\n              echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n              saf threshold -i scan-results.json -t threshold.yml\n              THRESHOLD_EXIT_CODE=$?\n\n              if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n                echo \"\u2705 Security scan passed threshold requirements\"\n              else\n                echo \"\u274c Security scan failed to meet threshold requirements\"\n                # Uncomment to enforce the threshold as a quality gate\n                # exit $THRESHOLD_EXIT_CODE\n              fi\n\n              # Generate summary for baseline results too\n              echo \"Generating baseline summary with SAF-CLI:\"\n              saf summary --input baseline-results.json --output-md baseline-summary.md\n\n              # Create a combined summary for GitHub step summary\n              echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n              cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n              echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n              cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          - name: Upload scan results\n            uses: actions/upload-artifact@v4\n            with:\n              name: security-scan-results\n              path: |\n                scan-results.json\n                baseline-results.json\n                scan-summary.md\n                baseline-summary.md\n\n          - name: Cleanup resources\n            if: always()\n            run: |\n              kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n    ```\n\n=== \"GitLab CI\"\n    ```yaml\n    stages:\n      - deploy\n      - scan\n      - report\n      - cleanup\n\n    variables:\n      SCANNER_NAMESPACE: \"inspec-test\"\n      TARGET_LABEL: \"app=target-app\"\n      THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n    deploy_container:\n      stage: deploy\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: scan-target-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n            labels:\n              app: target-app\n              pipeline: \"${CI_PIPELINE_ID}\"\n          spec:\n            containers:\n            - name: target\n              image: registry.example.com/my-image:latest\n              command: [\"sleep\", \"1h\"]\n          EOF\n        - |\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --timeout=120s\n        - |\n          # Save target info for later stages\n          echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n          echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n      artifacts:\n        reports:\n          dotenv: deploy.env\n\n    create_access:\n      stage: scan\n      needs: [deploy_container]\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          # Create the role for this specific pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${TARGET_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${TARGET_POD}\"]\n          EOF\n        - |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          EOF\n        - |\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${CI_PIPELINE_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n        - |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --duration=30m)\n          echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n          # Save cluster info\n          SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten \\\n            -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n          echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n          echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n      artifacts:\n        reports:\n          dotenv: scanner.env\n\n    run_scan:\n      stage: scan\n      needs: [deploy_container, create_access]\n      script:\n        - |\n          # Create a kubeconfig file\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${CLUSTER_SERVER}\n              certificate-authority-data: ${CLUSTER_CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCANNER_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${SCANNER_TOKEN}\n          EOF\n        - |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Run cinc-auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml \\\n            cinc-auditor exec ${CINC_PROFILE_PATH} \\\n            -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n            --reporter json:scan-results.json\n\n          # Generate scan summary using SAF CLI\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display summary in job output\n          cat scan-summary.md\n\n          # Check scan against threshold\n          saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n          THRESHOLD_RESULT=$?\n\n          # Save result for later stages\n          echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n          if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce threshold as a gate\n            # exit ${THRESHOLD_RESULT}\n          fi\n      artifacts:\n        paths:\n          - scan-results.json\n          - scan-summary.md\n        reports:\n          dotenv: scan.env\n\n    generate_report:\n      stage: report\n      needs: [run_scan]\n      script:\n        - |\n          # Install SAF CLI if needed in this stage\n          which saf || npm install -g @mitre/saf\n\n          # Generate a more comprehensive report\n          saf view -i scan-results.json --output scan-report.html\n\n          # Create a simple markdown report for the MR\n          cat &gt; scan-report.md &lt;&lt; EOF\n          # Security Scan Results\n\n          ## Summary\n\n          $(cat scan-summary.md)\n\n          ## Threshold Check\n\n          ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n          Threshold: ${THRESHOLD_VALUE}%\n\n          ## Details\n\n          For full results, see the artifacts.\n          EOF\n      artifacts:\n        paths:\n          - scan-report.html\n          - scan-report.md\n        when: always\n\n    cleanup:\n      stage: cleanup\n      needs: [run_scan]\n      when: always  # Run even if previous stages failed\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          # Delete all resources\n          kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --ignore-not-found\n    ```\n</code></pre></li> </ol>"},{"location":"contributing/code-snippets/#best-practices","title":"Best Practices","text":"<ol> <li>Use Existing Examples: Reference existing example files rather than duplicating code</li> <li>Relative Paths: Use relative paths from the docs directory</li> <li>Context: Always provide explanatory text around code snippets</li> <li>Highlighting: Use line highlighting to draw attention to important parts</li> <li>Annotations: Add annotations to explain complex code sections</li> </ol>"},{"location":"contributing/code-snippets/#available-example-files","title":"Available Example Files","text":""},{"location":"contributing/code-snippets/#github-workflow-examples","title":"GitHub Workflow Examples","text":"<ul> <li><code>github-workflow-examples/ci-cd-pipeline.yml</code></li> <li><code>github-workflow-examples/setup-and-scan.yml</code></li> <li><code>github-workflow-examples/dynamic-rbac-scanning.yml</code></li> <li><code>github-workflow-examples/existing-cluster-scanning.yml</code></li> <li><code>github-workflow-examples/sidecar-scanner.yml</code></li> </ul>"},{"location":"contributing/code-snippets/#gitlab-ci-examples","title":"GitLab CI Examples","text":"<ul> <li><code>gitlab-pipeline-examples/gitlab-ci.yml</code></li> <li><code>gitlab-pipeline-examples/dynamic-rbac-scanning.yml</code></li> <li><code>gitlab-pipeline-examples/existing-cluster-scanning.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-sidecar.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-sidecar-with-services.yml</code></li> </ul>"},{"location":"contributing/code-snippets/#further-reading","title":"Further Reading","text":"<p>For more information, see:</p> <ul> <li>PyMdown Extensions Documentation</li> <li>Material for MkDocs Code Blocks</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"contributing/diagram-color-guide/","title":"Diagram Color Guide","text":"<p>This guide provides standards for creating accessible, WCAG-compliant diagrams that work well in both light and dark modes.</p>"},{"location":"contributing/diagram-color-guide/#wcag-compliance-for-diagrams","title":"WCAG Compliance for Diagrams","text":"<p>All diagrams should follow the Web Content Accessibility Guidelines (WCAG) 2.1 Level AA standards:</p> <ol> <li>Text Contrast Ratio: Text should have a contrast ratio of at least 4.5:1 against its background</li> <li>Important Graphics: Graphical elements conveying information should have a contrast ratio of at least 3:1</li> <li>Color Independence: Information should not be conveyed by color alone; always use shapes, patterns, or labels alongside color</li> </ol>"},{"location":"contributing/diagram-color-guide/#recommended-color-palette","title":"Recommended Color Palette","text":"<p>The following color palette has been tested for WCAG compliance and works well in both light and dark modes:</p>"},{"location":"contributing/diagram-color-guide/#primary-colors","title":"Primary Colors","text":"Purpose Color Hex Code Light Mode BG Dark Mode BG Primary Blue #0066CC 5.9:1 6.3:1 with white text Secondary Purple #4C366B 7.8:1 8.3:1 with white text Success Green #217645 5.6:1 5.9:1 with white text Warning Orange #DD6100 5.4:1 5.8:1 with white text Danger Red #A30000 8.5:1 9.1:1 with white text Neutral Gray #505050 7.0:1 7.5:1 with white text"},{"location":"contributing/diagram-color-guide/#node-type-colors","title":"Node Type Colors","text":"<p>For consistency across all diagrams, use the following color assignments:</p> <ul> <li>Start/End Nodes: Blue (#0066CC)</li> <li>Process Nodes: Gray (#505050) or Green (#217645)</li> <li>Decision Nodes: Orange (#DD6100)</li> <li>Input/Output Nodes: Purple (#4C366B)</li> <li>Success States: Green (#217645)</li> <li>Failure States: Red (#A30000)</li> </ul>"},{"location":"contributing/diagram-color-guide/#mermaid-diagram-example","title":"Mermaid Diagram Example","text":"<p>Here's an example of a WCAG-compliant Mermaid diagram using the recommended palette:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B{Decision?}\n    B --&gt;|Yes| C[Process 1]\n    B --&gt;|No| D[Process 2]\n    C --&gt; E[Output]\n    D --&gt; E\n    E --&gt; F{Validation}\n    F --&gt;|Pass| G[Success]\n    F --&gt;|Fail| H[Failure]\n    G --&gt; I[End]\n    H --&gt; I\n\n    %% WCAG-compliant styling\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style H fill:#A30000,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style I fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold</code></pre>"},{"location":"contributing/diagram-color-guide/#implementation-in-mermaid","title":"Implementation in Mermaid","text":"<p>When creating Mermaid diagrams, use the following style properties:</p> <pre><code>style NodeID fill:#HexColor,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n</code></pre> <p>For light mode compatibility, white text (#FFFFFF) works well with all the recommended background colors.</p>"},{"location":"contributing/diagram-color-guide/#dark-mode-considerations","title":"Dark Mode Considerations","text":"<p>Our CSS and JavaScript configuration ensures that diagrams display properly in dark mode by:</p> <ol> <li>Increasing border contrast in dark mode</li> <li>Adjusting line thickness for better visibility</li> <li>Increasing font weight in dark mode for better readability</li> <li>Maintaining sufficient contrast for all elements</li> </ol>"},{"location":"contributing/diagram-color-guide/#testing-accessibility","title":"Testing Accessibility","text":"<p>To verify your diagram meets accessibility standards:</p> <ol> <li>Check color contrast using the WebAIM Contrast Checker</li> <li>Test in both light and dark modes</li> <li>Verify readability for users with color vision deficiencies using a tool like Color Oracle</li> </ol>"},{"location":"contributing/diagram-color-guide/#diagram-creation-process","title":"Diagram Creation Process","text":"<ol> <li>Design your diagram structure first</li> <li>Apply the standard color scheme based on node types</li> <li>Add clear, concise labels</li> <li>Include appropriate styling for all nodes</li> <li>Test in both light and dark mode</li> <li>Validate contrast ratios</li> </ol>"},{"location":"contributing/diagram-color-guide/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Pastel Colors: Avoid pale colors that lack sufficient contrast</li> <li>Red/Green Combinations: Avoid using red and green adjacently, which can be problematic for colorblind users</li> <li>Too Many Colors: Limit diagrams to 5-6 distinct colors for clarity</li> <li>Small Text: Ensure text is large enough and has sufficient weight</li> <li>Thin Lines: Use stroke-width of at least 2px for visibility</li> </ul> <p>By following these guidelines, your diagrams will be accessible to all users and display correctly in both light and dark mode themes.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"contributing/documentation-tools/","title":"Documentation Tools","text":"<p>This project provides a comprehensive documentation toolchain to ensure consistent, high-quality documentation. We use MkDocs with the Material theme as our documentation system, along with various validation tools.</p>"},{"location":"contributing/documentation-tools/#the-docs-toolssh-script","title":"The docs-tools.sh Script","text":"<p>Our <code>docs-tools.sh</code> script serves as the unified entry point for all documentation tasks, ensuring all contributors use consistent tooling and validation processes.</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Secure CINC Auditor Kubernetes Container Scanning          \u2503\n\u2503 Documentation Tools                                        \u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n\nUsage: ./docs-tools.sh [command]\n\nDocumentation Preview:\n  preview      - Start MkDocs server for local preview\n  status       - Check status of running preview server\n  stop         - Stop running preview server\n  restart      - Restart preview server\n  serve-prod   - Serve the production build locally\n\nDocumentation Quality:\n  lint         - Check Markdown files for style issues\n  fix          - Automatically fix linting issues where possible\n  spell        - Check spelling in documentation files\n  links        - Check for broken links (requires build first)\n  check-all    - Run all validation checks (lint, spell, links)\n\nBuild and Setup:\n  build        - Build static documentation site\n  setup        - Install/update all dependencies\n  help         - Show this help message\n</code></pre>"},{"location":"contributing/documentation-tools/#getting-started","title":"Getting Started","text":"<p>To start working on documentation:</p> <ol> <li>Clone the repository    <pre><code>git clone https://github.com/mitre/kube-cinc-secure-scanner.git\n</code></pre></li> <li>Navigate to the project root directory    <pre><code>cd kube-cinc-secure-scanner\n</code></pre></li> <li>Run initial setup to install dependencies:</li> </ol> <pre><code>./docs-tools.sh setup\n</code></pre> <ol> <li>Start the preview server:</li> </ol> <pre><code>./docs-tools.sh preview\n</code></pre> <p>The documentation will be available at http://localhost:8000.</p>"},{"location":"contributing/documentation-tools/#documentation-workflow","title":"Documentation Workflow","text":"<p>When working on documentation, follow this recommended workflow:</p>"},{"location":"contributing/documentation-tools/#1-start-your-session","title":"1. Start Your Session","text":"<pre><code># Update dependencies and start preview server\n./docs-tools.sh setup\n./docs-tools.sh preview\n</code></pre>"},{"location":"contributing/documentation-tools/#2-make-your-changes","title":"2. Make Your Changes","text":"<p>Edit markdown files in the <code>docs/</code> directory. The preview server automatically refreshes to show your changes.</p>"},{"location":"contributing/documentation-tools/#3-validate-your-work","title":"3. Validate Your Work","text":"<p>Before committing, always run the validation tools:</p> <pre><code># Check for style, spelling, and link issues\n./docs-tools.sh check-all\n</code></pre>"},{"location":"contributing/documentation-tools/#4-address-any-issues","title":"4. Address Any Issues","text":"<p>For linting issues: <pre><code># Automatically fix common style issues\n./docs-tools.sh fix\n</code></pre></p> <p>For spelling issues: <pre><code># Run spell check and add valid terms to dictionary\n./docs-tools.sh spell\n</code></pre></p>"},{"location":"contributing/documentation-tools/#5-finish-your-session","title":"5. Finish Your Session","text":"<pre><code># Stop the preview server when done\n./docs-tools.sh stop\n</code></pre>"},{"location":"contributing/documentation-tools/#documentation-standards","title":"Documentation Standards","text":"<p>When contributing to documentation, adhere to these standards:</p> <ol> <li>Consistent Terminology:</li> <li>Use \"CINC Auditor\" (not InSpec) consistently</li> <li> <p>Use standardized approach names:</p> <ul> <li>Kubernetes API Approach (recommended for enterprise)</li> <li>Debug Container Approach (interim solution)</li> <li>Sidecar Container Approach (interim solution)</li> </ul> </li> <li> <p>Strategic Emphasis:</p> </li> <li>Emphasize the Kubernetes API Approach as the enterprise-recommended solution</li> <li> <p>Clearly communicate that enhancing the train-k8s-container plugin is the highest strategic priority</p> </li> <li> <p>Links and References:</p> </li> <li>Use relative paths for links (e.g., <code>../overview/workflows.md</code>)</li> <li> <p>Ensure all external links are valid</p> </li> <li> <p>Code Snippets and Examples:</p> </li> <li>Use the Material for MkDocs snippet inclusion feature for code examples</li> <li>Place reusable code snippets in the <code>includes/</code> directory</li> <li> <p>Reference existing example files rather than duplicating them</p> </li> <li> <p>Validation Requirements:</p> </li> <li>All documentation must pass linting checks</li> <li>All spelling must be correct (with project-specific terms added to the dictionary)</li> <li>All links must be valid</li> </ol>"},{"location":"contributing/documentation-tools/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/documentation-tools/#preview-server-issues","title":"Preview Server Issues","text":"<p>If the preview server is unresponsive:</p> <pre><code># Check server status\n./docs-tools.sh status\n\n# Restart if necessary\n./docs-tools.sh restart\n</code></pre>"},{"location":"contributing/documentation-tools/#dependency-issues","title":"Dependency Issues","text":"<p>If you encounter dependency problems:</p> <pre><code># Clean and reinstall dependencies\n./docs-tools.sh setup --force\n</code></pre>"},{"location":"contributing/documentation-tools/#cicd-integration","title":"CI/CD Integration","text":"<p>The documentation is automatically built and validated in CI/CD pipelines using the same tools provided by the <code>docs-tools.sh</code> script. Any pull request with documentation changes will be checked for:</p> <ul> <li>Markdown style compliance</li> <li>Spelling correctness</li> <li>Link validity</li> <li>Successful build</li> </ul>"},{"location":"contributing/documentation-tools/#finding-help","title":"Finding Help","text":"<p>If you need assistance with documentation:</p> <ol> <li>Check the output of <code>./docs-tools.sh help</code></li> <li>Review the comments in the <code>mkdocs.yml</code> file</li> <li>Consult the MkDocs documentation</li> <li>Review the Material for MkDocs documentation</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"contributing/testing/dark-light-mode-test/","title":"Dark/Light Mode Rendering Test","text":"<p>This document tests the rendering of various elements in both dark and light themes to ensure proper display.</p>"},{"location":"contributing/testing/dark-light-mode-test/#mermaid-diagram-test","title":"Mermaid Diagram Test","text":"<p>The following Mermaid diagram should display correctly in both light and dark modes:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Run CINC Auditor Scan]\n    E --&gt; F[Generate Reports]\n    F --&gt; G[Validate Against Thresholds]\n    G --&gt; H[Cleanup Resources]\n    H --&gt; I[End]\n\n    %% High contrast WCAG-compliant colors\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#116644,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#yaml-code-block-test","title":"YAML Code Block Test","text":"<p>YAML code blocks should display with proper syntax highlighting:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: scanner-test-pod\n  labels:\n    app: security-scanner\nspec:\n  containers:\n  - name: scanner\n    image: cinc/auditor:latest\n    command: [\"sleep\", \"3600\"]\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000\n      capabilities:\n        drop: [\"ALL\"]\n  serviceAccountName: scanner-sa\n</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#bash-code-block-test","title":"Bash Code Block Test","text":"<p>Bash code should also display with proper syntax highlighting:</p> <pre><code>#!/bin/bash\n# Example script for scanning\n\n# Set up variables\nNAMESPACE=\"scanner-ns\"\nSERVICE_ACCOUNT=\"scanner-sa\"\nTARGET_POD=\"target-pod\"\n\n# Create scanner kubeconfig\n./scripts/generate-kubeconfig.sh \"$NAMESPACE\" \"$SERVICE_ACCOUNT\"\n\n# Run scanner\ncinc-auditor exec my-profile -t k8s-container://$TARGET_POD --namespace $NAMESPACE\n</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#admonition-test","title":"Admonition Test","text":"<p>Admonitions should display with proper styling in both themes:</p> <p>Note Box</p> <p>This is a note admonition that should display properly in both themes.</p> <p>Warning Box</p> <p>This is a warning admonition that should display properly in both themes.</p> <p>Danger Box</p> <p>This is a danger admonition that should display properly in both themes.</p> <p>Tip Box</p> <p>This is a tip admonition that should display properly in both themes.</p>"},{"location":"contributing/testing/dark-light-mode-test/#table-test","title":"Table Test","text":"<p>Tables should be readable in both themes:</p> Approach Pros Cons Enterprise Readiness Kubernetes API No extra containers Limited to standard containers High Debug Container Works with distroless Requires ephemeral containers Medium Sidecar Universal support Extra container overhead High"},{"location":"contributing/testing/dark-light-mode-test/#dark-mode-vs-light-mode-elements","title":"Dark Mode vs Light Mode Elements","text":"<p>When switching between dark and light modes:</p> <ol> <li>Code block backgrounds should adapt</li> <li>Table borders and backgrounds should adapt</li> <li>Mermaid diagrams should update colors for readability</li> <li>Admonition backgrounds should adapt</li> <li>Text should maintain high contrast</li> </ol>"},{"location":"contributing/testing/dark-light-mode-test/#wcag-compliant-complex-diagram","title":"WCAG-Compliant Complex Diagram","text":"<p>This diagram demonstrates WCAG-compliant colors with good contrast in both light and dark modes:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B{Container Type?}\n    B --&gt;|Standard| C[Run Standard Scan]\n    B --&gt;|Distroless| D{Debug Available?}\n    D --&gt;|Yes| E[Debug Container Scan]\n    D --&gt;|No| F[Sidecar Container Scan]\n    C --&gt; G[Generate Reports]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H{Thresholds Met?}\n    H --&gt;|Yes| I[Pass]\n    H --&gt;|No| J[Fail]\n    I --&gt; K[End]\n    J --&gt; K\n\n    %% WCAG-compliant high contrast color scheme\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style C fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style I fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style J fill:#A30000,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style K fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#color-scheme-explanation","title":"Color Scheme Explanation","text":"<p>The above diagram follows WCAG 2.1 color contrast guidelines:</p> Element Type Color Hex Code Purpose Contrast Ratio Start/End Blue #0066CC Primary flow 6.3:1 with white text Decision Orange #DD6100 Decision points 5.8:1 with white text Process Green #217645 Standard processes 5.9:1 with white text Special Purple #4C366B Special processes 8.3:1 with white text Success Green #217645 Success states 5.9:1 with white text Failure Red #A30000 Failure states 9.1:1 with white text <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"deployment/","title":"Deployment Scenarios","text":"<p>This document provides guidance on deploying the Secure CINC Auditor Kubernetes Container Scanning solution in various environments, from development to production.</p>"},{"location":"deployment/#overview","title":"Overview","text":"<p>The container scanning solution can be deployed in several ways:</p> <ol> <li>Script-based Deployment: Using helper scripts for direct deployment</li> <li>Helm Charts Deployment: Using modular Helm charts for production deployment</li> <li>CI/CD Pipeline Integration: Integrating scanning into existing CI/CD workflows</li> </ol> <p>Each deployment method has its own advantages and is suitable for different scenarios.</p>"},{"location":"deployment/#deployment-prerequisites","title":"Deployment Prerequisites","text":"<p>Before deploying, ensure you have:</p> <ol> <li>Kubernetes Cluster Requirements:</li> <li>Kubernetes 1.16+ (for all features including ephemeral containers)</li> <li>RBAC enabled</li> <li> <p>Service account support</p> </li> <li> <p>Tool Requirements:</p> </li> <li>kubectl with cluster access</li> <li>Helm 3+ (for Helm-based deployment)</li> <li>CINC Auditor/InSpec</li> <li> <p>SAF CLI (for threshold validation)</p> </li> <li> <p>Access Requirements:</p> </li> <li>Permissions to create namespaces, service accounts, and roles</li> <li>Permissions to create and manage pods</li> </ol>"},{"location":"deployment/#script-based-deployment","title":"Script-based Deployment","text":"<p>Ideal for: Development, testing, and one-off scanning operations</p>"},{"location":"deployment/#local-development-environment","title":"Local Development Environment","text":"<pre><code># Set up minikube for development\n./scripts/setup-minikube.sh\n\n# Run a scan against a specific container\n./scripts/scan-container.sh namespace-name pod-name container-name\n</code></pre>"},{"location":"deployment/#production-environment","title":"Production Environment","text":"<pre><code># Configure access to production cluster\nexport KUBECONFIG=/path/to/production/kubeconfig\n\n# Create restricted service account and role\nkubectl apply -f kubernetes/templates/namespace.yaml\nkubectl apply -f kubernetes/templates/service-account.yaml\nkubectl apply -f kubernetes/templates/rbac.yaml\n\n# Run scan with production settings\n./scripts/scan-container.sh namespace-name pod-name container-name --production-mode\n</code></pre>"},{"location":"deployment/#helm-charts-deployment","title":"Helm Charts Deployment","text":"<p>Ideal for: Production environments, automated deployments, and integration with existing Kubernetes workflows</p>"},{"location":"deployment/#basic-helm-deployment","title":"Basic Helm Deployment","text":"<pre><code># Add Helm repository (if hosted externally)\nhelm repo add secure-scanner https://example.com/helm-charts/\nhelm repo update\n\n# Install scanner infrastructure\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure\n\n# Install the appropriate scanner based on your container types\nhelm install standard-scanner ./helm-charts/standard-scanner\n</code></pre>"},{"location":"deployment/#customized-helm-deployment","title":"Customized Helm Deployment","text":"<pre><code># Create custom values file\ncat &gt; custom-values.yaml &lt;&lt; EOF\nglobal:\n  namespace: security-scanning\n  serviceAccount:\n    create: true\n    name: restricted-scanner\n  rbac:\n    timeoutSeconds: 900\n    podSelector:\n      matchLabels:\n        scan: enabled\nEOF\n\n# Install with custom values\nhelm install -f custom-values.yaml scanner-infrastructure ./helm-charts/scanner-infrastructure\n</code></pre>"},{"location":"deployment/#cicd-pipeline-integration-deployment","title":"CI/CD Pipeline Integration Deployment","text":"<p>Ideal for: Automated scanning in CI/CD workflows, DevSecOps pipelines</p>"},{"location":"deployment/#github-actions-deployment","title":"GitHub Actions Deployment","text":"<ol> <li> <p>Add the GitHub Actions workflow to your repository:    <pre><code># .github/workflows/container-scan.yml\nname: Container Security Scan\non: [push, pull_request]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n      - name: Deploy scanner\n        run: ./scripts/setup-minikube.sh\n      - name: Run scan\n        run: ./scripts/scan-container.sh default app-pod app-container\n</code></pre></p> </li> <li> <p>Configure repository secrets for any credentials needed.</p> </li> </ol>"},{"location":"deployment/#gitlab-ci-deployment","title":"GitLab CI Deployment","text":"<ol> <li> <p>Add the GitLab CI pipeline to your repository:    <pre><code># .gitlab-ci.yml\nstages:\n  - deploy\n  - scan\n  - report\n\ndeploy_scanner:\n  stage: deploy\n  script:\n    - ./scripts/setup-minikube.sh\n\nrun_scan:\n  stage: scan\n  script:\n    - ./scripts/scan-container.sh default app-pod app-container\n\ngenerate_report:\n  stage: report\n  script:\n    - saf report -i results.json -o report.html\n  artifacts:\n    paths:\n      - report.html\n</code></pre></p> </li> <li> <p>Configure CI/CD variables for any credentials needed.</p> </li> </ol>"},{"location":"deployment/#deployment-scenarios_1","title":"Deployment Scenarios","text":""},{"location":"deployment/#scenario-1-enterprise-production-environment","title":"Scenario 1: Enterprise Production Environment","text":"<p>Recommended Approach: Helm Charts Deployment</p> <p>Setup: 1. Deploy scanner infrastructure across all required namespaces 2. Configure RBAC with appropriate restrictions 3. Set up automated scanning for critical namespaces 4. Integrate with central compliance monitoring</p> <pre><code># Deploy base infrastructure\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set global.enterprise=true \\\n  --set global.monitoring.enabled=true\n\n# Deploy scanners with appropriate configurations\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set scanSchedule=\"0 0 * * *\" \\\n  --set notifications.slack.enabled=true\n\n# Set up distroless scanner if needed\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set kubernetes.version=1.16+\n</code></pre>"},{"location":"deployment/#scenario-2-development-environment","title":"Scenario 2: Development Environment","text":"<p>Recommended Approach: Script-based Deployment</p> <p>Setup: 1. Use the setup script to configure a local environment 2. Run scans on demand during development 3. Use direct commands for rapid iteration</p> <pre><code># Set up development environment\n./scripts/setup-minikube.sh --dev-mode\n\n# Run scan during development\n./scripts/scan-container.sh default app-pod app-container\n</code></pre>"},{"location":"deployment/#scenario-3-cicd-pipeline-environment","title":"Scenario 3: CI/CD Pipeline Environment","text":"<p>Recommended Approach: CI/CD Pipeline Integration</p> <p>Setup: 1. Integrate scanning into existing CI/CD pipelines 2. Configure threshold validation for pass/fail decisions 3. Generate and archive scan reports</p> <p>For detailed examples, see the CI/CD Integration documentation.</p>"},{"location":"deployment/#scenario-4-multi-tenant-kubernetes-environment","title":"Scenario 4: Multi-Tenant Kubernetes Environment","text":"<p>Recommended Approach: Helm Charts with Label-based RBAC</p> <p>Setup: 1. Deploy scanner infrastructure with label-based RBAC 2. Configure namespaced service accounts 3. Implement strict time-bound token validation</p> <pre><code># Deploy with label-based RBAC\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set rbac.strategy=label-based \\\n  --set rbac.labelSelector=scan=enabled\n</code></pre>"},{"location":"deployment/#scaling-considerations","title":"Scaling Considerations","text":"<p>For environments with a large number of containers to scan:</p> <ol> <li>Parallel Scanning:</li> <li>Configure multiple scanner deployments</li> <li> <p>Use job queues for coordinating scans</p> </li> <li> <p>Resource Allocation:</p> </li> <li>Allocate appropriate CPU and memory resources</li> <li> <p>Configure resource requests and limits</p> </li> <li> <p>Result Storage:</p> </li> <li>Implement centralized result storage</li> <li>Configure automatic cleanup of old results</li> </ol>"},{"location":"deployment/#security-considerations","title":"Security Considerations","text":"<p>When deploying in production:</p> <ol> <li>RBAC Restrictions:</li> <li>Use the most restrictive permissions possible</li> <li>Implement time-bound tokens</li> <li> <p>Consider label-based targeting for multi-tenant environments</p> </li> <li> <p>Scanner Isolation:</p> </li> <li>Run scanners in dedicated namespaces</li> <li>Implement network policies to restrict scanner communications</li> <li> <p>Use non-privileged containers where possible</p> </li> <li> <p>Sensitive Data Handling:</p> </li> <li>Ensure scan results are securely stored</li> <li>Implement access controls for viewing results</li> <li>Consider data retention policies</li> </ol>"},{"location":"deployment/#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":"<p>For long-term deployment:</p> <ol> <li>Health Monitoring:</li> <li>Set up liveness and readiness probes</li> <li>Monitor scanner resource usage</li> <li> <p>Configure alerts for scanner failures</p> </li> <li> <p>Version Updates:</p> </li> <li>Plan for regular updates of scanner components</li> <li>Test updates in a staging environment before production</li> <li> <p>Maintain version compatibility</p> </li> <li> <p>Backup and Recovery:</p> </li> <li>Back up critical scanner configurations</li> <li>Document recovery procedures</li> <li>Test restoration processes</li> </ol>"},{"location":"deployment/#advanced-deployment-options","title":"Advanced Deployment Options","text":""},{"location":"deployment/#air-gapped-environments","title":"Air-Gapped Environments","text":"<p>For environments without internet access:</p> <ol> <li>Download and package all required container images</li> <li>Prepare an internal registry for hosting images</li> <li>Configure Helm charts and scripts to use internal resources</li> </ol>"},{"location":"deployment/#high-security-environments","title":"High-Security Environments","text":"<p>For environments with strict security requirements:</p> <ol> <li>Implement additional security controls</li> <li>Use Mutual TLS for all communications</li> <li>Configure audit logging for all scanner actions</li> </ol>"},{"location":"deployment/#deployment-verification","title":"Deployment Verification","text":"<p>After deployment, verify the setup:</p> <ol> <li> <p>Functionality Check:    <pre><code># Run a test scan\n./scripts/scan-container.sh default test-pod test-container\n</code></pre></p> </li> <li> <p>Security Verification:</p> </li> <li>Confirm RBAC restrictions are working</li> <li>Verify token timeout functionality</li> <li> <p>Check proper cleanup of resources</p> </li> <li> <p>Integration Testing:</p> </li> <li>Verify integration with monitoring systems</li> <li>Test threshold validation</li> <li>Confirm report generation and distribution</li> </ol>"},{"location":"deployment/#additional-resources","title":"Additional Resources","text":"<ul> <li>Helm Charts Documentation</li> <li>RBAC Configuration</li> <li>Service Account Setup</li> <li>Threshold Configuration</li> <li>Integration Options</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"examples/code-display-demo/","title":"Code Display Demo","text":"<p>This page demonstrates the enhanced code display capabilities in our documentation.</p>"},{"location":"examples/code-display-demo/#github-actions-integration-examples","title":"GitHub Actions Integration Examples","text":"<p>Below is an example of a GitHub Actions workflow for setting up and scanning containers:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#highlighting-important-sections","title":"Highlighting Important Sections","text":"<p>Let's highlight the key parts of the configuration:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#adding-annotations","title":"Adding Annotations","text":"<p>Here's the same code with annotations explaining key components:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <ol> <li>This is the workflow name that appears in the GitHub Actions tab</li> <li>This workflow runs when code is pushed to the main branch</li> <li>This section defines the environment variables used throughout the workflow</li> <li>This job sets up the Kubernetes environment for scanning</li> <li>This step uses the official GitHub Action for Kubernetes</li> <li>The scanning job runs after the setup job completes successfully</li> </ol>"},{"location":"examples/code-display-demo/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>Let's compare with a GitLab CI configuration:</p> GitLab CI BasicGitLab CI with Services <pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"examples/code-display-demo/#sidecar-scanner-configuration","title":"Sidecar Scanner Configuration","text":"<p>This is a configuration for the sidecar container approach:</p> <pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#key-configuration-elements","title":"Key Configuration Elements","text":"<p>Let's break down the important configuration elements:</p> <ol> <li>Service Account: The scanner requires appropriate RBAC permissions</li> <li>Container Configuration: The scanner is deployed alongside the application container</li> <li>Volume Mounts: Configuration is provided through ConfigMaps</li> <li>Environment Variables: Control the scanner's behavior</li> </ol>"},{"location":"examples/code-display-demo/#comparing-different-approaches","title":"Comparing Different Approaches","text":"<p>Here's a comparison of different scanning approaches:</p> Sidecar ApproachRBAC ScanningExisting Cluster <pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre> <pre><code>name: Existing Cluster Container Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_namespace:\n        description: 'Namespace where target pods are deployed'\n        required: true\n        default: 'default'\n      target_label:\n        description: 'Label selector for target pods (app=myapp)'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan-existing-cluster:\n    name: Scan Containers in Existing Cluster\n    runs-on: ubuntu-latest\n\n    env:\n      SCAN_NAMESPACE: ${{ github.event.inputs.target_namespace }}\n      LABEL_SELECTOR: ${{ github.event.inputs.target_label }}\n      CINC_PROFILE: ${{ github.event.inputs.cinc_profile }}\n      THRESHOLD_VALUE: ${{ github.event.inputs.threshold }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v3\n\n      - name: Configure Kubernetes cluster\n        run: |\n          # Set up kubeconfig using supplied cluster credentials\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          chmod 600 kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Verify connection and target namespace\n          kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n          # Find pods matching the label selector\n          TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n          if [ -z \"$TARGET_PODS\" ]; then\n            echo \"No pods found matching label: ${LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n            exit 1\n          fi\n\n          # Count and list found pods\n          POD_COUNT=$(echo $TARGET_PODS | wc -w)\n          echo \"Found ${POD_COUNT} pods to scan:\"\n          kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} --show-labels\n\n          # Save the first pod as our primary target\n          PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n          echo \"Primary target pod: ${PRIMARY_POD}\"\n          echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Get container name for the primary pod\n          PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n          echo \"Primary container: ${PRIMARY_CONTAINER}\"\n          echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; $GITHUB_ENV\n\n          # Check if pod has profile annotation\n          PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n          if [ -n \"$PROFILE_ANNOTATION\" ]; then\n            echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n            echo \"CINC_PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; $GITHUB_ENV\n          fi\n\n      - name: Create dynamic RBAC for scanning\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create a unique ID for this run\n          RUN_ID=\"gh-${{ github.run_id }}-${{ github.run_attempt }}\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account for scanning\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          EOF\n\n          # Create role with least privilege\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Create token for service account (15 minute duration)\n          TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create restricted kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCAN_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Set up CINC Auditor and SAF-CLI\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installations\n          cinc-auditor --version\n          saf --version\n\n      - name: Run security scan with restricted access\n        run: |\n          # Verify access with restricted token\n          echo \"Verifying restricted access:\"\n          KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR}\n\n          # Verify we can access the target pod\n          ACCESSIBLE_POD=$(KUBECONFIG=scanner-kubeconfig.yaml kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.name}' 2&gt;/dev/null || echo \"\")\n          if [ -z \"$ACCESSIBLE_POD\" ]; then\n            echo \"Error: Cannot access pod ${PRIMARY_POD} with restricted token\"\n            exit 1\n          fi\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${CINC_PROFILE} \\\n            -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${THRESHOLD_VALUE}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate HTML report\n          saf view -i scan-results.json --output scan-report.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n\n      - name: Cleanup RBAC resources\n        if: always()\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Delete role binding\n          kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete role\n          kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete service account\n          kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"examples/code-display-demo/#conclusion","title":"Conclusion","text":"<p>The code display capabilities demonstrated on this page help make our documentation more:</p> <ul> <li>Clear: Code is syntax highlighted and properly formatted</li> <li>Interactive: Copy buttons and line highlighting improve usability</li> <li>Annotated: Comments help explain complex configurations</li> <li>Consistent: Using the same example files throughout documentation</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"github-workflow-examples/","title":"GitHub Workflow Examples","text":"<p>This directory contains example GitHub Action workflow files that demonstrate various container scanning approaches.</p>"},{"location":"github-workflow-examples/#available-examples","title":"Available Examples","text":"<ul> <li>CI/CD Pipeline: Complete CI/CD pipeline with build, deploy, and scan steps</li> <li>Dynamic RBAC Scanning: Dynamic RBAC implementation with least-privilege model</li> <li>Existing Cluster Scanning: Scanning pods in existing clusters with externally provided credentials</li> <li>Setup and Scan: Setup of minikube and scanning with distroless container support</li> <li>Sidecar Scanner: Sidecar container approach with shared process namespace</li> </ul>"},{"location":"github-workflow-examples/#cicd-pipeline-example","title":"CI/CD Pipeline Example","text":"<pre><code>name: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre>"},{"location":"github-workflow-examples/#dynamic-rbac-scanning-example","title":"Dynamic RBAC Scanning Example","text":"<pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre>"},{"location":"github-workflow-examples/#existing-cluster-scanning-example","title":"Existing Cluster Scanning Example","text":"<pre><code>name: Existing Cluster Container Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_namespace:\n        description: 'Namespace where target pods are deployed'\n        required: true\n        default: 'default'\n      target_label:\n        description: 'Label selector for target pods (app=myapp)'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan-existing-cluster:\n    name: Scan Containers in Existing Cluster\n    runs-on: ubuntu-latest\n\n    env:\n      SCAN_NAMESPACE: ${{ github.event.inputs.target_namespace }}\n      LABEL_SELECTOR: ${{ github.event.inputs.target_label }}\n      CINC_PROFILE: ${{ github.event.inputs.cinc_profile }}\n      THRESHOLD_VALUE: ${{ github.event.inputs.threshold }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v3\n\n      - name: Configure Kubernetes cluster\n        run: |\n          # Set up kubeconfig using supplied cluster credentials\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          chmod 600 kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Verify connection and target namespace\n          kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n          # Find pods matching the label selector\n          TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n          if [ -z \"$TARGET_PODS\" ]; then\n            echo \"No pods found matching label: ${LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n            exit 1\n          fi\n\n          # Count and list found pods\n          POD_COUNT=$(echo $TARGET_PODS | wc -w)\n          echo \"Found ${POD_COUNT} pods to scan:\"\n          kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} --show-labels\n\n          # Save the first pod as our primary target\n          PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n          echo \"Primary target pod: ${PRIMARY_POD}\"\n          echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Get container name for the primary pod\n          PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n          echo \"Primary container: ${PRIMARY_CONTAINER}\"\n          echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; $GITHUB_ENV\n\n          # Check if pod has profile annotation\n          PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n          if [ -n \"$PROFILE_ANNOTATION\" ]; then\n            echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n            echo \"CINC_PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; $GITHUB_ENV\n          fi\n\n      - name: Create dynamic RBAC for scanning\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create a unique ID for this run\n          RUN_ID=\"gh-${{ github.run_id }}-${{ github.run_attempt }}\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account for scanning\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          EOF\n\n          # Create role with least privilege\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Create token for service account (15 minute duration)\n          TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create restricted kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCAN_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Set up CINC Auditor and SAF-CLI\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installations\n          cinc-auditor --version\n          saf --version\n\n      - name: Run security scan with restricted access\n        run: |\n          # Verify access with restricted token\n          echo \"Verifying restricted access:\"\n          KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR}\n\n          # Verify we can access the target pod\n          ACCESSIBLE_POD=$(KUBECONFIG=scanner-kubeconfig.yaml kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.name}' 2&gt;/dev/null || echo \"\")\n          if [ -z \"$ACCESSIBLE_POD\" ]; then\n            echo \"Error: Cannot access pod ${PRIMARY_POD} with restricted token\"\n            exit 1\n          fi\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${CINC_PROFILE} \\\n            -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${THRESHOLD_VALUE}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate HTML report\n          saf view -i scan-results.json --output scan-report.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n\n      - name: Cleanup RBAC resources\n        if: always()\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Delete role binding\n          kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete role\n          kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete service account\n          kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"github-workflow-examples/#setup-and-scan-example","title":"Setup and Scan Example","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"github-workflow-examples/#sidecar-scanner-example","title":"Sidecar Scanner Example","text":"<pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"github-workflow-examples/#usage","title":"Usage","text":"<p>These workflow examples are designed to be adapted to your specific environment. Each example includes detailed comments explaining the purpose of each step and how to customize it for your needs.</p> <p>For detailed information on which scanning approach to use in different scenarios, see: - Approach Comparison - Approach Decision Matrix</p> <p>For detailed GitHub Actions integration instructions, see the GitHub Actions Integration Guide.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"gitlab-pipeline-examples/","title":"GitLab Pipeline Examples","text":"<p>This directory contains example GitLab CI pipeline configuration files that demonstrate various container scanning approaches.</p>"},{"location":"gitlab-pipeline-examples/#available-examples","title":"Available Examples","text":"<ul> <li>Standard Kubernetes API: Four-stage pipeline for container scanning using the Kubernetes API</li> <li>Dynamic RBAC Scanning: Label-based pod targeting with restricted RBAC permissions</li> <li>Existing Cluster Scanning: Configuration for scanning distroless containers</li> <li>GitLab CI with Services: Pipeline using GitLab services for a pre-configured scanning environment</li> <li>Sidecar Container: Pipeline implementing pod deployment with shared process namespace</li> <li>Sidecar with Services: Pipeline using GitLab services for sidecar scanner deployment</li> </ul>"},{"location":"gitlab-pipeline-examples/#standard-gitlab-ci-pipeline","title":"Standard GitLab CI Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#dynamic-rbac-scanning-pipeline","title":"Dynamic RBAC Scanning Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  KUBERNETES_NAMESPACE: \"dynamic-scan-$CI_PIPELINE_ID\"\n  TARGET_IMAGE: \"busybox:latest\"\n  SCAN_LABEL_KEY: \"scan-target\"\n  SCAN_LABEL_VALUE: \"true\"\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\" # Token duration in minutes\n\n# Allow overriding variables through pipeline triggers or UI\n.dynamic_variables: &amp;dynamic_variables\n  TARGET_IMAGE: ${TARGET_IMAGE}\n  SCAN_LABEL_KEY: ${SCAN_LABEL_KEY}\n  SCAN_LABEL_VALUE: ${SCAN_LABEL_VALUE}\n  CINC_PROFILE: ${CINC_PROFILE}\n  THRESHOLD_VALUE: ${THRESHOLD_VALUE}\n  ADDITIONAL_PROFILE_ANNOTATION: \"${ADDITIONAL_PROFILE_ANNOTATION}\"  # Optional annotation for specifying additional profiles\n\nsetup_test_environment:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create test namespace\n    - kubectl create namespace ${KUBERNETES_NAMESPACE}\n\n    # Create multiple test pods with different images and labels\n    - |\n      # Create 3 pods, but only mark the first one for scanning\n      for i in {1..3}; do\n        cat &lt;&lt;EOF | kubectl apply -f -\n        apiVersion: v1\n        kind: Pod\n        metadata:\n          name: pod-${i}\n          namespace: ${KUBERNETES_NAMESPACE}\n          labels:\n            app: test-pod-${i}\n            ${SCAN_LABEL_KEY}: \"$([ $i -eq 1 ] &amp;&amp; echo \"${SCAN_LABEL_VALUE}\" || echo \"false\")\"\n          annotations:\n            scan-profile: \"${CINC_PROFILE}\"\n            $([ -n \"${ADDITIONAL_PROFILE_ANNOTATION}\" ] &amp;&amp; echo \"${ADDITIONAL_PROFILE_ANNOTATION}\" || echo \"\")\n        spec:\n          containers:\n          - name: container\n            image: ${TARGET_IMAGE}\n            command: [\"sleep\", \"infinity\"]\n        EOF\n      done\n\n    # Wait for pods to be ready\n    - kubectl wait --for=condition=ready pod -l app=test-pod-1 -n ${KUBERNETES_NAMESPACE} --timeout=120s\n\n    # Get the name of the pod with our scan label\n    - |\n      TARGET_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$TARGET_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n        exit 1\n      fi\n      echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; deploy.env\n\n    # Save scan profile from annotations if available\n    - |\n      SCAN_PROFILE=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}')\n      if [ -n \"$SCAN_PROFILE\" ]; then\n        echo \"Found scan profile annotation: ${SCAN_PROFILE}\"\n        echo \"SCAN_PROFILE=${SCAN_PROFILE}\" &gt;&gt; deploy.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"SCAN_PROFILE=${CINC_PROFILE}\" &gt;&gt; deploy.env\n      fi\n\n    # Show all pods in the namespace\n    - kubectl get pods -n ${KUBERNETES_NAMESPACE} --show-labels\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_dynamic_rbac:\n  stage: scan\n  needs: [setup_test_environment]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      EOF\n\n    # Create role with label-based access\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role\n        namespace: ${KUBERNETES_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding\n        namespace: ${KUBERNETES_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token\n    - |\n      TOKEN=$(kubectl create token scanner-sa -n ${KUBERNETES_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_security_scan:\n  stage: scan\n  needs: [setup_test_environment, create_dynamic_rbac]\n  script:\n    # Create kubeconfig with restricted token\n    - |\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scan-kubeconfig.yaml\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n    # Install train-k8s-container plugin\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - npm install -g @mitre/saf\n\n    # Verify the tools\n    - cinc-auditor --version\n    - saf --version\n\n    # Find the target pod by label using the restricted token\n    - |\n      echo \"Looking for pods with label: ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n      SCANNED_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$SCANNED_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} using restricted access\"\n        exit 1\n      fi\n      echo \"Found target pod: ${SCANNED_POD}\"\n\n      # Verify it matches what we expected\n      if [ \"$SCANNED_POD\" != \"$TARGET_POD\" ]; then\n        echo \"Warning: Scanned pod ($SCANNED_POD) doesn't match expected target pod ($TARGET_POD)\"\n      fi\n\n    # Get container name\n    - CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n\n    # Run CINC Auditor scan\n    - |\n      echo \"Running CINC Auditor scan on ${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME}\"\n      KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${SCAN_PROFILE} \\\n        -t k8s-container://${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate comprehensive HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\nverify_rbac_restrictions:\n  stage: verify\n  needs: [setup_test_environment, create_dynamic_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a second kubeconfig with restricted token\n    - |\n      cat &gt; verify-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 verify-kubeconfig.yaml\n\n    # Get a non-target pod name\n    - OTHER_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${KUBERNETES_NAMESPACE} --resource-name=${TARGET_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n      echo \"Cannot create pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i delete pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n    # Create a security report for MR\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Results\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Details\n\n      - Target Pod: \\`${TARGET_POD}\\`\n      - Container: \\`${CONTAINER_NAME}\\`\n      - Image: \\`${TARGET_IMAGE}\\`\n      - Profile: \\`${SCAN_PROFILE}\\`\n\n      For full results, see the scan artifacts.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\ncleanup:\n  stage: cleanup\n  needs: [setup_test_environment]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete namespace ${KUBERNETES_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#existing-cluster-scanning-pipeline","title":"Existing Cluster Scanning Pipeline","text":"<pre><code>stages:\n  - prepare\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  # Default values - override in UI or with pipeline parameters\n  SCAN_NAMESPACE: \"default\"  # Existing namespace where pods are deployed\n  TARGET_LABEL_SELECTOR: \"scan-target=true\"  # Label to identify target pods\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\"  # Token duration in minutes\n\n# Define workflow\nworkflow:\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"web\"  # Manual trigger from UI\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"  # Scheduled pipeline\n    - if: $CI_PIPELINE_SOURCE == \"trigger\"  # API trigger with token\n\n# Find pods to scan in existing cluster\nprepare_scan:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  script:\n    # Configure kubectl with cluster credentials\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a unique run ID for this pipeline\n    - RUN_ID=\"gl-$CI_PIPELINE_ID-$CI_JOB_ID\"\n    - echo \"RUN_ID=${RUN_ID}\" &gt;&gt; prepare.env\n\n    # Verify the namespace exists\n    - kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n    # Find target pods with specified label\n    - |\n      TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n      if [ -z \"$TARGET_PODS\" ]; then\n        echo \"No pods found matching label: ${TARGET_LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n        exit 1\n      fi\n\n      # Count and list found pods\n      POD_COUNT=$(echo $TARGET_PODS | wc -w)\n      echo \"Found ${POD_COUNT} pods to scan:\"\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} --show-labels\n\n      # Get the first pod as primary target\n      PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n      echo \"Primary target pod: ${PRIMARY_POD}\"\n      echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; prepare.env\n\n      # Get container name for the primary pod\n      PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n      echo \"Primary container: ${PRIMARY_CONTAINER}\"\n      echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; prepare.env\n\n      # Check for custom profile annotation\n      PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$PROFILE_ANNOTATION\" ]; then\n        echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n        echo \"PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; prepare.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"PROFILE=${CINC_PROFILE}\" &gt;&gt; prepare.env\n      fi\n  artifacts:\n    reports:\n      dotenv: prepare.env\n\n# Create temporary RBAC for scanning\ncreate_rbac:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account for scanning\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      EOF\n\n    # Create role with least privilege\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${RUN_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token for service account\n    - |\n      TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; rbac.env\n  artifacts:\n    reports:\n      dotenv: rbac.env\n\n# Run the security scan with restricted access\nrun_security_scan:\n  stage: scan\n  image: registry.gitlab.com/gitlab-org/security-products/analyzers/container-scanning:5\n  needs: [prepare_scan, create_rbac]\n  script:\n    # Create restricted kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Install CINC Auditor and plugins\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - apt-get update &amp;&amp; apt-get install -y npm\n    - npm install -g @mitre/saf\n\n    # Test restricted access\n    - |\n      echo \"Testing restricted access:\"\n      export KUBECONFIG=scanner-kubeconfig.yaml\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR}\n\n      echo \"Verifying target pod access:\"\n      kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o name || { echo \"Cannot access target pod with restricted token\"; exit 1; }\n\n    # Run the scan\n    - |\n      echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n      KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n        -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n      - threshold.yml\n    reports:\n      dotenv: scan.env\n\n# Verify RBAC permissions are properly restricted\nverify_rbac:\n  stage: verify\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan, create_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create restricted kubeconfig for testing\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${PRIMARY_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n\n      echo \"Cannot create pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i delete pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n      # Find non-target pod for testing\n      OTHER_POD=$(kubectl get pods -n ${SCAN_NAMESPACE} -l app!=scan-target -o jsonpath='{.items[0].metadata.name}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$OTHER_POD\" ] &amp;&amp; [ \"$OTHER_POD\" != \"$PRIMARY_POD\" ]; then\n        echo \"Cannot exec into non-target pod:\"\n        KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${OTHER_POD} &amp;&amp; \n          echo \"\u274c Security issue: Can exec into non-target pod\" || \n          echo \"\u2705 Cannot exec into non-target pod (expected)\"\n      fi\n\n    # Create security report\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Details\n\n      - **Pipeline:** ${CI_PIPELINE_ID}\n      - **Target Namespace:** ${SCAN_NAMESPACE}\n      - **Target Pod:** ${PRIMARY_POD}\n      - **Target Container:** ${PRIMARY_CONTAINER}\n      - **CINC Profile:** ${PROFILE}\n      - **Compliance Threshold:** ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot exec into non-target pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Results\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      See scan artifacts for detailed compliance results.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\n# Always clean up RBAC resources\ncleanup_rbac:\n  stage: cleanup\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Delete role binding\n    - kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete role\n    - kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete service account\n    - kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    - echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"gitlab-pipeline-examples/#gitlab-ci-with-services-pipeline","title":"GitLab CI with Services Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#sidecar-container-pipeline","title":"Sidecar Container Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for CINC profile\n      cat &gt; container-baseline.rb &lt;&lt; EOF\n      # Example CINC Auditor profile for container scanning\n\n      title \"Container Baseline\"\n\n      control \"container-1.1\" do\n        impact 0.7\n        title \"Container files should have proper permissions\"\n        desc \"Critical files in the container should have proper permissions.\"\n\n        describe file('/etc/passwd') do\n          it { should exist }\n          its('mode') { should cmp '0644' }\n        end\n      end\n\n      control \"container-1.2\" do\n        impact 0.5\n        title \"Container should not have unnecessary packages\"\n        desc \"Container should be minimal and not contain unnecessary packages.\"\n\n        describe directory('/var/lib/apt') do\n          it { should_not exist }\n        end\n      end\n      EOF\n\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=container-baseline.rb \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: ruby:3.0-slim\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Install dependencies\n            apt-get update\n            apt-get install -y curl gnupg procps nodejs npm\n\n            # Install CINC Auditor\n            curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n            # Install SAF CLI\n            npm install -g @mitre/saf\n\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=\\$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print \\$2}')\n\n            if [ -z \"\\$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID \\$TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/\\$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=\\$?\n\n            echo \"Scan completed with exit code: \\$SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=\\$?\n                echo \"Threshold validation result: \\$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json ./scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md ./scan-summary.md -c scanner\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#sidecar-with-services-pipeline","title":"Sidecar with Services Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\n# Define a custom service image for CINC Auditor sidecar deployment\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Copy profile from within the service container\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n      docker exec cinc-scanner ls -la /tmp/profile\n\n      # Create ConfigMap for CINC profile from the service container\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=$(docker exec cinc-scanner find /tmp/profile -name \"*.rb\" | head -1) \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print $2}')\n\n            if [ -z \"$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID $TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=$?\n\n            echo \"Scan completed with exit code: $SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=$?\n                echo \"$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results using the service container\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json /tmp/scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md /tmp/scan-summary.md -c scanner\n\n      # Copy results to service container for processing\n      docker cp /tmp/scan-results.json cinc-scanner:/tmp/\n      docker cp /tmp/scan-summary.md cinc-scanner:/tmp/\n\n      # Process results in the service container\n      docker exec cinc-scanner bash -c \"\n        # Generate normalized report\n        saf normalize -i /tmp/scan-results.json -o /tmp/normalized-results.json\n\n        # Additional report processing\n        saf view -i /tmp/scan-results.json --output /tmp/scan-report.html\n      \"\n\n      # Copy processed results back\n      docker cp cinc-scanner:/tmp/normalized-results.json ./normalized-results.json\n      docker cp cinc-scanner:/tmp/scan-report.html ./scan-report.html\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - normalized-results.json\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\n# This example shows how to utilize the service container \n# to generate specialized reports from the scan results\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Use the service container to generate comprehensive reports\n      docker cp scan-results.json cinc-scanner:/tmp/\n\n      # Generate multiple report formats in the service container\n      docker exec cinc-scanner bash -c \"\n        cd /tmp\n\n        # Generate HTML report\n        saf view -i scan-results.json --output enhanced-report.html\n\n        # Generate CSV report\n        saf generate -i scan-results.json -o csv &gt; results.csv\n\n        # Generate Excel report\n        saf generate -i scan-results.json -o xlsx &gt; results.xlsx\n\n        # Generate JUnit report for CI integration\n        saf generate -i scan-results.json -o junit &gt; junit.xml\n      \"\n\n      # Copy all reports back\n      docker cp cinc-scanner:/tmp/enhanced-report.html ./enhanced-report.html\n      docker cp cinc-scanner:/tmp/results.csv ./results.csv\n      docker cp cinc-scanner:/tmp/results.xlsx ./results.xlsx\n      docker cp cinc-scanner:/tmp/junit.xml ./junit.xml\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([ \"${THRESHOLD_PASSED}\" -eq 0 ] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the enhanced report artifacts.\n\n      * HTML Report: enhanced-report.html\n      * CSV Report: results.csv\n      * Excel Report: results.xlsx\n      * JUnit Report: junit.xml\n      EOF\n  artifacts:\n    paths:\n      - enhanced-report.html\n      - results.csv\n      - results.xlsx\n      - junit.xml\n      - scan-report.md\n    reports:\n      junit: junit.xml\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#usage","title":"Usage","text":"<p>These pipeline examples are designed to be adapted to your specific environment. Each example includes detailed comments explaining the purpose of each step and how to customize it for your needs.</p> <p>Strategic Priority</p> <p>We strongly recommend the Kubernetes API Approach (standard GitLab CI example) for enterprise-grade container scanning. Our highest priority is enhancing the train-k8s-container plugin to support distroless containers. The other examples provide interim solutions until this enhancement is complete.</p> <p>For detailed information on which scanning approach to use in different scenarios, see: - Approach Comparison - Approach Decision Matrix</p> <p>For detailed GitLab integration instructions, see the GitLab Integration Guide.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/architecture/","title":"Helm Chart Architecture","text":"<p>This document provides a detailed overview of the architecture, relationships, and design principles of our Helm charts for Kubernetes container scanning.</p>"},{"location":"helm-charts/architecture/#chart-relationship-diagram","title":"Chart Relationship Diagram","text":"<pre><code>graph TD\n    subgraph \"Core Infrastructure\"\n        A[scanner-infrastructure] --&gt; A1[RBAC]\n        A --&gt; A2[Service Accounts]\n        A --&gt; A3[Token Management]\n        A --&gt; A4[Namespace]\n    end\n\n    subgraph \"Common Components\"\n        B[common-scanner] --&gt; B1[Scanning Scripts]\n        B --&gt; B2[SAF CLI Integration]\n        B --&gt; B3[Threshold Configuration]\n    end\n\n    subgraph \"Scanning Approaches\"\n        C[standard-scanner] --&gt; C1[Kubernetes API Scanning]\n        D[distroless-scanner] --&gt; D1[Debug Container Scanning]\n        E[sidecar-scanner] --&gt; E1[Sidecar Container Scanning]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n\n    classDef core fill:#f9f,stroke:#333,stroke-width:2px\n    classDef common fill:#bbf,stroke:#333,stroke-width:2px\n    classDef scanning fill:#bfb,stroke:#333,stroke-width:2px\n\n    class A,A1,A2,A3,A4 core\n    class B,B1,B2,B3 common\n    class C,C1,D,D1,E,E1 scanning</code></pre>"},{"location":"helm-charts/architecture/#layered-architecture","title":"Layered Architecture","text":"<p>Our Helm charts follow a layered architecture pattern with three distinct layers:</p> <ol> <li>Core Infrastructure Layer (scanner-infrastructure)</li> <li>Foundation for all scanning operations</li> <li>RBAC and security model implementation</li> <li>Service account and access control</li> <li> <p>Namespace management</p> </li> <li> <p>Common Components Layer (common-scanner)</p> </li> <li>Reusable scanning utilities and scripts</li> <li>SAF CLI integration for compliance validation</li> <li>Threshold configuration for pass/fail criteria</li> <li> <p>Results processing and reporting</p> </li> <li> <p>Scanning Approaches Layer (approach-specific charts)</p> </li> <li>Specialized components for each scanning approach</li> <li>Test pods for demonstration and validation</li> <li>Approach-specific configurations</li> <li>Usage examples</li> </ol>"},{"location":"helm-charts/architecture/#component-details","title":"Component Details","text":""},{"location":"helm-charts/architecture/#scanner-infrastructure","title":"scanner-infrastructure","text":"<p>The scanner-infrastructure chart creates the foundational security components:</p> <pre><code>graph TD\n    subgraph \"scanner-infrastructure\"\n        SA[Service Account] --&gt; RB[Role Binding]\n        R[Role] --&gt; RB\n        N[Namespace] --&gt; SA\n        CM[ConfigMap: Scripts] --&gt; SA\n    end</code></pre> <p>Key components: - Namespace: Isolated environment for scanning operations - Service Account: Identity for scanning operations - Role: Defines permissions needed for scanning - RoleBinding: Associates role with service account - ConfigMap: Scripts: Helper scripts for token generation</p>"},{"location":"helm-charts/architecture/#common-scanner","title":"common-scanner","text":"<p>The common-scanner chart provides shared components for scanning operations:</p> <pre><code>graph TD\n    subgraph \"common-scanner\"\n        SCS[ConfigMap: Scanning Scripts] --&gt; SAFC[SAF CLI Integration]\n        TC[ConfigMap: Thresholds] --&gt; SAFC\n    end</code></pre> <p>Key components: - ConfigMap: Scanning Scripts: CINC Auditor execution scripts - ConfigMap: Thresholds: Compliance threshold configuration - SAF CLI Integration: MITRE SAF CLI integration for results processing</p>"},{"location":"helm-charts/architecture/#standard-scanner-kubernetes-api-approach","title":"standard-scanner (Kubernetes API Approach)","text":"<p>The standard-scanner chart implements the Kubernetes API Approach:</p> <pre><code>graph TD\n    subgraph \"standard-scanner\"\n        TP[Test Pod] --&gt; CINC[CINC Auditor]\n        CINC --&gt; K8S[Kubernetes API]\n        K8S --&gt; TCP[Target Container Pod]\n    end</code></pre> <p>Key components: - Test Pod: Demo pod for validation - CINC Auditor: Execution via train-k8s-container transport - Kubernetes API: Direct interaction with target containers</p>"},{"location":"helm-charts/architecture/#distroless-scanner-debug-container-approach","title":"distroless-scanner (Debug Container Approach)","text":"<p>The distroless-scanner chart implements the Debug Container Approach:</p> <pre><code>graph TD\n    subgraph \"distroless-scanner\"\n        TP[Test Pod: Distroless] --&gt; DC[Debug Container]\n        DC --&gt; FS[Filesystem Access]\n        FS --&gt; TCP[Target Container]\n    end</code></pre> <p>Key components: - Test Pod: Distroless: Demo distroless container - Debug Container: Ephemeral container for scanning - Filesystem Access: Access to target container's filesystem</p>"},{"location":"helm-charts/architecture/#sidecar-scanner-sidecar-container-approach","title":"sidecar-scanner (Sidecar Container Approach)","text":"<p>The sidecar-scanner chart implements the Sidecar Container Approach:</p> <pre><code>graph TD\n    subgraph \"sidecar-scanner\"\n        TP[Pod with Two Containers] --&gt; TC[Target Container]\n        TP --&gt; SC[Scanner Sidecar]\n        SC --&gt; SH[Shared Process Namespace]\n        SH --&gt; TC\n    end</code></pre> <p>Key components: - Pod with Two Containers: Combined target and scanner - Target Container: Application container to scan - Scanner Sidecar: Container with CINC Auditor - Shared Process Namespace: Access between containers</p>"},{"location":"helm-charts/architecture/#value-flow","title":"Value Flow","text":"<p>Values flow through the chart hierarchy, allowing configuration at multiple levels:</p> <pre><code>graph TD\n    A[User Values] --&gt; B[standard-scanner Values]\n    B --&gt; C[common-scanner Values]\n    C --&gt; D[scanner-infrastructure Values]\n    D --&gt; E[Final Configuration]</code></pre> <p>This allows: - Global values set at top level - Approach-specific overrides - Component-specific settings - Local environment customization</p>"},{"location":"helm-charts/architecture/#security-model","title":"Security Model","text":"<p>The security model is implemented across all chart layers:</p> <pre><code>graph TD\n    subgraph \"Security Implementation\"\n        LP[Least Privilege] --&gt; RBAC[RBAC Controls]\n        RBAC --&gt; SA[Service Account]\n        SA --&gt; TK[Short-lived Tokens]\n        NS[Namespace Isolation] --&gt; RBAC\n    end</code></pre> <p>Key security features: - Least Privilege: Minimal permissions required - RBAC Controls: Fine-grained access control - Service Account: Dedicated identity for scanning - Short-lived Tokens: Time-limited access - Namespace Isolation: Segmentation by namespace</p>"},{"location":"helm-charts/architecture/#deployment-flow","title":"Deployment Flow","text":"<p>The typical deployment flow involves these steps:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Helm\n    participant K8s as Kubernetes\n    participant Scanner\n\n    User-&gt;&gt;Helm: Install Chart\n    Helm-&gt;&gt;K8s: Create Resources\n    User-&gt;&gt;K8s: Generate Tokens\n    User-&gt;&gt;Scanner: Run Scan\n    Scanner-&gt;&gt;K8s: Access Container\n    Scanner-&gt;&gt;User: Return Results</code></pre> <ol> <li>User installs Helm chart</li> <li>Helm creates Kubernetes resources</li> <li>User generates short-lived tokens</li> <li>User runs scanning operation</li> <li>Scanner accesses container via K8s API</li> <li>Results returned to user</li> </ol>"},{"location":"helm-charts/architecture/#integration-points","title":"Integration Points","text":"<p>Our charts provide integration points with external systems:</p> <pre><code>graph TD\n    subgraph \"Integration Points\"\n        Charts[Helm Charts] --&gt; CI[CI/CD Systems]\n        Charts --&gt; SM[Secret Management]\n        Charts --&gt; LO[Logging/Monitoring]\n        Charts --&gt; CMDB[CMDB/Inventory]\n    end</code></pre> <p>Key integration points: - CI/CD Systems: Pipeline integration - Secret Management: External secrets for tokens - Logging/Monitoring: Result tracking and alerting - CMDB/Inventory: Asset tracking and management</p>"},{"location":"helm-charts/architecture/#chart-dependencies","title":"Chart Dependencies","text":"<p>Formal Helm chart dependencies are defined in Chart.yaml files:</p> Chart Dependencies scanner-infrastructure None common-scanner scanner-infrastructure standard-scanner common-scanner distroless-scanner common-scanner sidecar-scanner common-scanner <p>These dependencies ensure proper installation order and value inheritance.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/common-scanner/","title":"Common Scanner Chart","text":""},{"location":"helm-charts/common-scanner/#overview","title":"Overview","text":"<p>The <code>common-scanner</code> chart provides shared utilities and components for container scanning in Kubernetes. It builds on top of the <code>scanner-infrastructure</code> chart and delivers the core scanning functionality used by all scanning approach-specific charts.</p> <p>This chart implements scanning scripts, SAF CLI integration for compliance validation, and threshold configuration for pass/fail determination.</p>"},{"location":"helm-charts/common-scanner/#components","title":"Components","text":""},{"location":"helm-charts/common-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>ConfigMap: Scanning Scripts</li> <li>Shell scripts for executing CINC Auditor scans</li> <li>Helper utilities for results processing</li> <li> <p>Support for both standard and distroless scanning</p> </li> <li> <p>ConfigMap: Thresholds</p> </li> <li>Compliance threshold configuration</li> <li>Rules for pass/fail determination</li> <li>Customizable by severity level</li> </ol>"},{"location":"helm-charts/common-scanner/#features","title":"Features","text":""},{"location":"helm-charts/common-scanner/#saf-cli-integration","title":"SAF CLI Integration","text":"<p>The chart integrates with the MITRE SAF CLI for compliance reporting and validation:</p> <ul> <li>Threshold-Based Validation: Define pass/fail criteria</li> <li>Compliance Scoring: Calculate overall compliance percentage</li> <li>Results Formatting: Format scan results for reporting</li> <li>Failure Handling: Process scan failures with configurable behavior</li> </ul>"},{"location":"helm-charts/common-scanner/#scanning-scripts","title":"Scanning Scripts","text":"<p>Includes specialized scripts for different scanning scenarios:</p> <ol> <li>scan-container.sh: Standard container scanning</li> <li>scan-distroless-container.sh: Distroless container scanning with debug containers</li> <li>scan-with-sidecar.sh: Scanning with sidecar container approach</li> </ol>"},{"location":"helm-charts/common-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/common-scanner/#basic-installation","title":"Basic Installation","text":"<pre><code># Install common scanner components with default settings\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/common-scanner/#custom-threshold-configuration","title":"Custom Threshold Configuration","text":"<pre><code># Install with custom threshold settings\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set safCli.thresholdConfig.compliance.min=90 \\\n  --set safCli.thresholdConfig.failed.critical.max=0 \\\n  --set safCli.thresholdConfig.failed.high.max=0 \\\n  --set safCli.thresholdConfig.failed.medium.max=5 \\\n  --set safCli.thresholdConfig.failed.low.max=10\n</code></pre>"},{"location":"helm-charts/common-scanner/#external-threshold-file","title":"External Threshold File","text":"<pre><code># Install with reference to external threshold file\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set safCli.thresholdFilePath=/path/to/threshold.yml\n</code></pre>"},{"location":"helm-charts/common-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/common-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/common-scanner/#script-configuration","title":"Script Configuration","text":"Parameter Description Default Required <code>scripts.generate</code> Generate helper scripts <code>true</code> No <code>scripts.directory</code> Directory for scripts <code>/tmp/inspec-scanner</code> No <code>scripts.includeScanScript</code> Include scan-container.sh <code>true</code> No <code>scripts.includeDistrolessScanScript</code> Include distroless scanning script <code>true</code> No <code>scripts.includeSidecarScanScript</code> Include sidecar scanning script <code>true</code> No"},{"location":"helm-charts/common-scanner/#saf-cli-configuration","title":"SAF CLI Configuration","text":"Parameter Description Default Required <code>safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/common-scanner/#threshold-configuration","title":"Threshold Configuration","text":"Parameter Description Default Required <code>safCli.thresholdConfig.compliance.min</code> Minimum compliance score <code>70</code> No <code>safCli.thresholdConfig.failed.critical.max</code> Maximum critical failures <code>0</code> No <code>safCli.thresholdConfig.failed.high.max</code> Maximum high failures <code>2</code> No <code>safCli.thresholdConfig.failed.medium.max</code> Maximum medium failures <code>5</code> No <code>safCli.thresholdConfig.failed.low.max</code> Maximum low failures <code>10</code> No <code>safCli.thresholdConfig.skipped.total.max</code> Maximum skipped controls <code>5</code> No"},{"location":"helm-charts/common-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/common-scanner/#basic-scanning","title":"Basic Scanning","text":"<p>After installing the chart, you can use the scanning scripts:</p> <pre><code># Generate kubeconfig\n./scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n\n# Run standard container scan\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/common-scanner/#threshold-configuration-examples","title":"Threshold Configuration Examples","text":"<p>Create a custom threshold file for compliance requirements:</p> <pre><code># threshold.yml\ncompliance:\n  min: 90\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\n  medium:\n    max: 2\n  low:\n    max: 5\nskipped:\n  total:\n    max: 3\n</code></pre> <p>Then use it in scanning:</p> <pre><code># Run scan with custom threshold\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/common-scanner/#integration-with-cicd","title":"Integration with CI/CD","text":""},{"location":"helm-charts/common-scanner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Container Scanning\n\non: [push, pull_request]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up kubeconfig\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; ./kubeconfig.yaml\n\n      - name: Run container scan\n        run: |\n          ./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline \\\n            --threshold-file=./ci-threshold.yml\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/common-scanner/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>container_scan:\n  stage: test\n  image: cinc-auditor:latest\n  script:\n    - mkdir -p ~/.kube\n    - echo \"$KUBECONFIG_DATA\" &gt; ~/.kube/config\n    - chmod 600 ~/.kube/config\n    - ./scripts/scan-container.sh ${CI_ENVIRONMENT_NAME} target-pod container-name ./profiles/container-baseline\n  variables:\n    THRESHOLD_FILE: ./ci-threshold.yml\n  artifacts:\n    paths:\n      - scan-results.json\n      - compliance-report.md\n</code></pre>"},{"location":"helm-charts/common-scanner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"helm-charts/common-scanner/#common-issues","title":"Common Issues","text":"<ol> <li>SAF CLI Integration Failures</li> <li>Verify SAF CLI is installed in execution environment</li> <li>Check threshold file format is correct</li> <li> <p>Ensure scan results are properly formatted</p> </li> <li> <p>Script Execution Errors</p> </li> <li>Check script permissions are executable</li> <li>Verify script directory exists and is writable</li> <li> <p>Ensure kubeconfig file is valid</p> </li> <li> <p>Threshold Validation Issues</p> </li> <li>Check threshold file syntax</li> <li>Verify threshold values are appropriate for profile</li> <li>Check if threshold file path exists</li> </ol>"},{"location":"helm-charts/common-scanner/#debugging","title":"Debugging","text":"<p>Add debugging to scan scripts by setting environment variables:</p> <pre><code># Enable debug output\nexport DEBUG=true\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n\n# Preserve intermediate files\nexport PRESERVE_TEMP=true\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/customization/","title":"Helm Chart Customization Guide","text":""},{"location":"helm-charts/customization/#overview","title":"Overview","text":"<p>This guide provides detailed instructions for customizing the Secure Kubernetes Container Scanning Helm charts to meet your specific needs. Our charts are designed to be highly customizable while maintaining security best practices and operational efficiency.</p>"},{"location":"helm-charts/customization/#common-customization-scenarios","title":"Common Customization Scenarios","text":""},{"location":"helm-charts/customization/#1-custom-security-profiles","title":"1. Custom Security Profiles","text":""},{"location":"helm-charts/customization/#adding-custom-cinc-auditor-profiles","title":"Adding Custom CINC Auditor Profiles","text":"<p>To add your own custom compliance profiles:</p> <pre><code># Create a custom profile ConfigMap\nkubectl create configmap custom-profiles -n scanning-namespace \\\n  --from-file=./my-custom-profile\n\n# Reference custom profile in sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set profiles.default.enabled=false \\\n  --set profiles.custom[0].name=my-profile \\\n  --set profiles.custom[0].configMap=custom-profiles \\\n  --set profiles.custom[0].path=/my-custom-profile\n</code></pre> <p>Alternatively, build a custom scanner image with embedded profiles:</p> <pre><code># Dockerfile for custom scanner image\nFROM chef/inspec:5.18.14\n\n# Add custom profiles\nCOPY ./my-profiles /profiles\n\n# Add custom scripts\nCOPY ./scripts /scripts\nRUN chmod +x /scripts/*.sh\n</code></pre> <p>Then use this custom image:</p> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=my-registry/custom-scanner:latest\n</code></pre>"},{"location":"helm-charts/customization/#2-custom-threshold-configurations","title":"2. Custom Threshold Configurations","text":""},{"location":"helm-charts/customization/#creating-environment-specific-thresholds","title":"Creating Environment-Specific Thresholds","text":"<p>Create different threshold files for various environments:</p> <pre><code># development-threshold.yml\ncompliance:\n  min: 70\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 5\n  medium:\n    max: 10\n</code></pre> <pre><code># production-threshold.yml\ncompliance:\n  min: 95\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\n  medium:\n    max: 2\n</code></pre> <p>Use them in your installations:</p> <pre><code># Development environment\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=dev-namespace \\\n  --set common-scanner.safCli.thresholdFilePath=/path/to/development-threshold.yml\n\n# Production environment\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-namespace \\\n  --set common-scanner.safCli.thresholdFilePath=/path/to/production-threshold.yml\n</code></pre>"},{"location":"helm-charts/customization/#3-advanced-rbac-customization","title":"3. Advanced RBAC Customization","text":""},{"location":"helm-charts/customization/#rbac-for-multiple-teams-and-namespaces","title":"RBAC for Multiple Teams and Namespaces","text":"<p>For multi-team environments with dedicated namespaces:</p> <pre><code># Team A scanner infrastructure\nhelm install team-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-a-namespace \\\n  --set rbac.roleName=team-a-scanner-role \\\n  --set rbac.roleBindingName=team-a-scanner-rolebinding \\\n  --set serviceAccount.name=team-a-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.team=team-a\n\n# Team B scanner infrastructure\nhelm install team-b-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-b-namespace \\\n  --set rbac.roleName=team-b-scanner-role \\\n  --set rbac.roleBindingName=team-b-scanner-rolebinding \\\n  --set serviceAccount.name=team-b-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.team=team-b\n</code></pre>"},{"location":"helm-charts/customization/#custom-rbac-rules","title":"Custom RBAC Rules","text":"<p>Add additional permissions to the scanner role:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.extraRules[0].apiGroups[0]=\"\" \\\n  --set rbac.extraRules[0].resources[0]=pods/log \\\n  --set rbac.extraRules[0].verbs[0]=get \\\n  --set rbac.extraRules[1].apiGroups[0]=apps \\\n  --set rbac.extraRules[1].resources[0]=deployments \\\n  --set rbac.extraRules[1].verbs[0]=get \\\n  --set rbac.extraRules[1].verbs[1]=list\n</code></pre>"},{"location":"helm-charts/customization/#4-cloud-provider-integration","title":"4. Cloud Provider Integration","text":""},{"location":"helm-charts/customization/#aws-eks-integration","title":"AWS EKS Integration","text":"<p>For EKS clusters with IAM roles for service accounts:</p> <pre><code># Create IAM role with proper permissions first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/scanner-role\n</code></pre>"},{"location":"helm-charts/customization/#google-gke-integration","title":"Google GKE Integration","text":"<p>For GKE clusters with Workload Identity:</p> <pre><code># Create GCP service account and bind IAM policy first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"iam.gke.io/gcp-service-account\"=scanner-sa@project-id.iam.gserviceaccount.com\n</code></pre>"},{"location":"helm-charts/customization/#azure-aks-integration","title":"Azure AKS Integration","text":"<p>For AKS clusters with Pod Identity or Workload Identity:</p> <pre><code># Create Azure identity first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"azure.workload.identity/client-id\"=00000000-0000-0000-0000-000000000000\n</code></pre>"},{"location":"helm-charts/customization/#5-resource-management","title":"5. Resource Management","text":""},{"location":"helm-charts/customization/#setting-resource-limits-and-requests","title":"Setting Resource Limits and Requests","text":"<p>For the sidecar scanner, set resource constraints:</p> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre> <p>For test pods:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set testPod.deploy=true \\\n  --set testPod.resources.requests.cpu=50m \\\n  --set testPod.resources.requests.memory=64Mi \\\n  --set testPod.resources.limits.cpu=100m \\\n  --set testPod.resources.limits.memory=128Mi\n</code></pre>"},{"location":"helm-charts/customization/#advanced-customization-techniques","title":"Advanced Customization Techniques","text":""},{"location":"helm-charts/customization/#creating-custom-value-files","title":"Creating Custom Value Files","text":"<p>For complex configurations, use custom value files:</p> <pre><code># values-production.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: production\n    rbac:\n      useResourceNames: true\n      useLabelSelector: true\n      podSelectorLabels:\n        app: myapp\n        env: production\n      rules:\n        ephemeralContainers:\n          enabled: true\n    serviceAccount:\n      annotations:\n        eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/scanner-role\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: 95\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 0\ntestPod:\n  deploy: false\n</code></pre> <p>Then use it for installation:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner -f values-production.yaml\n</code></pre>"},{"location":"helm-charts/customization/#templating-helm-charts-for-multiple-environments","title":"Templating Helm Charts for Multiple Environments","text":"<p>You can use Kustomize with Helm to manage multiple environments:</p> <pre><code># kustomization.yaml for Development\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nhelmCharts:\n- name: standard-scanner\n  repo: file://../helm-charts\n  releaseName: dev-scanner\n  namespace: development\n  valuesFile: values-development.yaml\n</code></pre> <pre><code># kustomization.yaml for Production\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nhelmCharts:\n- name: standard-scanner\n  repo: file://../helm-charts\n  releaseName: prod-scanner\n  namespace: production\n  valuesFile: values-production.yaml\n</code></pre>"},{"location":"helm-charts/customization/#building-custom-scanner-images","title":"Building Custom Scanner Images","text":"<p>For specialized environments, build custom scanner images:</p> <pre><code># Dockerfile for air-gapped environment scanner\nFROM registry.example.com/chef/inspec:5.18.14\n\n# Add all required profiles\nCOPY ./profiles /profiles\n\n# Add custom scripts\nCOPY ./scripts /scripts\nRUN chmod +x /scripts/*.sh\n\n# Add SAF CLI\nRUN pip install saf-cli==1.2.3\n\n# Add required gems\nRUN inspec plugin install inspec-kubernetes\n</code></pre>"},{"location":"helm-charts/customization/#upgrading-and-migration","title":"Upgrading and Migration","text":""},{"location":"helm-charts/customization/#upgrading-between-chart-versions","title":"Upgrading Between Chart Versions","text":"<p>To upgrade existing chart installations:</p> <pre><code># Check for changes first\nhelm diff upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace\n\n# Perform upgrade\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/customization/#migration-between-scanning-approaches","title":"Migration Between Scanning Approaches","text":"<p>Migrating from Debug Container Approach to Kubernetes API Approach (once distroless support is added):</p> <pre><code># First, uninstall the debug container scanner\nhelm uninstall distroless-scanner\n\n# Then, install the standard scanner with distroless support\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.scripts.includeDistrolessScanScript=true \\\n  --set distrolessSupport=true\n</code></pre>"},{"location":"helm-charts/customization/#integration-patterns","title":"Integration Patterns","text":""},{"location":"helm-charts/customization/#gitops-integration","title":"GitOps Integration","text":"<p>For GitOps workflows using tools like ArgoCD or Flux:</p> <pre><code># Example application manifest with scanner sidecar\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: application-with-scanner\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/your-org/your-app\n    targetRevision: HEAD\n    path: helm\n    helm:\n      valueFiles:\n      - values.yaml\n      - scanner-values.yaml\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: application-namespace\n</code></pre>"},{"location":"helm-charts/customization/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>These customizations work well with CI/CD pipelines:</p> <pre><code># GitHub Actions example with dynamic environment variables\nENV_NAME=\"${GITHUB_REF#refs/heads/}\"\nif [ \"$ENV_NAME\" = \"main\" ]; then\n  ENV_NAME=\"production\"\n  THRESHOLD_FILE=\"thresholds/production.yml\"\nelse\n  ENV_NAME=\"development\"\n  THRESHOLD_FILE=\"thresholds/development.yml\"\nfi\n\n# Install scanner with environment-specific settings\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=$ENV_NAME \\\n  --set common-scanner.safCli.thresholdFilePath=$THRESHOLD_FILE\n</code></pre>"},{"location":"helm-charts/customization/#troubleshooting-customizations","title":"Troubleshooting Customizations","text":""},{"location":"helm-charts/customization/#validating-chart-values","title":"Validating Chart Values","text":"<p>Before applying customizations, validate your values:</p> <pre><code># Validate custom values\nhelm install --debug --dry-run standard-scanner ./helm-charts/standard-scanner -f my-values.yaml\n</code></pre>"},{"location":"helm-charts/customization/#debugging-template-rendering","title":"Debugging Template Rendering","text":"<p>If you encounter issues with template rendering:</p> <pre><code># See what templates will render\nhelm template standard-scanner ./helm-charts/standard-scanner -f my-values.yaml\n\n# Check specific template\nhelm template standard-scanner ./helm-charts/standard-scanner -f my-values.yaml \\\n  --show-only templates/test-pod.yaml\n</code></pre>"},{"location":"helm-charts/customization/#common-customization-issues","title":"Common Customization Issues","text":"<ol> <li>Value Path Issues: Ensure you're using the correct hierarchy for nested values</li> <li>RBAC Configuration: Verify RBAC settings don't conflict with cluster policies</li> <li>Resource Constraints: Check that resource limits aren't too restrictive</li> <li>Cloud Provider Integration: Validate cloud provider annotations format</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/distroless-scanner/","title":"Distroless Scanner Chart (Debug Container Approach)","text":""},{"location":"helm-charts/distroless-scanner/#overview","title":"Overview","text":"<p>The <code>distroless-scanner</code> chart implements the Debug Container Approach for scanning distroless containers in Kubernetes. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specialized components for scanning containers without shell access.</p> <p>The Debug Container Approach uses Kubernetes ephemeral debug containers to temporarily attach to target pods and access the filesystem of distroless containers, enabling compliance scanning without modifying the original containers.</p>"},{"location":"helm-charts/distroless-scanner/#components","title":"Components","text":""},{"location":"helm-charts/distroless-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo distroless container for testing</li> <li>Typically based on Google's distroless images</li> <li> <p>Demonstrates distroless scanning capabilities</p> </li> <li> <p>RBAC for Ephemeral Containers</p> </li> <li>Additional permissions for ephemeral container creation</li> <li>Limited to specific pods when resource names are used</li> </ol> <p>This chart primarily relies on components from its dependencies: - <code>common-scanner</code>: Scanning scripts and SAF CLI integration - <code>scanner-infrastructure</code>: Core RBAC, service accounts, and security model</p>"},{"location":"helm-charts/distroless-scanner/#features","title":"Features","text":""},{"location":"helm-charts/distroless-scanner/#ephemeral-container-scanning","title":"Ephemeral Container Scanning","text":"<p>The Debug Container Approach provides these capabilities:</p> <ul> <li>Distroless Container Support: Scan containers without shell access</li> <li>Non-Intrusive: Temporary debug containers that are removed after scanning</li> <li>Filesystem Analysis: Read access to target container filesystem</li> <li>Specialized Profiles: Support for profiles focused on filesystem analysis</li> <li>Kubernetes 1.16+ Required: Uses ephemeral container feature</li> </ul>"},{"location":"helm-charts/distroless-scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Temporary Attack Surface: Debug container is only active during scanning</li> <li>Minimal Permissions: Limited access to specific target containers</li> <li>Non-Persistent: Debug containers are automatically removed when scanning completes</li> <li>Read-Only Analysis: Filesystem access is typically read-only</li> </ul>"},{"location":"helm-charts/distroless-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/distroless-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true \\\n  --set common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled=true\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app \\\n  --set common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled=true\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#installation-with-custom-debug-container","title":"Installation with Custom Debug Container","text":"<pre><code># Install with custom debug container settings\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.image=alpine:3.15 \\\n  --set debugContainer.command=\"/bin/sh\" \\\n  --set debugContainer.args=\"-c,sleep 3600\"\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/distroless-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No <code>common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container permissions <code>true</code> Yes"},{"location":"helm-charts/distroless-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>distroless-target-helm</code> No <code>testPod.image</code> Test pod image <code>gcr.io/distroless/base:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sleep\", \"3600\"]</code> No"},{"location":"helm-charts/distroless-scanner/#debug-container-configuration","title":"Debug Container Configuration","text":"Parameter Description Default Required <code>debugContainer.image</code> Debug container image <code>alpine:latest</code> No <code>debugContainer.command</code> Debug container command <code>null</code> No <code>debugContainer.args</code> Debug container arguments <code>null</code> No <code>debugContainer.timeout</code> Debug container timeout in seconds <code>600</code> No"},{"location":"helm-charts/distroless-scanner/#scanning-configuration-inherited-from-common-scanner","title":"Scanning Configuration (Inherited from common-scanner)","text":"Parameter Description Default Required <code>common-scanner.safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>common-scanner.safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>common-scanner.safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/distroless-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/distroless-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Generate kubeconfig\n./scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n\n# Run distroless scan against test pod\n./scripts/scan-distroless-container.sh inspec-test distroless-target-helm distroless ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#using-with-existing-distroless-applications","title":"Using with Existing Distroless Applications","text":"<p>For scanning existing distroless application containers:</p> <pre><code># Generate kubeconfig\n./scripts/generate-kubeconfig.sh prod-scanning inspec-scanner ./kubeconfig.yaml\n\n# Run scan against distroless application container\n./scripts/scan-distroless-container.sh prod-scanning my-distroless-app application-container ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#using-with-saf-cli-for-compliance-validation","title":"Using with SAF CLI for Compliance Validation","text":"<pre><code># Run scan with compliance validation\n./scripts/scan-distroless-container.sh prod-scanning my-distroless-app application-container \\\n  ./examples/cinc-profiles/container-baseline \\\n  --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"helm-charts/distroless-scanner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Distroless Container Scanning\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v1\n\n      - name: Set up kubeconfig\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; ./kubeconfig.yaml\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n\n      - name: Install SAF CLI\n        run: |\n          pip install saf-cli\n\n      - name: Run distroless container scan\n        run: |\n          ./scripts/scan-distroless-container.sh prod-scanning distroless-app container-name \\\n            ./profiles/container-baseline --threshold-file=./ci-threshold.yml\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>stages:\n  - deploy\n  - scan\n\ndeploy:\n  stage: deploy\n  script:\n    - kubectl apply -f kubernetes/distroless-app.yaml\n\nscan:\n  stage: scan\n  image: registry.gitlab.com/your-org/cinc-auditor-saf:latest\n  script:\n    - ./scripts/scan-distroless-container.sh ${CI_ENVIRONMENT_NAME} distroless-app container-name \\\n        ./profiles/container-baseline --threshold-file=./ci-threshold.yml\n  artifacts:\n    paths:\n      - scan-results.json\n      - compliance-report.md\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"helm-charts/distroless-scanner/#common-issues","title":"Common Issues","text":"<ol> <li>Ephemeral Container Creation Issues</li> <li>Verify Kubernetes version supports ephemeral containers (1.16+)</li> <li>Check RBAC permissions include ephemeral container access</li> <li> <p>Ensure target pod is running and stable</p> </li> <li> <p>Debug Container Access Problems</p> </li> <li>Verify debug container has proper tools installed</li> <li>Check that target filesystem is accessible via proc</li> <li> <p>Ensure debug container image is compatible with your environment</p> </li> <li> <p>Profile Execution Failures</p> </li> <li>Verify profile is suitable for distroless containers</li> <li>Ensure profile focuses on filesystem checks rather than command execution</li> <li>Check for dependencies that might be missing in the debug container</li> </ol>"},{"location":"helm-charts/distroless-scanner/#debugging","title":"Debugging","text":"<p>Enable debug output for the distroless container scanning script:</p> <pre><code># Run with debug output\nDEBUG=true ./scripts/scan-distroless-container.sh inspec-test distroless-target-helm distroless ./examples/cinc-profiles/container-baseline\n</code></pre> <p>Manually test ephemeral container creation:</p> <pre><code># Try creating a debug container manually\nkubectl debug -it -n inspec-test distroless-target-helm --image=alpine:latest --target=distroless\n</code></pre>"},{"location":"helm-charts/distroless-scanner/#limitations","title":"Limitations","text":"<ol> <li>Kubernetes Version Requirement: Requires Kubernetes 1.16+ for ephemeral container support</li> <li>Command Execution: Cannot execute commands in the target container, only filesystem access</li> <li>Profile Compatibility: Standard profiles that rely on command execution won't work properly</li> <li>Alpha/Beta Feature: Ephemeral containers were in alpha/beta stage in earlier Kubernetes versions</li> </ol>"},{"location":"helm-charts/distroless-scanner/#next-steps","title":"Next Steps","text":"<p>After successfully installing and using the distroless scanner:</p> <ol> <li>Review the Customization guide for tailoring your scanning environment</li> <li>Explore Security Considerations for hardening recommendations</li> <li>Learn about CI/CD Integration for automated scanning</li> <li>Consider moving to the Sidecar Scanner for an alternative approach</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/overview/","title":"Helm Charts Overview","text":"<p>The Secure Kubernetes Container Scanning solution provides a comprehensive set of Helm charts for deploying container scanning infrastructure in Kubernetes environments. These charts are designed with security, modularity, and enterprise usability in mind.</p>"},{"location":"helm-charts/overview/#introduction","title":"Introduction","text":"<p>Our Helm charts implement a layered architecture to support all three container scanning approaches:</p> <ol> <li>Kubernetes API Approach (standard-scanner): For scanning regular containers via Kubernetes API</li> <li>Debug Container Approach (distroless-scanner): For scanning distroless containers using ephemeral debug containers</li> <li>Sidecar Container Approach (sidecar-scanner): For universal container scanning using process namespace sharing</li> </ol> <p>The charts are structured to maximize reusability and minimize duplication, with common components extracted into shared charts.</p>"},{"location":"helm-charts/overview/#chart-organization","title":"Chart Organization","text":"<p>The charts are organized in a hierarchical structure:</p> <pre><code>helm-charts/\n\u251c\u2500\u2500 scanner-infrastructure/  # Core RBAC, service accounts, tokens\n\u251c\u2500\u2500 common-scanner/          # Common scanning components and utilities\n\u251c\u2500\u2500 standard-scanner/        # Kubernetes API Approach (regular containers)\n\u251c\u2500\u2500 distroless-scanner/      # Debug Container Approach (distroless containers)\n\u2514\u2500\u2500 sidecar-scanner/         # Sidecar Container Approach (shared process namespace)\n</code></pre>"},{"location":"helm-charts/overview/#deployment-options","title":"Deployment Options","text":""},{"location":"helm-charts/overview/#local-development-and-testing","title":"Local Development and Testing","text":"<p>For local development and testing (such as with Minikube or Kind), our charts provide simplified installation with test pods and examples:</p> <pre><code># Install for local testing with included test pods\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre> <p>This setup is ideal for: - Learning how the scanning solution works - Testing custom profiles and configurations - Developing new scanning approaches - Local demonstration and validation</p>"},{"location":"helm-charts/overview/#production-deployment","title":"Production Deployment","text":"<p>For production environments, our charts support enterprise-grade deployment patterns:</p> <pre><code># Install core infrastructure in production namespace\nhelm install scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=security-prod \\\n  --set rbac.useLabelSelector=true \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/scanner-role\n\n# Install scanning components with production values\nhelm install scanner-components ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=security-prod \\\n  --set safCli.thresholdConfig.compliance.min=90 \\\n  --values ./production-values.yaml\n</code></pre> <p>Production features include: - External auth provider integration (OIDC, AWS IAM, etc.) - Custom threshold configurations - Resource limits and requests - Network policies and security constraints - Integration with external monitoring and logging</p>"},{"location":"helm-charts/overview/#key-features","title":"Key Features","text":""},{"location":"helm-charts/overview/#security-first-design","title":"Security-First Design","text":"<p>All charts implement security best practices: - Least-privilege RBAC model - Short-lived access tokens - Non-privileged containers - Resource limitations - Namespace isolation</p>"},{"location":"helm-charts/overview/#modularity","title":"Modularity","text":"<p>The charts are designed for maximum flexibility: - Use only the components you need - Mix and match scanning approaches - Customize individual chart values - Extend with your own configurations</p>"},{"location":"helm-charts/overview/#enterprise-integration","title":"Enterprise Integration","text":"<p>Built-in support for enterprise environments: - CI/CD pipeline integration - Compliance reporting with SAF CLI - Threshold-based validation - Multi-team and multi-cluster support</p>"},{"location":"helm-charts/overview/#getting-started","title":"Getting Started","text":"<p>To get started with our Helm charts:</p> <ol> <li>See the Architecture page for an overview of chart components and relationships</li> <li>Visit the page for your preferred scanning approach:</li> <li>Kubernetes API Scanner (recommended)</li> <li>Debug Container Scanner (for distroless containers)</li> <li>Sidecar Container Scanner (universal approach)</li> <li>Follow the Customization guide for tailoring charts to your environment</li> <li>Review the Security Considerations for important security guidance</li> <li>Explore CI/CD Integration for automating scans in your pipelines</li> </ol>"},{"location":"helm-charts/overview/#version-compatibility","title":"Version Compatibility","text":"Chart Version Kubernetes Versions CINC Auditor Version Notes 1.0.x 1.19 - 1.27 5.18.14+ Initial stable release 0.9.x 1.18 - 1.26 5.18.14+ Beta release <p>Note: The Debug Container Approach requires Kubernetes 1.16+ for ephemeral container support.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/","title":"Scanner Infrastructure Chart","text":""},{"location":"helm-charts/scanner-infrastructure/#overview","title":"Overview","text":"<p>The <code>scanner-infrastructure</code> chart provides the foundational components required for secure container scanning in Kubernetes. It establishes the security model, access controls, and base configurations that all other scanning components depend on.</p> <p>This chart implements least-privilege security principles with fine-grained RBAC controls, service accounts with minimal permissions, and short-lived access tokens.</p>"},{"location":"helm-charts/scanner-infrastructure/#components","title":"Components","text":""},{"location":"helm-charts/scanner-infrastructure/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Namespace</li> <li>Dedicated namespace for scanning operations</li> <li> <p>Isolation boundary for scanner components</p> </li> <li> <p>Service Account</p> </li> <li>Identity for scanner operations</li> <li> <p>Configurable with annotations for cloud provider integration</p> </li> <li> <p>Role</p> </li> <li>Limited permissions for container scanning</li> <li> <p>Configurable rules with resource name restrictions</p> </li> <li> <p>RoleBinding</p> </li> <li>Links service account to role</li> <li> <p>Scoped to specific namespace</p> </li> <li> <p>ConfigMap: Scripts</p> </li> <li>Helper scripts for token generation</li> <li>Kubeconfig creation utilities</li> </ol>"},{"location":"helm-charts/scanner-infrastructure/#security-features","title":"Security Features","text":""},{"location":"helm-charts/scanner-infrastructure/#rbac-model","title":"RBAC Model","text":"<p>The chart implements a carefully designed RBAC model with these characteristics:</p> <ul> <li>Least-Privilege Access: Only the minimum permissions required</li> <li>Resource Name Restrictions: Limits access to specific pods (when enabled)</li> <li>Label Selector Options: Restrict access by pod labels (when enabled)</li> <li>Ephemeral Container Control: Optional permissions for debug containers</li> <li>Time-Bound Access: Short-lived tokens for limited access duration</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#permission-scopes","title":"Permission Scopes","text":"<p>The chart supports multiple permission scoping options:</p> <ol> <li>Resource Name Scoping: Access limited to specific pod names</li> <li>Label Selector Scoping: Access limited to pods with specific labels</li> <li>Namespace Scoping: All access limited to a single namespace</li> </ol>"},{"location":"helm-charts/scanner-infrastructure/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/scanner-infrastructure/#basic-installation","title":"Basic Installation","text":"<pre><code># Install scanner infrastructure with default settings\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#production-installation","title":"Production Installation","text":"<pre><code># Install with enhanced security for production\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=prod-scanning \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app \\\n  --set rbac.podSelectorLabels.env=production \\\n  --set token.duration=15\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#cloud-provider-integration","title":"Cloud Provider Integration","text":"<pre><code># AWS EKS with IAM Role integration\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=eks-scanning \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/scanner-role\n\n# GKE with Workload Identity\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=gke-scanning \\\n  --set serviceAccount.annotations.\"iam.gke.io/gcp-service-account\"=scanner-sa@project-id.iam.gserviceaccount.com\n\n# Azure AKS with Managed Identity\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=aks-scanning \\\n  --set serviceAccount.annotations.\"azure.workload.identity/client-id\"=00000000-0000-0000-0000-000000000000\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/scanner-infrastructure/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>targetNamespace</code> Namespace where scanning will occur <code>inspec-test</code> Yes <code>createNamespace</code> Whether to create the namespace <code>true</code> No"},{"location":"helm-charts/scanner-infrastructure/#service-account-configuration","title":"Service Account Configuration","text":"Parameter Description Default Required <code>serviceAccount.create</code> Create a dedicated service account <code>true</code> No <code>serviceAccount.name</code> Name of the service account <code>inspec-scanner</code> No <code>serviceAccount.annotations</code> Annotations for the service account <code>{}</code> No"},{"location":"helm-charts/scanner-infrastructure/#rbac-configuration","title":"RBAC Configuration","text":"Parameter Description Default Required <code>rbac.create</code> Create RBAC resources <code>true</code> No <code>rbac.roleName</code> Name of the scanning role <code>inspec-container-role</code> No <code>rbac.roleBindingName</code> Name of the role binding <code>inspec-container-rolebinding</code> No <code>rbac.useResourceNames</code> Use resource names for strict RBAC <code>false</code> No <code>rbac.useLabelSelector</code> Use label selectors for RBAC <code>false</code> No <code>rbac.podSelectorLabels</code> Labels for pod selection <code>{ scan-target: \"true\" }</code> No"},{"location":"helm-charts/scanner-infrastructure/#rule-configuration","title":"Rule Configuration","text":"Parameter Description Default Required <code>rbac.rules.core.enabled</code> Enable core API permissions <code>true</code> No <code>rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container permissions <code>false</code> No <code>rbac.rules.extraRules</code> Additional RBAC rules <code>[]</code> No"},{"location":"helm-charts/scanner-infrastructure/#token-configuration","title":"Token Configuration","text":"Parameter Description Default Required <code>token.duration</code> Token validity duration in minutes <code>60</code> No <code>token.audience</code> Token audience <code>kubernetes.default.svc</code> No"},{"location":"helm-charts/scanner-infrastructure/#helper-scripts-configuration","title":"Helper Scripts Configuration","text":"Parameter Description Default Required <code>scripts.generate</code> Generate helper scripts <code>true</code> No <code>scripts.directory</code> Directory for scripts <code>/tmp/inspec-scanner</code> No"},{"location":"helm-charts/scanner-infrastructure/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/scanner-infrastructure/#token-generation","title":"Token Generation","text":"<p>After installing the chart, you can generate tokens for scanning:</p> <pre><code># Using the helper script\n./scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n\n# Manual token generation\nSERVICE_ACCOUNT=inspec-scanner\nNAMESPACE=scanning-namespace\nSECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT} -n ${NAMESPACE} -o jsonpath='{.secrets[0].name}')\nTOKEN=$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.token}' | base64 --decode)\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#using-with-cinc-auditor","title":"Using with CINC Auditor","text":"<p>With the generated kubeconfig:</p> <pre><code># Run CINC Auditor scan with kubeconfig\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profiles/container-baseline \\\n  -t k8s-container://scanning-namespace/target-pod/container-name\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#security-considerations","title":"Security Considerations","text":""},{"location":"helm-charts/scanner-infrastructure/#token-lifecycle-management","title":"Token Lifecycle Management","text":"<p>For enhanced security:</p> <ol> <li>Keep token duration short (15-30 minutes for production)</li> <li>Generate new tokens for each scanning operation</li> <li>Store kubeconfig files securely</li> <li>Revoke tokens after scanning is complete</li> </ol>"},{"location":"helm-charts/scanner-infrastructure/#permission-minimization","title":"Permission Minimization","text":"<p>To minimize permissions:</p> <ol> <li>Use resource name restrictions when target pods are known</li> <li>Use label selectors for dynamic pod targeting</li> <li>Enable only the required rule sets</li> <li>Consider namespace isolation for multi-team environments</li> </ol>"},{"location":"helm-charts/scanner-infrastructure/#custom-rbac-rules","title":"Custom RBAC Rules","text":"<p>For advanced use cases, you can add custom RBAC rules:</p> <pre><code>rbac:\n  extraRules:\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\"]\n  - apiGroups: [\"apps\"]\n    resources: [\"deployments\"]\n    verbs: [\"get\", \"list\"]\n</code></pre>"},{"location":"helm-charts/scanner-infrastructure/#troubleshooting","title":"Troubleshooting","text":""},{"location":"helm-charts/scanner-infrastructure/#common-issues","title":"Common Issues","text":"<ol> <li>Permission Denied Errors</li> <li>Verify RBAC role has sufficient permissions</li> <li>Check if resource name restrictions are too limiting</li> <li> <p>Ensure service account has proper role binding</p> </li> <li> <p>Token Generation Failures</p> </li> <li>Verify service account exists</li> <li>Check for proper secret creation</li> <li> <p>Ensure proper namespace context</p> </li> <li> <p>Container Access Issues</p> </li> <li>Verify pod names match resource name restrictions (if enabled)</li> <li>Check if pods have required labels (if label selector is used)</li> <li>Ensure pods are in the correct namespace</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/security/","title":"Helm Chart Security Considerations","text":""},{"location":"helm-charts/security/#overview","title":"Overview","text":"<p>This document outlines security considerations for deploying and using the Secure Kubernetes Container Scanning Helm charts. Security is a core design principle of our solution, with all charts implementing a least-privilege model, short-lived credentials, and other security best practices.</p>"},{"location":"helm-charts/security/#security-architecture","title":"Security Architecture","text":""},{"location":"helm-charts/security/#security-first-design","title":"Security-First Design","text":"<p>Our Helm charts implement a layered security architecture:</p> <ol> <li>Core Security Layer (scanner-infrastructure)</li> <li>Least-privilege RBAC implementation</li> <li>Short-lived access tokens</li> <li>Namespace isolation</li> <li> <p>Service account permissions</p> </li> <li> <p>Operational Security Layer (common-scanner)</p> </li> <li>Secure script execution</li> <li>Result data protection</li> <li> <p>Failure handling</p> </li> <li> <p>Approach-Specific Security Controls</p> </li> <li>Different security models for each scanning approach</li> <li>Approach-specific hardening options</li> </ol>"},{"location":"helm-charts/security/#helm-chart-security-best-practices","title":"Helm Chart Security Best Practices","text":""},{"location":"helm-charts/security/#1-rbac-hardening","title":"1. RBAC Hardening","text":"<p>Implement strict RBAC controls:</p> <pre><code># Use resource name restrictions for maximum security\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app\n</code></pre> <p>This configuration limits the scanner's access to only pods with the specific label and name.</p>"},{"location":"helm-charts/security/#2-token-lifecycle-management","title":"2. Token Lifecycle Management","text":"<p>Minimize token lifespan for enhanced security:</p> <pre><code># Reduce token validity period for production environments\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set token.duration=15  # 15 minutes\n</code></pre> <p>Always generate fresh tokens for each scanning operation:</p> <pre><code># Generate a short-lived token before each scan\n./scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n\n# Run scan with the fresh token\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n\n# Remove token after scan\nrm ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/security/#3-network-security","title":"3. Network Security","text":"<p>Implement network policies to restrict scanner communication:</p> <pre><code># network-policy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-policy\n  namespace: scanning-namespace\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: scanning-namespace\n    - podSelector:\n        matchLabels:\n          scan-target: \"true\"\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - protocol: TCP\n      port: 443  # Kubernetes API\n</code></pre> <p>Apply the network policy:</p> <pre><code>kubectl apply -f network-policy.yaml\n</code></pre>"},{"location":"helm-charts/security/#4-secure-container-configuration","title":"4. Secure Container Configuration","text":"<p>Enforce security features in scanner containers:</p> <pre><code># Apply security hardening for sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.securityContext.runAsNonRoot=true \\\n  --set scanner.securityContext.runAsUser=10000 \\\n  --set scanner.securityContext.readOnlyRootFilesystem=true \\\n  --set scanner.securityContext.allowPrivilegeEscalation=false \\\n  --set scanner.securityContext.capabilities.drop[0]=ALL\n</code></pre>"},{"location":"helm-charts/security/#5-secret-management","title":"5. Secret Management","text":"<p>Integrate with external secret management systems:</p> <pre><code># AWS Secrets Manager integration\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/secrets-access-role\n</code></pre> <p>Then access secrets in your scanning scripts:</p> <pre><code># Retrieve threshold file from AWS Secrets Manager\nTHRESHOLD=$(aws secretsmanager get-secret-value --secret-id scanning/thresholds/production --query SecretString --output text)\necho \"$THRESHOLD\" &gt; ./threshold.yml\n\n# Use in scan\n./scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/security/#security-considerations-by-scanning-approach","title":"Security Considerations by Scanning Approach","text":""},{"location":"helm-charts/security/#kubernetes-api-approach-standard-scanner","title":"Kubernetes API Approach (standard-scanner)","text":"<p>This approach offers the strongest security posture:</p> <ul> <li>Minimal Attack Surface: Uses only Kubernetes API exec</li> <li>No Additional Containers: Maintains container isolation</li> <li>Clean Security Boundary: Clear separation between scanner and target</li> </ul> <p>Recommended security configurations:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.token.duration=15 \\\n  --set common-scanner.safCli.failOnThresholdError=true\n</code></pre>"},{"location":"helm-charts/security/#debug-container-approach-distroless-scanner","title":"Debug Container Approach (distroless-scanner)","text":"<p>This approach has specific security considerations:</p> <ul> <li>Temporary Attack Surface Increase: Ephemeral debug container</li> <li>Process Namespace Consideration: Debug container can access target processes</li> <li>Limited Duration: Container exists only during scanning</li> </ul> <p>Recommended security configurations:</p> <pre><code>helm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.token.duration=15 \\\n  --set debugContainer.securityContext.runAsNonRoot=true \\\n  --set debugContainer.securityContext.runAsUser=10000 \\\n  --set debugContainer.securityContext.readOnlyRootFilesystem=true\n</code></pre>"},{"location":"helm-charts/security/#sidecar-container-approach-sidecar-scanner","title":"Sidecar Container Approach (sidecar-scanner)","text":"<p>This approach has the highest security impact:</p> <ul> <li>Persistent Attack Surface Increase: Sidecar container remains with pod</li> <li>Process Namespace Sharing: Breaks container isolation boundary</li> <li>Resource Consumption: Additional container in every pod</li> </ul> <p>Recommended security configurations:</p> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set scanner.securityContext.runAsNonRoot=true \\\n  --set scanner.securityContext.runAsUser=10000 \\\n  --set scanner.securityContext.readOnlyRootFilesystem=true \\\n  --set scanner.securityContext.allowPrivilegeEscalation=false \\\n  --set scanner.securityContext.capabilities.drop[0]=ALL\n</code></pre>"},{"location":"helm-charts/security/#security-standards-alignment","title":"Security Standards Alignment","text":"<p>Our Helm charts align with key security standards and frameworks:</p>"},{"location":"helm-charts/security/#cis-kubernetes-benchmark","title":"CIS Kubernetes Benchmark","text":"<p>The charts follow CIS Kubernetes Benchmark recommendations:</p> <ul> <li>RBAC Limitation: Strict role-based access control</li> <li>Namespace Segregation: Isolated scanning namespace</li> <li>Service Account Controls: Dedicated service accounts with minimal permissions</li> <li>Secret Management: Proper handling of token secrets</li> </ul>"},{"location":"helm-charts/security/#nist-sp-800-190-container-security","title":"NIST SP 800-190 Container Security","text":"<p>Alignment with NIST guidelines:</p> <ul> <li>Least Privilege: Minimal permissions for scanning operations</li> <li>Container Isolation: Maintaining container boundaries where possible</li> <li>Image Security: Support for scanning image content</li> <li>Runtime Security: Controlled access to container runtimes</li> </ul>"},{"location":"helm-charts/security/#nsacisa-kubernetes-hardening-guidance","title":"NSA/CISA Kubernetes Hardening Guidance","text":"<p>Adherence to NSA/CISA recommendations:</p> <ul> <li>Pod Security Standards: Implementing pod security contexts</li> <li>Network Segmentation: Support for network policies</li> <li>Authentication: Short-lived authentication tokens</li> <li>Authorization: Fine-grained RBAC implementation</li> </ul>"},{"location":"helm-charts/security/#security-risk-assessment-by-chart","title":"Security Risk Assessment by Chart","text":""},{"location":"helm-charts/security/#scanner-infrastructure","title":"scanner-infrastructure","text":"Risk Severity Mitigation Excessive RBAC permissions High Use resource names and label selectors Long-lived tokens Medium Set short token duration (15-30 minutes) Namespace pollution Medium Use dedicated scanning namespace Service account misuse Medium Use dedicated service account with minimal permissions"},{"location":"helm-charts/security/#common-scanner","title":"common-scanner","text":"Risk Severity Mitigation Script injection Medium Use configMaps with verified script content Insecure result storage Medium Implement proper result handling and cleanup Threshold bypassing Low Enable failOnThresholdError option"},{"location":"helm-charts/security/#standard-scanner","title":"standard-scanner","text":"Risk Severity Mitigation Unauthorized container access Medium Use resource name restrictions in RBAC Command execution in container Medium Use read-only access where possible"},{"location":"helm-charts/security/#distroless-scanner","title":"distroless-scanner","text":"Risk Severity Mitigation Debug container privileges High Apply security context constraints to debug container Process namespace access Medium Limit scanning duration Ephemeral container persistence Low Ensure proper cleanup after scanning"},{"location":"helm-charts/security/#sidecar-scanner","title":"sidecar-scanner","text":"Risk Severity Mitigation Process namespace sharing High Apply strict security context to scanner container Persistent sidecar presence Medium Consider approach tradeoffs carefully Resource consumption Low Set appropriate resource limits"},{"location":"helm-charts/security/#security-incident-response","title":"Security Incident Response","text":"<p>Prepare for security incidents with these steps:</p> <ol> <li>Token Revocation: Script to revoke all scanner tokens</li> </ol> <pre><code>#!/bin/bash\n# revoke-scanner-tokens.sh\nNAMESPACE=\"scanning-namespace\"\nSERVICE_ACCOUNT=\"inspec-scanner\"\n\n# Find all secrets for the service account\nSECRETS=$(kubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o json | jq -r '.secrets[].name')\n\n# Delete each secret to force recreation\nfor SECRET in $SECRETS; do\n  kubectl delete secret $SECRET -n $NAMESPACE\ndone\n\necho \"All tokens for $SERVICE_ACCOUNT in $NAMESPACE have been revoked.\"\n</code></pre> <ol> <li>Scanner Shutdown: Process to immediately stop all scanning operations</li> </ol> <pre><code># Delete all scanner pods\nkubectl delete pods -n scanning-namespace -l role=scanner\n\n# Revoke RBAC temporarily if needed\nkubectl delete rolebinding -n scanning-namespace scanner-rolebinding\n</code></pre> <ol> <li>Audit Logging: Enable audit logging for scanner operations</li> </ol> <pre><code># scanner-audit-policy.yaml\napiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n- level: RequestResponse\n  users: [\"system:serviceaccount:scanning-namespace:inspec-scanner\"]\n  resources:\n  - group: \"\"\n    resources: [\"pods\", \"pods/exec\"]\n</code></pre>"},{"location":"helm-charts/security/#conclusion","title":"Conclusion","text":"<p>Security is a foundational aspect of our Helm charts, with each scanning approach offering different security tradeoffs. The Kubernetes API Approach provides the strongest security posture and is recommended for production environments. However, all approaches implement strong security controls to minimize risk.</p> <p>For the most secure deployment:</p> <ol> <li>Use the Kubernetes API Approach where possible</li> <li>Implement strict RBAC controls with resource name restrictions</li> <li>Keep token lifetimes short (15-30 minutes)</li> <li>Apply security contexts to all scanner containers</li> <li>Implement network policies to restrict scanner communications</li> <li>Regularly update and audit your scanning infrastructure</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/sidecar-scanner/","title":"Sidecar Scanner Chart (Sidecar Container Approach)","text":""},{"location":"helm-charts/sidecar-scanner/#overview","title":"Overview","text":"<p>The <code>sidecar-scanner</code> chart implements the Sidecar Container Approach for universal container scanning in Kubernetes. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specialized components for scanning using process namespace sharing.</p> <p>The Sidecar Container Approach deploys a scanner container alongside the target container in the same pod, using Kubernetes shared process namespace feature to access the target container's filesystem and processes.</p>"},{"location":"helm-charts/sidecar-scanner/#components","title":"Components","text":""},{"location":"helm-charts/sidecar-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo pod with target and scanner containers</li> <li>Demonstrates sidecar scanning approach</li> <li> <p>Shows process namespace sharing configuration</p> </li> <li> <p>ConfigMap: Profiles</p> </li> <li>CINC Auditor profiles for container scanning</li> <li> <p>Pre-packaged compliance profiles</p> </li> <li> <p>ConfigMap: Thresholds</p> </li> <li>Compliance threshold configurations</li> <li>Custom threshold settings for the sidecar approach</li> </ol> <p>This chart primarily relies on components from its dependencies: - <code>common-scanner</code>: Scanning scripts and SAF CLI integration - <code>scanner-infrastructure</code>: Core RBAC, service accounts, and security model</p>"},{"location":"helm-charts/sidecar-scanner/#features","title":"Features","text":""},{"location":"helm-charts/sidecar-scanner/#sidecar-container-scanning","title":"Sidecar Container Scanning","text":"<p>The Sidecar Container Approach provides these capabilities:</p> <ul> <li>Universal Container Support: Works with both standard and distroless containers</li> <li>Process Namespace Sharing: Access to target container processes and filesystem</li> <li>Pre-Deployment Integration: Sidecar is deployed with the target container</li> <li>Immediate Scanning: Can scan immediately after container startup</li> <li>Result Persistence: Can store results in shared volumes</li> </ul>"},{"location":"helm-charts/sidecar-scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Increased Attack Surface: Persistent sidecar container increases the attack surface</li> <li>Process Namespace Breach: Violates process isolation between containers</li> <li>Resource Overhead: Additional container in every pod adds resource overhead</li> <li>One Process Per Container: Violates the Docker best practice of \"one process per container\"</li> </ul>"},{"location":"helm-charts/sidecar-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/sidecar-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#installation-with-custom-scanner-image","title":"Installation with Custom Scanner Image","text":"<pre><code># Install with custom scanner image and profiles\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=registry.example.com/cinc-auditor:5.18.14 \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=200m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/sidecar-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/sidecar-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>sidecar-target</code> No <code>testPod.targetImage</code> Target container image <code>nginx:latest</code> No <code>testPod.shareProcessNamespace</code> Enable process namespace sharing <code>true</code> Yes"},{"location":"helm-charts/sidecar-scanner/#scanner-configuration","title":"Scanner Configuration","text":"Parameter Description Default Required <code>scanner.image</code> Scanner container image <code>chef/inspec:5.18.14</code> No <code>scanner.command</code> Scanner container command <code>null</code> No <code>scanner.args</code> Scanner container arguments <code>null</code> No <code>scanner.resources.requests.cpu</code> CPU request <code>100m</code> No <code>scanner.resources.requests.memory</code> Memory request <code>256Mi</code> No <code>scanner.resources.limits.cpu</code> CPU limit <code>200m</code> No <code>scanner.resources.limits.memory</code> Memory limit <code>512Mi</code> No"},{"location":"helm-charts/sidecar-scanner/#profile-configuration","title":"Profile Configuration","text":"Parameter Description Default Required <code>profiles.default.enabled</code> Enable default profile <code>true</code> No <code>profiles.default.path</code> Default profile path <code>/profiles/container-baseline</code> No <code>profiles.custom</code> Custom profile configuration <code>[]</code> No"},{"location":"helm-charts/sidecar-scanner/#results-configuration","title":"Results Configuration","text":"Parameter Description Default Required <code>results.directory</code> Results directory in scanner <code>/results</code> No <code>results.format</code> Results output format <code>json</code> No <code>results.thresholdEnabled</code> Enable threshold validation <code>true</code> No"},{"location":"helm-charts/sidecar-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/sidecar-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Check if pod is ready\nkubectl wait --for=condition=ready pod/sidecar-target -n inspec-test\n\n# Check scan results\nkubectl exec -n inspec-test sidecar-target -c scanner -- ls -la /results\n\n# Copy results locally\nkubectl cp inspec-test/sidecar-target:/results/scan-results.json ./results.json -c scanner\n\n# Process results with SAF CLI\nsaf summary --input ./results.json --output-md ./summary.md\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#using-with-existing-applications","title":"Using with Existing Applications","text":"<p>For scanning existing applications, you would typically add the sidecar container to your application pod specification:</p> <pre><code># Example application pod with scanner sidecar\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-application\n  namespace: prod-scanning\nspec:\n  shareProcessNamespace: true  # Important for sidecar scanning\n  containers:\n  - name: application\n    image: my-application:latest\n  - name: scanner\n    image: chef/inspec:5.18.14\n    command: [\"sh\", \"-c\"]\n    args:\n    - |\n      inspec exec /profiles/container-baseline -t proc://1/root --reporter json:/results/scan-results.json;\n      touch /results/scan-complete;\n      sleep 3600;\n    volumeMounts:\n    - name: results\n      mountPath: /results\n    - name: profiles\n      mountPath: /profiles\n  volumes:\n  - name: results\n    emptyDir: {}\n  - name: profiles\n    configMap:\n      name: inspec-profiles\n</code></pre> <p>Alternatively, use the scan script:</p> <pre><code># Deploy application with scanner sidecar\n./scripts/scan-with-sidecar.sh prod-scanning my-app:latest ./profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"helm-charts/sidecar-scanner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Sidecar Container Scanning\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy-and-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v1\n\n      - name: Set up kubeconfig\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; ./kubeconfig.yaml\n\n      - name: Deploy with sidecar scanner\n        run: |\n          ./scripts/scan-with-sidecar.sh ${NAMESPACE} ${IMAGE_NAME}:${IMAGE_TAG} ./profiles/container-baseline\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n          NAMESPACE: production\n          IMAGE_NAME: my-application\n          IMAGE_TAG: ${{ github.sha }}\n\n      - name: Wait for scan to complete\n        run: |\n          kubectl wait --for=condition=ready pod/${POD_NAME} -n ${NAMESPACE}\n          until kubectl exec -n ${NAMESPACE} ${POD_NAME} -c scanner -- test -f /results/scan-complete; do\n            echo \"Waiting for scan to complete...\"\n            sleep 5\n          done\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n          NAMESPACE: production\n          POD_NAME: my-application-scanner\n\n      - name: Retrieve scan results\n        run: |\n          kubectl cp ${NAMESPACE}/${POD_NAME}:/results/scan-results.json ./scan-results.json -c scanner\n          saf summary --input ./scan-results.json --output-md ./summary.md\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n          NAMESPACE: production\n          POD_NAME: my-application-scanner\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>stages:\n  - build\n  - deploy\n  - scan\n\nbuild:\n  stage: build\n  script:\n    - docker build -t ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA} .\n    - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}\n\ndeploy-with-scanner:\n  stage: deploy\n  script:\n    - ./scripts/scan-with-sidecar.sh ${CI_ENVIRONMENT_NAME} ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA} ./profiles/container-baseline\n  environment:\n    name: production\n\nprocess-results:\n  stage: scan\n  script:\n    - kubectl wait --for=condition=ready pod/${CI_JOB_NAME}-scanner -n ${CI_ENVIRONMENT_NAME}\n    - kubectl cp ${CI_ENVIRONMENT_NAME}/${CI_JOB_NAME}-scanner:/results/scan-results.json ./scan-results.json -c scanner\n    - saf summary --input ./scan-results.json --output-md ./summary.md\n  artifacts:\n    paths:\n      - scan-results.json\n      - summary.md\n  environment:\n    name: production\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"helm-charts/sidecar-scanner/#common-issues","title":"Common Issues","text":"<ol> <li>Process Namespace Sharing Issues</li> <li>Verify pod specification includes <code>shareProcessNamespace: true</code></li> <li>Check if Kubernetes version supports process namespace sharing</li> <li> <p>Ensure container runtime supports this feature</p> </li> <li> <p>Scanner Container Failures</p> </li> <li>Check scanner container logs for errors</li> <li>Verify scanner image has CINC Auditor properly installed</li> <li> <p>Ensure profiles are correctly mounted into the container</p> </li> <li> <p>Target Access Problems</p> </li> <li>Check if target PID can be accessed via <code>/proc</code></li> <li>Verify filesystem mount points are accessible</li> <li>Ensure profiles are written to work with proc filesystem paths</li> </ol>"},{"location":"helm-charts/sidecar-scanner/#debugging","title":"Debugging","text":"<p>Shell into the scanner container for debugging:</p> <pre><code># Access scanner container shell\nkubectl exec -it -n inspec-test sidecar-target -c scanner -- sh\n\n# Check process list\nps aux\n\n# Verify access to target container root filesystem\nls -la /proc/1/root/\n\n# Try manual scan execution\ninspec exec /profiles/container-baseline -t proc://1/root --logger debug\n</code></pre>"},{"location":"helm-charts/sidecar-scanner/#limitations","title":"Limitations","text":"<ol> <li>Security Boundary Violation: Process namespace sharing breaks container isolation</li> <li>Resource Overhead: Additional container per pod increases resource consumption</li> <li>Deployment Changes: Requires modifications to application deployment manifests</li> <li>Shared Lifecycle: Scanner container lifecycle tied to target container</li> </ol>"},{"location":"helm-charts/sidecar-scanner/#next-steps","title":"Next Steps","text":"<p>After successfully installing and using the sidecar scanner:</p> <ol> <li>Review the Customization guide for tailoring your scanning environment</li> <li>Explore Security Considerations for hardening recommendations</li> <li>Learn about CI/CD Integration for automated scanning</li> <li>Consider migrating to the Kubernetes API Approach once it supports distroless containers</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/standard-scanner/","title":"Standard Scanner Chart (Kubernetes API Approach)","text":""},{"location":"helm-charts/standard-scanner/#overview","title":"Overview","text":"<p>The <code>standard-scanner</code> chart implements the Kubernetes API Approach for container scanning, which is our recommended enterprise approach for scanning containers with shell access. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specific resources for standard container scanning.</p> <p>The Kubernetes API Approach uses the <code>train-k8s-container</code> transport plugin for CINC Auditor to directly scan containers via the Kubernetes API, providing the most efficient and secure scanning method.</p>"},{"location":"helm-charts/standard-scanner/#components","title":"Components","text":""},{"location":"helm-charts/standard-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo pod for testing and validation</li> <li>Standard Linux container with shell</li> <li>Demonstrates scanning capabilities</li> </ol> <p>This chart primarily relies on components from its dependencies: - <code>common-scanner</code>: Scanning scripts and SAF CLI integration - <code>scanner-infrastructure</code>: RBAC, service accounts, and security model</p>"},{"location":"helm-charts/standard-scanner/#features","title":"Features","text":""},{"location":"helm-charts/standard-scanner/#direct-container-scanning","title":"Direct Container Scanning","text":"<p>The Kubernetes API Approach provides these advantages:</p> <ul> <li>Minimal Resource Footprint: Uses only <code>kubectl exec</code> for scanning</li> <li>No Additional Containers: Doesn't require debug or sidecar containers</li> <li>Streamlined Security Model: Simplest and most secure approach</li> <li>Fast Execution: Direct access to container without intermediate layers</li> <li>Enterprise Recommended: Ideal for production environments</li> </ul>"},{"location":"helm-charts/standard-scanner/#security-benefits","title":"Security Benefits","text":"<ul> <li>Minimal Attack Surface: Smallest possible attack surface</li> <li>Container Integrity: No modifications to target containers</li> <li>One Process Per Container: Maintains Docker best practice of one process per container</li> <li>Strong Resource Boundaries: Clear separation between scanner and target</li> </ul>"},{"location":"helm-charts/standard-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/standard-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"helm-charts/standard-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app\n</code></pre>"},{"location":"helm-charts/standard-scanner/#installation-with-custom-thresholds","title":"Installation with Custom Thresholds","text":"<pre><code># Install with custom compliance thresholds\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.safCli.thresholdConfig.compliance.min=90 \\\n  --set common-scanner.safCli.thresholdConfig.failed.critical.max=0 \\\n  --set common-scanner.safCli.thresholdConfig.failed.high.max=0\n</code></pre>"},{"location":"helm-charts/standard-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/standard-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/standard-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>inspec-target-helm</code> No <code>testPod.image</code> Test pod image <code>busybox:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sh\", \"-c\", \"while true; do sleep 3600; done\"]</code> No"},{"location":"helm-charts/standard-scanner/#scanning-configuration-inherited-from-common-scanner","title":"Scanning Configuration (Inherited from common-scanner)","text":"Parameter Description Default Required <code>common-scanner.safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>common-scanner.safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>common-scanner.safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/standard-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/standard-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Generate kubeconfig\n./scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n\n# Run scan against test pod\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target-helm/busybox\n</code></pre>"},{"location":"helm-charts/standard-scanner/#using-with-existing-applications","title":"Using with Existing Applications","text":"<p>For scanning existing application containers:</p> <pre><code># Generate kubeconfig\n./scripts/generate-kubeconfig.sh prod-scanning inspec-scanner ./kubeconfig.yaml\n\n# Run scan against application container\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://prod-scanning/my-application-pod/application-container\n\n# Alternatively, use the scan script\n./scripts/scan-container.sh prod-scanning my-application-pod application-container ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/standard-scanner/#using-with-saf-cli-for-compliance-validation","title":"Using with SAF CLI for Compliance Validation","text":"<pre><code># Run scan with compliance validation\n./scripts/scan-container.sh prod-scanning my-application-pod application-container \\\n  ./examples/cinc-profiles/container-baseline \\\n  --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/standard-scanner/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"helm-charts/standard-scanner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Container Scanning\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Install Helm\n        uses: azure/setup-helm@v1\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v1\n\n      - name: Set up kubeconfig\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; ./kubeconfig.yaml\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n\n      - name: Install SAF CLI\n        run: |\n          pip install saf-cli\n\n      - name: Run container scan\n        run: |\n          ./scripts/scan-container.sh prod-scanning application-pod container-name \\\n            ./profiles/container-baseline --threshold-file=./ci-threshold.yml\n        env:\n          KUBECONFIG: ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/standard-scanner/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>stages:\n  - deploy\n  - scan\n\ndeploy:\n  stage: deploy\n  script:\n    - kubectl apply -f kubernetes/application.yaml\n\nscan:\n  stage: scan\n  image: registry.gitlab.com/your-org/cinc-auditor-saf:latest\n  script:\n    - ./scripts/scan-container.sh ${CI_ENVIRONMENT_NAME} application-pod container-name \\\n        ./profiles/container-baseline --threshold-file=./ci-threshold.yml\n  artifacts:\n    paths:\n      - scan-results.json\n      - compliance-report.md\n</code></pre>"},{"location":"helm-charts/standard-scanner/#troubleshooting","title":"Troubleshooting","text":""},{"location":"helm-charts/standard-scanner/#common-issues","title":"Common Issues","text":"<ol> <li>Container Access Issues</li> <li>Verify target container has a shell available (typically /bin/sh)</li> <li>Check that the container is running and healthy</li> <li> <p>Ensure proper RBAC permissions for container access</p> </li> <li> <p>Transport Plugin Errors</p> </li> <li>Verify train-k8s-container transport is installed</li> <li>Check kubectl connection to cluster</li> <li> <p>Ensure kubeconfig file has proper permissions</p> </li> <li> <p>Profile Execution Failures</p> </li> <li>Verify profile is compatible with target container</li> <li>Check for missing dependencies in target container</li> <li>Ensure profile syntax is correct</li> </ol>"},{"location":"helm-charts/standard-scanner/#debugging","title":"Debugging","text":"<p>Enable debug output for the CINC Auditor transport:</p> <pre><code># Run with debug output\nCINC_LOGGER=debug KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target-helm/busybox\n</code></pre> <p>Check connection to target container:</p> <pre><code># Verify exec access\nkubectl exec -n inspec-test inspec-target-helm -- /bin/sh -c \"echo 'Connection successful'\"\n</code></pre>"},{"location":"helm-charts/standard-scanner/#next-steps","title":"Next Steps","text":"<p>After successfully installing and using the standard scanner:</p> <ol> <li>Review the Customization guide for tailoring your scanning environment</li> <li>Explore Security Considerations for hardening recommendations</li> <li>Learn about CI/CD Integration for automated scanning</li> <li>Consider moving to the Distroless Scanner if you need to scan distroless containers</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/troubleshooting/","title":"Helm Chart Troubleshooting Guide","text":""},{"location":"helm-charts/troubleshooting/#overview","title":"Overview","text":"<p>This guide provides solutions for common issues encountered when using the Secure Kubernetes Container Scanning Helm charts. It covers installation problems, scanning errors, RBAC issues, and performance troubleshooting.</p>"},{"location":"helm-charts/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"helm-charts/troubleshooting/#chart-dependency-resolution-failures","title":"Chart Dependency Resolution Failures","text":"<p>Problem: Dependencies not resolved during installation.</p> <pre><code>Error: found in Chart.yaml, but missing in charts/ directory: common-scanner, scanner-infrastructure\n</code></pre> <p>Solution:</p> <pre><code># Update dependencies before installing\nhelm dependency update ./helm-charts/standard-scanner\n\n# Alternative: build dependencies explicitly\ncd ./helm-charts\nhelm dependency build standard-scanner\nhelm install standard-scanner ./standard-scanner\n</code></pre>"},{"location":"helm-charts/troubleshooting/#namespace-conflicts","title":"Namespace Conflicts","text":"<p>Problem: Chart tries to create a namespace that already exists.</p> <pre><code>Error: rendered manifests contain a resource that already exists. Unable to continue with install: namespace \"inspec-test\" exists\n</code></pre> <p>Solution:</p> <pre><code># Disable namespace creation\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.createNamespace=false \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"helm-charts/troubleshooting/#chart-version-incompatibility","title":"Chart Version Incompatibility","text":"<p>Problem: Helm version doesn't support the chart schema version.</p> <p>Solution:</p> <pre><code># Check Helm version\nhelm version\n\n# Upgrade Helm if needed\ncurl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre>"},{"location":"helm-charts/troubleshooting/#rbac-and-authentication-issues","title":"RBAC and Authentication Issues","text":""},{"location":"helm-charts/troubleshooting/#permission-denied-errors","title":"Permission Denied Errors","text":"<p>Problem: Scanner can't access target containers.</p> <pre><code>Error: PERMISSION_DENIED: pods \"target-pod\" is forbidden: User \"system:serviceaccount:inspec-test:inspec-scanner\" cannot exec into pods in the namespace \"inspec-test\"\n</code></pre> <p>Solution:</p> <ol> <li>Verify RBAC configuration:</li> </ol> <pre><code># Check service account\nkubectl get serviceaccount inspec-scanner -n inspec-test\n\n# Check role and permissions\nkubectl get role inspec-container-role -n inspec-test -o yaml\n\n# Check role binding\nkubectl get rolebinding inspec-container-rolebinding -n inspec-test -o yaml\n</code></pre> <ol> <li>Ensure proper role configuration:</li> </ol> <pre><code># Update chart with explicit permissions\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.rules.core.enabled=true \\\n  --set rbac.rules.ephemeralContainers.enabled=true  # If needed\n</code></pre>"},{"location":"helm-charts/troubleshooting/#resource-name-restriction-issues","title":"Resource Name Restriction Issues","text":"<p>Problem: When using resource name restrictions, scanner can't access pods.</p> <p>Solution:</p> <pre><code># Disable resource name restrictions temporarily for debugging\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.useResourceNames=false\n\n# Or set the correct pod names in restrictions\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.resourceNames[0]=target-pod-1 \\\n  --set rbac.resourceNames[1]=target-pod-2\n</code></pre>"},{"location":"helm-charts/troubleshooting/#token-generation-issues","title":"Token Generation Issues","text":"<p>Problem: Can't generate valid tokens for scanner.</p> <p>Solution:</p> <pre><code># Check service account secrets\nkubectl get serviceaccount inspec-scanner -n inspec-test -o yaml\n\n# Recreate service account if needed\nkubectl delete serviceaccount inspec-scanner -n inspec-test\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\n# Manual token generation\nSERVICE_ACCOUNT=inspec-scanner\nNAMESPACE=inspec-test\nSECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT} -n ${NAMESPACE} -o jsonpath='{.secrets[0].name}')\nTOKEN=$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.token}' | base64 --decode)\necho $TOKEN\n</code></pre>"},{"location":"helm-charts/troubleshooting/#scanning-issues","title":"Scanning Issues","text":""},{"location":"helm-charts/troubleshooting/#standard-scanner-kubernetes-api-approach-issues","title":"Standard Scanner (Kubernetes API Approach) Issues","text":""},{"location":"helm-charts/troubleshooting/#transport-plugin-errors","title":"Transport Plugin Errors","text":"<p>Problem: CINC Auditor can't connect to target container.</p> <pre><code>Error connecting to 'k8s-container://inspec-test/target-pod/container': unable to execute command on pod...\n</code></pre> <p>Solution:</p> <pre><code># Check if container has shell\nkubectl exec -n inspec-test target-pod -c container -- /bin/sh -c \"echo test\"\n\n# Verify CINC Auditor plugin installation\ncinc-auditor plugin list\n\n# Install plugin if missing\ncinc-auditor plugin install inspec-k8s-container\n\n# Update transport plugin version\ncinc-auditor plugin update inspec-k8s-container\n</code></pre>"},{"location":"helm-charts/troubleshooting/#shell-command-failures","title":"Shell Command Failures","text":"<p>Problem: CINC Auditor can't execute commands in target container.</p> <p>Solution:</p> <pre><code># Check container shell\nkubectl exec -n inspec-test target-pod -c container -- ls -la /bin/sh\n\n# If using Alpine, ensure sh is available\nkubectl exec -n inspec-test target-pod -c container -- apk add --no-cache bash\n\n# Update profile to use available commands\n# Edit profile to use `/bin/sh` instead of `/bin/bash`\n</code></pre>"},{"location":"helm-charts/troubleshooting/#distroless-scanner-debug-container-approach-issues","title":"Distroless Scanner (Debug Container Approach) Issues","text":""},{"location":"helm-charts/troubleshooting/#ephemeral-container-creation-failures","title":"Ephemeral Container Creation Failures","text":"<p>Problem: Debug container can't be created.</p> <pre><code>Error: ephemeral containers are disabled for this cluster\n</code></pre> <p>Solution:</p> <pre><code># Check Kubernetes version\nkubectl version\n\n# Enable ephemeral containers in API server (requires admin access)\n# For k8s &lt; 1.23, update kube-apiserver with feature gate:\n--feature-gates=EphemeralContainers=true\n\n# For newer versions, ephemeral containers should be enabled by default\n# Verify API version support\nkubectl api-resources | grep ephemeralcontainers\n</code></pre>"},{"location":"helm-charts/troubleshooting/#debug-container-access-issues","title":"Debug Container Access Issues","text":"<p>Problem: Debug container can't access target container filesystem.</p> <p>Solution:</p> <pre><code># Manually test ephemeral container access\nkubectl debug -it -n inspec-test target-pod --image=alpine:latest --target=container -- sh\n\n# Inside debug container, check process list and filesystem access\nps aux\nls -la /proc/1/root/\n\n# If access issues persist, check security policies\nkubectl get psp  # PodSecurityPolicies in older clusters\nkubectl get podsecuritypolicy  # In newer clusters\n</code></pre>"},{"location":"helm-charts/troubleshooting/#sidecar-scanner-issues","title":"Sidecar Scanner Issues","text":""},{"location":"helm-charts/troubleshooting/#process-namespace-sharing-failures","title":"Process Namespace Sharing Failures","text":"<p>Problem: Sidecar can't access target container processes.</p> <p>Solution:</p> <pre><code># Verify pod has shareProcessNamespace enabled\nkubectl get pod sidecar-target -n inspec-test -o yaml | grep shareProcessNamespace\n\n# Recreate pod with proper configuration\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.shareProcessNamespace=true\n</code></pre>"},{"location":"helm-charts/troubleshooting/#sidecar-container-failures","title":"Sidecar Container Failures","text":"<p>Problem: Scanner container crashes or can't run profiles.</p> <p>Solution:</p> <pre><code># Check scanner container logs\nkubectl logs -n inspec-test sidecar-target -c scanner\n\n# Shell into scanner container for debugging\nkubectl exec -it -n inspec-test sidecar-target -c scanner -- sh\n\n# Try manual profile execution\ninspec exec /profiles/container-baseline -t proc://1/root --logger debug\n</code></pre>"},{"location":"helm-charts/troubleshooting/#saf-cli-integration-issues","title":"SAF CLI Integration Issues","text":""},{"location":"helm-charts/troubleshooting/#threshold-validation-failures","title":"Threshold Validation Failures","text":"<p>Problem: SAF CLI can't validate against threshold file.</p> <pre><code>Error: Failed to validate results against threshold: Invalid threshold file format\n</code></pre> <p>Solution:</p> <pre><code># Check threshold file format\ncat threshold.yml\n\n# Ensure threshold file has correct structure:\ncompliance:\n  min: 70\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 2\n\n# Validate threshold file with SAF CLI\nsaf validate-threshold --threshold threshold.yml\n\n# Update chart with correct threshold configuration\nhelm upgrade common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test \\\n  --set safCli.thresholdConfig.compliance.min=70 \\\n  --set safCli.thresholdConfig.failed.critical.max=0 \\\n  --set safCli.thresholdConfig.failed.high.max=2\n</code></pre>"},{"location":"helm-charts/troubleshooting/#saf-cli-missing-or-incompatible","title":"SAF CLI Missing or Incompatible","text":"<p>Problem: SAF CLI not available or incompatible version.</p> <p>Solution:</p> <pre><code># Check if SAF CLI is installed\nsaf --version\n\n# Install SAF CLI if missing\npip install saf-cli\n\n# Update to compatible version\npip install saf-cli==1.2.3\n\n# Alternatively, disable SAF CLI integration temporarily\nhelm upgrade common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test \\\n  --set safCli.enabled=false\n</code></pre>"},{"location":"helm-charts/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"helm-charts/troubleshooting/#scan-taking-too-long","title":"Scan Taking Too Long","text":"<p>Problem: Container scans taking too long to complete.</p> <p>Solution:</p> <pre><code># Profile optimization\n# Use smaller, focused profiles instead of large ones\n\n# For standard scanner, add timeout\ncinc-auditor exec ./profiles/container-baseline -t k8s-container://inspec-test/target-pod/container --timeout 300\n\n# For distroless scanner, adjust debug container timeout\nhelm upgrade distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set debugContainer.timeout=300\n\n# For sidecar scanner, adjust resource limits\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/troubleshooting/#resource-constraints","title":"Resource Constraints","text":"<p>Problem: Scanner or target pods experiencing resource issues.</p> <p>Solution:</p> <pre><code># Check resource usage\nkubectl top pods -n inspec-test\n\n# Adjust resource limits and requests\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/troubleshooting/#helm-chart-specific-issues","title":"Helm Chart Specific Issues","text":""},{"location":"helm-charts/troubleshooting/#chart-value-inheritance-issues","title":"Chart Value Inheritance Issues","text":"<p>Problem: Values not being passed correctly through chart dependencies.</p> <p>Solution:</p> <pre><code># Check how values are passed through dependencies\nhelm template standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --debug\n\n# Use explicit values file instead\ncat &gt; values.yaml &lt;&lt; EOF\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: inspec-test\n    rbac:\n      useResourceNames: true\nEOF\n\nhelm install standard-scanner ./helm-charts/standard-scanner -f values.yaml\n</code></pre>"},{"location":"helm-charts/troubleshooting/#chart-update-issues","title":"Chart Update Issues","text":"<p>Problem: Helm upgrade not applying changes as expected.</p> <p>Solution:</p> <pre><code># Verify changes before upgrade\nhelm diff upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n\n# Force resource updates if needed\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --force\n\n# Worst case, uninstall and reinstall\nhelm uninstall standard-scanner\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"helm-charts/troubleshooting/#diagram-troubleshooting-flowchart","title":"Diagram: Troubleshooting Flowchart","text":"<pre><code>flowchart TD\n    A[Installation Issue?] --&gt;|Yes| B[Chart Installation Issues]\n    A --&gt;|No| C[Scanning Issue?]\n\n    B --&gt; B1[Dependency Resolution]\n    B --&gt; B2[Namespace Conflicts]\n    B --&gt; B3[Version Incompatibility]\n\n    C --&gt;|Yes| D[Which Scanning Approach?]\n    C --&gt;|No| E[RBAC/Auth Issue?]\n\n    D --&gt; D1[Standard Scanner]\n    D --&gt; D2[Distroless Scanner]\n    D --&gt; D3[Sidecar Scanner]\n\n    D1 --&gt; D1A[Transport Plugin Error]\n    D1 --&gt; D1B[Shell Command Failures]\n\n    D2 --&gt; D2A[Ephemeral Container Creation]\n    D2 --&gt; D2B[Debug Container Access]\n\n    D3 --&gt; D3A[Process Namespace Sharing]\n    D3 --&gt; D3B[Sidecar Container Failures]\n\n    E --&gt;|Yes| F[Permission Denied]\n    E --&gt; F1[Resource Name Restrictions]\n    E --&gt; F2[Token Generation]\n\n    C --&gt;|No| G[SAF CLI Issue?]\n\n    G --&gt;|Yes| H[Threshold Validation]\n    G --&gt; H1[SAF CLI Missing]\n\n    G --&gt;|No| I[Performance Issue?]\n\n    I --&gt;|Yes| J[Scan Too Long]\n    I --&gt; J1[Resource Constraints]\n\n    I --&gt;|No| K[Chart-Specific Issue]\n\n    K --&gt; K1[Value Inheritance]\n    K --&gt; K2[Chart Updates]</code></pre>"},{"location":"helm-charts/troubleshooting/#diagnostic-scripts","title":"Diagnostic Scripts","text":""},{"location":"helm-charts/troubleshooting/#scanner-setup-diagnostics","title":"Scanner Setup Diagnostics","text":"<p>Use this script to diagnose scanner setup issues:</p> <pre><code>#!/bin/bash\n# scanner-diagnostics.sh\nNAMESPACE=\"inspec-test\"\nSERVICE_ACCOUNT=\"inspec-scanner\"\n\necho \"Scanner Diagnostics\"\necho \"===================\"\n\n# Check namespace\necho \"\\nChecking namespace...\"\nkubectl get ns $NAMESPACE || echo \"Namespace $NAMESPACE does not exist!\"\n\n# Check service account\necho \"\\nChecking service account...\"\nkubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o yaml || echo \"Service account $SERVICE_ACCOUNT does not exist!\"\n\n# Check role and role binding\necho \"\\nChecking RBAC configuration...\"\nROLE_NAME=$(kubectl get rolebinding -n $NAMESPACE -o json | jq -r '.items[] | select(.subjects[] | select(.kind==\"ServiceAccount\" and .name==\"'$SERVICE_ACCOUNT'\")) | .roleRef.name')\necho \"Role name: $ROLE_NAME\"\nkubectl get role $ROLE_NAME -n $NAMESPACE -o yaml || echo \"Role $ROLE_NAME does not exist!\"\n\n# Check token secrets\necho \"\\nChecking token secrets...\"\nSECRETS=$(kubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o json | jq -r '.secrets[].name')\nfor SECRET in $SECRETS; do\n  echo \"Secret: $SECRET\"\n  kubectl get secret $SECRET -n $NAMESPACE -o yaml | grep -v \"token:\" || echo \"Secret $SECRET does not exist!\"\ndone\n\necho \"\\nDiagnostics complete!\"\n</code></pre>"},{"location":"helm-charts/troubleshooting/#scanning-diagnostics","title":"Scanning Diagnostics","text":"<p>Use this script to diagnose scanning issues:</p> <pre><code>#!/bin/bash\n# scan-diagnostics.sh\nNAMESPACE=\"inspec-test\"\nPOD_NAME=\"target-pod\"\nCONTAINER_NAME=\"container\"\n\necho \"Scanning Diagnostics\"\necho \"===================\"\n\n# Check pod\necho \"\\nChecking target pod...\"\nkubectl get pod $POD_NAME -n $NAMESPACE || { echo \"Pod $POD_NAME does not exist!\"; exit 1; }\n\n# Check container\necho \"\\nChecking container status...\"\nSTATUS=$(kubectl get pod $POD_NAME -n $NAMESPACE -o json | jq -r '.status.containerStatuses[] | select(.name==\"'$CONTAINER_NAME'\") | .ready')\necho \"Container ready status: $STATUS\"\n\n# Check shell access\necho \"\\nChecking shell access...\"\nkubectl exec -n $NAMESPACE $POD_NAME -c $CONTAINER_NAME -- /bin/sh -c \"echo 'Shell access working'\" || echo \"No shell access to container!\"\n\n# Check process list for sidecar approach\necho \"\\nChecking process namespace sharing (for sidecar approach)...\"\nSHARE_NS=$(kubectl get pod $POD_NAME -n $NAMESPACE -o json | jq -r '.spec.shareProcessNamespace')\necho \"Process namespace sharing: $SHARE_NS\"\n\n# Check CINC Auditor installation for manual troubleshooting\necho \"\\nChecking CINC Auditor installation...\"\nwhich cinc-auditor || echo \"CINC Auditor not found in PATH!\"\ncinc-auditor plugin list 2&gt;/dev/null || echo \"Error listing CINC Auditor plugins!\"\n\necho \"\\nDiagnostics complete!\"\n</code></pre>"},{"location":"helm-charts/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered in this guide:</p> <ol> <li>Check Logs: Always start by checking pod logs</li> </ol> <pre><code>kubectl logs -n inspec-test target-pod -c container\nkubectl logs -n inspec-test target-pod -c scanner  # For sidecar approach\n</code></pre> <ol> <li>Increase Logging Verbosity: Enable debug logging</li> </ol> <pre><code># For CINC Auditor\nCINC_LOGGER=debug KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profiles/container-baseline -t k8s-container://inspec-test/target-pod/container\n\n# For scanning scripts\nDEBUG=true ./scripts/scan-container.sh inspec-test target-pod container ./profiles/container-baseline\n</code></pre> <ol> <li>Report Issues: If you believe you've found a bug in the charts, please report it with:</li> <li>Chart version</li> <li>Kubernetes version</li> <li>Error messages</li> <li>Steps to reproduce</li> <li>Any modifications made to default values</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/","title":"Scanner Infrastructure Helm Chart","text":"<p>This chart provides the core infrastructure components for secure container scanning, including:</p> <ul> <li>RBAC configuration</li> <li>Service accounts</li> <li>Namespaces</li> <li>Supporting scripts and configurations</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#overview","title":"Overview","text":"<p>The Scanner Infrastructure Helm chart is the foundation for all container scanning approaches in this project. It creates the necessary Kubernetes resources to enable secure, least-privilege scanning access.</p>"},{"location":"helm-charts/scanner-infrastructure/#key-components","title":"Key Components","text":"<ul> <li>Namespace: Creates a dedicated namespace for scanning operations</li> <li>Service Account: Creates a service account with time-limited tokens</li> <li>RBAC: Sets up appropriate roles and role bindings with least-privilege access</li> <li>ConfigMap: Stores scripts and configuration for scanning operations</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#values","title":"Values","text":"Parameter Description Default <code>targetNamespace</code> Namespace where the scanning infrastructure will be deployed <code>inspec-test</code> <code>serviceAccount.name</code> Name of the service account for scanning <code>inspec-scanner</code> <code>serviceAccount.ttl</code> Time-to-live for service account tokens <code>1h</code> <code>rbac.roleName</code> Name of the RBAC role <code>scanner-role</code> <code>rbac.clusterWide</code> Whether to create cluster-wide permissions <code>false</code>"},{"location":"helm-charts/scanner-infrastructure/#usage","title":"Usage","text":"<p>See the main Helm Charts documentation for details on how to use this chart as part of the overall container scanning solution.</p>"},{"location":"helm-charts/scanner-infrastructure/#security-considerations","title":"Security Considerations","text":"<p>This chart is designed with security in mind:</p> <ul> <li>Time-limited tokens ensure credentials can't be misused long-term</li> <li>Least-privilege access model restricts scanning to specific pods</li> <li>Namespace isolation prevents cross-namespace access</li> <li>No privileged access required for container scanning</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#related-charts","title":"Related Charts","text":"<ul> <li>Common Scanner - Common components used by all scanner types</li> <li>Standard Scanner - For standard containers</li> <li>Distroless Scanner - For distroless containers</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":"<p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/approach-mapping/","title":"CI/CD Integration by Scanning Approach","text":"<p>This document provides a comprehensive mapping of our CI/CD examples to each scanning approach, helping you choose the right workflow for your specific container scanning needs.</p>"},{"location":"integration/approach-mapping/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach is our recommended method for scanning containers in production environments. Support for distroless containers is currently in progress through enhancements to the train-k8s-container plugin.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code>name: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <p>This workflow implements: - Complete CI/CD pipeline with build, deploy, and scan steps - Standard Kubernetes API-based scanning - SAF-CLI integration for threshold checking - Quality gates enforcement options</p>"},{"location":"integration/approach-mapping/#dynamic-rbac-scanning","title":"Dynamic RBAC Scanning","text":"<pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre> <p>This workflow implements: - Label-based pod selection for targeted scanning - Least-privilege RBAC model - Dynamic service account and token creation</p>"},{"location":"integration/approach-mapping/#setup-and-scan","title":"Setup and Scan","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements: - Scanning pods in existing clusters - Using externally provided kubeconfig - Limited-duration token generation - Annotation-based profile selection</p>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#standard-pipeline","title":"Standard Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements: - Standard Kubernetes API approach - Four-stage pipeline (deploy, scan, report, cleanup) - SAF-CLI integration for report generation - Threshold-based quality gates</p>"},{"location":"integration/approach-mapping/#dynamic-rbac-scanning_1","title":"Dynamic RBAC Scanning","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  KUBERNETES_NAMESPACE: \"dynamic-scan-$CI_PIPELINE_ID\"\n  TARGET_IMAGE: \"busybox:latest\"\n  SCAN_LABEL_KEY: \"scan-target\"\n  SCAN_LABEL_VALUE: \"true\"\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\" # Token duration in minutes\n\n# Allow overriding variables through pipeline triggers or UI\n.dynamic_variables: &amp;dynamic_variables\n  TARGET_IMAGE: ${TARGET_IMAGE}\n  SCAN_LABEL_KEY: ${SCAN_LABEL_KEY}\n  SCAN_LABEL_VALUE: ${SCAN_LABEL_VALUE}\n  CINC_PROFILE: ${CINC_PROFILE}\n  THRESHOLD_VALUE: ${THRESHOLD_VALUE}\n  ADDITIONAL_PROFILE_ANNOTATION: \"${ADDITIONAL_PROFILE_ANNOTATION}\"  # Optional annotation for specifying additional profiles\n\nsetup_test_environment:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create test namespace\n    - kubectl create namespace ${KUBERNETES_NAMESPACE}\n\n    # Create multiple test pods with different images and labels\n    - |\n      # Create 3 pods, but only mark the first one for scanning\n      for i in {1..3}; do\n        cat &lt;&lt;EOF | kubectl apply -f -\n        apiVersion: v1\n        kind: Pod\n        metadata:\n          name: pod-${i}\n          namespace: ${KUBERNETES_NAMESPACE}\n          labels:\n            app: test-pod-${i}\n            ${SCAN_LABEL_KEY}: \"$([ $i -eq 1 ] &amp;&amp; echo \"${SCAN_LABEL_VALUE}\" || echo \"false\")\"\n          annotations:\n            scan-profile: \"${CINC_PROFILE}\"\n            $([ -n \"${ADDITIONAL_PROFILE_ANNOTATION}\" ] &amp;&amp; echo \"${ADDITIONAL_PROFILE_ANNOTATION}\" || echo \"\")\n        spec:\n          containers:\n          - name: container\n            image: ${TARGET_IMAGE}\n            command: [\"sleep\", \"infinity\"]\n        EOF\n      done\n\n    # Wait for pods to be ready\n    - kubectl wait --for=condition=ready pod -l app=test-pod-1 -n ${KUBERNETES_NAMESPACE} --timeout=120s\n\n    # Get the name of the pod with our scan label\n    - |\n      TARGET_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$TARGET_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n        exit 1\n      fi\n      echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; deploy.env\n\n    # Save scan profile from annotations if available\n    - |\n      SCAN_PROFILE=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}')\n      if [ -n \"$SCAN_PROFILE\" ]; then\n        echo \"Found scan profile annotation: ${SCAN_PROFILE}\"\n        echo \"SCAN_PROFILE=${SCAN_PROFILE}\" &gt;&gt; deploy.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"SCAN_PROFILE=${CINC_PROFILE}\" &gt;&gt; deploy.env\n      fi\n\n    # Show all pods in the namespace\n    - kubectl get pods -n ${KUBERNETES_NAMESPACE} --show-labels\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_dynamic_rbac:\n  stage: scan\n  needs: [setup_test_environment]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      EOF\n\n    # Create role with label-based access\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role\n        namespace: ${KUBERNETES_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding\n        namespace: ${KUBERNETES_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token\n    - |\n      TOKEN=$(kubectl create token scanner-sa -n ${KUBERNETES_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_security_scan:\n  stage: scan\n  needs: [setup_test_environment, create_dynamic_rbac]\n  script:\n    # Create kubeconfig with restricted token\n    - |\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scan-kubeconfig.yaml\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n    # Install train-k8s-container plugin\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - npm install -g @mitre/saf\n\n    # Verify the tools\n    - cinc-auditor --version\n    - saf --version\n\n    # Find the target pod by label using the restricted token\n    - |\n      echo \"Looking for pods with label: ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n      SCANNED_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$SCANNED_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} using restricted access\"\n        exit 1\n      fi\n      echo \"Found target pod: ${SCANNED_POD}\"\n\n      # Verify it matches what we expected\n      if [ \"$SCANNED_POD\" != \"$TARGET_POD\" ]; then\n        echo \"Warning: Scanned pod ($SCANNED_POD) doesn't match expected target pod ($TARGET_POD)\"\n      fi\n\n    # Get container name\n    - CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n\n    # Run CINC Auditor scan\n    - |\n      echo \"Running CINC Auditor scan on ${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME}\"\n      KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${SCAN_PROFILE} \\\n        -t k8s-container://${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate comprehensive HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\nverify_rbac_restrictions:\n  stage: verify\n  needs: [setup_test_environment, create_dynamic_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a second kubeconfig with restricted token\n    - |\n      cat &gt; verify-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 verify-kubeconfig.yaml\n\n    # Get a non-target pod name\n    - OTHER_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${KUBERNETES_NAMESPACE} --resource-name=${TARGET_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n      echo \"Cannot create pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i delete pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n    # Create a security report for MR\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Results\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Details\n\n      - Target Pod: \\`${TARGET_POD}\\`\n      - Container: \\`${CONTAINER_NAME}\\`\n      - Image: \\`${TARGET_IMAGE}\\`\n      - Profile: \\`${SCAN_PROFILE}\\`\n\n      For full results, see the scan artifacts.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\ncleanup:\n  stage: cleanup\n  needs: [setup_test_environment]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete namespace ${KUBERNETES_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements: - Label-based pod targeting - Restricted RBAC permissions - Time-bound access credentials</p>"},{"location":"integration/approach-mapping/#gitlab-services-variant","title":"GitLab Services Variant","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide: - Pre-configured scanning environment - Separation of scanning tools from main job - Reduced pipeline setup time</p>"},{"location":"integration/approach-mapping/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach is our interim solution for scanning distroless containers while we complete full distroless support in the Kubernetes API Approach.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation_1","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#setup-and-scan-with-debug-containers","title":"Setup and Scan with Debug Containers","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements: - Setup of a minikube cluster for testing - Deployment of test containers including distroless containers - Configuration for ephemeral debug containers - Scanning with CINC Auditor through debug containers</p>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation_1","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#existing-cluster-with-debug-containers","title":"Existing Cluster with Debug Containers","text":"<pre><code>stages:\n  - prepare\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  # Default values - override in UI or with pipeline parameters\n  SCAN_NAMESPACE: \"default\"  # Existing namespace where pods are deployed\n  TARGET_LABEL_SELECTOR: \"scan-target=true\"  # Label to identify target pods\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\"  # Token duration in minutes\n\n# Define workflow\nworkflow:\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"web\"  # Manual trigger from UI\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"  # Scheduled pipeline\n    - if: $CI_PIPELINE_SOURCE == \"trigger\"  # API trigger with token\n\n# Find pods to scan in existing cluster\nprepare_scan:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  script:\n    # Configure kubectl with cluster credentials\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a unique run ID for this pipeline\n    - RUN_ID=\"gl-$CI_PIPELINE_ID-$CI_JOB_ID\"\n    - echo \"RUN_ID=${RUN_ID}\" &gt;&gt; prepare.env\n\n    # Verify the namespace exists\n    - kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n    # Find target pods with specified label\n    - |\n      TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n      if [ -z \"$TARGET_PODS\" ]; then\n        echo \"No pods found matching label: ${TARGET_LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n        exit 1\n      fi\n\n      # Count and list found pods\n      POD_COUNT=$(echo $TARGET_PODS | wc -w)\n      echo \"Found ${POD_COUNT} pods to scan:\"\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} --show-labels\n\n      # Get the first pod as primary target\n      PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n      echo \"Primary target pod: ${PRIMARY_POD}\"\n      echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; prepare.env\n\n      # Get container name for the primary pod\n      PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n      echo \"Primary container: ${PRIMARY_CONTAINER}\"\n      echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; prepare.env\n\n      # Check for custom profile annotation\n      PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$PROFILE_ANNOTATION\" ]; then\n        echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n        echo \"PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; prepare.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"PROFILE=${CINC_PROFILE}\" &gt;&gt; prepare.env\n      fi\n  artifacts:\n    reports:\n      dotenv: prepare.env\n\n# Create temporary RBAC for scanning\ncreate_rbac:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account for scanning\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      EOF\n\n    # Create role with least privilege\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${RUN_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token for service account\n    - |\n      TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; rbac.env\n  artifacts:\n    reports:\n      dotenv: rbac.env\n\n# Run the security scan with restricted access\nrun_security_scan:\n  stage: scan\n  image: registry.gitlab.com/gitlab-org/security-products/analyzers/container-scanning:5\n  needs: [prepare_scan, create_rbac]\n  script:\n    # Create restricted kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Install CINC Auditor and plugins\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - apt-get update &amp;&amp; apt-get install -y npm\n    - npm install -g @mitre/saf\n\n    # Test restricted access\n    - |\n      echo \"Testing restricted access:\"\n      export KUBECONFIG=scanner-kubeconfig.yaml\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR}\n\n      echo \"Verifying target pod access:\"\n      kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o name || { echo \"Cannot access target pod with restricted token\"; exit 1; }\n\n    # Run the scan\n    - |\n      echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n      KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n        -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n      - threshold.yml\n    reports:\n      dotenv: scan.env\n\n# Verify RBAC permissions are properly restricted\nverify_rbac:\n  stage: verify\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan, create_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create restricted kubeconfig for testing\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${PRIMARY_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n\n      echo \"Cannot create pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i delete pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n      # Find non-target pod for testing\n      OTHER_POD=$(kubectl get pods -n ${SCAN_NAMESPACE} -l app!=scan-target -o jsonpath='{.items[0].metadata.name}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$OTHER_POD\" ] &amp;&amp; [ \"$OTHER_POD\" != \"$PRIMARY_POD\" ]; then\n        echo \"Cannot exec into non-target pod:\"\n        KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${OTHER_POD} &amp;&amp; \n          echo \"\u274c Security issue: Can exec into non-target pod\" || \n          echo \"\u2705 Cannot exec into non-target pod (expected)\"\n      fi\n\n    # Create security report\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Details\n\n      - **Pipeline:** ${CI_PIPELINE_ID}\n      - **Target Namespace:** ${SCAN_NAMESPACE}\n      - **Target Pod:** ${PRIMARY_POD}\n      - **Target Container:** ${PRIMARY_CONTAINER}\n      - **CINC Profile:** ${PROFILE}\n      - **Compliance Threshold:** ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot exec into non-target pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Results\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      See scan artifacts for detailed compliance results.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\n# Always clean up RBAC resources\ncleanup_rbac:\n  stage: cleanup\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Delete role binding\n    - kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete role\n    - kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete service account\n    - kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    - echo \"RBAC resources cleaned up\"\n</code></pre> <p>This pipeline implements: - Configuration for scanning distroless containers - Support for ephemeral debug containers - Flexible profile selection</p>"},{"location":"integration/approach-mapping/#gitlab-services-with-debug-containers","title":"GitLab Services with Debug Containers","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide: - Specialized service container for distroless scanning - Pre-installed dependencies for debug container approach - Simplified workflow for distroless container scanning</p>"},{"location":"integration/approach-mapping/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach is our universal interim solution with minimal privileges that works for both standard and distroless containers.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation_2","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#sidecar-scanner-approach","title":"Sidecar Scanner Approach","text":"<pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements: - Shared process namespace setup - Sidecar container deployment with CINC Auditor - Process identification and scanning - Support for both standard and distroless containers</p>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation_2","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#standard-sidecar-approach","title":"Standard Sidecar Approach","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for CINC profile\n      cat &gt; container-baseline.rb &lt;&lt; EOF\n      # Example CINC Auditor profile for container scanning\n\n      title \"Container Baseline\"\n\n      control \"container-1.1\" do\n        impact 0.7\n        title \"Container files should have proper permissions\"\n        desc \"Critical files in the container should have proper permissions.\"\n\n        describe file('/etc/passwd') do\n          it { should exist }\n          its('mode') { should cmp '0644' }\n        end\n      end\n\n      control \"container-1.2\" do\n        impact 0.5\n        title \"Container should not have unnecessary packages\"\n        desc \"Container should be minimal and not contain unnecessary packages.\"\n\n        describe directory('/var/lib/apt') do\n          it { should_not exist }\n        end\n      end\n      EOF\n\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=container-baseline.rb \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: ruby:3.0-slim\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Install dependencies\n            apt-get update\n            apt-get install -y curl gnupg procps nodejs npm\n\n            # Install CINC Auditor\n            curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n            # Install SAF CLI\n            npm install -g @mitre/saf\n\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=\\$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print \\$2}')\n\n            if [ -z \"\\$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID \\$TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/\\$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=\\$?\n\n            echo \"Scan completed with exit code: \\$SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=\\$?\n                echo \"Threshold validation result: \\$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json ./scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md ./scan-summary.md -c scanner\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements: - Pod deployment with shared process namespace - Sidecar scanner container configuration - Process-based scanning approach</p>"},{"location":"integration/approach-mapping/#sidecar-with-services","title":"Sidecar with Services","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\n# Define a custom service image for CINC Auditor sidecar deployment\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Copy profile from within the service container\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n      docker exec cinc-scanner ls -la /tmp/profile\n\n      # Create ConfigMap for CINC profile from the service container\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=$(docker exec cinc-scanner find /tmp/profile -name \"*.rb\" | head -1) \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print $2}')\n\n            if [ -z \"$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID $TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=$?\n\n            echo \"Scan completed with exit code: $SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=$?\n                echo \"$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results using the service container\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json /tmp/scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md /tmp/scan-summary.md -c scanner\n\n      # Copy results to service container for processing\n      docker cp /tmp/scan-results.json cinc-scanner:/tmp/\n      docker cp /tmp/scan-summary.md cinc-scanner:/tmp/\n\n      # Process results in the service container\n      docker exec cinc-scanner bash -c \"\n        # Generate normalized report\n        saf normalize -i /tmp/scan-results.json -o /tmp/normalized-results.json\n\n        # Additional report processing\n        saf view -i /tmp/scan-results.json --output /tmp/scan-report.html\n      \"\n\n      # Copy processed results back\n      docker cp cinc-scanner:/tmp/normalized-results.json ./normalized-results.json\n      docker cp cinc-scanner:/tmp/scan-report.html ./scan-report.html\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - normalized-results.json\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\n# This example shows how to utilize the service container \n# to generate specialized reports from the scan results\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Use the service container to generate comprehensive reports\n      docker cp scan-results.json cinc-scanner:/tmp/\n\n      # Generate multiple report formats in the service container\n      docker exec cinc-scanner bash -c \"\n        cd /tmp\n\n        # Generate HTML report\n        saf view -i scan-results.json --output enhanced-report.html\n\n        # Generate CSV report\n        saf generate -i scan-results.json -o csv &gt; results.csv\n\n        # Generate Excel report\n        saf generate -i scan-results.json -o xlsx &gt; results.xlsx\n\n        # Generate JUnit report for CI integration\n        saf generate -i scan-results.json -o junit &gt; junit.xml\n      \"\n\n      # Copy all reports back\n      docker cp cinc-scanner:/tmp/enhanced-report.html ./enhanced-report.html\n      docker cp cinc-scanner:/tmp/results.csv ./results.csv\n      docker cp cinc-scanner:/tmp/results.xlsx ./results.xlsx\n      docker cp cinc-scanner:/tmp/junit.xml ./junit.xml\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([ \"${THRESHOLD_PASSED}\" -eq 0 ] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the enhanced report artifacts.\n\n      * HTML Report: enhanced-report.html\n      * CSV Report: results.csv\n      * Excel Report: results.xlsx\n      * JUnit Report: junit.xml\n      EOF\n  artifacts:\n    paths:\n      - enhanced-report.html\n      - results.csv\n      - results.xlsx\n      - junit.xml\n      - scan-report.md\n    reports:\n      junit: junit.xml\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide: - Pre-configured sidecar scanner service - Simplified deployment and configuration - Consistent scanning environment</p>"},{"location":"integration/approach-mapping/#choosing-the-right-example","title":"Choosing the Right Example","text":"<p>Use this guide to select the appropriate CI/CD implementation:</p> <ol> <li>For Standard Containers in Production:</li> <li>GitHub: Use <code>github-workflows/existing-cluster-scanning.yml</code></li> <li> <p>GitLab: Use <code>gitlab-examples/gitlab-ci.yml</code> or <code>gitlab-examples/gitlab-ci-with-services.yml</code></p> </li> <li> <p>For Distroless Containers:</p> </li> <li>GitHub: Use <code>github-workflows/setup-and-scan.yml</code> with distroless configuration</li> <li> <p>GitLab: Use <code>gitlab-examples/existing-cluster-scanning.yml</code> with distroless configuration or <code>gitlab-examples/gitlab-ci-with-services.yml</code> with distroless service</p> </li> <li> <p>For Universal Scanning (both standard and distroless):</p> </li> <li>GitHub: Use <code>github-workflows/sidecar-scanner.yml</code></li> <li> <p>GitLab: Use <code>gitlab-examples/gitlab-ci-sidecar.yml</code> or <code>gitlab-examples/gitlab-ci-sidecar-with-services.yml</code></p> </li> <li> <p>For Local Development and Testing:</p> </li> <li>GitHub: Use <code>github-workflows/setup-and-scan.yml</code></li> <li>GitLab: Use <code>gitlab-examples/gitlab-ci.yml</code> with minikube setup</li> </ol>"},{"location":"integration/approach-mapping/#features-comparison","title":"Features Comparison","text":"Feature Kubernetes API Approach Debug Container Approach Sidecar Container Approach Standard Container Support \u2705 Best approach \u2705 Supported \u2705 Supported Distroless Container Support \ud83d\udd04 In progress \u2705 Best interim approach \u2705 Supported No Pod Modification Required \u2705 Yes \u274c No \u274c No Minimal Privileges \u2705 Yes \u274c No \u2705 Yes GitHub Actions Support \u2705 Yes \u2705 Yes \u2705 Yes GitLab CI Support \u2705 Yes \u2705 Yes \u2705 Yes GitLab Services Support \u2705 Yes \u2705 Yes \u2705 Yes <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/github-actions/","title":"GitHub Actions Integration","text":"<p>This guide explains how to use GitHub Actions for secure Kubernetes container scanning with CINC Auditor (using the train-k8s-container plugin) and MITRE SAF-CLI.</p> <p>Strategic Priority: We strongly recommend the Kubernetes API Approach using the train-k8s-container plugin for enterprise-grade container scanning. Our highest priority is enhancing this plugin to support distroless containers. See Approach Comparison and Security Compliance for more details.</p>"},{"location":"integration/github-actions/#available-workflows","title":"Available Workflows","text":"<p>We provide three GitHub Actions workflow examples:</p> <ol> <li>Basic Setup and Scan - Sets up a minikube cluster and runs a basic scan against a container</li> <li>Dynamic RBAC Scanning - Demonstrates dynamic pod selection by labels with secure RBAC</li> <li>CI/CD Pipeline - Complete pipeline that builds, deploys, scans a container, and processes results with SAF-CLI</li> </ol>"},{"location":"integration/github-actions/#setup-instructions","title":"Setup Instructions","text":""},{"location":"integration/github-actions/#1-repository-setup","title":"1. Repository Setup","text":"<ol> <li>Create a new GitHub repository or use an existing one</li> <li>Copy the workflow files from the <code>docs/github-workflow-examples</code> directory to <code>.github/workflows</code> in your repository</li> <li>Commit and push the changes</li> </ol>"},{"location":"integration/github-actions/#2-workflow-permissions","title":"2. Workflow Permissions","text":"<p>Ensure your GitHub Actions workflows have appropriate permissions:</p> <ol> <li>Go to your repository Settings &gt; Actions &gt; General</li> <li>Under \"Workflow permissions\", select \"Read and write permissions\"</li> <li>Check \"Allow GitHub Actions to create and approve pull requests\"</li> </ol>"},{"location":"integration/github-actions/#running-the-workflows","title":"Running the Workflows","text":""},{"location":"integration/github-actions/#basic-setup-and-scan","title":"Basic Setup and Scan","text":"<p>This workflow sets up a minikube cluster and runs a basic scan against a busybox container:</p> <ol> <li>Navigate to the Actions tab in your repository</li> <li>Select the \"Setup Minikube and Run CINC Auditor Scan\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Minikube version: Version of minikube to use (default: v1.32.0)</li> <li>Kubernetes version: Version of Kubernetes to use (default: v1.28.3)</li> <li>CINC profile: Profile to run (default: dev-sec/linux-baseline)</li> <li>Click Run workflow to start the scan</li> </ol> <p>The workflow will: - Set up a minikube cluster - Create a test pod - Configure restricted RBAC - Run CINC Auditor against the container - Upload the scan results as artifacts</p>"},{"location":"integration/github-actions/#dynamic-rbac-scanning-dynamic-rbac-configuration","title":"Dynamic RBAC Scanning {#dynamic-rbac-configuration}","text":"<p>This workflow demonstrates more advanced scanning with dynamic pod targeting:</p> <ol> <li>Navigate to the Actions tab</li> <li>Select the \"Dynamic RBAC Pod Scanning\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Target container image: Container image to scan</li> <li>Scan label: Label to identify the target container (format: key=value)</li> <li>CINC profile: Profile to run</li> <li>Click Run workflow</li> </ol> <p>The workflow will: - Create multiple pods but only label one for scanning - Set up label-based RBAC - Run CINC Auditor against the labeled container only - Verify that access is properly restricted - Upload the results as artifacts</p>"},{"location":"integration/github-actions/#cicd-pipeline-with-saf-cli","title":"CI/CD Pipeline with SAF-CLI","text":"<p>This workflow demonstrates a complete CI/CD pipeline with security scanning and quality gates:</p> <ol> <li>Navigate to the Actions tab</li> <li>Select the \"CI/CD Pipeline with CINC Auditor Scanning\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Image tag: Tag for the container image</li> <li>Scan namespace: Kubernetes namespace for deployment and scanning</li> <li>Threshold: Minimum passing score (0-100) for security checks</li> <li>Click Run workflow</li> </ol> <p>The workflow will: - Create a simple test application - Build a container image - Deploy it to Kubernetes - Set up secure scanning access - Run custom security checks with CINC Auditor - Generate reports with SAF-CLI - Apply threshold checks for quality gates - Upload all results as artifacts</p>"},{"location":"integration/github-actions/#mitre-saf-cli-integration","title":"MITRE SAF-CLI Integration","text":""},{"location":"integration/github-actions/#overview","title":"Overview","text":"<p>The workflow uses MITRE SAF-CLI for processing scan results and implementing quality gates. SAF-CLI provides:</p> <ol> <li>Formatted summaries (Markdown, JSON, etc.)</li> <li>Threshold-based quality gates </li> <li>Visualization capabilities</li> </ol>"},{"location":"integration/github-actions/#saf-cli-commands-used","title":"SAF-CLI Commands Used","text":""},{"location":"integration/github-actions/#summary-generation","title":"Summary Generation","text":"<pre><code># Generate a markdown summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Display the summary in the logs\ncat scan-summary.md\n</code></pre>"},{"location":"integration/github-actions/#threshold-checks","title":"Threshold Checks","text":"<pre><code># Check against threshold value (exits with non-zero if below threshold)\nsaf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\nTHRESHOLD_EXIT_CODE=$?\n\nif [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\n  # Uncomment to enforce the threshold as a quality gate\n  # exit $THRESHOLD_EXIT_CODE\nfi\n</code></pre>"},{"location":"integration/github-actions/#advanced-thresholds","title":"Advanced Thresholds","text":"<p>For more granular control, you can extend the threshold command:</p> <pre><code># Zero critical failures, max 2 high severity failures, 70% overall\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/github-actions/#github-step-summary-integration","title":"GitHub Step Summary Integration","text":"<pre><code># Create a combined summary for GitHub step summary\necho \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\ncat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\necho \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\ncat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>"},{"location":"integration/github-actions/#customizing-the-workflows","title":"Customizing the Workflows","text":""},{"location":"integration/github-actions/#using-your-own-profiles","title":"Using Your Own Profiles","text":"<p>To use your own CINC Auditor profiles:</p> <ol> <li>Create a profile in your repository (e.g., <code>./profiles/my-custom-profile</code>)</li> <li>When running the workflow, enter <code>./profiles/my-custom-profile</code> as the profile parameter</li> </ol> <p>Or use a profile from a URL:</p> <ol> <li>Host your profile in a Git repository</li> <li>When running the workflow, enter the URL of your profile</li> </ol>"},{"location":"integration/github-actions/#integrating-with-pull-requests","title":"Integrating with Pull Requests","text":"<p>You can modify the workflows to run on pull requests:</p> <ol> <li>Edit the workflow file</li> <li>Update the <code>on:</code> section to include pull requests:</li> </ol> <pre><code>on:\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n    # keep existing inputs\n</code></pre> <ol> <li>Add comment reporting using SAF-CLI output:</li> </ol> <pre><code>- name: Comment on PR with scan results\n  if: github.event_name == 'pull_request'\n  uses: actions/github-script@v6\n  with:\n    github-token: ${{ secrets.GITHUB_TOKEN }}\n    script: |\n      const fs = require('fs');\n      const summary = fs.readFileSync('scan-summary.md', 'utf8');\n\n      github.rest.issues.createComment({\n        issue_number: context.issue.number,\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        body: `## Security Scan Results\\n\\n${summary}\\n\\n[View detailed results](${artifactsUrl})`\n      });\n</code></pre>"},{"location":"integration/github-actions/#enforcing-quality-gates","title":"Enforcing Quality Gates","text":"<p>To enforce quality gates in your workflow:</p> <ol> <li>Edit the workflow file</li> <li>Modify the threshold check to exit on failure:</li> </ol> <pre><code>- name: Check security threshold\n  run: |\n    # Apply threshold check\n    saf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\n    if [ $? -ne 0 ]; then\n      echo \"\u274c Security scan failed to meet threshold requirements\"\n      exit 1\n    fi\n</code></pre>"},{"location":"integration/github-actions/#security-considerations","title":"Security Considerations","text":""},{"location":"integration/github-actions/#github-secrets","title":"GitHub Secrets","text":"<p>For production use, consider storing sensitive configuration in GitHub Secrets:</p> <ol> <li>Go to repository Settings &gt; Secrets and variables &gt; Actions</li> <li>Create secrets for:</li> <li><code>KUBE_CONFIG</code>: Base64-encoded kubeconfig (for external clusters)</li> <li><code>CINC_LICENSE</code>: License acceptance for CINC Auditor (if needed)</li> </ol>"},{"location":"integration/github-actions/#rbac-best-practices","title":"RBAC Best Practices","text":"<p>The workflows demonstrate secure RBAC patterns:</p> <ol> <li>Use time-limited tokens (15 minutes)</li> <li>Clean up resources after scanning</li> <li>Only grant necessary permissions</li> <li>Use label selectors for dynamic targeting</li> </ol>"},{"location":"integration/github-actions/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/github-actions/#common-issues","title":"Common Issues","text":"<ol> <li>Minikube startup fails - Increase resource limits in the action</li> <li>Plugin installation fails - Check network connectivity or use pre-built images</li> <li>Scan access denied - Verify RBAC permissions and token validity</li> <li>SAF-CLI installation fails - Ensure Node.js is available in the runner</li> </ol>"},{"location":"integration/github-actions/#saf-cli-debugging","title":"SAF-CLI Debugging","text":"<p>If you encounter issues with SAF-CLI:</p> <pre><code># Check SAF-CLI version\nsaf --version\n\n# Run with debug flag\nsaf threshold -i scan-results.json -t 70 --debug\n\n# Validate JSON format\njq . scan-results.json &gt; /dev/null &amp;&amp; echo \"Valid JSON\" || echo \"Invalid JSON\"\n</code></pre>"},{"location":"integration/github-actions/#references","title":"References","text":"<ul> <li>CINC Auditor Documentation</li> <li>MITRE SAF-CLI Documentation</li> <li>GitHub Actions Documentation</li> <li>Minikube GitHub Action</li> <li>Kubernetes RBAC Documentation</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/gitlab-services-analysis/","title":"Analysis: GitLab CI Services for Container Scanning","text":"<p>This document provides an analysis of using GitLab CI/CD Services for enhancing our container scanning workflow.</p>"},{"location":"integration/gitlab-services-analysis/#executive-summary","title":"Executive Summary","text":"<p>GitLab CI Services provide an excellent way to improve our container scanning workflow, particularly for distroless containers. The services approach allows us to create specialized, pre-configured environments for scanning while maintaining a clean separation between the scanning tools and the CI/CD job itself.</p> <p>Recommendation: Implement GitLab CI Services for our scanning workflow to improve maintainability, consistency, and support for both standard and distroless container scanning approaches.</p>"},{"location":"integration/gitlab-services-analysis/#key-findings","title":"Key Findings","text":""},{"location":"integration/gitlab-services-analysis/#benefits","title":"Benefits","text":"<ol> <li> <p>Pre-configured Scanning Environment: Services allow us to create Docker images with CINC Auditor, the train-k8s-container plugin, and the SAF CLI pre-installed, eliminating the need to install these in each job.</p> </li> <li> <p>Support for Both Scanning Approaches: Different service containers can be created for standard and distroless container scanning, supporting both our approaches without complicating the CI/CD configuration.</p> </li> <li> <p>Improved Consistency: Every scan job uses the exact same scanning environment, reducing variability and potential issues across different runners.</p> </li> <li> <p>Reduced Setup Time: By moving the installation of dependencies to the container build process, we reduce the runtime of each job significantly.</p> </li> <li> <p>Better Isolation: Scanning tools are isolated from the CI/CD environment, reducing potential conflicts with other job dependencies.</p> </li> </ol>"},{"location":"integration/gitlab-services-analysis/#potential-challenges","title":"Potential Challenges","text":"<ol> <li> <p>Additional Complexity: Introducing services adds another layer to the CI/CD configuration, which may be challenging for users to understand initially.</p> </li> <li> <p>Docker-in-Docker Requirements: Services require either Docker socket access or Docker-in-Docker service, which may not be available in all CI/CD environments.</p> </li> <li> <p>Maintenance Overhead: Scanner service images need to be maintained and updated as dependencies change.</p> </li> </ol>"},{"location":"integration/gitlab-services-analysis/#implementation-recommendations","title":"Implementation Recommendations","text":""},{"location":"integration/gitlab-services-analysis/#1-create-specialized-service-images","title":"1. Create Specialized Service Images","text":"<p>Build and maintain two specialized Docker images:</p> <ul> <li>Standard Scanner Image: Contains CINC Auditor with the train-k8s-container plugin for scanning standard containers.</li> <li>Distroless Scanner Image: Includes the additional tooling needed for our distroless container scanning approach.</li> </ul>"},{"location":"integration/gitlab-services-analysis/#2-provide-clear-documentation","title":"2. Provide Clear Documentation","text":"<p>Create clear documentation that explains: - How services are used in the scanning workflow - When to use standard vs. distroless scanning - How to troubleshoot common issues</p>"},{"location":"integration/gitlab-services-analysis/#3-cicd-configuration-examples","title":"3. CI/CD Configuration Examples","text":"<p>Provide both basic examples for simple setups and advanced examples that leverage services for more complex scenarios.</p>"},{"location":"integration/gitlab-services-analysis/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Services add some overhead due to additional container startup</li> <li>Balance this with the time saved by not installing dependencies in each job</li> <li>Consider caching strategies for service images</li> </ul>"},{"location":"integration/gitlab-services-analysis/#comparison-with-github-actions","title":"Comparison with GitHub Actions","text":"<p>While GitHub Actions doesn't provide an exact equivalent to GitLab CI Services, similar benefits can be achieved using:</p> <ul> <li>Custom container actions</li> <li>Service containers feature</li> <li>Job containers that come pre-configured with necessary tools</li> </ul> <p>For GitHub Actions integration, we recommend a similar approach of creating specialized containers while accounting for the differences in how GitHub Actions handles services.</p>"},{"location":"integration/gitlab-services-analysis/#next-steps","title":"Next Steps","text":"<ol> <li>Build and publish the scanner service Docker images</li> <li>Update GitLab CI example templates to demonstrate services usage</li> <li>Enhance documentation to explain the services approach</li> <li>Create parallel GitHub Actions examples for cross-platform compatibility</li> </ol>"},{"location":"integration/gitlab-services-analysis/#conclusion","title":"Conclusion","text":"<p>GitLab CI Services provide a significant enhancement to our container scanning workflow without overcomplicating it. By creating specialized, pre-configured scanner images, we can improve consistency, reduce setup time, and better support both standard and distroless container scanning approaches. The benefits outweigh the additional complexity, making services an excellent choice for improving our GitLab CI integration.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/gitlab-services/","title":"GitLab CI Integration with Services","text":"<p>This document explains how to use GitLab CI/CD services with the Kubernetes CINC Secure Scanner for enhanced container scanning workflows.</p>"},{"location":"integration/gitlab-services/#overview","title":"Overview","text":"<p>GitLab CI/CD services allow you to run Docker containers alongside your CI/CD jobs. These service containers can provide additional functionality and dependencies without cluttering your main job container. For our scanning workflows, services can provide a consistent, pre-configured environment for running CINC Auditor scans.</p>"},{"location":"integration/gitlab-services/#benefits-of-using-services","title":"Benefits of Using Services","text":"<ol> <li>Pre-installed Dependencies: Service containers can have CINC Auditor, the train-k8s-container plugin, and the SAF CLI pre-installed.</li> <li>Isolation: Scanning tools are isolated from your application code and build tools.</li> <li>Consistency: Every scan job uses the exact same scanning environment.</li> <li>Specialized Containers: Different service containers can be used for different types of scans (standard vs. distroless).</li> <li>Reduced Setup Time: Eliminates the need to install dependencies in each job.</li> </ol>"},{"location":"integration/gitlab-services/#implementation","title":"Implementation","text":""},{"location":"integration/gitlab-services/#creating-scanner-service-images","title":"Creating Scanner Service Images","text":"<p>Create Docker images for your scanning services:</p>"},{"location":"integration/gitlab-services/#standard-scanner-image","title":"Standard Scanner Image","text":"<pre><code>FROM ruby:3.0-slim\n\n# Install dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl \\\n    gnupg \\\n    nodejs \\\n    npm \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install CINC Auditor\nRUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n# Install train-k8s-container plugin\nRUN cinc-auditor plugin install train-k8s-container\n\n# Install SAF CLI\nRUN npm install -g @mitre/saf\n\n# Set up a working directory\nWORKDIR /opt/scanner\n\nENTRYPOINT [\"sleep\", \"infinity\"]\n</code></pre>"},{"location":"integration/gitlab-services/#distroless-scanner-image","title":"Distroless Scanner Image","text":"<pre><code>FROM ruby:3.0-slim\n\n# Install dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl \\\n    gnupg \\\n    nodejs \\\n    npm \\\n    kubectl \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install CINC Auditor\nRUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n# Install train-k8s-container plugin\nRUN cinc-auditor plugin install train-k8s-container\n\n# Install SAF CLI\nRUN npm install -g @mitre/saf\n\n# Copy specialized scripts\nCOPY scripts/scan-distroless.sh /opt/scripts/\nRUN chmod +x /opt/scripts/scan-distroless.sh\n\n# Set up a working directory\nWORKDIR /opt/scanner\n\nENTRYPOINT [\"sleep\", \"infinity\"]\n</code></pre>"},{"location":"integration/gitlab-services/#using-scanner-services-in-gitlab-ci","title":"Using Scanner Services in GitLab CI","text":"<p>See the <code>gitlab-examples/gitlab-ci-with-services.yml</code> file in the repository for a complete implementation. Here's how to define services in your <code>.gitlab-ci.yml</code> file:</p> <pre><code># Define a global service for all jobs\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\n# Or define a service for a specific job\nrun_distroless_scan:\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    # Job commands that interact with the service\n</code></pre>"},{"location":"integration/gitlab-services/#communication-between-jobs-and-services","title":"Communication Between Jobs and Services","text":"<p>To interact with service containers:</p> <ol> <li>Docker Commands: Use <code>docker cp</code> and <code>docker exec</code> to copy files and run commands in service containers.</li> <li>File Exchange: Use temporary files to exchange data between the job and service containers.</li> <li>Container Networking: Service containers are accessible via their alias hostnames.</li> </ol>"},{"location":"integration/gitlab-services/#considerations","title":"Considerations","text":""},{"location":"integration/gitlab-services/#advantages","title":"Advantages","text":"<ul> <li>Clean separation of concerns</li> <li>Pre-built, consistent scanning environment</li> <li>Reduced pipeline setup time</li> <li>Support for both standard and distroless scanning approaches</li> </ul>"},{"location":"integration/gitlab-services/#potential-challenges","title":"Potential Challenges","text":"<ul> <li>Complexity: Adds another layer to the CI/CD configuration</li> <li>Docker-in-Docker: Requires Docker socket access or Docker-in-Docker service</li> <li>Performance: Additional overhead from running multiple containers</li> <li>Maintenance: Scanner service images need to be maintained and updated</li> </ul>"},{"location":"integration/gitlab-services/#complete-example","title":"Complete Example","text":"<p>See the <code>gitlab-examples/gitlab-ci-with-services.yml</code> file in the repository for a complete example of integrating scanner services into your GitLab CI/CD pipeline.</p>"},{"location":"integration/gitlab-services/#workflow-diagram","title":"Workflow Diagram","text":"<p>For a visual representation of how GitLab CI services integrate with the scanning workflow, see the Workflow Diagrams document.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/gitlab/","title":"GitLab CI/CD Integration","text":"<p>This guide explains how to integrate secure container scanning using CINC Auditor with the train-k8s-container plugin into GitLab CI/CD pipelines.</p> <p>Strategic Priority: We strongly recommend the Kubernetes API Approach using the train-k8s-container plugin for enterprise-grade container scanning. Our highest priority is enhancing this plugin to support distroless containers. See Approach Comparison and Security Compliance for more details.</p>"},{"location":"integration/gitlab/#overview","title":"Overview","text":"<p>The integration handles these key steps:</p> <ol> <li>Creating a container to scan in Kubernetes</li> <li>Generating dynamic, restricted access to that container</li> <li>Running CINC Auditor with the train-k8s-container transport</li> <li>Using MITRE SAF-CLI for results processing and quality gates</li> <li>Cleaning up temporary resources</li> </ol>"},{"location":"integration/gitlab/#prerequisites","title":"Prerequisites","text":""},{"location":"integration/gitlab/#gitlab-runner-setup","title":"GitLab Runner Setup","text":"<ol> <li>A GitLab Runner with access to your Kubernetes cluster</li> <li>The runner needs:</li> <li>kubectl installed</li> <li>Access to the cluster (kubeconfig)</li> <li>Permissions to create service accounts and roles</li> <li>Node.js installed (for SAF-CLI)</li> </ol>"},{"location":"integration/gitlab/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ol> <li>A namespace for the scanner infrastructure</li> <li>Permission to create and manage:</li> <li>Pods</li> <li>Service accounts</li> <li>Roles and RoleBindings</li> </ol>"},{"location":"integration/gitlab/#configuration","title":"Configuration","text":""},{"location":"integration/gitlab/#gitlab-ci-variables","title":"GitLab CI Variables","text":"<p>Set up these CI/CD variables in GitLab:</p> <ul> <li><code>KUBE_CONFIG</code>: Base64-encoded kubeconfig with permissions to manage RBAC</li> <li><code>SCANNER_NAMESPACE</code>: The namespace for scanner resources</li> <li><code>CINC_PROFILE_PATH</code>: Path to the CINC Auditor profile to run</li> <li><code>THRESHOLD_VALUE</code>: Minimum passing score (0-100) for security scans</li> </ul>"},{"location":"integration/gitlab/#gitlab-ciyml-example-with-saf-cli","title":".gitlab-ci.yml Example with SAF-CLI","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"integration/gitlab/#using-the-saf-cli-in-your-pipeline","title":"Using the SAF-CLI in Your Pipeline","text":"<p>The MITRE SAF-CLI provides powerful capabilities for security scan results:</p>"},{"location":"integration/gitlab/#installation","title":"Installation","text":"<pre><code># Install SAF-CLI\nnpm install -g @mitre/saf\n</code></pre>"},{"location":"integration/gitlab/#generate-summaries","title":"Generate Summaries","text":"<pre><code># Create a markdown summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Create a JSON summary\nsaf summary --input scan-results.json --output scan-summary.json\n</code></pre>"},{"location":"integration/gitlab/#threshold-quality-gates","title":"Threshold Quality Gates","text":"<pre><code># Check against a threshold (exits with non-zero if below threshold)\nsaf threshold -i scan-results.json -t 70\n\n# More advanced threshold options\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/gitlab/#visualization-and-reports","title":"Visualization and Reports","text":"<pre><code># Generate a standalone HTML report\nsaf view -i scan-results.json --output report.html\n</code></pre>"},{"location":"integration/gitlab/#security-enhancements","title":"Security Enhancements","text":""},{"location":"integration/gitlab/#pipeline-specific-token-durations","title":"Pipeline-Specific Token Durations","text":"<p>Adjust token durations based on scan complexity:</p> <pre><code># For simple scans\nTOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --duration=15m)\n\n# For complex scans\nTOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --duration=60m)\n</code></pre>"},{"location":"integration/gitlab/#pipeline-specific-namespaces","title":"Pipeline-Specific Namespaces","text":"<p>For stricter isolation, create a dedicated namespace per pipeline:</p> <pre><code>deploy_container:\n  script:\n    - |\n      # Create namespace with unique name\n      kubectl create namespace ${SCANNER_NAMESPACE}-${CI_PIPELINE_ID}\n\n      # Set variable for other stages\n      echo \"PIPELINE_NAMESPACE=${SCANNER_NAMESPACE}-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n\n      # Create pod in isolated namespace\n      # ...\n\ncleanup:\n  script:\n    - |\n      # Delete entire namespace\n      kubectl delete namespace ${PIPELINE_NAMESPACE}\n</code></pre>"},{"location":"integration/gitlab/#implementing-quality-gates","title":"Implementing Quality Gates","text":"<p>You can configure the pipeline to fail based on scan results:</p> <pre><code>run_scan:\n  script:\n    # ... run scan ...\n\n    # Threshold check\n    saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n    THRESHOLD_RESULT=$?\n\n    # Fail the pipeline if below threshold\n    exit ${THRESHOLD_RESULT}\n</code></pre> <p>For more advanced quality gates:</p> <pre><code># Zero critical failures, at most 2 high failures, overall score of 70%\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/gitlab/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/gitlab/#common-issues","title":"Common Issues","text":"<ol> <li>SAF-CLI installation fails: Make sure Node.js is installed correctly on your runner</li> <li>Token expiration: If scans take longer than expected, increase the token duration</li> <li>Threshold failures: Adjust threshold values or temporarily disable enforcement during initial implementation</li> </ol>"},{"location":"integration/gitlab/#debugging","title":"Debugging","text":"<p>Add these steps to your pipeline for better visibility:</p> <pre><code># Display SAF-CLI version\nsaf --version\n\n# Debug specific controls that are failing\njq '.profiles[0].controls[] | select(.status==\"failed\") | {id, title, status}' scan-results.json\n\n# Examine compliance score\njq '.profiles[0].statistics.percent_passed' scan-results.json\n</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/overview/","title":"CI/CD Integration Overview","text":"<p>This document provides a comprehensive overview of the CI/CD integration options available for the CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"integration/overview/#introduction","title":"Introduction","text":"<p>Integrating our container scanning capabilities into CI/CD pipelines is a critical part of implementing a secure software delivery lifecycle. This document outlines the approaches we support across different CI/CD platforms and provides guidance on selecting the right approach for your environment.</p>"},{"location":"integration/overview/#supported-cicd-platforms","title":"Supported CI/CD Platforms","text":"<p>We provide detailed integration guides and examples for the following CI/CD platforms:</p> <ol> <li>GitHub Actions: Using GitHub's built-in automation platform</li> <li>GitLab CI/CD: Native integration with GitLab's CI/CD system</li> <li>GitLab CI/CD with Services: Enhanced integration leveraging GitLab's services feature</li> </ol> <p>Each platform has its own strengths and implementation details, but they all follow our core security principles and scanning approaches. See the Approach Mapping document for a comprehensive guide to which CI/CD examples support each scanning approach.</p>"},{"location":"integration/overview/#common-integration-patterns","title":"Common Integration Patterns","text":"<p>Regardless of the CI/CD platform, our integration solutions implement these key patterns:</p>"},{"location":"integration/overview/#1-secure-rbac-model","title":"1. Secure RBAC Model","text":"<p>All integrations use our least-privilege RBAC model:</p> <ul> <li>Time-limited tokens (typically 15-30 minutes)</li> <li>Precisely scoped permissions for specific containers</li> <li>Clean-up of resources after scanning</li> <li>Optional label-based pod selection</li> </ul>"},{"location":"integration/overview/#2-scanning-approaches","title":"2. Scanning Approaches","text":"<p>We support all three scanning approaches in our CI/CD integrations:</p> Approach CI/CD Support Best For Kubernetes API Approach All platforms Standard containers in production environments Debug Container Approach All platforms Distroless containers when pod modification is acceptable Sidecar Container Approach All platforms Universal scanning with minimal privileges <p>Note: Distroless container support for the Kubernetes API Approach is currently in progress and will become our recommended approach for all container types.</p>"},{"location":"integration/overview/#3-saf-cli-integration","title":"3. SAF-CLI Integration","text":"<p>All CI/CD examples include integration with MITRE's SAF-CLI for:</p> <ul> <li>Results processing and formatting</li> <li>Threshold-based quality gates</li> <li>Report generation</li> </ul>"},{"location":"integration/overview/#4-environment-deployment-options","title":"4. Environment Deployment Options","text":"<p>Our CI/CD examples work with:</p> <ul> <li>Minikube test clusters</li> <li>Existing Kubernetes clusters</li> <li>Cloud provider managed services (EKS, GKE, AKS)</li> </ul>"},{"location":"integration/overview/#choosing-the-right-integration","title":"Choosing the Right Integration","text":"<p>Consider these factors when selecting a CI/CD integration approach:</p> <ol> <li>CI/CD Platform: Select the guide matching your platform (GitHub Actions or GitLab CI)</li> <li>Container Type: Standard containers use the Kubernetes API Approach; distroless containers currently require the Debug Container Approach or Sidecar Container Approach</li> <li>Environment: Development environments may use minikube, while production pipelines would connect to existing clusters</li> <li>Security Requirements: Use label-based RBAC for enhanced security in multi-tenant environments</li> </ol> <p>For detailed mapping of CI/CD examples to specific scanning approaches, see our Approach Mapping document.</p>"},{"location":"integration/overview/#cross-references","title":"Cross-References","text":"<ul> <li>Helm Chart Deployment: Understand the Helm chart architecture that supports CI/CD deployments</li> <li>Security Analysis: Review security considerations for CI/CD integration</li> <li>RBAC Model: Learn about the RBAC model underpinning our secure CI/CD approach</li> <li>SAF CLI Integration: Understand how SAF-CLI enhances CI/CD workflows</li> </ul>"},{"location":"integration/overview/#examples","title":"Examples","text":"<p>The repository includes ready-to-use examples for all supported platforms:</p> <ul> <li>GitHub Actions: See the <code>github-workflows/</code> directory</li> <li>GitLab CI: See the <code>gitlab-examples/</code> directory</li> </ul> <p>These examples can be directly integrated into your repositories with minimal configuration changes.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/approach-comparison/","title":"Scanning Approach Comparison","text":"<p>This document provides a comprehensive comparison of the three container scanning approaches implemented in this project. This analysis will help you select the most appropriate approach based on your specific environment, requirements, and constraints.</p>"},{"location":"overview/approach-comparison/#approach-overview","title":"Approach Overview","text":"Approach Description Best For Kubernetes API Approach Uses the train-k8s-container plugin to directly interact with containers through the Kubernetes API Enterprise production environments, security/compliance-focused organizations, CI/CD pipelines at scale Debug Container Approach Attaches ephemeral debug containers to pods with distroless containers Interim solution for distroless containers when ephemeral containers are supported Sidecar Container Approach Deploys scanner containers alongside target containers with shared process namespace Interim solution for distroless containers with minimal Kubernetes version requirements"},{"location":"overview/approach-comparison/#feature-comparison-matrix","title":"Feature Comparison Matrix","text":"Feature Kubernetes API Approach Debug Container Approach Sidecar Container Approach Kubernetes Compatibility Any version 1.16+ (requires ephemeral containers) Any version Works with existing pods \u2705 Yes \u2705 Yes \u274c No (requires pod modification) Standard container support \u2705 Best approach \u2705 Supported \u2705 Supported Distroless container support \ud83d\udd04 In progress \u2705 Best interim approach \u2705 Supported No pod modification required \u2705 Yes \u274c No \u274c No Minimal privileges \u2705 Yes \u274c No \u2705 Yes Implementation complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium User experience \ud83d\udfe2 Seamless \ud83d\udfe0 Complex \ud83d\udfe0 Medium Security footprint \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Runtime dependencies kubectl, inspec kubectl, ephemeral containers kubectl, pod access CI/CD integration ease \ud83d\udfe2 Simple \ud83d\udfe0 Complex \ud83d\udfe0 Medium Development status \ud83d\udd04 In progress (for distroless) \u2705 Complete \u2705 Complete GitHub Actions support \u2705 Yes \u2705 Yes \u2705 Yes GitLab CI support \u2705 Yes \u2705 Yes \u2705 Yes GitLab Services support \u2705 Yes \u2705 Yes \u2705 Yes"},{"location":"overview/approach-comparison/#technical-requirements","title":"Technical Requirements","text":""},{"location":"overview/approach-comparison/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Standard Kubernetes cluster (any version)</li> <li>RBAC permissions to execute commands in target containers</li> <li>For distroless containers: Enhanced plugin capabilities (in development)</li> </ul>"},{"location":"overview/approach-comparison/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Kubernetes 1.16+ with ephemeral containers feature enabled</li> <li>Permissions to create debug containers</li> <li>Privileges to access target container filesystem</li> </ul>"},{"location":"overview/approach-comparison/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Standard Kubernetes cluster (any version)</li> <li>Ability to modify pod definitions to enable shared process namespace</li> <li>Permissions to create pods with sidecar containers</li> </ul>"},{"location":"overview/approach-comparison/#recommended-usage-scenarios","title":"Recommended Usage Scenarios","text":""},{"location":"overview/approach-comparison/#enterprise-production-environments","title":"Enterprise Production Environments","text":"<p>Recommended Approach: Kubernetes API Approach</p> <ul> <li>Lowest security risk profile</li> <li>Simplest implementation with minimal overhead</li> <li>Most transparent to end users</li> <li>Minimal permissions required in production clusters</li> <li>Best for multi-team environments</li> </ul>"},{"location":"overview/approach-comparison/#distroless-containers-interim","title":"Distroless Containers (Interim)","text":"<p>Recommended Approach: Debug Container or Sidecar Container Approach</p> <ul> <li>If on Kubernetes 1.16+: Debug Container Approach</li> <li>If needing universal compatibility: Sidecar Container Approach</li> <li>Long-term: Plan for migration to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"overview/approach-comparison/#local-development-and-testing","title":"Local Development and Testing","text":"<p>Recommended Approach: Any approach depending on container types</p> <ul> <li>For standard containers: Kubernetes API Approach is simplest</li> <li>For mixed container types: Sidecar Container Approach is most flexible</li> </ul>"},{"location":"overview/approach-comparison/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>Recommended Approach: Any approach, depending on container types</p> <ul> <li>All approaches work well with CI/CD pipelines</li> <li>For standard containers, Kubernetes API Approach is preferred</li> <li>For distroless containers, choose based on environment capabilities</li> </ul>"},{"location":"overview/approach-comparison/#migration-paths","title":"Migration Paths","text":""},{"location":"overview/approach-comparison/#to-kubernetes-api-approach-recommended","title":"To Kubernetes API Approach (Recommended)","text":"<ul> <li>For standard containers: Immediate adoption</li> <li>For distroless containers: Plan adoption as enhanced distroless support is completed</li> <li>Maintain same commands and workflows for consistent user experience</li> </ul>"},{"location":"overview/approach-comparison/#between-approaches","title":"Between Approaches","text":"<ul> <li>Debug Container to Sidecar: Modify pod definitions to enable shared process</li> <li>Sidecar to Debug Container: Ensure cluster supports ephemeral containers</li> <li>Either to Kubernetes API: Wait for distroless support completion</li> </ul>"},{"location":"overview/approach-comparison/#enterprise-adoption-strategy","title":"Enterprise Adoption Strategy","text":"<p>For enterprise environments implementing container scanning at scale:</p> <ol> <li>Phase 1: Standard Containers</li> <li>Implement Kubernetes API Approach for all standard containers</li> <li> <p>Document and train teams on standardized workflow</p> </li> <li> <p>Phase 2: Distroless Containers (Interim)</p> </li> <li>Implement appropriate fallback based on environment</li> <li> <p>Document temporary approach and plan for migration</p> </li> <li> <p>Phase 3: Complete Migration</p> </li> <li>Migrate all scanning to Kubernetes API Approach once distroless support is complete</li> <li>Standardize on universal approach for all container types</li> </ol>"},{"location":"overview/approach-comparison/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kubernetes API Approach Documentation</li> <li>Debug Container Approach Documentation</li> <li>Sidecar Container Approach Documentation</li> <li>Approach Decision Matrix</li> <li>Security Risk Analysis</li> <li>Enterprise Integration Analysis</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/approach-decision-matrix/","title":"Container Scanning Approach Decision Matrix","text":"<p>This decision matrix provides a comprehensive comparison of the three container scanning approaches available in this project. Use this guide to select the most appropriate approach based on your specific requirements and environment constraints.</p>"},{"location":"overview/approach-decision-matrix/#quick-selection-guide","title":"Quick Selection Guide","text":"If you need... Recommended Approach Enterprise-ready, scalable solution Kubernetes API Approach Simplest implementation for standard containers Kubernetes API Approach Compliance with security standards Kubernetes API Approach CI/CD pipeline for enterprise scale Kubernetes API Approach Minimal cluster permissions Kubernetes API Approach Distroless support (interim) with K8s 1.16+ Debug Container Approach Distroless support (interim) with any K8s version Sidecar Container Approach Universal solution for all container types Kubernetes API Approach (once distroless support is complete)"},{"location":"overview/approach-decision-matrix/#comprehensive-comparison-matrix","title":"Comprehensive Comparison Matrix","text":"Factor Kubernetes API Approach Debug Container Sidecar Container Compatibility Standard containers \u2705 Full support \u2705 Full support \u2705 Full support Distroless containers \ud83d\udd36 In development \u2705 Full support \u2705 Full support Kubernetes version requirement Any version 1.16+ (ephemeral containers) Any version Implementation Implementation complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium CI/CD integration effort \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Maintenance burden \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Setup complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Security Overall security risk \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 Medium-High Required permissions \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Isolation level \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udd34 Lower Attack surface \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Operational Scan speed \ud83d\udfe2 Fast \ud83d\udfe0 Medium \ud83d\udfe2 Fast Resource overhead \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Intrusiveness \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 Higher Runtime dependencies kubectl, inspec kubectl, ephemeral containers kubectl, pod access Enterprise Factors Multi-team adoption \ud83d\udfe2 Easy \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Learning curve \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Documentation effort \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Monitoring/observability \ud83d\udfe2 Standard logs \ud83d\udfe0 Multiple components \ud83d\udfe0 Multiple components Long-term enterprise viability \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udfe0 Medium"},{"location":"overview/approach-decision-matrix/#detailed-analysis-by-use-case","title":"Detailed Analysis by Use Case","text":""},{"location":"overview/approach-decision-matrix/#use-case-1-enterprise-environments","title":"Use Case 1: Enterprise Environments","text":"<p>Best Approach: Kubernetes API Approach</p> <p>Rationale: - Designed for enterprise scalability and adoption - Simplest implementation with minimal overhead - Works well with standard containers and future distroless support - Lowest security risk profile - Most transparent to end users - Same commands for both standard and distroless containers (with future enhancement) - Minimal permissions required in production clusters - Best for multi-team environments</p>"},{"location":"overview/approach-decision-matrix/#use-case-2-production-with-mixed-container-types","title":"Use Case 2: Production with Mixed Container Types","text":"<p>Best Approach: Kubernetes API Approach with Sidecar Container fallback</p> <p>Rationale: - Kubernetes API Approach offers best enterprise integration  - For current distroless containers, Sidecar Container Approach offers:   - Universal compatibility with all container types   - Works regardless of Kubernetes version   - Can be implemented with automated sidecar injection - Long-term plan should be migrating to Kubernetes API Approach as distroless support matures</p>"},{"location":"overview/approach-decision-matrix/#use-case-3-advanced-kubernetes-environment-116","title":"Use Case 3: Advanced Kubernetes Environment (1.16+)","text":"<p>Best Approach: Kubernetes API Approach with Debug Container fallback</p> <p>Rationale: - Kubernetes API Approach is the recommended long-term solution - For current distroless containers, Debug Container Approach offers:   - Native Kubernetes ephemeral containers feature   - More isolated than sidecar approach   - Debug containers are ephemeral (removed after scan)   - Good balance of security and capabilities</p>"},{"location":"overview/approach-decision-matrix/#use-case-4-highly-secure-zero-trust-environment","title":"Use Case 4: Highly Secure / Zero-Trust Environment","text":"<p>Best Approach: Kubernetes API Approach (with fallback to Debug Container)</p> <p>Rationale: - Kubernetes API Approach has the lowest risk profile - Minimal permissions required - Minimal attack surface - If distroless containers are required, use Debug Container approach with strict controls until Kubernetes API Approach supports distroless</p>"},{"location":"overview/approach-decision-matrix/#use-case-5-cicd-pipeline-integration","title":"Use Case 5: CI/CD Pipeline Integration","text":"<p>Best Approach: Kubernetes API Approach (with appropriate interim solution for distroless containers)</p> <p>Rationale: - While all approaches are technically possible in CI/CD pipelines, the Kubernetes API Approach offers critical advantages:   - Compliance: Fully aligned with security standards and compliance frameworks as detailed in Security Compliance Analysis   - Scale: Significantly lower resource overhead and faster execution for high-volume scanning (hundreds to thousands of containers)   - Consistency: Same workflow, commands, and permissions model regardless of environment   - Enterprise adoption: Simplifies cross-team standardization and governance   - Security posture: Minimizes attack surface and privilege requirements in CI/CD environments - For distroless containers in CI/CD:   - Use the appropriate interim solution based on cluster capabilities   - Plan migration path to Kubernetes API Approach as distroless support is completed   - Document compliance deviations if using alternative approaches - While alternative approaches may work in isolated CI/CD use cases, they are not recommended for enterprise-scale implementations</p>"},{"location":"overview/approach-decision-matrix/#implementation-decision-tree","title":"Implementation Decision Tree","text":"<ol> <li>Is enterprise scalability your primary concern?</li> <li>Yes: Use Kubernetes API Approach (with appropriate fallback for distroless containers until fully supported)</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Are you scanning standard containers with shell access?</p> </li> <li>Yes: Use Kubernetes API Approach</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Are you on Kubernetes 1.16+ with ephemeral containers enabled?</p> </li> <li>Yes: Use Debug Container Approach (until Kubernetes API Approach supports distroless)</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Can you modify pod definitions to add shareProcessNamespace?</p> </li> <li>Yes: Use Sidecar Container Approach</li> <li> <p>No: Consider cluster upgrade to enable ephemeral containers</p> </li> <li> <p>Is security your primary concern?</p> </li> <li>Yes: Use Kubernetes API Approach where possible, with strict controls on any alternate approach</li> <li>No: Choose based on compatibility and operational factors</li> </ol>"},{"location":"overview/approach-decision-matrix/#migration-paths","title":"Migration Paths","text":""},{"location":"overview/approach-decision-matrix/#to-kubernetes-api-approach-enterprise-recommended","title":"To Kubernetes API Approach (Enterprise Recommended)","text":"<ul> <li>For standard containers: Immediate adoption</li> <li>For distroless containers: Plan adoption as enhanced distroless support is completed</li> <li>Maintain same commands and workflows across all container types for seamless user experience</li> </ul>"},{"location":"overview/approach-decision-matrix/#from-kubernetes-api-to-debug-container-for-distroless-containers","title":"From Kubernetes API to Debug Container (for distroless containers)","text":"<ul> <li>Implement ephemeral container support in cluster</li> <li>Add debug container configuration</li> <li>Modify scan scripts to use debug container method</li> <li>Plan migration back to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"overview/approach-decision-matrix/#from-kubernetes-api-to-sidecar-container-for-distroless-containers","title":"From Kubernetes API to Sidecar Container (for distroless containers)","text":"<ul> <li>Modify pod definitions to enable shareProcessNamespace</li> <li>Add sidecar container configuration</li> <li>Configure process detection and filesystem access</li> <li>Plan migration back to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"overview/approach-decision-matrix/#from-debug-container-to-sidecar-container","title":"From Debug Container to Sidecar Container","text":"<ul> <li>Modify pod definitions to enable shareProcessNamespace</li> <li>Configure sidecar deployment approach</li> <li>No cluster version dependencies</li> </ul>"},{"location":"overview/approach-decision-matrix/#enterprise-adoption-strategy","title":"Enterprise Adoption Strategy","text":"<p>For enterprise environments planning to adopt container scanning at scale, we recommend:</p> <ol> <li>Phase 1: Standard Containers</li> <li>Implement Kubernetes API Approach for all standard containers</li> <li> <p>Document and train teams on the standardized approach</p> </li> <li> <p>Phase 2: Distroless Containers (Interim)</p> </li> <li>Implement appropriate fallback method based on environment:<ul> <li>Debug Container Approach (if ephemeral containers are supported)</li> <li>Sidecar Container Approach (for universal compatibility)</li> </ul> </li> <li> <p>Document temporary approach and plan for future migration</p> </li> <li> <p>Phase 3: Complete Migration to Universal Solution</p> </li> <li>Migrate all scanning to Kubernetes API Approach once distroless support is complete</li> <li>Standardize on a single, universal approach for all container types</li> <li>Maintain simplified user experience with consistent commands</li> <li>Eliminate the need for multiple approaches or special handling for different container types</li> </ol>"},{"location":"overview/approach-decision-matrix/#conclusion","title":"Conclusion","text":"<p>After comprehensive analysis of security compliance, enterprise scalability, operational efficiency, and implementation complexity, the Kubernetes API Approach emerges as the clear superior solution for container scanning in production environments.</p> <p>Our recommendation is based on thorough evaluation against: - Security compliance frameworks (DoD 8500.01, DISA Container Platform SRG, Kubernetes STIG, CIS Benchmarks) - Enterprise-scale operational requirements (supporting hundreds to thousands of container scans) - Resource efficiency and performance considerations - CI/CD integration capabilities - Maintainability and adoption across teams</p> <p>For enterprise deployments, the Kubernetes API Approach is not just preferred but strongly recommended as the only approach that fully satisfies enterprise security, compliance, and scale requirements. The alternative approaches, while technically functional, introduce significant compliance challenges, security considerations, and operational complexities that make them unsuitable for enterprise-scale production use.</p> <p>Strategic Direction: 1. Implement Kubernetes API Approach for standard containers immediately 2. Use appropriate interim solutions for distroless containers with proper risk documentation 3. Prioritize completing Kubernetes API Approach support for distroless containers 4. Migrate all scanning to the unified Kubernetes API Approach when complete</p> <p>This strategy provides the most secure, compliant, and scalable path forward for enterprise container security.</p> <p>For detailed implementation guidance, refer to the specific documentation: - Kubernetes API Approach - Debug Container Approach (interim distroless solution) - Sidecar Container Approach (interim distroless solution)</p> <p>For comprehensive security analysis, see: - Security Compliance Analysis - Security Risk Analysis - Enterprise Integration Analysis</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/ascii-diagrams/","title":"ASCII Text-Based Workflow and Architecture Diagrams","text":"<p>This document provides ASCII text-based diagrams for the key workflows and architectures in our project. These diagrams are intended to complement the Mermaid diagrams and provide a more accessible alternative that can be viewed directly in a terminal or without rendering.</p>"},{"location":"overview/ascii-diagrams/#minikube-architecture","title":"Minikube Architecture","text":"<pre><code>+-----------------------------------------------------------------------+\n|                                                                       |\n|                          MINIKUBE CLUSTER                             |\n|                                                                       |\n|  +-------------------------+        +-------------------------+        |\n|  |                         |        |                         |        |\n|  |      CONTROL NODE       |        |      WORKER NODE 1      |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |  kube-apiserver   |  |        |  | Target Containers |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |       etcd        |  |        |  |   Scanner Pods    |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  +-------------------------+        +-------------------------+        |\n|                                                                       |\n|                                                                       |\n|                           +-------------------------+                  |\n|                           |                         |                  |\n|                           |      WORKER NODE 2      |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |  Debug Containers |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |   Sidecar Pods    |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           +-------------------------+                  |\n|                                                                       |\n+-----------------------------------------------------------------------+\n                        |                |                |\n                        |                |                |\n                        v                v                v\n          +------------------+  +------------------+  +------------------+\n          |                  |  |                  |  |                  |\n          |   CINC Profiles  |  | Service Accounts |  |     SAF CLI      |\n          |   (Compliance    |  |    and RBAC      |  |  (Reporting &amp;    |\n          |    Controls)     |  |  (Access Control)|  |  Thresholds)     |\n          |                  |  |                  |  |                  |\n          +------------------+  +------------------+  +------------------+\n</code></pre>"},{"location":"overview/ascii-diagrams/#standard-container-scanning-workflow-approach-1","title":"Standard Container Scanning Workflow (Approach 1)","text":"<pre><code>              START STANDARD CONTAINER SCANNING\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|              STEP 1: SETUP &amp; PREPARATION                 |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |     Identify     |---------&gt;|  Create RBAC and   |    |\n|  |     Target       |          |  Service Account   |    |\n|  |     Container    |          |                    |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Generate Short-lived         |\n|                      |       Security Token               |\n|                      |                                    |\n|                      +------------------------------------+\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Create Restricted            |\n|                      |       Kubeconfig File              |\n|                      |                                    |\n|                      +------------------------------------+\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|                STEP 2: SCANNING EXECUTION                |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Run CINC      |          |    Process with    |    |\n|  |    Auditor with  |&lt;---------|    SAF CLI &amp;       |    |\n|  |    k8s-container |          |    Check Threshold |    |\n|  |    Transport     |          |                    |    |\n|  +------------------+          +--------------------+    |\n|          |                                              |\n|          v                                              |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Generate      |---------&gt;|    Clean up RBAC   |    |\n|  |    Reports and   |          |    &amp; Service       |    |\n|  |    Validations   |          |    Account         |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n                       SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#distroless-container-debug-container-approach-approach-2","title":"Distroless Container - Debug Container Approach (Approach 2)","text":"<pre><code>         START DEBUG CONTAINER APPROACH FOR DISTROLESS CONTAINERS\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 1: ATTACH DEBUG CONTAINER                    |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Identify        |-------&gt;|  Create Ephemeral       |     |\n|  |    Distroless      |        |  Debug Container with   |     |\n|  |    Target Container|        |  kubectl debug command  |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Deploy CINC Auditor in       |     |\n|                       |     Ephemeral Debug Container    |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER  |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Chroot to       |-------&gt;|  Run CINC Auditor       |     |\n|  |    Target Container|        |  Against Target         |     |\n|  |    Filesystem      |        |  Container Root         |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Export Scan Results to       |     |\n|                       |     Host System                  |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Process Results |-------&gt;|  Terminate Debug        |     |\n|  |    with SAF CLI    |        |  Container &amp; Clean Up   |     |\n|  |    Threshold Check |        |  Resources              |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#sidecar-container-approach-approach-3","title":"Sidecar Container Approach (Approach 3)","text":""},{"location":"overview/ascii-diagrams/#ascii-diagram-legacy","title":"ASCII Diagram (Legacy)","text":"<pre><code>            START SIDECAR CONTAINER APPROACH FOR SCANNING\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 1: DEPLOY POD WITH SIDECAR                  |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Deploy Target    |------&gt;|   Deploy Scanner       |       |\n|  |   Container in     |       |   Sidecar Container    |       |\n|  |   Kubernetes Pod   |       |   in Same Pod          |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Enable Shared Process Namespace      ||\n|                      |   Between Containers in Pod            ||\n|                      |   (shareProcessNamespace: true)        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 2: PERFORM SCAN USING SIDECAR               |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Sidecar Finds    |------&gt;|   Access Target        |       |\n|  |   Target Process   |       |   Filesystem via       |       |\n|  |   Using 'ps'       |       |   /proc/PID/root       |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Run CINC Auditor Against             ||\n|                      |   Target Container's Filesystem        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                          |                     |\n|                                          v                     |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Store Results    |------&gt;|   Process Results with |       |\n|  |   in Shared        |       |   SAF CLI &amp; Validate   |       |\n|  |   Volume           |       |   Against Threshold    |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Retrieve Results from Sidecar        ||\n|                      |   via kubectl cp or Volume Mount       ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#mermaid-diagram-wcag-compliant","title":"Mermaid Diagram (WCAG Compliant)","text":"<pre><code>flowchart TD\n    start([Start]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        deploy_target[\"Deploy Target Container in Kubernetes Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container in Same Pod\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace Between Containers\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        find_process[\"Sidecar Finds Target Process Using 'ps'\"] --&gt; access_fs[\"Access Target Filesystem via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target Container's Filesystem\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI &amp; Validate Against Threshold\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar via kubectl cp or Volume Mount\"]\n    end\n\n    step2 --&gt; complete([Scan Complete])\n\n    %% Applying WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step grouping styling\n    style step1 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000\n    style step2 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000</code></pre>"},{"location":"overview/ascii-diagrams/#modified-transport-plugin-approach-approach-1-enterprise","title":"Modified Transport Plugin Approach (Approach 1 - Enterprise)","text":"<pre><code>            START MODIFIED TRANSPORT PLUGIN APPROACH\n                            |\n                            v\n+------------------------------------------------------------+\n|                                                            |\n|          STEP 1: CONTAINER DETECTION AND SETUP             |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Target         |-------&gt;|  Modified            |       |\n|  |  Container      |        |  train-k8s-container |       |\n|  |  Identification |        |  Plugin (Enhanced)   |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                       |                    |\n|                                       v                    |\n|                    +----------------------------------+    |\n|                    |                                  |    |\n|                    |  Auto-Detect if Container        |    |\n|                    |  is Distroless (No Shell)        |    |\n|                    |                                  |    |\n|                    +----------------------------------+    |\n|                             /           \\                  |\n|                            /             \\                 |\n|                           v               v                |\n| +-------------------------+   +---------------------------+|\n| |                         |   |                           ||\n| |  If Regular Container:  |   |  If Distroless Container: ||\n| |  Use Standard Direct    |   |  Automatically Use Debug  ||\n| |  Exec Connection        |   |  Container Fallback       ||\n| |                         |   |                           ||\n| +-------------------------+   +---------------------------+|\n|          |                                   |             |\n|          |                                   v             |\n|          |                    +---------------------------+|\n|          |                    |                           ||\n|          |                    |  Create Temporary Debug   ||\n|          |                    |  Container Automatically  ||\n|          |                    |                           ||\n|          |                    +---------------------------+|\n|          |                                   |             |\n+------------------------------------------------------------+\n                   |                          |\n                   v                          v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 2: SCANNING EXECUTION                    |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Run CINC       |        |  Process Results     |       |\n|  |  Auditor Scan   |-------&gt;|  with SAF CLI &amp;      |       |\n|  |  Transparently  |        |  Check Thresholds    |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 3: CLEANUP (FOR DISTROLESS)              |\n|                                                            |\n|                    +---------------------------+           |\n|                    |                           |           |\n|                    |  If Debug Container Used: |           |\n|                    |  Terminate and Clean Up   |           |\n|                    |  Resources                |           |\n|                    |                           |           |\n|                    +---------------------------+           |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n                          SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#gitlab-ci-pipeline-with-services","title":"GitLab CI Pipeline with Services","text":"<pre><code>                    GITLAB CI PIPELINE WITH SERVICES\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: PIPELINE SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Start CINC Auditor  |        |\n|  |  Pipeline Begins  |         |  Scanner as a        |        |\n|  |                   |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Deploy Target Container in        |    |\n|                      |  Kubernetes Cluster                |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SECURITY SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Create RBAC &amp;    |--------&gt;|  Generate Short-lived|        |\n|  |  Service Account  |         |  Security Token      |        |\n|  |  in Cluster       |         |                      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Create Restricted kubeconfig      |    |\n|                      |  with Minimal Permissions          |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: SCANNING &amp; REPORTING               |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Execute Scan     |--------&gt;|  Process Results     |        |\n|  |  in Service       |         |  with SAF CLI in     |        |\n|  |  Container        |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Copy Results from Service         |    |\n|                      |  to Pipeline &amp; Generate Reports    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Clean Up Resources in Kubernetes  |    |\n|                      |  (Pods, Service Accounts, RBAC)    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#gitlab-ci-sidecar-approach","title":"GitLab CI Sidecar Approach","text":"<pre><code>                    GITLAB CI SIDECAR APPROACH\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: DEPLOYMENT                         |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Deploy Pod with    |        |\n|  |  Pipeline Begins  |         |  Target Container   |        |\n|  |                   |         |  and Scanner Sidecar|        |\n|  |                   |         |  in Same Pod        |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Enable Shared Process Namespace   |    |\n|                      |  Between Target and Scanner        |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SCANNING                           |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Sidecar Scanner  |--------&gt;|  Scan Target via    |        |\n|  |  Container Starts |         |  /proc Filesystem   |        |\n|  |                   |         |  Access Method      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Store Results in Shared Volume   |    |\n|                      |  and Process with SAF CLI         |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: RESULTS PROCESSING                 |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Retrieve Scan    |--------&gt;|  Process Results    |        |\n|  |  Results from     |         |  and Generate       |        |\n|  |  Sidecar Container|         |  Reports            |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Upload Results as Pipeline       |    |\n|                      |  Artifacts &amp; Clean Up Resources   |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>                   GITHUB ACTIONS WORKFLOW\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster (Kind)         |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Install CINC Auditor &amp;              |    |\n|                    | train-k8s-container Plugin          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: TARGET DEPLOYMENT                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Target    |-------&gt;| Create RBAC &amp;          |        |\n| | Container in     |        | Service Account        |        |\n| | Kubernetes       |        | for Scanner            |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Short-lived Token &amp;        |    |\n|                    | Create Restricted kubeconfig       |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: SCAN &amp; REPORT                       |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Run CINC Auditor |-------&gt;| Process Results with   |        |\n| | Against Target   |        | SAF CLI &amp; Threshold    |        |\n| | Container        |        | Validation             |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Reports, Upload as         |    |\n|                    | GitHub Artifacts &amp; Clean Up         |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#github-actions-sidecar-approach","title":"GitHub Actions Sidecar Approach","text":"<pre><code>                GITHUB ACTIONS SIDECAR APPROACH\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster using Kind     |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Build Scanner Container Image      |    |\n|                    | with CINC Auditor &amp; SAF CLI        |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: DEPLOYMENT &amp; SCANNING               |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Pod with  |-------&gt;| Configure Shared       |        |\n| | Target Container |        | Process Namespace      |        |\n| | and Scanner      |        | Between Containers     |        |\n| | Sidecar          |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Scanner Sidecar Automatically       |    |\n|                    | Finds &amp; Scans Target Container     |    |\n|                    | via /proc/PID/root Access          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: RESULTS PROCESSING                  |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Wait for Scan    |-------&gt;| Retrieve Results       |        |\n| | Completion       |        | from Sidecar Container |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Process Results  |-------&gt;| Upload Results         |        |\n| | with SAF CLI &amp;   |        | as GitHub Artifacts    |        |\n| | Generate Reports |        | &amp; Clean Up Resources   |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#end-to-end-security-architecture","title":"End-to-End Security Architecture","text":"<pre><code>                   SECURITY ARCHITECTURE\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                SECURITY PRINCIPLES                   |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Principle of   |-----&gt;|   Short-lived    |      |\n|  |   Least          |      |   Token          |      |\n|  |   Privilege      |      |   Generation     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Namespace      |&lt;----&gt;|   No Permanent   |      |\n|  |   Isolation      |      |   Elevated       |      |\n|  |                  |      |   Privileges     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|               IMPLEMENTATION CONTROLS                |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  | Resource-specific|&lt;----&gt;|   Security       |      |\n|  | RBAC Controls    |      |   First Design   |      |\n|  | (Pod-specific)   |      |                  |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Audit Trail    |&lt;----&gt;|   Automatic      |      |\n|  |   of Scan        |      |   Cleanup After  |      |\n|  |   Access         |      |   Scan Completion|      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                COMPLIANCE VALIDATION                 |\n|                                                      |\n|  +--------------------------------------------------+|\n|  |                                                  ||\n|  |            Threshold-based Compliance            ||\n|  |            Validation with SAF CLI               ||\n|  |                                                  ||\n|  |       * Minimum compliance percentage            ||\n|  |       * Maximum critical/high failures           ||\n|  |       * Enforced in CI/CD pipelines              ||\n|  |                                                  ||\n|  +--------------------------------------------------+|\n|                                                      |\n+------------------------------------------------------+\n</code></pre>"},{"location":"overview/ascii-diagrams/#comparison-of-approaches","title":"Comparison of Approaches","text":"<pre><code>+---------------------------------------------------------------------+\n|                                                                     |\n|                        APPROACH COMPARISON                          |\n|                                                                     |\n+---------------------------------------------------------------------+\n|                                                                     |\n|                        KEY CHARACTERISTICS                          |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Works with all      |                |             |                |\n| Kubernetes versions |      No        |     No      |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| Works with          |                |             |                |\n| existing pods       |      Yes       |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| User experience     |    Seamless    |   Complex   |    Medium      |\n| complexity          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Implementation      |    Complex     |   Medium    |    Simple      |\n| difficulty          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                      TECHNICAL REQUIREMENTS                         |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Special K8s         |                |             |                |\n| features needed     |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Ephemeral container |                |             |                |\n| support required    |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Can scan distroless |                |             |                |\n| containers          |      Yes       |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| CI/CD               |                |             |                |\n| integration ease    |    Simple      |   Complex   |    Medium      |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                           IMPLEMENTATION STATUS                     |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Development         | In Progress    | Complete    | Complete       |\n| status              |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Security            |                |             |                |\n| footprint           |    Medium      |   High      |    Medium      |\n+---------------------+----------------+-------------+----------------+\n| Recommended         | Enterprise     | Advanced    | Universal      |\n| usage               | environments   | users       | compatibility  |\n+---------------------+----------------+-------------+----------------+\n| GitHub Actions      |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| GitLab CI           |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/ascii-to-mermaid/","title":"ASCII to Mermaid Diagram Conversion","text":"<p>This document demonstrates the conversion of ASCII diagrams to Mermaid diagrams for better visualization in the documentation.</p>"},{"location":"overview/ascii-to-mermaid/#example-1-basic-workflow","title":"Example 1: Basic Workflow","text":""},{"location":"overview/ascii-to-mermaid/#original-ascii-diagram","title":"Original ASCII Diagram","text":"<pre><code>+--------+     +---------------+     +----------------+\n| Start  |----&gt;| Create RBAC   |----&gt;| Generate Token |\n+--------+     +---------------+     +----------------+\n                                           |\n                                           v\n+--------+     +---------------+     +----------------+\n|  End   |&lt;----| Run Results   |&lt;----| Execute Scan   |\n+--------+     +---------------+     +----------------+\n</code></pre>"},{"location":"overview/ascii-to-mermaid/#converted-mermaid-diagram","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart LR\n    A[Start] --&gt; B[Create RBAC]\n    B --&gt; C[Generate Token]\n    C --&gt; D[Execute Scan]\n    D --&gt; E[Run Results]\n    E --&gt; F[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:2px\n    style F fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/ascii-to-mermaid/#example-2-container-relationships","title":"Example 2: Container Relationships","text":""},{"location":"overview/ascii-to-mermaid/#original-ascii-diagram_1","title":"Original ASCII Diagram","text":"<pre><code>+------------------------------------------+\n| Pod                                      |\n|  +-------------+     +---------------+   |\n|  | Application |&lt;---&gt;| Sidecar       |   |\n|  | Container   |     | Scanner       |   |\n|  +-------------+     +---------------+   |\n|         |                  |             |\n|         v                  v             |\n|  +-----------------------------------+   |\n|  | Shared Process Namespace          |   |\n|  +-----------------------------------+   |\n+------------------------------------------+\n</code></pre>"},{"location":"overview/ascii-to-mermaid/#converted-mermaid-diagram_1","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart TD\n    subgraph Pod\n        A[Application Container] &lt;--&gt; B[Sidecar Scanner]\n        A --&gt; C[Shared Process Namespace]\n        B --&gt; C\n    end\n\n    style A fill:#bbf,stroke:#333,stroke-width:2px\n    style B fill:#bfb,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/ascii-to-mermaid/#example-3-approach-decision-tree","title":"Example 3: Approach Decision Tree","text":""},{"location":"overview/ascii-to-mermaid/#original-ascii-diagram_2","title":"Original ASCII Diagram","text":"<pre><code>                 +------------------+\n                 | Container Type?  |\n                 +------------------+\n                         |\n          +--------------+---------------+\n          |                              |\n          v                              v\n+------------------+            +------------------+\n| Standard         |            | Distroless       |\n+------------------+            +------------------+\n          |                              |\n          v                              v\n+------------------+            +------------------+\n| Kubernetes API   |            | Debug Available? |\n| Approach         |            +------------------+\n+------------------+                     |\n                             +-----------+----------+\n                             |                      |\n                             v                      v\n                    +------------------+   +------------------+\n                    | Debug Container  |   | Sidecar         |\n                    | Approach         |   | Approach        |\n                    +------------------+   +------------------+\n</code></pre>"},{"location":"overview/ascii-to-mermaid/#converted-mermaid-diagram_2","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart TD\n    A{Container Type?} --&gt;|Standard| B[Kubernetes API Approach]\n    A --&gt;|Distroless| C{Debug Available?}\n    C --&gt;|Yes| D[Debug Container Approach]\n    C --&gt;|No| E[Sidecar Approach]\n\n    style A fill:#fbb,stroke:#333,stroke-width:2px\n    style B fill:#bfb,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/ascii-to-mermaid/#conversion-benefits","title":"Conversion Benefits","text":"<p>Converting ASCII diagrams to Mermaid offers several advantages:</p> <ol> <li>Improved readability - Mermaid diagrams are more visually appealing and easier to read</li> <li>Theme compatibility - Mermaid diagrams adapt to light/dark themes automatically</li> <li>Maintainability - Mermaid syntax is more structured and easier to modify</li> <li>Interactive features - Diagrams can be made interactive with clickable elements</li> <li>Consistency - Unified diagram style across the documentation</li> </ol>"},{"location":"overview/ascii-to-mermaid/#conversion-process","title":"Conversion Process","text":"<p>When converting ASCII to Mermaid:</p> <ol> <li>Identify the core elements and relationships in the ASCII diagram</li> <li>Choose the appropriate Mermaid diagram type (flowchart, sequence, etc.)</li> <li>Map each ASCII element to its Mermaid counterpart</li> <li>Add styling to improve visual clarity</li> <li>Test the diagram in both light and dark modes</li> </ol>"},{"location":"overview/ascii-to-mermaid/#example-syntax-comparison","title":"Example Syntax Comparison","text":""},{"location":"overview/ascii-to-mermaid/#ascii-syntax-difficult-to-maintain","title":"ASCII Syntax (difficult to maintain)","text":"<pre><code>+--------+     +---------------+\n| Start  |----&gt;| Middle Step   |\n+--------+     +---------------+\n                      |\n                      v\n               +---------------+\n               | End Step      |\n               +---------------+\n</code></pre>"},{"location":"overview/ascii-to-mermaid/#mermaid-syntax-structured-and-maintainable","title":"Mermaid Syntax (structured and maintainable)","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Middle Step]\n    B --&gt; C[End Step]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C fill:#f9f,stroke:#333,stroke-width:2px\n</code></pre> <p>Which renders as:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Middle Step]\n    B --&gt; C[End Step]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C fill:#f9f,stroke:#333,stroke-width:2px</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/enterprise-integration-analysis/","title":"Enterprise Integration Analysis","text":"<p>This document analyzes the enterprise integration aspects of the Secure Kubernetes Container Scanning solution, focusing on scalability, maintainability, and user experience considerations for each approach.</p>"},{"location":"overview/enterprise-integration-analysis/#1-scalability-considerations","title":"1. Scalability Considerations","text":""},{"location":"overview/enterprise-integration-analysis/#cluster-level-scalability","title":"Cluster-Level Scalability","text":"Approach Resource Utilization Parallel Scanning Cluster Impact Kubernetes API Approach \ud83d\udfe2 Low (single exec process) \ud83d\udfe2 High (stateless) \ud83d\udfe2 Minimal (API server only) Debug Container Approach \ud83d\udfe0 Medium (ephemeral container) \ud83d\udfe0 Medium (ephemeral limit) \ud83d\udfe0 Moderate (API server + kubelet) Sidecar Container Approach \ud83d\udd34 Higher (persistent sidecar) \ud83d\udfe2 High (pre-deployed) \ud83d\udfe0 Moderate (resource reservation) <p>Analysis: - Kubernetes API Approach provides the lightest resource footprint with minimal cluster impact - Debug Container Approach creates moderate load on API server when created dynamically - Sidecar Container Approach consumes more persistent resources but distributes load</p> <p>Recommendations for Scale: - For large clusters (1000+ nodes): Consider distributed scanning with regional controllers - For frequent scans (100+ per hour): Pre-deploy sidecar containers to avoid creation overhead - For scan batching: Implement rate limiting and queuing for all approaches</p>"},{"location":"overview/enterprise-integration-analysis/#pipeline-integration-scalability","title":"Pipeline Integration Scalability","text":"Approach Pipeline Parallelism Resource Requirements Multi-Team Support Kubernetes API Approach \ud83d\udfe2 High \ud83d\udfe2 Low \ud83d\udfe2 Simple configuration Debug Container Approach \ud83d\udfe0 Medium \ud83d\udfe0 Medium \ud83d\udfe0 More configuration Sidecar Container Approach \ud83d\udfe0 Medium \ud83d\udfe0 Medium \ud83d\udfe0 More configuration <p>Analysis: - All approaches can scale with pipeline parallelism - Kubernetes API Approach has lowest resource requirements per scan - All approaches support multi-team usage with proper RBAC segmentation</p> <p>Recommendations for CI/CD Scale: - Implement dedicated scanning service accounts per team - Use dedicated namespaces for scanning operations - Consider centralized scanning service for high-volume environments</p>"},{"location":"overview/enterprise-integration-analysis/#2-maintenance-considerations","title":"2. Maintenance Considerations","text":""},{"location":"overview/enterprise-integration-analysis/#operational-maintenance","title":"Operational Maintenance","text":"Aspect Kubernetes API Approach Debug Container Approach Sidecar Container Approach Upgrade Impact \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Dependency Management \ud83d\udfe2 Simple \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Troubleshooting \ud83d\udfe2 Straightforward \ud83d\udfe0 More complex \ud83d\udfe0 More complex Monitoring \ud83d\udfe2 Standard logs \ud83d\udfe0 Multiple components \ud83d\udfe0 Multiple components <p>Analysis: - Kubernetes API Approach has fewest moving parts and dependencies - Debug Container and Sidecar Container approaches require more monitoring points - All approaches utilize Kubernetes native logging and events</p> <p>Maintenance Best Practices: - Document scanner version compatibility with Kubernetes versions - Implement automated testing for all scanning approaches after cluster upgrades - Create dedicated troubleshooting guides for each approach - Monitor scan success rates and duration metrics</p>"},{"location":"overview/enterprise-integration-analysis/#long-term-sustainability","title":"Long-Term Sustainability","text":"Consideration Kubernetes API Approach Debug Container Approach Sidecar Container Approach Kubernetes Compatibility \ud83d\udfe2 Stable long-term \ud83d\udfe0 Dependent on ephemeral containers \ud83d\udfe2 Stable long-term Future-Proofing \ud83d\udfe2 Core K8s API \ud83d\udfe0 Newer feature \ud83d\udfe2 Core K8s feature Community Support \ud83d\udfe2 Widespread \ud83d\udfe0 Growing \ud83d\udfe2 Widespread Vendor Lock-in Risk \ud83d\udfe2 Low \ud83d\udfe2 Low \ud83d\udfe2 Low Universal Solution \ud83d\udfe2 Yes (with distroless support) \ud83d\udfe0 Limited use cases \ud83d\udfe2 Yes <p>Analysis: - Kubernetes API and Sidecar Container approaches rely on stable, core Kubernetes features - Both Kubernetes API and Sidecar Container approaches will be universal solutions - The Kubernetes API Approach will be a universal solution once distroless support is implemented - Debug Container Approach depends on newer Kubernetes features - All approaches avoid vendor lock-in through standard Kubernetes interfaces</p> <p>Sustainability Recommendations: - Implement version detection in scanning scripts - Create compatibility matrix for Kubernetes versions - Monitor Kubernetes deprecation notices for impact on scanning approaches - Maintain feature parity across all approaches where possible</p>"},{"location":"overview/enterprise-integration-analysis/#3-user-experience-analysis","title":"3. User Experience Analysis","text":""},{"location":"overview/enterprise-integration-analysis/#developer-experience","title":"Developer Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Learning Curve \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Debugging Ease \ud83d\udfe2 Simple \ud83d\udfe0 More complex \ud83d\udfe0 More complex Local Testing \ud83d\udfe2 Easy \ud83d\udfe0 More setup \ud83d\udfe0 More setup Feedback Speed \ud83d\udfe2 Fast \ud83d\udfe0 Medium \ud83d\udfe2 Fast Container Type Support \ud83d\udfe2 All types (with distroless support) \ud83d\udfe0 Primarily distroless \ud83d\udfe2 All types <p>Analysis: - Kubernetes API Approach provides the most straightforward developer experience - Kubernetes API Approach will support all container types once distroless support is implemented - Debug Container and Sidecar Container approaches require more understanding of Kubernetes concepts - All approaches can be integrated into developer workflows</p> <p>Developer Experience Recommendations: - Create simplified CLI wrappers for all scanning approaches - Provide IDE integrations for scanning operations - Build detailed error messages with troubleshooting guidance - Implement scan result visualization for quick understanding</p>"},{"location":"overview/enterprise-integration-analysis/#security-team-experience","title":"Security Team Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Policy Implementation \ud83d\udfe2 Straightforward \ud83d\udfe0 More complex \ud83d\udfe0 More complex Compliance Verification \ud83d\udfe2 Direct evidence \ud83d\udfe2 Direct evidence \ud83d\udfe2 Direct evidence Risk Assessment \ud83d\udfe2 Clear model \ud83d\udfe0 More components \ud83d\udfe0 More components Audit Trail \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs Universal Coverage \ud83d\udfe2 Complete (with distroless support) \ud83d\udfe0 Partial \ud83d\udfe2 Complete Standards Alignment \ud83d\udfe2 High (NIST, CIS, NSA/CISA) \ud83d\udfe2 High \ud83d\udfe2 High <p>Analysis: - All approaches provide strong compliance verification capabilities - Kubernetes API Approach has the clearest security model for auditing - Kubernetes API Approach will provide complete coverage of all container types with distroless support - All approaches support comprehensive logging for audit trails - All approaches align with key security standards and benchmarks</p> <p>Security Experience Recommendations: - Implement scan scheduling with compliance deadlines - Create security dashboards for scan coverage and results - Develop automated remediation workflows - Provide attestation for scan execution and results - Map scanning controls to NIST SP 800-190 and CIS Benchmarks</p>"},{"location":"overview/enterprise-integration-analysis/#operations-team-experience","title":"Operations Team Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Deployment Complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Resource Management \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Monitoring Requirements \ud83d\udfe2 Basic \ud83d\udfe0 Enhanced \ud83d\udfe0 Enhanced Backup/Restore \ud83d\udfe2 Simple \ud83d\udfe2 Simple \ud83d\udfe2 Simple Universality \ud83d\udfe2 High (with distroless support) \ud83d\udfe0 Medium \ud83d\udfe2 High <p>Analysis: - Kubernetes API Approach is easiest to deploy and manage - Kubernetes API Approach will become a universal solution with distroless support - Debug Container and Sidecar Container approaches require more operational overhead - All approaches have similar backup/restore considerations</p> <p>Operations Recommendations: - Create Helm charts for all scanning approaches - Implement monitoring dashboards for scan operations - Develop automated health checks for scanning infrastructure - Provide capacity planning guidelines for each approach</p>"},{"location":"overview/enterprise-integration-analysis/#4-enterprise-integration-patterns","title":"4. Enterprise Integration Patterns","text":""},{"location":"overview/enterprise-integration-analysis/#pattern-1-centralized-scanning-service","title":"Pattern 1: Centralized Scanning Service","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Recommended for enterprise-wide deployment Debug Container Approach \ud83d\udfe0 Limited applicability Primarily for temporary distroless container scanning needs Sidecar Container Approach \ud83d\udfe0 Interim solution Temporary alternative until Kubernetes API Approach supports distroless <p>Implementation: - Central scanning service with dedicated namespace - Scanning requests via API or message queue - Results stored in central database - Role-based access to scan results</p> <p>Best For: Large enterprises with many teams and strict governance</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-2-distributed-team-ownership","title":"Pattern 2: Distributed Team Ownership","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Simplest adoption path for teams Debug Container Approach \ud83d\udfe0 Situational use For specific debugging scenarios only Sidecar Container Approach \ud83d\udfe0 Temporary solution Additional complexity not ideal for wide team adoption <p>Implementation: - Scanning tools deployed per team - Consistent configuration via GitOps - Centralized result aggregation - Team-specific scanning policies</p> <p>Best For: Organizations with autonomous teams and strong DevOps culture</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-3-cicd-pipeline-integration","title":"Pattern 3: CI/CD Pipeline Integration","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Simplest and most efficient integration Debug Container Approach \ud83d\udfe0 Limited use case For specialized distroless scanning until API approach supports it Sidecar Container Approach \ud83d\udfe0 Interim solution Workable but with additional complexity <p>Implementation: - Scanning as pipeline stage - Dynamic RBAC provisioning - Scan results as pipeline artifacts - Automatic policy enforcement</p> <p>Best For: Organizations with mature CI/CD practices</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-4-security-as-a-service","title":"Pattern 4: Security as a Service","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent foundation Recommended for enterprise-wide security service Debug Container Approach \ud83d\udfe0 Specialized use For specific distroless scenarios during transition Sidecar Container Approach \ud83d\udfe0 Transition solution Temporary approach until Kubernetes API supports distroless <p>Implementation: - Dedicated security team owns scanning infrastructure - Self-service portal for scan requests - Automated scan scheduling and reporting - Integration with security tools ecosystem</p> <p>Best For: Organizations with dedicated security operations team</p>"},{"location":"overview/enterprise-integration-analysis/#5-integration-with-enterprise-systems","title":"5. Integration with Enterprise Systems","text":""},{"location":"overview/enterprise-integration-analysis/#compatibility-matrix","title":"Compatibility Matrix","text":"Enterprise System Kubernetes API Approach Debug Container Approach Sidecar Container Approach SIEM Integration \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs CMDB Integration \ud83d\udfe2 Simple mapping \ud83d\udfe2 Simple mapping \ud83d\udfe2 Simple mapping Ticketing Systems \ud83d\udfe2 API integration \ud83d\udfe2 API integration \ud83d\udfe2 API integration Compliance Reporting \ud83d\udfe2 SAF-CLI support \ud83d\udfe2 SAF-CLI support \ud83d\udfe2 SAF-CLI support Vulnerability Management \ud83d\udfe2 Standard format \ud83d\udfe2 Standard format \ud83d\udfe2 Standard format Universal Container Support \ud83d\udfe2 Yes (with distroless support) \ud83d\udfe0 Partial \ud83d\udfe2 Yes <p>Integration Recommendations: - Use SAF-CLI for standardized output across all approaches - Implement standard logging format for SIEM integration - Create API hooks for ticketing system integration - Develop compliance dashboards with drill-down capabilities</p>"},{"location":"overview/enterprise-integration-analysis/#6-security-standards-alignment","title":"6. Security Standards Alignment","text":"Security Standard Kubernetes API Approach Debug Container Approach Sidecar Container Approach NIST SP 800-190 \ud83d\udfe2 High alignment \ud83d\udfe2 High alignment \ud83d\udfe2 High alignment CIS Docker Benchmark \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment CIS Kubernetes Benchmark \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment NSA/CISA K8s Hardening \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment Docker Best Practices \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment MITRE ATT&amp;CK for Containers \ud83d\udfe2 Strong mitigations \ud83d\udfe2 Strong mitigations \ud83d\udfe2 Strong mitigations <p>Security Alignment Details:</p> <ol> <li>NIST SP 800-190 Alignment: All approaches implement the recommended controls for container security:</li> <li>Least-privilege access to container resources</li> <li>Proper isolation between containers</li> <li>Validation of container configuration</li> <li> <p>Monitoring of container activities</p> </li> <li> <p>CIS Benchmarks Alignment: The Kubernetes API Approach best aligns with CIS recommendations:</p> </li> <li>Proper RBAC configurations</li> <li>Limited container privileges</li> <li>Resource constraints implementation</li> <li> <p>Container isolation preservation</p> </li> <li> <p>NSA/CISA Kubernetes Hardening: All approaches implement key recommendations:</p> </li> <li>Pod Security Standards implementation</li> <li>Namespace separation and isolation</li> <li>Minimized container capabilities</li> <li> <p>Proper authentication and authorization</p> </li> <li> <p>Docker Best Practices: The Kubernetes API Approach best preserves Docker's \"one application per container\" principle, while the Debug Container and Sidecar approaches temporarily modify this principle for scanning purposes.</p> </li> <li> <p>MITRE ATT&amp;CK Mitigations: All approaches implement controls to mitigate container-specific attack techniques:</p> </li> <li>T1610 (Deploy Container): Prevents unauthorized container deployment</li> <li>T1613 (Container Discovery): Limits visibility to container resources</li> <li>T1543.005 (Container Service): Prevents modification of container configurations</li> </ol>"},{"location":"overview/enterprise-integration-analysis/#7-roi-and-cost-analysis","title":"7. ROI and Cost Analysis","text":"Cost Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Infrastructure Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Implementation Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Training Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Maintenance Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Long-term Investment Value \ud83d\udfe2 High \ud83d\udfe0 Low \ud83d\udfe0 Medium <p>ROI Considerations: - All approaches provide similar security value - Kubernetes API Approach has lowest total cost of ownership - Sidecar and Debug Container approaches provide interim distroless container coverage - The Kubernetes API Approach will offer the best long-term ROI once distroless support is implemented - A universal solution via the Kubernetes API Approach will provide the highest value for enterprise deployments</p>"},{"location":"overview/enterprise-integration-analysis/#8-enterprise-adoption-roadmap","title":"8. Enterprise Adoption Roadmap","text":""},{"location":"overview/enterprise-integration-analysis/#phase-1-pilot-implementation","title":"Phase 1: Pilot Implementation","text":"<ul> <li>Implement Kubernetes API Approach for standard containers in development environment</li> <li>Train operators and security teams</li> <li>Establish baseline metrics and scanning policies</li> <li>Develop initial integration with enterprise systems</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-2-expanded-coverage-with-interim-solutions","title":"Phase 2: Expanded Coverage with Interim Solutions","text":"<ul> <li>Implement Sidecar Container Approach or Debug Container Approach for distroless containers temporarily</li> <li>Expand to test/staging environments</li> <li>Refine scanning policies and remediation processes</li> <li>Enhance integration with security tools ecosystem</li> <li>Begin development of distroless support for Kubernetes API Approach</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-3-production-deployment","title":"Phase 3: Production Deployment","text":"<ul> <li>Deploy to production environments</li> <li>Complete development of distroless support for Kubernetes API Approach</li> <li>Implement automated compliance reporting</li> <li>Establish scanning governance model</li> <li>Complete enterprise system integrations</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-4-universal-solution-migration","title":"Phase 4: Universal Solution Migration","text":"<ul> <li>Migrate all scanning to Kubernetes API Approach as the universal solution</li> <li>Retire interim solutions (Sidecar and Debug Container approaches)</li> <li>Implement performance optimizations</li> <li>Expand to additional clusters and environments</li> <li>Develop advanced analytics for scanning trends</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#conclusion","title":"Conclusion","text":"<p>Each scanning approach has distinct characteristics that impact enterprise integration. The Kubernetes API Approach offers the simplest integration path with lowest overhead and will become the universal solution once distroless support is implemented. The Debug Container and Sidecar Container approaches provide interim solutions for distroless containers, but with increased complexity.</p> <p>For most enterprises, a strategic phased approach is recommended:</p> <ol> <li>Current State (Transition Period):</li> <li>Use Kubernetes API Approach for all standard containers</li> <li>Use either Debug Container or Sidecar Container approach temporarily for distroless containers</li> <li> <p>Implement consistent tooling and reporting across all approaches</p> </li> <li> <p>Target State (Long-term):</p> </li> <li>Migrate to the Kubernetes API Approach as the universal solution for all container types</li> <li>Benefit from simplified operations, consistent user experience, and lower costs</li> <li>Maintain a single approach for enterprise-wide container scanning</li> <li>Achieve high alignment with industry security standards and frameworks</li> </ol> <p>This analysis provides a foundation for planning enterprise integration of container scanning approaches, considering various factors that impact successful adoption and long-term sustainability, with a clear path toward the recommended Kubernetes API Approach as the universal solution.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/executive-summary/","title":"Executive Summary: Secure Kubernetes Container Scanning","text":""},{"location":"overview/executive-summary/#overview","title":"Overview","text":"<p>The Secure Kubernetes Container Scanning solution provides a comprehensive, security-focused approach to scanning containers in Kubernetes environments using CINC Auditor (open-source InSpec). This project addresses critical enterprise needs for secure container compliance scanning while adhering to security best practices including least privilege access.</p>"},{"location":"overview/executive-summary/#key-value-proposition","title":"Key Value Proposition","text":"<p>This solution solves three critical challenges faced by enterprise organizations:</p> <ol> <li>Security-First Design: Implements least-privilege access model to minimize attack surface during container scanning</li> <li>Universal Container Support: Provides multiple approaches to scan both standard and distroless containers</li> <li>Enterprise Integration: Seamlessly integrates with existing CI/CD pipelines and security workflows</li> </ol>"},{"location":"overview/executive-summary/#approaches-and-capabilities","title":"Approaches and Capabilities","text":"<p>The platform provides three distinct approaches for container scanning:</p> Approach Description Best For Kubernetes API Approach Direct scanning using train-k8s-container transport Enterprise-recommended approach, currently for standard containers with future distroless support Debug Container Approach Ephemeral debug container with filesystem access Interim solution for distroless containers in Kubernetes 1.16+ Sidecar Container Approach Shared process namespace for filesystem access Interim universal approach until Kubernetes API Approach supports distroless"},{"location":"overview/executive-summary/#security-benefits","title":"Security Benefits","text":"<ul> <li>Minimized Attack Surface: Targeted access to specific containers only</li> <li>Short-lived Credentials: Temporary tokens for scanning operations</li> <li>Resource Isolation: Contained scanning environment with limited permissions</li> <li>Least-Privilege Model: RBAC permissions limited to specific scanning operations</li> <li>Standards Compliance: Aligns with NIST SP 800-190, CIS Benchmarks, and NSA/CISA Kubernetes Hardening Guidelines</li> <li>MITRE ATT&amp;CK Mitigation: Helps prevent container-related attack techniques identified in the MITRE ATT&amp;CK framework</li> </ul>"},{"location":"overview/executive-summary/#enterprise-integration","title":"Enterprise Integration","text":"<p>The solution provides:</p> <ul> <li>CI/CD Pipeline Integration: GitHub Actions and GitLab CI examples</li> <li>Compliance Validation: MITRE SAF-CLI integration for threshold-based validation</li> <li>Deployment Options: Shell scripts and Helm charts for flexible implementation</li> <li>Comprehensive Documentation: Decision matrices, workflow diagrams, and examples</li> </ul>"},{"location":"overview/executive-summary/#business-impact","title":"Business Impact","text":"<p>This solution enables organizations to:</p> <ol> <li>Reduce Security Risk: Implement container scanning without compromising cluster security</li> <li>Increase Scanning Coverage: Scan all container types, including modern distroless containers</li> <li>Accelerate Compliance: Automate scanning in CI/CD pipelines with pass/fail thresholds</li> <li>Standardize Scanning: Consistent approach across development and production environments</li> </ol>"},{"location":"overview/executive-summary/#compliance-and-security-posture","title":"Compliance and Security Posture","text":"<p>From a compliance and security best practices standpoint, our approaches have been evaluated against DoD 8500.01, DISA Container Platform SRG, Kubernetes STIG v2r2, and CIS Kubernetes Benchmarks:</p>"},{"location":"overview/executive-summary/#recommended-approach","title":"Recommended Approach","text":"<p>The Kubernetes API Approach is strongly recommended for medium to high-security environments, including DoD, government, financial, and healthcare sectors due to:</p> <ul> <li>Standard Interface Alignment: Utilizes vendor-supported Kubernetes APIs, aligning with DoD 8500.01 requirements</li> <li>Least Privilege Compliance: Implements minimal permissions required by SRG-APP-000142 and STIG controls</li> <li>Isolation Preservation: Maintains strong container isolation boundaries recommended by CIS Benchmark 5.2.4</li> <li>No Pod Modification: Operates without modifying pod definitions or sharing process namespaces</li> <li>Clear Audit Trail: Provides straightforward audit records of all scanning activities</li> <li>Low Compliance Documentation Burden: Follows standard patterns recognized by security assessors</li> </ul>"},{"location":"overview/executive-summary/#alternative-approaches-considerations","title":"Alternative Approaches Considerations","text":"<p>Organizations considering alternative approaches should be aware of compliance implications:</p> <ul> <li>Debug Container Approach introduces compliance challenges including non-standard debugging interfaces and additional privileges.</li> <li>Not recommended for high-security environments without formal risk acceptance documentation</li> <li> <p>May be considered as an interim solution in medium-security environments with proper controls</p> </li> <li> <p>Sidecar Container Approach presents significant compliance challenges including violation of container isolation principles.</p> </li> <li>Not recommended for high-security environments due to explicit conflict with CIS Benchmark 5.2.4</li> <li>Should be avoided in medium-security environments without comprehensive risk documentation and security approval</li> </ul> <p>Organizations that must use alternative approaches for distroless containers should: 1. Document compliance deviations with formal risk acceptance 2. Implement additional security controls to mitigate risks 3. Plan for migration to the Kubernetes API Approach when distroless support is complete</p>"},{"location":"overview/executive-summary/#strategic-roadmap-for-maximum-compliance","title":"Strategic Roadmap for Maximum Compliance","text":"<p>Our comprehensive compliance analysis leads to a clear strategic roadmap:</p>"},{"location":"overview/executive-summary/#immediate-priority-enhance-train-k8s-container-plugin","title":"Immediate Priority: Enhance train-k8s-container Plugin","text":"<p>Enhancing the train-k8s-container plugin to support distroless containers represents the highest strategic priority for our container scanning solution. This approach will:</p> <ul> <li>Maintain Full Compliance: Continue to meet all DoD, DISA, STIG, and CIS requirements</li> <li>Eliminate Alternative Approaches: Remove the need for compliance-challenged interim solutions</li> <li>Enable Enterprise Scale: Support scanning hundreds to thousands of containers across multiple teams and projects</li> <li>Provide Universal Coverage: Work consistently with all container types, including distroless configurations</li> <li>Simplify Security Posture: Present a unified, compliant approach for all scanning needs</li> </ul> <p>This enhancement is backed by detailed analysis against major security standards, with the Kubernetes API Approach consistently demonstrating the strongest compliance profile. The enhanced plugin will support the full range of container scanning including Kubernetes platforms, container OS's, web servers, databases, applications, and services\u2014all through a standard, compliant interface.</p> <p>For organizations needing comprehensive, standards-compliant container security at scale, this strategic roadmap provides a clear path that minimizes security risks while maximizing scanning capabilities.</p> <p>For detailed compliance analysis, see Security Compliance Analysis.</p>"},{"location":"overview/executive-summary/#getting-started","title":"Getting Started","text":"<p>See Quickstart Guide for implementation steps.</p> <p>For detailed information on approaches: - Approach Comparison - Security Compliance Analysis - Approach Decision Matrix</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/mermaid-diagrams/","title":"Container Scanning Workflow Diagrams","text":"<p>This document provides WCAG-compliant Mermaid diagrams illustrating the key scanning workflows, CI/CD integrations, and architecture patterns in our container security platform. These diagrams follow our project's color standards and are designed to display properly in both light and dark modes.</p>"},{"location":"overview/mermaid-diagrams/#minikube-architecture","title":"Minikube Architecture","text":"<pre><code>flowchart TD\n    subgraph MiniKubeCluster[\"MINIKUBE CLUSTER\"]\n        direction TB\n        subgraph ControlNode[\"CONTROL NODE\"]\n            direction TB\n            apiserver[\"kube-apiserver\"]\n            etcd[\"etcd\"]\n        end\n\n        subgraph WorkerNode1[\"WORKER NODE 1\"]\n            direction TB\n            containers[\"Target Containers\"]\n            scanner_pods[\"Scanner Pods\"]\n        end\n\n        subgraph WorkerNode2[\"WORKER NODE 2\"]\n            direction TB\n            debug_containers[\"Debug Containers\"]\n            sidecar_pods[\"Sidecar Pods\"]\n        end\n    end\n\n    MiniKubeCluster --- cinc[\"CINC Profiles\\n(Compliance Controls)\"]\n    MiniKubeCluster --- rbac[\"Service Accounts\\nand RBAC\\n(Access Control)\"]\n    MiniKubeCluster --- saf[\"SAF CLI\\n(Reporting &amp;\\nThresholds)\"]\n\n    %% WCAG-compliant styling for subgraph labels - works in both light/dark\n    style MiniKubeCluster fill:none,stroke:#505050,stroke-width:4px\n    style ControlNode fill:none,stroke:#0066CC,stroke-width:4px\n    style WorkerNode1 fill:none,stroke:#0066CC,stroke-width:4px\n    style WorkerNode2 fill:none,stroke:#0066CC,stroke-width:4px\n\n    %% Component styling\n    style apiserver fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style etcd fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style containers fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug_containers fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar_pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class MiniKubeCluster,ControlNode,WorkerNode1,WorkerNode2 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#kubernetes-api-approach-workflow","title":"Kubernetes API Approach Workflow","text":"<pre><code>flowchart TD\n    start([START KUBERNETES API APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: SETUP &amp; PREPARATION\"]\n        direction TB\n        identify[\"Identify Target Container\"] --&gt; create_rbac[\"Create RBAC and Service Account\"]\n        create_rbac --&gt; generate_token[\"Generate Short-lived Security Token\"]\n        generate_token --&gt; create_kubeconfig[\"Create Restricted Kubeconfig File\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: SCANNING EXECUTION\"]\n        direction TB\n        run_cinc[\"Run CINC Auditor with k8s-container Transport\"] --&gt; process[\"Process with SAF CLI &amp; Check Threshold\"]\n        process --&gt; generate_reports[\"Generate Reports and Validations\"]\n        generate_reports --&gt; cleanup[\"Clean up RBAC &amp; Service Account\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_kubeconfig fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"overview/mermaid-diagrams/#debug-container-approach-workflow","title":"Debug Container Approach Workflow","text":"<pre><code>flowchart TD\n    start([START DEBUG CONTAINER APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: ATTACH DEBUG CONTAINER\"]\n        direction TB\n        identify[\"Identify Distroless Target Container\"] --&gt; create_debug[\"Create Ephemeral Debug Container\"]\n        create_debug --&gt; deploy_cinc[\"Deploy CINC Auditor in Debug Container\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER\"]\n        direction TB\n        chroot[\"Chroot to Target Container Filesystem\"] --&gt; run_cinc[\"Run CINC Auditor Against Target\"]\n        run_cinc --&gt; export_results[\"Export Scan Results to Host System\"]\n        export_results --&gt; process[\"Process Results with SAF CLI\"]\n        process --&gt; terminate[\"Terminate Debug Container &amp; Clean Up\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_debug fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_cinc fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style chroot fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style export_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style terminate fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class step1,step2 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#sidecar-approach-workflow","title":"Sidecar Approach Workflow","text":"<pre><code>flowchart TD\n    start([START SIDECAR APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        direction TB\n        deploy_target[\"Deploy Target Container in Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        direction TB\n        find_process[\"Sidecar Finds Target Process\"] --&gt; access_fs[\"Access Target via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class step1,step2 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#enhanced-kubernetes-api-approach-workflow","title":"Enhanced Kubernetes API Approach Workflow","text":"<pre><code>flowchart TD\n    start([START ENHANCED KUBERNETES API APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: CONTAINER DETECTION AND SETUP\"]\n        direction TB\n        identify[\"Target Container Identification\"] --&gt; plugin[\"Modified train-k8s-container Plugin\"]\n        plugin --&gt; detect[\"Auto-Detect if Container is Distroless\"]\n        detect --&gt;|Regular| standard[\"Use Standard Direct Exec Connection\"]\n        detect --&gt;|Distroless| debug[\"Use Debug Container Fallback\"]\n        debug --&gt; create_debug[\"Create Temporary Debug Container\"]\n    end\n\n    standard --&gt; step2\n    create_debug --&gt; step2\n\n    subgraph step2[\"STEP 2: SCANNING EXECUTION\"]\n        direction TB\n        run_cinc[\"Run CINC Auditor Scan\"] --&gt; process[\"Process Results with SAF CLI\"]\n    end\n\n    step2 --&gt; step3\n\n    subgraph step3[\"STEP 3: CLEANUP (FOR DISTROLESS)\"]\n        direction TB\n        cleanup[\"Terminate and Clean Up Resources\"]\n    end\n\n    step3 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n    style step3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style plugin fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style detect fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_debug fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"overview/mermaid-diagrams/#gitlab-ci-kubernetes-api-approach-with-services","title":"GitLab CI Kubernetes API Approach with Services","text":"<pre><code>flowchart TD\n    start([GITLAB CI WITH SERVICES]) --&gt; stage1\n\n    subgraph stage1[\"STAGE 1: PIPELINE SETUP\"]\n        direction TB\n        pipeline_start[\"GitLab CI Pipeline Begins\"] --&gt; start_service[\"Start CINC Auditor Scanner Service\"]\n        start_service --&gt; deploy[\"Deploy Target Container\"]\n    end\n\n    stage1 --&gt; stage2\n\n    subgraph stage2[\"STAGE 2: SECURITY SETUP\"]\n        direction TB\n        create_rbac[\"Create RBAC &amp; Service Account\"] --&gt; generate_token[\"Generate Short-lived Security Token\"]\n        generate_token --&gt; create_kubeconfig[\"Create Restricted kubeconfig\"]\n    end\n\n    stage2 --&gt; stage3\n\n    subgraph stage3[\"STAGE 3: SCANNING &amp; REPORTING\"]\n        direction TB\n        execute_scan[\"Execute Scan in Service Container\"] --&gt; process[\"Process Results with SAF CLI\"]\n        process --&gt; copy_results[\"Copy Results &amp; Generate Reports\"]\n        copy_results --&gt; cleanup[\"Clean Up Resources\"]\n    end\n\n    stage3 --&gt; complete([COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Stage styling with WCAG-compliant colors - works in both light/dark\n    style stage1 fill:none,stroke:#DD6100,stroke-width:4px\n    style stage2 fill:none,stroke:#DD6100,stroke-width:4px\n    style stage3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style pipeline_start fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style start_service fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_kubeconfig fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style execute_scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style copy_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class stage1,stage2,stage3 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#gitlab-ci-sidecar-approach","title":"GitLab CI Sidecar Approach","text":"<pre><code>flowchart TD\n    start([GITLAB CI SIDECAR APPROACH]) --&gt; stage1\n\n    subgraph stage1[\"STAGE 1: DEPLOYMENT\"]\n        direction TB\n        pipeline_start[\"GitLab CI Pipeline Begins\"] --&gt; deploy[\"Deploy Pod with Target and Sidecar\"]\n        deploy --&gt; shared_namespace[\"Enable Shared Process Namespace\"]\n    end\n\n    stage1 --&gt; stage2\n\n    subgraph stage2[\"STAGE 2: SCANNING\"]\n        direction TB\n        sidecar_start[\"Sidecar Scanner Starts\"] --&gt; scan[\"Scan Target via /proc Filesystem\"]\n        scan --&gt; store_results[\"Store Results in Shared Volume\"]\n    end\n\n    stage2 --&gt; stage3\n\n    subgraph stage3[\"STAGE 3: RESULTS PROCESSING\"]\n        direction TB\n        retrieve[\"Retrieve Results from Sidecar\"] --&gt; process[\"Process Results and Generate Reports\"]\n        process --&gt; upload[\"Upload Results &amp; Clean Up Resources\"]\n    end\n\n    stage3 --&gt; complete([COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Stage styling with WCAG-compliant colors - works in both light/dark\n    style stage1 fill:none,stroke:#DD6100,stroke-width:4px\n    style stage2 fill:none,stroke:#DD6100,stroke-width:4px\n    style stage3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style pipeline_start fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar_start fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style upload fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class stage1,stage2,stage3 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#github-actions-kubernetes-api-approach","title":"GitHub Actions Kubernetes API Approach","text":"<pre><code>flowchart TD\n    start([GITHUB ACTIONS KUBERNETES API APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: ENVIRONMENT SETUP\"]\n        direction TB\n        workflow_start[\"GitHub Actions Workflow Start\"] --&gt; setup_k8s[\"Setup Kubernetes Cluster\"]\n        setup_k8s --&gt; install[\"Install CINC Auditor &amp; Plugin\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: TARGET DEPLOYMENT\"]\n        direction TB\n        deploy[\"Deploy Target Container\"] --&gt; create_rbac[\"Create RBAC &amp; Service Account\"]\n        create_rbac --&gt; generate_token[\"Generate Token &amp; kubeconfig\"]\n    end\n\n    step2 --&gt; step3\n\n    subgraph step3[\"STEP 3: SCAN &amp; REPORT\"]\n        direction TB\n        run_cinc[\"Run CINC Auditor Against Target\"] --&gt; process[\"Process Results with SAF CLI\"]\n        process --&gt; generate_reports[\"Generate Reports &amp; Clean Up\"]\n    end\n\n    step3 --&gt; complete([COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n    style step3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style workflow_start fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style setup_k8s fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style install fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Add more vertical space\n    classDef space height:20px;\n    class step1,step2,step3 space;</code></pre>"},{"location":"overview/mermaid-diagrams/#github-actions-sidecar-approach","title":"GitHub Actions Sidecar Approach","text":"<pre><code>flowchart TD\n    start([START GITHUB ACTIONS SIDECAR APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: ENVIRONMENT SETUP\"]\n        direction TB\n        workflow_start[\"GitHub Actions Workflow Start\"] --&gt; setup_k8s[\"Setup Kubernetes Cluster\"]\n        setup_k8s --&gt; build_image[\"Build Scanner Container Image\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: DEPLOYMENT &amp; SCANNING\"]\n        direction TB\n        deploy[\"Deploy Pod with Target and Scanner\"] --&gt; shared_namespace[\"Configure Shared Process Namespace\"]\n        shared_namespace --&gt; scanner_scan[\"Sidecar Scans Target Container\"]\n    end\n\n    step2 --&gt; step3\n\n    subgraph step3[\"STEP 3: RESULTS PROCESSING\"]\n        direction TB\n        wait[\"Wait for Completion\"] --&gt; retrieve[\"Retrieve Results\"]\n        retrieve --&gt; process[\"Process Results &amp; Generate Reports\"]\n        process --&gt; upload[\"Upload Results &amp; Clean Up\"]\n    end\n\n    step3 --&gt; complete([COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n    style step3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style workflow_start fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style setup_k8s fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style build_image fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style wait fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style upload fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"overview/mermaid-diagrams/#end-to-end-security-architecture","title":"End-to-End Security Architecture","text":"<pre><code>flowchart TD\n    start([START]) --&gt; principles\n\n    subgraph principles[\"SECURITY PRINCIPLES\"]\n        direction TB\n        least_privilege[\"Principle of Least Privilege\"] --&gt; token[\"Short-lived Token Generation\"]\n        namespace[\"Namespace Isolation\"] --&gt; no_privileges[\"No Permanent Elevated Privileges\"]\n    end\n\n    principles --&gt; controls\n\n    subgraph controls[\"IMPLEMENTATION CONTROLS\"]\n        direction TB\n        rbac[\"Resource-specific RBAC Controls\"] --&gt; security_first[\"Security First Design\"]\n        audit[\"Audit Trail of Scan Access\"] --&gt; cleanup[\"Automatic Cleanup\"]\n    end\n\n    controls --&gt; compliance\n\n    subgraph compliance[\"COMPLIANCE VALIDATION\"]\n        direction TB\n        threshold[\"Threshold-based Validation with SAF CLI\"]\n    end\n\n    compliance --&gt; complete([END])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Section styling with WCAG-compliant colors - works in both light/dark\n    style principles fill:none,stroke:#DD6100,stroke-width:4px\n    style controls fill:none,stroke:#DD6100,stroke-width:4px\n    style compliance fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style least_privilege fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style namespace fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style no_privileges fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style security_first fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style audit fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style threshold fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you quickly set up the secure CINC Auditor container scanning infrastructure.</p>"},{"location":"overview/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>A running Kubernetes cluster (1.24+)</li> <li>kubectl installed and configured</li> <li>Helm (optional, for chart deployment)</li> <li>CINC Auditor with the train-k8s-container plugin installed</li> </ul>"},{"location":"overview/quickstart/#installation","title":"Installation","text":""},{"location":"overview/quickstart/#option-1-using-kubectl","title":"Option 1: Using kubectl","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/mitre/kube-cinc-secure-scanner.git\ncd kube-cinc-secure-scanner\n</code></pre> <ol> <li>Deploy the basic components:</li> </ol> <pre><code>kubectl apply -f kubernetes/templates/namespace.yaml\nkubectl apply -f kubernetes/templates/service-account.yaml\nkubectl apply -f kubernetes/templates/rbac.yaml\n</code></pre> <ol> <li>Deploy a test pod:</li> </ol> <pre><code>kubectl apply -f kubernetes/templates/test-pod.yaml\n</code></pre> <p>Note: Paths may vary depending on your actual repository structure. The paths above are based on the default project layout.</p>"},{"location":"overview/quickstart/#option-2-using-helm","title":"Option 2: Using Helm","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/mitre/kube-cinc-secure-scanner.git\ncd kube-cinc-secure-scanner\n</code></pre> <ol> <li>Install the Helm charts:</li> </ol> <pre><code># Install all charts at once using the installer script\n./helm-charts/install-all.sh --namespace inspec-test --release-prefix scanner\n\n# Or install individual charts separately\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"overview/quickstart/#testing-the-setup","title":"Testing the Setup","text":"<ol> <li>Generate a temporary configuration:</li> </ol> <pre><code>./scripts/generate-kubeconfig.sh inspec-test inspec-scanner\n</code></pre> <ol> <li>Run a test scan:</li> </ol> <pre><code>KUBECONFIG=./kubeconfig.yaml \\\n  inspec exec ./sample-profiles/basic \\\n  -t k8s-container://inspec-test/inspec-target/busybox\n</code></pre>"},{"location":"overview/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Review the RBAC configuration to understand the permission model</li> <li>Explore CI/CD integration for pipeline automation</li> <li>Check token management for managing short-lived credentials</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/security-analysis/","title":"Security Analysis","text":"<p>This document provides a comprehensive security analysis of the different container scanning approaches offered by the Secure Kubernetes Container Scanning solution, with a focus on industry standards, best practices, and security frameworks.</p>"},{"location":"overview/security-analysis/#security-model-comparison","title":"Security Model Comparison","text":"Security Aspect Kubernetes API Approach Debug Container Approach Sidecar Container Approach Attack Surface \ud83d\udfe2 Minimal \ud83d\udfe0 Temporarily increased \ud83d\udfe0 Moderately increased Container Isolation \ud83d\udfe2 Fully preserved \ud83d\udfe0 Temporarily broken \ud83d\udfe0 Partially broken Access Control \ud83d\udfe2 Fine-grained RBAC \ud83d\udfe2 Fine-grained RBAC \ud83d\udfe2 Fine-grained RBAC Credential Lifespan \ud83d\udfe2 Short-lived tokens \ud83d\udfe2 Short-lived tokens \ud83d\udfe2 Short-lived tokens Resource Boundaries \ud83d\udfe2 Strong \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate \"One Process Per Container\" \ud83d\udfe2 Respected \ud83d\udfe0 Temporarily violated \ud83d\udd34 Permanently violated"},{"location":"overview/security-analysis/#industry-standards-alignment","title":"Industry Standards Alignment","text":"<p>The Secure Kubernetes Container Scanning solution has been designed with alignment to key industry security standards and best practices:</p>"},{"location":"overview/security-analysis/#nist-sp-800-190-application-container-security-guide","title":"NIST SP 800-190 Application Container Security Guide","text":"NIST Control Area Implementation Container Images Regular scanning for vulnerabilities and misconfigurations Container Runtime Least-privilege execution with minimal capabilities Orchestrator Security Strong RBAC controls and namespace isolation Container Deployment Secure deployment patterns without privileged access <p>All scanning approaches implement NIST SP 800-190 recommended controls, with the Kubernetes API Approach offering the highest level of alignment.</p>"},{"location":"overview/security-analysis/#nsacisa-kubernetes-hardening-guidelines","title":"NSA/CISA Kubernetes Hardening Guidelines","text":"<p>Our scanning approaches implement key recommendations from the NSA/CISA Kubernetes Hardening Guidelines:</p> <ol> <li>Pod Security Standards: All approaches enforce pod security controls</li> <li>Network Separation: Proper network policies for scanner components</li> <li>Authentication and Authorization: Strong RBAC implementation with least privilege</li> <li>Audit Logging: Comprehensive logging of all scanning activities</li> <li>Vulnerability Scanning: Integrated compliance validation</li> </ol> <p>The Kubernetes API Approach best aligns with these guidelines by minimizing deviations from Kubernetes security best practices.</p>"},{"location":"overview/security-analysis/#cis-benchmarks","title":"CIS Benchmarks","text":"<p>Our solution aligns with both CIS Kubernetes and Docker Benchmarks:</p> CIS Benchmark Area Implementation RBAC Configuration Specific, limited roles for scanning operations Container Privileges Non-privileged container execution Resource Limits Defined CPU and memory constraints Network Policies Restricted network access for scanners"},{"location":"overview/security-analysis/#mitre-attck-for-containers","title":"MITRE ATT&amp;CK for Containers","text":"<p>The scanning approaches help mitigate several container-related attack techniques from the MITRE ATT&amp;CK framework:</p> ATT&amp;CK Technique Mitigation T1610 - Deploy Container Strong RBAC prevents unauthorized container deployment T1613 - Container Discovery Limited visibility to container resources T1543.005 - Container Service Prevents modification of container configurations T1552 - Unsecured Credentials Short-lived tokens prevent credential theft"},{"location":"overview/security-analysis/#docker-best-practices-alignment","title":"Docker Best Practices Alignment","text":"<p>Our approach alignment with Docker's best practices:</p>"},{"location":"overview/security-analysis/#decouple-applications-one-process-per-container","title":"Decouple Applications (One Process Per Container)","text":"<ul> <li>Kubernetes API Approach: \ud83d\udfe2 Fully maintains the \"one process per container\" principle</li> <li>Debug Container Approach: \ud83d\udfe0 Temporarily introduces a second container but removes it after scanning</li> <li>Sidecar Container Approach: \ud83d\udd34 Permanently introduces an additional container for scanning</li> </ul>"},{"location":"overview/security-analysis/#minimize-container-privileges","title":"Minimize Container Privileges","text":"<p>All approaches implement the principle of least privilege, with: - Non-root users for scanning operations - Minimal capabilities granted to containers - Read-only filesystem where possible - No privileged containers used</p>"},{"location":"overview/security-analysis/#secure-container-supply-chain","title":"Secure Container Supply Chain","text":"<p>Our scanning solution integrates with secure container supply chain practices: - Supports scanning of signed images - Verifies image integrity before scanning - Integrates with CI/CD pipeline vulnerability scanning - Provides evidence for container compliance attestation</p>"},{"location":"overview/security-analysis/#threat-model-analysis","title":"Threat Model Analysis","text":""},{"location":"overview/security-analysis/#key-threats-addressed","title":"Key Threats Addressed","text":"<ol> <li>Unauthorized Access to Container Contents</li> <li>All approaches use strong RBAC controls</li> <li>Limited access duration through short-lived tokens</li> <li> <p>Namespace isolation for multi-tenant environments</p> </li> <li> <p>Privilege Escalation</p> </li> <li>Non-privileged scanning operations</li> <li>Minimal container capabilities</li> <li> <p>No host filesystem mounts</p> </li> <li> <p>Information Disclosure</p> </li> <li>Scanning results properly secured</li> <li>Network policies restrict communication</li> <li> <p>Logs sanitized of sensitive information</p> </li> <li> <p>Denial of Service</p> </li> <li>Resource limits on all scanner components</li> <li>Graceful handling of failed scans</li> <li>Timeouts for long-running operations</li> </ol>"},{"location":"overview/security-analysis/#approach-specific-security-considerations","title":"Approach-Specific Security Considerations","text":""},{"location":"overview/security-analysis/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Strengths: Minimal attack surface, maintains container isolation</li> <li>Considerations: Depends on Kubernetes API server availability</li> </ul> <p>Recommended Approach</p> <p>The Kubernetes API Approach is the enterprise-recommended solution as it provides the strongest security posture with minimal attack surface and adherence to container design principles.</p>"},{"location":"overview/security-analysis/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Strengths: Temporary access, automatically removed after scanning</li> <li>Considerations: Temporarily breaks container isolation, requires ephemeral container feature</li> </ul> <p>Interim Solution</p> <p>While functional, the Debug Container Approach temporarily breaks container isolation and should be considered an interim solution until the Kubernetes API Approach is fully implemented for distroless containers.</p>"},{"location":"overview/security-analysis/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Strengths: Works with all Kubernetes versions, universal container support</li> <li>Considerations: Permanently adds components to pods, increases resource usage</li> </ul> <p>Alternative Approach</p> <p>The Sidecar Container Approach violates the \"one process per container\" principle and permanently increases the attack surface. Use only when other approaches are not viable, and implement additional security controls to mitigate risks.</p>"},{"location":"overview/security-analysis/#compliance-validation-controls","title":"Compliance Validation Controls","text":"<p>The solution implements controls for compliance validation:</p> <ol> <li>Evidence Collection</li> <li>All scanning approaches collect and preserve evidence of compliance</li> <li>Results formatted for integration with security dashboards</li> <li> <p>Detailed logs for audit trail</p> </li> <li> <p>Attestation Support</p> </li> <li>SAF-CLI integration for generating attestation reports</li> <li>Threshold-based pass/fail determination</li> <li> <p>Integration with Software Bill of Materials (SBOM)</p> </li> <li> <p>Automated Remediation</p> </li> <li>Findings can trigger automated remediation workflows</li> <li>Integration with CI/CD pipelines for feedback</li> <li>Policy-as-code implementation for consistent enforcement</li> </ol>"},{"location":"overview/security-analysis/#security-best-practices-implementation","title":"Security Best Practices Implementation","text":"Best Practice Implementation Defense in Depth Multiple security controls at different layers Least Privilege Minimal permissions for scanning operations Secure Defaults Conservative default settings for all components Fail Secure Scanning operations fail closed rather than open Secure Logging Comprehensive, non-sensitive logging Regular Updates Scanner components updated with security patches"},{"location":"overview/security-analysis/#conclusion","title":"Conclusion","text":"<p>Strategic Direction</p> <p>Our strategic priority is to implement and use the Kubernetes API Approach for all container scanning, including distroless containers. The other approaches are provided as interim solutions.</p> <p>The Kubernetes API Approach provides the strongest security posture among the three scanning approaches, with the highest alignment to industry standards and best practices. It maintains container security boundaries, minimizes attack surface, and preserves the integrity of containerized applications.</p> <p>For distroless containers, the Debug Container and Sidecar Container approaches offer viable interim solutions with acceptable security tradeoffs until distroless support is implemented in the Kubernetes API Approach. All approaches implement strong security controls and align with enterprise security requirements.</p> <p>Enterprise Recommendation</p> <p>For enterprise environments with stringent security requirements, invest in implementing the Kubernetes API Approach for all container types. The approach modification required for distroless containers provides a better long-term solution than maintaining multiple scanning methodologies.</p> <p>The comprehensive security analysis demonstrates that all approaches provide strong security controls while meeting container scanning needs. The Kubernetes API Approach is recommended as the target universal solution for long-term deployment, offering the best balance of security, performance, and operational simplicity.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/security-compliance/","title":"Security Compliance Analysis","text":"<p>This document analyzes how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with key security standards and compliance frameworks, particularly focusing on Department of Defense (DoD) requirements and best practices.</p>"},{"location":"overview/security-compliance/#compliance-overview","title":"Compliance Overview","text":"<p>Our container scanning approach has been designed to meet rigorous security requirements defined in:</p> <ol> <li>DoD Instruction 8500.01: \"Cybersecurity\"</li> <li>DISA Container Platform Security Requirements Guide (SRG)</li> <li>Kubernetes Security Technical Implementation Guide (STIG)</li> <li>Center for Internet Security (CIS) Kubernetes Benchmarks</li> </ol> <p>This analysis demonstrates how our recommended scanning approaches align with these frameworks and provide a compliant solution for container security.</p>"},{"location":"overview/security-compliance/#dod-instruction-850001-alignment","title":"DoD Instruction 8500.01 Alignment","text":"<p>DoD Instruction 8500.01 establishes the cybersecurity program to protect and defend DoD information and information technology.</p>"},{"location":"overview/security-compliance/#key-requirements-and-alignment","title":"Key Requirements and Alignment","text":"DoD 8500.01 Requirement Our Compliance Approach Risk Management Framework (RMF) Our scanning solution provides continuous assessment of container security posture, supporting RMF Step 4 (Assessment) and Step 6 (Monitoring) Defense in Depth Implementation of multiple security layers through RBAC controls, minimal privileges, and time-bound tokens Secure Configuration Scanning containers against security baselines to ensure compliance with secure configuration standards Vendor-supported Access Methods Kubernetes API Approach uses standard, vendor-supported interfaces for container access Managed Access Control Implementation of least-privilege RBAC and service accounts with time-limited tokens Standard Ports, Protocols, and Services Use of standard Kubernetes API interfaces rather than custom or unusual access methods"},{"location":"overview/security-compliance/#specific-dod-850001-policy-alignment","title":"Specific DoD 8500.01 Policy Alignment","text":"<p>Section 4.b.(1)(b) of DoD 8500.01 emphasizes the need for standardized, managed interfaces. Our Kubernetes API Approach fully aligns with this requirement by using:</p> <ul> <li>Standard, vendor-supported interfaces (Kubernetes API)</li> <li>Managed authentication mechanisms (service accounts and tokens)</li> <li>Standardized access controls (RBAC)</li> </ul>"},{"location":"overview/security-compliance/#disa-container-platform-srg-alignment","title":"DISA Container Platform SRG Alignment","text":"<p>The DISA Container Platform SRG provides security requirements for container technologies deployed in DoD environments.</p>"},{"location":"overview/security-compliance/#key-srg-requirements-and-alignment","title":"Key SRG Requirements and Alignment","text":"SRG ID Description Our Compliance Approach SRG-APP-000001 Access controls must enforce validated authorization of users and devices Implemented through Kubernetes RBAC, service accounts, and token management SRG-APP-000133 The application must use vendor-supported interfaces for accessing resources Kubernetes API Approach uses standard Kubernetes interfaces SRG-APP-000142 The application must implement least privilege Implemented through pod-specific RBAC and minimal permissions SRG-APP-000343 Audit trails must be maintained for system access Kubernetes audit logs capture all scanner access to containers SRG-APP-000516 Security controls must be implemented without modification to source code Our scanning approach requires no modifications to target containers"},{"location":"overview/security-compliance/#srg-recommendations-for-container-access","title":"SRG Recommendations for Container Access","text":"<p>The Container Platform SRG specifically recommends:</p> <ol> <li>Using standardized interfaces for accessing container resources</li> <li>Avoiding custom, unmanaged access methods</li> <li>Implementing proper authentication and authorization</li> <li>Maintaining least privilege for all access</li> </ol> <p>Our Kubernetes API Approach fully aligns with these recommendations by utilizing the standard Kubernetes API for container access, with proper RBAC controls and minimal privileges.</p>"},{"location":"overview/security-compliance/#kubernetes-stig-alignment-v2r2","title":"Kubernetes STIG Alignment (v2r2)","text":"<p>The Kubernetes STIG provides detailed security requirements for Kubernetes deployments in DoD environments.</p>"},{"location":"overview/security-compliance/#key-stig-requirements-and-alignment","title":"Key STIG Requirements and Alignment","text":"STIG ID Description Our Compliance Approach V-242376 Kubernetes must have cryptographic mechanisms to prevent unauthorized disclosure of information We use standard Kubernetes TLS encryption for all API communications V-242377 Kubernetes must record audit information Scanner access is captured in Kubernetes audit logs V-242423 Role-Based Access Control (RBAC) must be used for authorization Comprehensive RBAC implementation for scanner access V-242432 Namespaces must be used to isolate resources Scanner resources are deployed in isolated namespaces V-242433 Pod Security Policies must be defined to restrict privilege escalation Scanner pods run with minimal privileges V-242440 ServiceAccount tokens must be disabled for pods that do not require them We generate time-limited tokens only when needed V-242459 Container images must be received from trusted registries Scanner container images are pulled from authorized registries"},{"location":"overview/security-compliance/#stig-compatibility-analysis","title":"STIG Compatibility Analysis","text":"<p>Our Kubernetes API Approach aligns perfectly with STIG requirements because it:</p> <ol> <li>Uses standard Kubernetes mechanisms (fully compliant with STIG V-242376)</li> <li>Generates proper audit trails (compliant with STIG V-242377)</li> <li>Implements comprehensive RBAC (compliant with STIG V-242423)</li> <li>Uses namespace isolation (compliant with STIG V-242432)</li> <li>Operates with minimal privileges (compliant with STIG V-242433)</li> <li>Implements token management (compliant with STIG V-242440)</li> <li>Uses trusted container images (compliant with STIG V-242459)</li> </ol>"},{"location":"overview/security-compliance/#cis-kubernetes-benchmark-alignment","title":"CIS Kubernetes Benchmark Alignment","text":"<p>The CIS Kubernetes Benchmark provides industry-standard best practices for securing Kubernetes deployments.</p>"},{"location":"overview/security-compliance/#key-cis-requirements-and-alignment","title":"Key CIS Requirements and Alignment","text":"CIS Control Description Our Compliance Approach 5.1.5 Ensure that default service accounts are not used Custom service accounts created for scanner operations 5.1.6 Ensure that Service Account Tokens are only mounted where necessary Tokens mounted only when needed for scanning 5.2.1 Minimize the admission of privileged containers Scanner runs without privileged access when possible 5.2.4 Minimize the admission of containers wishing to share the host process ID namespace Process namespace sharing only used when absolutely necessary (sidecar approach) 5.2.6 Minimize the admission of containers with access to the host IPC namespace Scanner containers do not access host IPC 5.2.7 Minimize the admission of containers with access to the host network Scanner containers do not access host network 5.7.2 Ensure that the seccomp profile is set to docker/default or runtime/default Appropriate seccomp profiles applied to scanner containers"},{"location":"overview/security-compliance/#compliance-analysis-of-all-approaches","title":"Compliance Analysis of All Approaches","text":"<p>Let's analyze all three approaches against the security standards and compliance frameworks to understand potential compliance challenges and validate assumptions.</p>"},{"location":"overview/security-compliance/#kubernetes-api-approach-compliance-analysis","title":"Kubernetes API Approach Compliance Analysis","text":"<p>Strengths from Compliance Perspective: - Uses standard, vendor-supported interfaces (DoD 8500.01 requirement) - Implements least privilege access (SRG-APP-000142, V-242433) - Utilizes proper RBAC (V-242423) - Avoids unnecessary pod modifications - Generates appropriate audit trails (V-242377) - Minimal attack surface - Does not require privileged access or host access - Follows the principle of using standard interfaces</p> <p>Compliance Challenges: - Currently limited support for distroless containers (being addressed through development)</p>"},{"location":"overview/security-compliance/#debug-container-approach-compliance-analysis","title":"Debug Container Approach Compliance Analysis","text":"<p>Strengths from Compliance Perspective: - Provides isolation through ephemeral containers - Does not permanently modify target pods - Can support ephemeral container-based debugging</p> <p>Compliance Challenges: - May require higher privileges than recommended by SRG-APP-000142 (least privilege) - Requires Kubernetes 1.16+ with ephemeral containers feature  - Uses a debugging pathway rather than standard access interface (potential conflict with DoD 8500.01) - Introduces additional components (ephemeral containers) into the security boundary - CIS Benchmark 5.2.4 recommends minimizing containers with host process namespace sharing</p>"},{"location":"overview/security-compliance/#sidecar-container-approach-compliance-analysis","title":"Sidecar Container Approach Compliance Analysis","text":"<p>Strengths from Compliance Perspective: - Works with any Kubernetes version - Provides consistent mechanism for all container types</p> <p>Compliance Challenges: - Requires modification of pod definitions (adding shareProcessNamespace: true) - Violates container isolation principle recommended by CIS Benchmark and STIG guidance - CIS Benchmark 5.2.4 specifically recommends minimizing containers that share process namespaces - Requires elevated permissions for process namespace sharing - More complex audit trail because of shared process context - Represents a non-standard access pattern (potential conflict with DoD 8500.01)</p>"},{"location":"overview/security-compliance/#compliance-comparison-table","title":"Compliance Comparison Table","text":"Compliance Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach DoD 8500.01 - Standard Interfaces \u2705 Uses standard K8s API \u26a0\ufe0f Uses debug features which may be considered non-standard \u26a0\ufe0f Uses process namespace sharing (non-standard access) SRG-APP-000142 - Least Privilege \u2705 Minimal, well-defined permissions \u26a0\ufe0f Requires additional privileges \u26a0\ufe0f Requires process namespace privileges STIG V-242423 - RBAC Authorization \u2705 Clear RBAC implementation \u2705 Can use RBAC, but with broader scope \u2705 Can use RBAC, but with broader scope STIG V-242432 - Namespace Isolation \u2705 Maintains isolation \u2705 Maintains namespace isolation \u26a0\ufe0f Breaks process isolation within pod STIG V-242433 - Restrict Privilege \u2705 Minimal privileges \u26a0\ufe0f Requires debug privileges \u26a0\ufe0f Requires process sharing privileges CIS 5.1.6 - Service Account Tokens \u2705 Tokens only used when needed \u2705 Tokens can be limited \u2705 Tokens can be limited CIS 5.2.1 - Privileged Containers \u2705 No privileged access needed \u26a0\ufe0f May need elevated privileges \u26a0\ufe0f Requires elevated privileges for process sharing CIS 5.2.4 - Process Namespace Sharing \u2705 No process sharing needed \u2705 No process sharing with host \u274c Explicitly requires process namespace sharing Audit Trail Clarity \u2705 Clear, direct access audit \u26a0\ufe0f More complex audit trail \u26a0\ufe0f Complicated by shared process context Pod Modification Required \u2705 No modification needed \u26a0\ufe0f Temporary modification (ephemeral) \u274c Requires pod definition changes Compliance Documentation Burden \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 High Enterprise Production Readiness \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udfe0 Medium"},{"location":"overview/security-compliance/#validation-of-approach-preferences","title":"Validation of Approach Preferences","text":"<p>Based on the detailed compliance analysis above, the preference for the Kubernetes API Approach in high-security environments is well-founded for the following reasons:</p> <ol> <li> <p>Standard Interfaces: The Kubernetes API Approach aligns most closely with DoD 8500.01's requirement to use standardized, vendor-supported interfaces. Both alternative approaches use mechanisms that could be considered non-standard from a compliance perspective.</p> </li> <li> <p>Least Privilege: The Kubernetes API Approach requires the least amount of privileges, aligning with SRG-APP-000142 and STIG V-242433. Both alternative approaches require additional privileges that could be difficult to justify in a compliance review.</p> </li> <li> <p>Container Isolation: The Kubernetes API Approach maintains proper container isolation, while the Sidecar Approach explicitly breaks process isolation, contradicting CIS Benchmark 5.2.4.</p> </li> <li> <p>Documentation Burden: From a compliance documentation perspective, the Kubernetes API Approach presents the lowest burden because it follows standard patterns that are well-understood by security assessors.</p> </li> </ol>"},{"location":"overview/security-compliance/#compliance-based-approach-selection","title":"Compliance-Based Approach Selection","text":"<p>Based on the above analysis, we make the following recommendations:</p>"},{"location":"overview/security-compliance/#for-dod-and-high-security-environments","title":"For DoD and High-Security Environments","text":"<p>Primary Recommendation: Kubernetes API Approach</p> <p>Rationale: - Uses standard, vendor-supported interfaces (DoD 8500.01 requirement) - Implements least privilege access (SRG-APP-000142, V-242433) - Utilizes proper RBAC (V-242423) - Avoids unnecessary pod modifications - Generates appropriate audit trails (V-242377) - Lowest compliance documentation burden</p> <p>Interim Solution for Distroless Containers: - If on Kubernetes 1.16+: Debug Container Approach (with documented risk acceptance) - If universal compatibility needed: Sidecar Container Approach with strict controls (with formal risk acceptance documentation)</p>"},{"location":"overview/security-compliance/#for-environments-with-specific-requirements","title":"For Environments with Specific Requirements","text":"Environment Compliance Focus Recommended Approach DoD Production DoD 8500.01, STIG Kubernetes API Approach Government NIST, FISMA Kubernetes API Approach Financial PCI DSS Kubernetes API Approach (preferred) or Sidecar with risk documentation Healthcare HIPAA Kubernetes API Approach (preferred) or Sidecar with risk documentation"},{"location":"overview/security-compliance/#implementation-guidelines-for-compliance","title":"Implementation Guidelines for Compliance","text":"<p>To ensure compliance with the security standards outlined above:</p> <ol> <li>RBAC Implementation:</li> <li>Implement minimal, pod-specific permissions</li> <li>Use time-bound tokens (15-30 minutes maximum)</li> <li> <p>Implement proper audit logging</p> </li> <li> <p>Scanner Deployment:</p> </li> <li>Deploy in isolated namespaces</li> <li>Implement network policies to restrict communications</li> <li> <p>Use non-privileged containers where possible</p> </li> <li> <p>Authentication and Authorization:</p> </li> <li>Use service accounts rather than user credentials</li> <li>Implement proper token management</li> <li> <p>Validate all access through Kubernetes RBAC</p> </li> <li> <p>Monitoring and Auditing:</p> </li> <li>Enable comprehensive audit logging</li> <li>Monitor scanner activity</li> <li>Maintain records of scan results for compliance reporting</li> </ol>"},{"location":"overview/security-compliance/#risk-documentation-requirements-for-alternative-approaches","title":"Risk Documentation Requirements for Alternative Approaches","text":"<p>When using alternative approaches (Debug Container or Sidecar Container) in environments with strict compliance requirements, proper risk documentation is essential. This section explains the documentation requirements for each alternative approach.</p>"},{"location":"overview/security-compliance/#debug-container-approach-risk-documentation","title":"Debug Container Approach Risk Documentation","text":"<p>If using the Debug Container Approach as an interim solution, document the following:</p> <ol> <li>Security Control Deviation:</li> <li>Document that this approach deviates from standard access interfaces</li> <li>Reference the specific compliance control exceptions (DoD 8500.01, SRG-APP-000142)</li> <li> <p>Include justification for using non-standard debug features</p> </li> <li> <p>Risk Assessment:</p> </li> <li>Document the additional attack surface introduced by ephemeral containers</li> <li>Describe mitigating controls implemented to address risks</li> <li> <p>Include timeframe for migration to Kubernetes API Approach once distroless support is complete</p> </li> <li> <p>Authorization:</p> </li> <li>Obtain formal approval from security authority for the exception</li> <li>Document approval with signature and expiration date</li> <li> <p>Schedule regular reviews of the exception status</p> </li> <li> <p>Enhanced Monitoring:</p> </li> <li>Document additional monitoring implemented for debug container access</li> <li>Include audit log review procedures specific to debug container usage</li> <li>Describe incident response procedures for potential misuse</li> </ol>"},{"location":"overview/security-compliance/#sidecar-container-approach-risk-documentation","title":"Sidecar Container Approach Risk Documentation","text":"<p>If using the Sidecar Container Approach, more extensive risk documentation is required:</p> <ol> <li>Security Control Deviation:</li> <li>Document explicit deviation from CIS Benchmark 5.2.4 (shared process namespaces)</li> <li>Reference all applicable control exceptions (CIS, STIG, SRG)</li> <li> <p>Provide detailed justification for breaking container isolation</p> </li> <li> <p>Technical Risk Assessment:</p> </li> <li>Document shared process namespace security implications</li> <li>Analyze potential for cross-container attacks</li> <li>Detail all mitigating controls implemented</li> <li> <p>Provide clear explanation of why this risk is acceptable</p> </li> <li> <p>Implementation Controls:</p> </li> <li>Document strict limitations on which pods can use shared namespaces</li> <li>Detail additional hardening of sidecar containers</li> <li>Describe additional security measures for scanner containerization</li> <li> <p>Explain heightened network isolation for pods with shared namespaces</p> </li> <li> <p>Formal Approval Chain:</p> </li> <li>Security review board documentation</li> <li>Chief Information Security Officer (CISO) approval</li> <li>System Owner authorization with signature</li> <li> <p>Documentation of regular risk reassessment schedule</p> </li> <li> <p>Migration Plan:</p> </li> <li>Document timeline for migration to Kubernetes API Approach</li> <li>Include milestones and trigger points for migration</li> <li>Assign responsible parties for monitoring for migration readiness</li> </ol> <p>The risk documentation should be comprehensive enough to demonstrate to auditors that the organization: 1. Is fully aware of compliance deviations 2. Has thoroughly assessed the risk 3. Has implemented appropriate mitigating controls 4. Has obtained proper authorization 5. Has a plan to migrate to a fully compliant solution</p>"},{"location":"overview/security-compliance/#conclusion-and-strategic-path-forward","title":"Conclusion and Strategic Path Forward","text":"<p>The Secure CINC Auditor Kubernetes Container Scanning solution, particularly using the Kubernetes API Approach, aligns most closely with DoD 8500.01, the DISA Container Platform SRG, the Kubernetes STIG, and CIS Kubernetes Benchmarks. This comprehensive compliance analysis demonstrates that:</p> <ol> <li> <p>The Kubernetes API Approach is the most compliant solution, using standard interfaces, least privilege access, and maintaining proper container isolation. It represents the only approach that fully satisfies all major compliance frameworks without requiring formal risk acceptance documentation.</p> </li> <li> <p>The Debug Container Approach, while useful as an interim solution for distroless containers, introduces compliance challenges related to non-standard interfaces and requires additional privileges. If used, it requires proper risk documentation and approval.</p> </li> <li> <p>The Sidecar Container Approach presents the most significant compliance challenges, particularly with its violation of container isolation principles in CIS Benchmark 5.2.4 and potential conflicts with DoD 8500.01's preference for standard interfaces. This approach requires the most extensive risk documentation if deployed in high-security environments.</p> </li> </ol>"},{"location":"overview/security-compliance/#strategic-path-forward","title":"Strategic Path Forward","text":"<p>Based on this comprehensive compliance analysis, we have identified a clear strategic path forward:</p> <ol> <li> <p>Enhance the train-k8s-container Plugin - The highest priority next step is enhancing the train-k8s-container plugin to support distroless containers through the Kubernetes API Approach. This represents the most strategic investment to achieve universal container scanning while maintaining full compliance with security standards.</p> </li> <li> <p>Apply Interim Solutions with Caution - For organizations that must scan distroless containers immediately, interim solutions should be implemented with proper risk documentation and clear timelines for migration to the enhanced Kubernetes API Approach.</p> </li> <li> <p>Plan for Enterprise-Scale Implementation - The Kubernetes API Approach, once enhanced with distroless support, provides the foundation for scalable, multi-team, and multi-project scanning across hundreds to thousands of containers with a wide range of InSpec/CINC profiles.</p> </li> </ol> <p>This analysis validates the preference for the Kubernetes API Approach in security-conscious environments and provides a clear strategic roadmap for comprehensive container security. The path forward prioritizes maintaining compliance while extending capabilities to all container types\u2014including distroless\u2014through enhancements to the Kubernetes API transport mechanism rather than through compliance-challenged alternatives.</p> <p>By following the implementation guidelines and risk documentation requirements provided in this document, organizations can deploy a container scanning solution that both identifies security issues in containers and maintains alignment with rigorous security standards and best practices, even at enterprise scale.</p>"},{"location":"overview/security-compliance/#references","title":"References","text":"<ol> <li>DoD Instruction 8500.01: https://www.esd.whs.mil/portals/54/documents/dd/issuances/dodi/850001_2014.pdf</li> <li>DISA Container Platform SRG: https://www.stigviewer.com/stig/container_platform_security_requirements_guide/</li> <li>Kubernetes STIG v2r2: https://www.tenable.com/audits/DISA_STIG_Kubernetes_v2r2</li> <li>CIS Kubernetes Benchmark: https://www.cisecurity.org/benchmark/kubernetes</li> </ol> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/security-risk-analysis/","title":"Security Risk Analysis","text":"<p>This document provides a comprehensive security analysis of the three container scanning approaches provided by this project. Each approach has different security characteristics, risks, and mitigations that are important to understand when selecting the appropriate method for your environment.</p>"},{"location":"overview/security-risk-analysis/#security-risk-overview","title":"Security Risk Overview","text":"Security Factor Standard Scanning Debug Container Sidecar Container Required Privileges Container access Ephemeral container creation Process namespace sharing Attack Surface Minimal Moderate Moderate Credential Exposure Minimal Minimal Minimal Isolation Level High Moderate Lower Persistence Risk None (stateless) None (ephemeral) Container lifetime"},{"location":"overview/security-risk-analysis/#detailed-risk-assessment","title":"Detailed Risk Assessment","text":""},{"location":"overview/security-risk-analysis/#1-standard-container-scanning-train-k8s-container","title":"1. Standard Container Scanning (train-k8s-container)","text":"<p>Security Model: Uses Kubernetes API to execute commands within target containers.</p>"},{"location":"overview/security-risk-analysis/#risks","title":"Risks:","text":"<ul> <li>Requires shell access within container</li> <li>Transport plugin requires minimal RBAC permissions</li> <li>Standard kubeconfig authentication process</li> </ul>"},{"location":"overview/security-risk-analysis/#mitigations","title":"Mitigations:","text":"<ul> <li>Uses time-limited service account tokens</li> <li>Strict RBAC permissions limit access to specific containers</li> <li>No additional infrastructure components</li> <li>Scan process executes and exits quickly</li> </ul>"},{"location":"overview/security-risk-analysis/#security-verdict-lowest-risk","title":"Security Verdict: Lowest Risk","text":"<p>This approach has the simplest security model with fewest points of failure. Limited to containers with shell access.</p>"},{"location":"overview/security-risk-analysis/#2-debug-container-approach","title":"2. Debug Container Approach","text":"<p>Security Model: Creates an ephemeral debug container attached to target pod's namespace.</p>"},{"location":"overview/security-risk-analysis/#risks_1","title":"Risks:","text":"<ul> <li>Requires permissions to create ephemeral containers</li> <li>Debug container has access to target container filesystem</li> <li>Ephemeral container must contain scanning tools</li> </ul>"},{"location":"overview/security-risk-analysis/#mitigations_1","title":"Mitigations:","text":"<ul> <li>Debug container is ephemeral (deleted after scan)</li> <li>Time-limited tokens for authentication</li> <li>RBAC limits which pods/containers can be targeted</li> <li>Filesystem access is read-only</li> </ul>"},{"location":"overview/security-risk-analysis/#security-verdict-moderate-risk","title":"Security Verdict: Moderate Risk","text":"<p>More complex security model but ephemeral nature limits persistence risks. Requires API server capability for ephemeral containers.</p>"},{"location":"overview/security-risk-analysis/#3-sidecar-container-approach","title":"3. Sidecar Container Approach","text":"<p>Security Model: Uses shared process namespace between containers in the same pod.</p>"},{"location":"overview/security-risk-analysis/#risks_2","title":"Risks:","text":"<ul> <li>Process namespace sharing allows visibility into target processes</li> <li>Scanner container persists during pod lifetime</li> <li>Direct filesystem access via /proc//root <li>Potential container escape techniques could be misused</li>"},{"location":"overview/security-risk-analysis/#mitigations_2","title":"Mitigations:","text":"<ul> <li>Strict RBAC permissions for sidecar deployment</li> <li>Non-privileged container runs in user namespace</li> <li>No host filesystem access required</li> <li>Read-only access to process filesystem</li> </ul>"},{"location":"overview/security-risk-analysis/#security-verdict-moderate-higher-risk","title":"Security Verdict: Moderate-Higher Risk","text":"<p>Most complex security model with more potential attack vectors. Shared process namespace is a powerful capability that should be carefully controlled.</p>"},{"location":"overview/security-risk-analysis/#risk-mitigation-strategies","title":"Risk Mitigation Strategies","text":""},{"location":"overview/security-risk-analysis/#universal-mitigations-all-approaches","title":"Universal Mitigations (All Approaches)","text":"<ol> <li>Least-Privilege RBAC</li> <li>Limit service accounts to minimum required permissions</li> <li>Use namespace-scoped roles, not cluster roles</li> <li> <p>Apply label selector constraints when possible</p> </li> <li> <p>Short-lived Credentials</p> </li> <li>Generate tokens with 15-minute (or less) expiration</li> <li>Revoke tokens after scan completion</li> <li> <p>Use token request API instead of long-lived secrets</p> </li> <li> <p>Scan Isolation</p> </li> <li>Run scans from isolated environments</li> <li>Limit network access during scanning</li> <li> <p>Use resource quotas to prevent DoS conditions</p> </li> <li> <p>Security Context</p> </li> <li>Run scanner containers as non-root users</li> <li>Apply seccomp and AppArmor profiles when possible</li> <li>Use read-only root filesystem for scanner containers</li> </ol>"},{"location":"overview/security-risk-analysis/#approach-specific-mitigations","title":"Approach-Specific Mitigations","text":""},{"location":"overview/security-risk-analysis/#standard-scanning","title":"Standard Scanning","text":"<ul> <li>Validate container integrity before scanning</li> <li>Limit scan duration with timeout controls</li> <li>Run scanner with minimal network access</li> </ul>"},{"location":"overview/security-risk-analysis/#debug-container","title":"Debug Container","text":"<ul> <li>Use dedicated, minimal scanner image</li> <li>Apply strict resource limits</li> <li>Automatically terminate debug containers after scan</li> <li>Monitor for unauthorized debug container creation</li> </ul>"},{"location":"overview/security-risk-analysis/#sidecar-container","title":"Sidecar Container","text":"<ul> <li>Implement process namespace security policies</li> <li>Use dedicated service accounts for sidecar deployment</li> <li>Consider short-lived pods dedicated to scanning</li> <li>Monitor for unauthorized sidecar injection</li> </ul>"},{"location":"overview/security-risk-analysis/#enterprise-security-recommendations","title":"Enterprise Security Recommendations","text":"<ol> <li>Scanning Governance</li> <li>Implement approval processes for scanning operations</li> <li>Log all scanning activities with detailed attribution</li> <li> <p>Setup alerts for unauthorized scanning attempts</p> </li> <li> <p>CI/CD Pipeline Controls</p> </li> <li>Ensure pipeline credentials are properly secured</li> <li>Validate scanner configuration before deployment</li> <li> <p>Scan the scanner images themselves for vulnerabilities</p> </li> <li> <p>Network Controls</p> </li> <li>Implement network policies to restrict scanner communication</li> <li>Consider running scanning operations in dedicated namespaces</li> <li> <p>Implement egress filtering for scanning components</p> </li> <li> <p>Monitoring and Auditing</p> </li> <li>Monitor for abnormal scanning patterns</li> <li>Audit scanner configuration changes</li> <li> <p>Review scanner logs for suspicious activities</p> </li> <li> <p>Image Security</p> </li> <li>Ensure scanner images are from trusted sources</li> <li>Regularly update scanner components</li> <li>Sign scanner images with trusted signatures</li> </ol>"},{"location":"overview/security-risk-analysis/#comparison-and-selection","title":"Comparison and Selection","text":"Consideration Best Approach Maximum Security Standard Scanning Universal Coverage Sidecar Container Feature Compatibility Debug Container Minimal Permissions Standard Scanning CI/CD Integration All approaches equal <p>Selection Framework: 1. If all containers have shell access \u2192 Use Standard Scanning 2. If using Kubernetes 1.16+ with ephemeral containers \u2192 Consider Debug Container approach 3. If need universal solution or restricted environments \u2192 Use Sidecar Container approach</p> <p>For critical or highly sensitive environments, consider implementing additional security controls regardless of chosen approach.</p>"},{"location":"overview/security-risk-analysis/#conclusion","title":"Conclusion","text":"<p>All three scanning approaches can be implemented securely with proper controls. The standard scanning approach provides the simplest security model with lowest risk, while the debug and sidecar approaches introduce additional capabilities at the cost of slightly increased security complexity. Organizations should select the approach that best balances their security requirements with their operational needs.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/security/","title":"Security Considerations","text":"<p>This document outlines the security design principles of the secure InSpec container scanning solution.</p>"},{"location":"overview/security/#core-security-principles","title":"Core Security Principles","text":""},{"location":"overview/security/#1-principle-of-least-privilege","title":"1. Principle of Least Privilege","text":"<p>All components follow the principle of least privilege:</p> <ul> <li>Service accounts have minimal permissions</li> <li>Roles are scoped to specific containers, not entire namespaces</li> <li>Only required verbs (\"get\", \"list\", \"create\" for exec) are granted</li> <li>No cluster-wide permissions are used</li> </ul>"},{"location":"overview/security/#2-ephemeral-credentials","title":"2. Ephemeral Credentials","text":"<ul> <li>Short-lived tokens are generated for each scan</li> <li>Token expiration can be configured (default: 1 hour)</li> <li>No long-lived tokens stored in CI/CD variables or config files</li> </ul>"},{"location":"overview/security/#3-resource-isolation","title":"3. Resource Isolation","text":"<ul> <li>Each scan operates within a specific namespace</li> <li>Only specifically named pods can be accessed</li> <li>No access to other cluster resources</li> <li>Option for dedicated namespaces per CI/CD pipeline</li> </ul>"},{"location":"overview/security/#4-secure-transport","title":"4. Secure Transport","text":"<ul> <li>All API communication uses TLS</li> <li>Kubeconfig files include the cluster's certificate authority data</li> <li>No insecure TLS options are enabled</li> </ul>"},{"location":"overview/security/#threat-mitigation","title":"Threat Mitigation","text":""},{"location":"overview/security/#mitigating-token-exposure","title":"Mitigating Token Exposure","text":"<p>If a token is exposed, the attacker can only:</p> <ol> <li>List pods in the target namespace</li> <li>Execute commands in specifically allowed containers</li> <li>View logs of specifically allowed containers</li> </ol> <p>The token cannot be used to:</p> <ol> <li>Create, modify, or delete any resources</li> <li>Access any other containers</li> <li>Access any cluster-wide information</li> <li>Escalate privileges</li> </ol>"},{"location":"overview/security/#preventing-lateral-movement","title":"Preventing Lateral Movement","text":"<p>The RBAC configuration prevents lateral movement:</p> <ul> <li>No access to secrets</li> <li>No access to configmaps</li> <li>No ability to create new resources</li> <li>No ability to modify service accounts</li> </ul>"},{"location":"overview/security/#security-recommendations","title":"Security Recommendations","text":"<ol> <li>Namespace Isolation: Use dedicated namespaces for your scanning infrastructure</li> <li>Regular Rotation: Regenerate service accounts and roles periodically</li> <li>CI/CD Variables: Mask any generated tokens in CI/CD variables</li> <li>Audit Logging: Enable audit logging in your Kubernetes cluster</li> <li>Time-bound Tokens: Configure token expiration appropriately for your security requirements</li> </ol>"},{"location":"overview/security/#compliance-considerations","title":"Compliance Considerations","text":"<p>This setup helps meet compliance requirements by:</p> <ul> <li>Providing audit trails of container scanning</li> <li>Implementing least privilege access</li> <li>Ensuring separation of duties</li> <li>Supporting temporary credential models</li> </ul> <p>For specific compliance frameworks (e.g., SOC2, FedRAMP), additional controls may be required as documented in the relevant compliance guides.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"overview/workflows/","title":"Workflow Diagrams","text":"<p>This document provides workflow diagrams to help visualize the scanning process and approaches used in the Kubernetes CINC Secure Scanner. The diagrams are created using Mermaid syntax and can be rendered in GitHub and GitLab markdown viewers.</p>"},{"location":"overview/workflows/#standard-container-scanning-workflow","title":"Standard Container Scanning Workflow","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Run CINC Auditor Scan]\n    E --&gt; F[Generate Reports]\n    F --&gt; G[Validate Against Thresholds]\n    G --&gt; H[Cleanup Resources]\n    H --&gt; I[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n    style G fill:#bfb,stroke:#333,stroke-width:2px\n    style I fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#distroless-container-scanning-approaches","title":"Distroless Container Scanning Approaches","text":""},{"location":"overview/workflows/#approach-1-modified-transport-plugin","title":"Approach 1: Modified Transport Plugin","text":"<p>This approach involves modifying the train-k8s-container plugin to support distroless containers by detecting when standard commands are unavailable and using alternative methods.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Run CINC Auditor with Modified Plugin]\n    E --&gt; F1{Commands Available?}\n    F1 --&gt;|Yes| G1[Use Standard Commands]\n    F1 --&gt;|No| H1[Use Alternative Approaches]\n    G1 --&gt; I[Execute Controls]\n    H1 --&gt; I\n    I --&gt; J[Generate Reports]\n    J --&gt; K[Validate Against Thresholds]\n    K --&gt; L[Cleanup Resources]\n    L --&gt; M[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n    style F1 fill:#fbb,stroke:#333,stroke-width:2px\n    style K fill:#bfb,stroke:#333,stroke-width:2px\n    style M fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#approach-2-debug-container-with-cinc-auditor","title":"Approach 2: Debug Container with CINC Auditor","text":"<p>This approach involves creating a debug container that mounts the target container's filesystem and scans it using chroot.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Deploy Debug Container]\n    E --&gt; F[Mount Target Filesystem]\n    F --&gt; G[Run CINC Auditor in Debug Container]\n    G --&gt; H[Chroot into Target Filesystem]\n    H --&gt; I[Execute Controls]\n    I --&gt; J[Bridge Results to Host]\n    J --&gt; K[Generate Reports]\n    K --&gt; L[Validate Against Thresholds]\n    L --&gt; M[Cleanup Resources]\n    M --&gt; N[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n    style G fill:#bbf,stroke:#333,stroke-width:2px\n    style L fill:#bfb,stroke:#333,stroke-width:2px\n    style N fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#cicd-integration-workflow","title":"CI/CD Integration Workflow","text":"<pre><code>flowchart TD\n    A[Start CI/CD Pipeline] --&gt; B[Deploy Test Container]\n    B --&gt; C[Create Minimal RBAC]\n    C --&gt; D[Generate Short-lived Token]\n    D --&gt; E[Create Scanner Kubeconfig]\n    E --&gt; F{Container Type}\n    F --&gt;|Standard| G1[Run Standard Scan]\n    F --&gt;|Distroless| G2[Run Distroless Scan]\n    G1 --&gt; H[Generate Reports]\n    G2 --&gt; H\n    H --&gt; I[Validate Against Thresholds]\n    I --&gt; J{Threshold Met?}\n    J --&gt;|Yes| K[Mark as Passed]\n    J --&gt;|No| L[Mark as Failed]\n    K --&gt; M[Cleanup Resources]\n    L --&gt; M\n    M --&gt; N[End Pipeline]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#fbb,stroke:#333,stroke-width:2px\n    style J fill:#fbb,stroke:#333,stroke-width:2px\n    style K fill:#bfb,stroke:#333,stroke-width:2px\n    style L fill:#fbb,stroke:#333,stroke-width:2px\n    style N fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#minikube-setup-and-scanning-workflow","title":"Minikube Setup and Scanning Workflow","text":"<p>This diagram shows the complete workflow from setting up a Minikube environment to scanning containers.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Run setup-minikube.sh]\n    B --&gt; C{With Distroless Flag?}\n\n    C --&gt;|No| D1[Create Standard Minikube Cluster]\n    C --&gt;|Yes| D2[Create Minikube with Distroless Support]\n\n    D1 --&gt; E1[Deploy Standard RBAC]\n    D2 --&gt; E2[Deploy Extended RBAC with Ephemeral Container Support]\n\n    E1 --&gt; F1[Deploy Test Containers]\n    E2 --&gt; F2[Deploy Test Containers + Distroless Containers]\n\n    F1 --&gt; G1[Generate Scanner Kubeconfig]\n    F2 --&gt; G2[Generate Scanner Kubeconfig]\n\n    G1 --&gt; H1[Run scan-container.sh]\n    G2 --&gt; H2{Container Type?}\n\n    H2 --&gt;|Standard| H3[Run scan-container.sh]\n    H2 --&gt;|Distroless| H4[Run scan-distroless-container.sh]\n\n    H1 --&gt; I1[Generate Reports]\n    H3 --&gt; I1\n    H4 --&gt; I1\n\n    I1 --&gt; J[Validate with SAF-CLI]\n    J --&gt; K[Clean Up Resources]\n    K --&gt; L[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px\n    style H2 fill:#fbb,stroke:#333,stroke-width:2px\n    style J fill:#bfb,stroke:#333,stroke-width:2px\n    style L fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#cinc-auditor-sidecar-container-approach","title":"CINC Auditor Sidecar Container Approach","text":"<p>This diagram shows how a CINC Auditor sidecar container could be implemented for scanning.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Deploy Pod with Sidecar]\n\n    subgraph \"Target Pod\"\n    C1[Target Container]\n    C2[CINC Auditor Sidecar]\n    end\n\n    B --&gt; D[Mount Shared Volume]\n    D --&gt; E[Share Process Namespace]\n    E --&gt; F[Run CINC Auditor in Sidecar]\n    F --&gt; G[Access Target Filesystem via /proc]\n    G --&gt; H[Execute Compliance Controls]\n    H --&gt; I[Write Results to Shared Volume]\n    I --&gt; J[Container or Scheduler Retrieves Results]\n    J --&gt; K[Generate Reports]\n    K --&gt; L[Validate Against Thresholds]\n    L --&gt; M[End]\n\n    C1 --- C2\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C1 fill:#fbb,stroke:#333,stroke-width:2px\n    style C2 fill:#bbf,stroke:#333,stroke-width:2px\n    style F fill:#bbf,stroke:#333,stroke-width:2px\n    style L fill:#bfb,stroke:#333,stroke-width:2px\n    style M fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>This diagram shows a detailed GitHub Actions workflow for container scanning.</p> <pre><code>flowchart TD\n    A[Start GitHub Action] --&gt; B[Check Out Code]\n\n    B --&gt; C[Setup Minikube Cluster]\n    C --&gt; D[Deploy RBAC Resources]\n    D --&gt; E[Build and Deploy Test Containers]\n\n    E --&gt; F{Container Type Decision}\n    F --&gt;|Standard| G1[Run Standard Scan Job]\n    F --&gt;|Distroless| G2[Run Distroless Scan Job]\n\n    subgraph \"Standard Scan Job\"\n    H1[Generate Scanner Kubeconfig]\n    H1 --&gt; I1[Execute CINC Auditor]\n    I1 --&gt; J1[Process Results]\n    end\n\n    subgraph \"Distroless Scan Job\"\n    H2[Generate Scanner Kubeconfig]\n    H2 --&gt; I2[Deploy Debug Container]\n    I2 --&gt; J2[Execute CINC in Debug Container]\n    J2 --&gt; K2[Process Results]\n    end\n\n    G1 --&gt; H1\n    G2 --&gt; H2\n\n    J1 --&gt; L[Validate Results Against Threshold]\n    K2 --&gt; L\n\n    L --&gt; M{Threshold Met?}\n    M --&gt;|Yes| N1[Mark Step as Successful]\n    M --&gt;|No| N2[Mark Step as Failed]\n\n    N1 --&gt; O[Clean Up Resources]\n    N2 --&gt; O\n    O --&gt; P[Upload Results as Artifacts]\n    P --&gt; Q[End GitHub Action]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#fbb,stroke:#333,stroke-width:2px\n    style M fill:#fbb,stroke:#333,stroke-width:2px\n    style N1 fill:#bfb,stroke:#333,stroke-width:2px\n    style N2 fill:#fbb,stroke:#333,stroke-width:2px\n    style Q fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"overview/workflows/#gitlab-ci-integration-with-services","title":"GitLab CI Integration with Services","text":"<p>This diagram shows how GitLab CI Services could be integrated into our scanning workflow.</p> <pre><code>flowchart TD\n    A[Start GitLab CI Pipeline] --&gt; B[Deploy Target Container]\n\n    subgraph \"GitLab CI Services\"\n    S1[CINC Auditor Service]\n    S2[SAF CLI Service]\n    end\n\n    B --&gt; C[Create Minimal RBAC]\n    C --&gt; D[Generate Short-lived Token]\n    D --&gt; E[Create Scanner Kubeconfig]\n    E --&gt; F[Run Scan Job]\n\n    S1 --&gt; F\n    S2 --&gt; F\n\n    F --&gt; G[Generate Reports]\n    G --&gt; H[Validate Against Thresholds]\n    H --&gt; I{Threshold Met?}\n    I --&gt;|Yes| J[Mark as Passed]\n    I --&gt;|No| K[Mark as Failed]\n    J --&gt; L[Cleanup Resources]\n    K --&gt; L\n    L --&gt; M[End Pipeline]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style S1 fill:#bbf,stroke:#333,stroke-width:2px\n    style S2 fill:#bbf,stroke:#333,stroke-width:2px\n    style I fill:#fbb,stroke:#333,stroke-width:2px\n    style J fill:#bfb,stroke:#333,stroke-width:2px\n    style K fill:#fbb,stroke:#333,stroke-width:2px\n    style M fill:#f9f,stroke:#333,stroke-width:2px</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"project/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"project/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"project/changelog/#added","title":"Added","text":"<ul> <li>Initial project structure and core functionality</li> <li>Three container scanning approaches:</li> <li>Kubernetes API Approach (train-k8s-container plugin)</li> <li>Debug Container Approach (ephemeral containers)</li> <li>Sidecar Container Approach (shared process namespace)</li> <li>Helm charts for all scanning approaches</li> <li>CI/CD pipeline examples for GitHub Actions and GitLab</li> <li>Comprehensive documentation with approach comparisons and decision matrices</li> </ul>"},{"location":"project/changelog/#changed","title":"Changed","text":"<ul> <li>2025-03-19: Documentation consistency enhancement</li> <li>Added consistent strategic priority statements about Kubernetes API Approach in key files</li> <li>Standardized terminology from \"InSpec\" to \"CINC Auditor\" across all documents</li> <li>Fixed broken relative links to use absolute paths (e.g., <code>/docs/overview/workflows.md</code>)</li> <li>Updated path references to reflect current directory structure</li> <li>Added clear labeling of interim approaches vs enterprise-recommended solutions</li> <li>Standardized approach naming (Kubernetes API Approach, Debug Container Approach, Sidecar Container Approach)</li> <li>Added explicit strategic priority statements for train-k8s-container plugin enhancement </li> <li>Updated integration documentation to consistently recommend Kubernetes API Approach</li> <li>Fixed cross-references between GitHub Actions and GitLab CI documentation</li> <li>Corrected examples' directory paths and workflow references</li> <li>Updated TASKS.md to highlight highest priority implementation items</li> <li>Added consistent \"Strategic Priority\" banners to key technical documents</li> <li>Enhanced integration guides with consistent approach recommendations</li> <li>Fixed repository name references in quickstart documentation</li> <li>Updated index files for GitHub and GitLab examples with consistent messaging</li> <li>Added strategic implementation path to plugin-modifications.md</li> </ul>"},{"location":"project/changelog/#fixed","title":"Fixed","text":"<ul> <li>Broken links in documentation</li> <li>Directory structure inconsistencies</li> <li>MkDocs build warnings with proper exclude_docs configuration</li> </ul>"},{"location":"project/changelog/#security","title":"Security","text":"<ul> <li>Enhanced documentation of security compliance considerations</li> <li>Clarified risk documentation requirements for alternative approaches</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"project/tasks/","title":"Project Tasks Tracker","text":""},{"location":"project/tasks/#core-development-tasks","title":"Core Development Tasks","text":"<ul> <li> Implement three distroless container scanning approaches</li> <li> HIGHEST PRIORITY: Approach 1 (Kubernetes API Approach): Modify the train-k8s-container plugin (Enterprise Recommended)<ul> <li> Add ephemeral container detection and fallback</li> <li> Implement direct filesystem access through debug container</li> <li> Modify connection and exec client classes</li> </ul> </li> <li> Approach 2 (Debug Container Approach): CINC Auditor in debug container with chroot (Interim solution)<ul> <li> Create specialized debug container with CINC Auditor pre-installed</li> <li> Implement chroot-based filesystem access to target container</li> <li> Bridge results back to host system</li> </ul> </li> <li> <p> Approach 3 (Sidecar Container Approach): Sidecar container with shared process namespace (Interim solution)</p> <ul> <li> Create script for sidecar deployment and scanning</li> <li> Implement process detection and filesystem access</li> <li> Integration with CI/CD pipelines</li> </ul> </li> <li> <p> Complete Helm chart templates</p> </li> <li> Finish configmap templates for remaining components</li> <li> Create helpers and utilities</li> <li> Ensure proper chart dependencies</li> <li> <p> Create Helm chart for sidecar container approach</p> </li> <li> <p> Testing with container types</p> </li> <li> Test with Google's distroless images</li> <li> Test with custom minimalist containers</li> <li> Test with different language runtimes (Go, Java, Python)</li> </ul>"},{"location":"project/tasks/#documentation-tasks","title":"Documentation Tasks","text":"<ul> <li> Create detailed documentation showing script/command equivalence</li> <li> Document what <code>setup-minikube.sh</code> does vs. direct minikube/kubectl commands</li> <li> Document what <code>scan-container.sh</code> does vs. direct kubectl/inspec commands</li> <li> Document what <code>scan-distroless-container.sh</code> does vs. direct ephemeral container commands</li> <li> <p> Create a <code>/docs/direct-commands.md</code> file with examples</p> </li> <li> <p> Update main README.md</p> </li> <li> Clarify the two approaches (shell scripts vs. Helm)</li> <li> Add installation requirements</li> <li> <p> Improve usage examples</p> </li> <li> <p> Create comprehensive documentation</p> </li> <li> Design architecture and flow diagrams showing container interactions</li> <li> Create ASCII text-based versions of all diagrams for terminal viewing</li> <li> Develop Executive Summary for stakeholders and decision makers</li> <li> Create detailed security risk analysis for all three approaches</li> <li> Document risk mitigation strategies and security considerations</li> <li> Create Enterprise Integration Analysis (scalability, maintenance, UX)</li> <li> Develop comprehensive decision matrix for approach selection</li> </ul>"},{"location":"project/tasks/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li> Create CI/CD pipeline examples</li> <li> GitHub Actions workflows for container scanning<ul> <li> Dynamic RBAC scanning workflow</li> <li> Existing cluster scanning workflow</li> </ul> </li> <li> GitLab CI pipelines for container scanning<ul> <li> Dynamic RBAC scanning pipeline</li> <li> Existing cluster scanning pipeline</li> </ul> </li> <li> <p> Jenkins pipeline example (optional)</p> </li> <li> <p> Create CI/CD examples for all distroless approaches</p> </li> <li> HIGHEST PRIORITY: GitHub Actions workflow for Approach 1 (Kubernetes API Approach)</li> <li> GitHub Actions workflow for Approach 2 (Debug Container Approach) - interim solution</li> <li> GitHub Actions workflow for Approach 3 (Sidecar Container Approach) - interim solution</li> <li> HIGHEST PRIORITY: GitLab CI configuration for Approach 1 (Kubernetes API Approach)</li> <li> GitLab CI configuration for Approach 2 (Debug Container Approach) - interim solution</li> <li> GitLab CI configuration for Approach 3 (Sidecar Container Approach) - interim solution</li> <li> <p> GitLab CI with Services for Approach 3 (Sidecar Container Approach) - interim solution</p> </li> <li> <p> Additional Security Scanning Integration Examples</p> </li> <li> OWASP ZAP integration for web application security scanning<ul> <li> Create GitHub Actions example for ZAP scanning integration</li> <li> Create GitLab CI pipeline examples for ZAP integration</li> <li> Create GitLab Services configuration for ZAP scanning</li> <li> Document integration points between container and application scanning</li> </ul> </li> <li> Create examples showing combined container/application security reporting</li> </ul>"},{"location":"project/tasks/#saf-cli-integration","title":"SAF CLI Integration","text":"<ul> <li> Implement threshold configuration files</li> <li> Create sample threshold YAML files</li> <li> Document threshold configuration options</li> <li> <p> Add examples for pass/fail criteria</p> </li> <li> <p> Add SAF CLI integration examples</p> </li> <li> Show how to process scan results with SAF CLI</li> <li> Demonstrate compliance reporting</li> <li> Document threshold checks</li> </ul>"},{"location":"project/tasks/#validation-and-refinement","title":"Validation and Refinement","text":"<ul> <li> Security review</li> <li> Audit RBAC permissions for least privilege</li> <li> Review token generation and management</li> <li> Assess network security model</li> <li> <p> Compare security implications of both distroless approaches</p> </li> <li> <p> Performance optimization</p> </li> <li> Measure and optimize scan times for both approaches</li> <li> Reduce resource usage during scans</li> <li> Improve startup time</li> <li> <p> Benchmark and compare performance between approaches</p> </li> <li> <p> Comparative analysis</p> </li> <li> Document pros and cons of each distroless approach</li> <li> Create decision matrix for approach selection</li> <li> Provide usage recommendations based on different scenarios</li> </ul>"},{"location":"project/tasks/#documentation-system","title":"Documentation System","text":"<ul> <li> Implement MkDocs with Material theme</li> <li> Create mkdocs.yml configuration</li> <li> Set up GitHub Actions for documentation deployment</li> <li> Create enhanced navigation hierarchy</li> <li> Add requirements.txt for Python dependencies</li> <li> Update README.md with documentation usage instructions</li> <li> <p> Update terminology for consistent naming of approaches</p> </li> <li> <p> Documentation Refinement</p> </li> <li> Standardize approach naming across all documents</li> <li> Create Helm Chart documentation section</li> <li> Integrate ASCII diagram approach comparison into main documentation</li> <li> Fix approach-mapping.md links to workflow YAML files </li> <li> Ensure consistent messaging about the Kubernetes API Approach as enterprise-recommended solution</li> <li> Add clear strategic priority statements across all key documentation</li> <li> Add development and testing documentation section</li> <li> Conduct comprehensive documentation review for coherence and flow</li> </ul>"},{"location":"project/tasks/#administrative","title":"Administrative","text":"<ul> <li> Project release preparation</li> <li> Version tagging (v1.0.0)</li> <li> Release notes with key features and capabilities</li> <li> Comprehensive documentation website with MkDocs</li> <li> Final review of all example code and scripts</li> <li> Create project logo and branding assets</li> <li> Prepare demonstration of all three scanning approaches</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"project/archive/ascii-diagrams/","title":"ASCII Text-Based Workflow and Architecture Diagrams","text":"<p>This document provides ASCII text-based diagrams for the key workflows and architectures in our project. These diagrams are intended to complement the Mermaid diagrams and provide a more accessible alternative that can be viewed directly in a terminal or without rendering.</p>"},{"location":"project/archive/ascii-diagrams/#minikube-architecture","title":"Minikube Architecture","text":"<pre><code>+-----------------------------------------------------------------------+\n|                                                                       |\n|                          MINIKUBE CLUSTER                             |\n|                                                                       |\n|  +-------------------------+        +-------------------------+        |\n|  |                         |        |                         |        |\n|  |      CONTROL NODE       |        |      WORKER NODE 1      |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |  kube-apiserver   |  |        |  | Target Containers |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |       etcd        |  |        |  |   Scanner Pods    |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  +-------------------------+        +-------------------------+        |\n|                                                                       |\n|                                                                       |\n|                           +-------------------------+                  |\n|                           |                         |                  |\n|                           |      WORKER NODE 2      |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |  Debug Containers |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |   Sidecar Pods    |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           +-------------------------+                  |\n|                                                                       |\n+-----------------------------------------------------------------------+\n                        |                |                |\n                        |                |                |\n                        v                v                v\n          +------------------+  +------------------+  +------------------+\n          |                  |  |                  |  |                  |\n          |   CINC Profiles  |  | Service Accounts |  |     SAF CLI      |\n          |   (Compliance    |  |    and RBAC      |  |  (Reporting &amp;    |\n          |    Controls)     |  |  (Access Control)|  |  Thresholds)     |\n          |                  |  |                  |  |                  |\n          +------------------+  +------------------+  +------------------+\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#standard-container-scanning-workflow-approach-1","title":"Standard Container Scanning Workflow (Approach 1)","text":"<pre><code>              START STANDARD CONTAINER SCANNING\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|              STEP 1: SETUP &amp; PREPARATION                 |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |     Identify     |---------&gt;|  Create RBAC and   |    |\n|  |     Target       |          |  Service Account   |    |\n|  |     Container    |          |                    |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Generate Short-lived         |\n|                      |       Security Token               |\n|                      |                                    |\n|                      +------------------------------------+\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Create Restricted            |\n|                      |       Kubeconfig File              |\n|                      |                                    |\n|                      +------------------------------------+\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|                STEP 2: SCANNING EXECUTION                |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Run CINC      |          |    Process with    |    |\n|  |    Auditor with  |&lt;---------|    SAF CLI &amp;       |    |\n|  |    k8s-container |          |    Check Threshold |    |\n|  |    Transport     |          |                    |    |\n|  +------------------+          +--------------------+    |\n|          |                                              |\n|          v                                              |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Generate      |---------&gt;|    Clean up RBAC   |    |\n|  |    Reports and   |          |    &amp; Service       |    |\n|  |    Validations   |          |    Account         |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n                       SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#distroless-container-debug-container-approach-approach-2","title":"Distroless Container - Debug Container Approach (Approach 2)","text":"<pre><code>         START DEBUG CONTAINER APPROACH FOR DISTROLESS CONTAINERS\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 1: ATTACH DEBUG CONTAINER                    |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Identify        |-------&gt;|  Create Ephemeral       |     |\n|  |    Distroless      |        |  Debug Container with   |     |\n|  |    Target Container|        |  kubectl debug command  |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Deploy CINC Auditor in       |     |\n|                       |     Ephemeral Debug Container    |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER  |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Chroot to       |-------&gt;|  Run CINC Auditor       |     |\n|  |    Target Container|        |  Against Target         |     |\n|  |    Filesystem      |        |  Container Root         |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Export Scan Results to       |     |\n|                       |     Host System                  |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Process Results |-------&gt;|  Terminate Debug        |     |\n|  |    with SAF CLI    |        |  Container &amp; Clean Up   |     |\n|  |    Threshold Check |        |  Resources              |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#sidecar-container-approach-approach-3","title":"Sidecar Container Approach (Approach 3)","text":""},{"location":"project/archive/ascii-diagrams/#ascii-diagram-legacy","title":"ASCII Diagram (Legacy)","text":"<pre><code>            START SIDECAR CONTAINER APPROACH FOR SCANNING\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 1: DEPLOY POD WITH SIDECAR                  |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Deploy Target    |------&gt;|   Deploy Scanner       |       |\n|  |   Container in     |       |   Sidecar Container    |       |\n|  |   Kubernetes Pod   |       |   in Same Pod          |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Enable Shared Process Namespace      ||\n|                      |   Between Containers in Pod            ||\n|                      |   (shareProcessNamespace: true)        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 2: PERFORM SCAN USING SIDECAR               |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Sidecar Finds    |------&gt;|   Access Target        |       |\n|  |   Target Process   |       |   Filesystem via       |       |\n|  |   Using 'ps'       |       |   /proc/PID/root       |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Run CINC Auditor Against             ||\n|                      |   Target Container's Filesystem        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                          |                     |\n|                                          v                     |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Store Results    |------&gt;|   Process Results with |       |\n|  |   in Shared        |       |   SAF CLI &amp; Validate   |       |\n|  |   Volume           |       |   Against Threshold    |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Retrieve Results from Sidecar        ||\n|                      |   via kubectl cp or Volume Mount       ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#mermaid-diagram-wcag-compliant","title":"Mermaid Diagram (WCAG Compliant)","text":"<pre><code>flowchart TD\n    start([Start]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        deploy_target[\"Deploy Target Container in Kubernetes Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container in Same Pod\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace Between Containers\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        find_process[\"Sidecar Finds Target Process Using 'ps'\"] --&gt; access_fs[\"Access Target Filesystem via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target Container's Filesystem\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI &amp; Validate Against Threshold\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar via kubectl cp or Volume Mount\"]\n    end\n\n    step2 --&gt; complete([Scan Complete])\n\n    %% Applying WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step grouping styling\n    style step1 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000\n    style step2 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000</code></pre>"},{"location":"project/archive/ascii-diagrams/#modified-transport-plugin-approach-approach-1-enterprise","title":"Modified Transport Plugin Approach (Approach 1 - Enterprise)","text":"<pre><code>            START MODIFIED TRANSPORT PLUGIN APPROACH\n                            |\n                            v\n+------------------------------------------------------------+\n|                                                            |\n|          STEP 1: CONTAINER DETECTION AND SETUP             |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Target         |-------&gt;|  Modified            |       |\n|  |  Container      |        |  train-k8s-container |       |\n|  |  Identification |        |  Plugin (Enhanced)   |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                       |                    |\n|                                       v                    |\n|                    +----------------------------------+    |\n|                    |                                  |    |\n|                    |  Auto-Detect if Container        |    |\n|                    |  is Distroless (No Shell)        |    |\n|                    |                                  |    |\n|                    +----------------------------------+    |\n|                             /           \\                  |\n|                            /             \\                 |\n|                           v               v                |\n| +-------------------------+   +---------------------------+|\n| |                         |   |                           ||\n| |  If Regular Container:  |   |  If Distroless Container: ||\n| |  Use Standard Direct    |   |  Automatically Use Debug  ||\n| |  Exec Connection        |   |  Container Fallback       ||\n| |                         |   |                           ||\n| +-------------------------+   +---------------------------+|\n|          |                                   |             |\n|          |                                   v             |\n|          |                    +---------------------------+|\n|          |                    |                           ||\n|          |                    |  Create Temporary Debug   ||\n|          |                    |  Container Automatically  ||\n|          |                    |                           ||\n|          |                    +---------------------------+|\n|          |                                   |             |\n+------------------------------------------------------------+\n                   |                          |\n                   v                          v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 2: SCANNING EXECUTION                    |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Run CINC       |        |  Process Results     |       |\n|  |  Auditor Scan   |-------&gt;|  with SAF CLI &amp;      |       |\n|  |  Transparently  |        |  Check Thresholds    |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 3: CLEANUP (FOR DISTROLESS)              |\n|                                                            |\n|                    +---------------------------+           |\n|                    |                           |           |\n|                    |  If Debug Container Used: |           |\n|                    |  Terminate and Clean Up   |           |\n|                    |  Resources                |           |\n|                    |                           |           |\n|                    +---------------------------+           |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n                          SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#gitlab-ci-pipeline-with-services","title":"GitLab CI Pipeline with Services","text":"<pre><code>                    GITLAB CI PIPELINE WITH SERVICES\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: PIPELINE SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Start CINC Auditor  |        |\n|  |  Pipeline Begins  |         |  Scanner as a        |        |\n|  |                   |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Deploy Target Container in        |    |\n|                      |  Kubernetes Cluster                |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SECURITY SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Create RBAC &amp;    |--------&gt;|  Generate Short-lived|        |\n|  |  Service Account  |         |  Security Token      |        |\n|  |  in Cluster       |         |                      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Create Restricted kubeconfig      |    |\n|                      |  with Minimal Permissions          |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: SCANNING &amp; REPORTING               |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Execute Scan     |--------&gt;|  Process Results     |        |\n|  |  in Service       |         |  with SAF CLI in     |        |\n|  |  Container        |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Copy Results from Service         |    |\n|                      |  to Pipeline &amp; Generate Reports    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Clean Up Resources in Kubernetes  |    |\n|                      |  (Pods, Service Accounts, RBAC)    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#gitlab-ci-sidecar-approach","title":"GitLab CI Sidecar Approach","text":"<pre><code>                    GITLAB CI SIDECAR APPROACH\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: DEPLOYMENT                         |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Deploy Pod with    |        |\n|  |  Pipeline Begins  |         |  Target Container   |        |\n|  |                   |         |  and Scanner Sidecar|        |\n|  |                   |         |  in Same Pod        |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Enable Shared Process Namespace   |    |\n|                      |  Between Target and Scanner        |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SCANNING                           |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Sidecar Scanner  |--------&gt;|  Scan Target via    |        |\n|  |  Container Starts |         |  /proc Filesystem   |        |\n|  |                   |         |  Access Method      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Store Results in Shared Volume   |    |\n|                      |  and Process with SAF CLI         |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: RESULTS PROCESSING                 |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Retrieve Scan    |--------&gt;|  Process Results    |        |\n|  |  Results from     |         |  and Generate       |        |\n|  |  Sidecar Container|         |  Reports            |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Upload Results as Pipeline       |    |\n|                      |  Artifacts &amp; Clean Up Resources   |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>                   GITHUB ACTIONS WORKFLOW\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster (Kind)         |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Install CINC Auditor &amp;              |    |\n|                    | train-k8s-container Plugin          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: TARGET DEPLOYMENT                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Target    |-------&gt;| Create RBAC &amp;          |        |\n| | Container in     |        | Service Account        |        |\n| | Kubernetes       |        | for Scanner            |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Short-lived Token &amp;        |    |\n|                    | Create Restricted kubeconfig       |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: SCAN &amp; REPORT                       |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Run CINC Auditor |-------&gt;| Process Results with   |        |\n| | Against Target   |        | SAF CLI &amp; Threshold    |        |\n| | Container        |        | Validation             |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Reports, Upload as         |    |\n|                    | GitHub Artifacts &amp; Clean Up         |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#github-actions-sidecar-approach","title":"GitHub Actions Sidecar Approach","text":"<pre><code>                GITHUB ACTIONS SIDECAR APPROACH\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster using Kind     |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Build Scanner Container Image      |    |\n|                    | with CINC Auditor &amp; SAF CLI        |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: DEPLOYMENT &amp; SCANNING               |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Pod with  |-------&gt;| Configure Shared       |        |\n| | Target Container |        | Process Namespace      |        |\n| | and Scanner      |        | Between Containers     |        |\n| | Sidecar          |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Scanner Sidecar Automatically       |    |\n|                    | Finds &amp; Scans Target Container     |    |\n|                    | via /proc/PID/root Access          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: RESULTS PROCESSING                  |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Wait for Scan    |-------&gt;| Retrieve Results       |        |\n| | Completion       |        | from Sidecar Container |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Process Results  |-------&gt;| Upload Results         |        |\n| | with SAF CLI &amp;   |        | as GitHub Artifacts    |        |\n| | Generate Reports |        | &amp; Clean Up Resources   |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#end-to-end-security-architecture","title":"End-to-End Security Architecture","text":"<pre><code>                   SECURITY ARCHITECTURE\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                SECURITY PRINCIPLES                   |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Principle of   |-----&gt;|   Short-lived    |      |\n|  |   Least          |      |   Token          |      |\n|  |   Privilege      |      |   Generation     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Namespace      |&lt;----&gt;|   No Permanent   |      |\n|  |   Isolation      |      |   Elevated       |      |\n|  |                  |      |   Privileges     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|               IMPLEMENTATION CONTROLS                |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  | Resource-specific|&lt;----&gt;|   Security       |      |\n|  | RBAC Controls    |      |   First Design   |      |\n|  | (Pod-specific)   |      |                  |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Audit Trail    |&lt;----&gt;|   Automatic      |      |\n|  |   of Scan        |      |   Cleanup After  |      |\n|  |   Access         |      |   Scan Completion|      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                COMPLIANCE VALIDATION                 |\n|                                                      |\n|  +--------------------------------------------------+|\n|  |                                                  ||\n|  |            Threshold-based Compliance            ||\n|  |            Validation with SAF CLI               ||\n|  |                                                  ||\n|  |       * Minimum compliance percentage            ||\n|  |       * Maximum critical/high failures           ||\n|  |       * Enforced in CI/CD pipelines              ||\n|  |                                                  ||\n|  +--------------------------------------------------+|\n|                                                      |\n+------------------------------------------------------+\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#comparison-of-approaches","title":"Comparison of Approaches","text":"<pre><code>+---------------------------------------------------------------------+\n|                                                                     |\n|                        APPROACH COMPARISON                          |\n|                                                                     |\n+---------------------------------------------------------------------+\n|                                                                     |\n|                        KEY CHARACTERISTICS                          |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Works with all      |                |             |                |\n| Kubernetes versions |      No        |     No      |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| Works with          |                |             |                |\n| existing pods       |      Yes       |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| User experience     |    Seamless    |   Complex   |    Medium      |\n| complexity          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Implementation      |    Complex     |   Medium    |    Simple      |\n| difficulty          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                      TECHNICAL REQUIREMENTS                         |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Special K8s         |                |             |                |\n| features needed     |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Ephemeral container |                |             |                |\n| support required    |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Can scan distroless |                |             |                |\n| containers          |      Yes       |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| CI/CD               |                |             |                |\n| integration ease    |    Simple      |   Complex   |    Medium      |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                           IMPLEMENTATION STATUS                     |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Development         | In Progress    | Complete    | Complete       |\n| status              |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Security            |                |             |                |\n| footprint           |    Medium      |   High      |    Medium      |\n+---------------------+----------------+-------------+----------------+\n| Recommended         | Enterprise     | Advanced    | Universal      |\n| usage               | environments   | users       | compatibility  |\n+---------------------+----------------+-------------+----------------+\n| GitHub Actions      |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| GitLab CI           |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n</code></pre> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"rbac/","title":"RBAC Configuration Guide","text":"<p>This guide explains the Role-Based Access Control (RBAC) configuration used for secure container scanning with InSpec.</p>"},{"location":"rbac/#overview","title":"Overview","text":"<p>The RBAC configuration consists of three key components:</p> <ol> <li>Role: Defines the permissions allowed for scanning containers</li> <li>ServiceAccount: The identity used to access the Kubernetes API</li> <li>RoleBinding: Links the Role to the ServiceAccount</li> </ol>"},{"location":"rbac/#basic-rbac-configuration","title":"Basic RBAC Configuration","text":""},{"location":"rbac/#role","title":"Role","text":"<p>The basic Role grants minimal permissions required for container scanning:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"inspec-target\"]  # Only allows exec into this pod\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"inspec-target\"]  # Only allows logs from this pod\n</code></pre> <p>Key security aspects: - <code>pods</code> access is limited to <code>get</code> and <code>list</code> (no create/modify/delete) - <code>pods/exec</code> is limited to <code>create</code> only for specific pods by name - <code>pods/log</code> is limited to <code>get</code> only for specific pods by name</p>"},{"location":"rbac/#rolebinding","title":"RoleBinding","text":"<p>The RoleBinding links the Role to the ServiceAccount:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-user\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"rbac/#dynamic-rbac-configurations","title":"Dynamic RBAC Configurations","text":"<p>For CI/CD environments, you can create dynamic RBAC configurations:</p>"},{"location":"rbac/#label-based-roles","title":"Label-Based Roles","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-dynamic-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n</code></pre> <p>Combined with a RoleBinding that includes a label selector in the subjects section.</p>"},{"location":"rbac/#temporary-roles","title":"Temporary Roles","text":"<p>For single-use scans, create temporary roles with a unique identifier:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-scan-role-${RUN_ID}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre>"},{"location":"rbac/#additional-rbac-strategies","title":"Additional RBAC Strategies","text":"<p>See the following documentation for more specialized RBAC configurations:</p> <ul> <li>Namespace-Isolated RBAC: Configure RBAC permissions isolated to specific namespaces</li> <li>Label-Based Access Control: Secures pods using label selectors</li> <li>CI/CD Dynamic Configuration: Demonstrated in the CI/CD examples</li> </ul>"},{"location":"rbac/#references","title":"References","text":"<ul> <li>Kubernetes RBAC Documentation</li> <li>RBAC Good Practices</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"rbac/label-based/","title":"Label-Based RBAC Configuration","text":"<p>This document describes how to implement label-based RBAC for more flexible container scanning access.</p>"},{"location":"rbac/label-based/#overview","title":"Overview","text":"<p>Label-based RBAC allows you to grant access to containers based on their labels rather than their names. This approach is more flexible in dynamic environments where pod names change frequently.</p>"},{"location":"rbac/label-based/#implementation","title":"Implementation","text":""},{"location":"rbac/label-based/#1-pod-labeling","title":"1. Pod Labeling","text":"<p>Label your target pods with a designated label:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\n  namespace: production\n  labels:\n    security-scan: \"enabled\"  # Label for scan selection\n</code></pre>"},{"location":"rbac/label-based/#2-role-configuration","title":"2. Role Configuration","text":"<p>Create a role that doesn't specify resourceNames, but instead relies on the label selector:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-label-role\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n</code></pre> <p>Note: This role allows access to all pods in the namespace. The limitation will come from how we use this role.</p>"},{"location":"rbac/label-based/#3-script-based-access-control","title":"3. Script-Based Access Control","text":"<p>Use a script to: 1. Find pods with the target label 2. Generate a temporary kubeconfig 3. Run InSpec only against those pods</p> <pre><code>#!/bin/bash\nNAMESPACE=\"production\"\nLABEL_SELECTOR=\"security-scan=enabled\"\n\n# Find pods with the label\nPODS=$(kubectl get pods -n ${NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n\nif [ -z \"$PODS\" ]; then\n  echo \"No pods found with label ${LABEL_SELECTOR} in namespace ${NAMESPACE}\"\n  exit 1\nfi\n\n# Generate token for service account\nTOKEN=$(kubectl create token scanner-sa -n ${NAMESPACE})\n\n# Create kubeconfig\n# [... kubeconfig generation code ...]\n\n# For each pod, run the scan\nfor POD in $PODS; do\n  CONTAINER=$(kubectl get pod ${POD} -n ${NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n  echo \"Scanning ${NAMESPACE}/${POD}/${CONTAINER}\"\n  KUBECONFIG=./kubeconfig.yaml inspec exec ./profiles/container \\\n    -t k8s-container://${NAMESPACE}/${POD}/${CONTAINER}\ndone\n</code></pre>"},{"location":"rbac/label-based/#advanced-labelselector-with-subjectaccessreview","title":"Advanced: LabelSelector with SubjectAccessReview","text":"<p>For more robust access control, you can use a Kubernetes ValidatingWebhook to perform SubjectAccessReview based on pod labels. This approach requires additional components:</p> <ol> <li>A ValidatingWebhookConfiguration</li> <li>A webhook server that performs label checks</li> <li>Integration with your authentication system</li> </ol> <p>For a full implementation, see the advanced label RBAC section below.</p>"},{"location":"rbac/label-based/#security-considerations","title":"Security Considerations","text":"<p>Label-based RBAC is more permissive than name-based RBAC:</p> <ol> <li>If a pod is mislabeled, it becomes accessible</li> <li>Users can potentially scan any pod with the target label</li> <li>More complex to audit and trace</li> </ol> <p>Mitigations:</p> <ol> <li>Strict control over who can apply labels to pods</li> <li>Regular auditing of pod labels</li> <li>Isolated namespaces for different sensitivity levels</li> <li>Time-bound access tokens</li> </ol>"},{"location":"rbac/label-based/#example-yaml","title":"Example YAML","text":"<p>A complete example configuration is available in the repository under <code>kubernetes/templates/label-rbac.yaml</code>.</p> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"service-accounts/","title":"Service Account Configuration","text":"<p>This guide covers the setup and management of service accounts for secure container scanning.</p>"},{"location":"service-accounts/#basic-service-account-setup","title":"Basic Service Account Setup","text":"<p>Create a dedicated service account for InSpec scanning:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: inspec-scanner\n  namespace: inspec-test\n  labels:\n    app: inspec-scanner\n    purpose: security-scanning\n</code></pre>"},{"location":"service-accounts/#serviceaccount-naming-conventions","title":"ServiceAccount Naming Conventions","text":"<p>Consider using a consistent naming convention for scanner service accounts:</p> <ul> <li>Dedicated namespace: <code>inspec-scanner</code></li> <li>CI/CD pipelines: <code>inspec-scanner-{pipeline-id}</code></li> <li>Team-specific: <code>inspec-scanner-{team-name}</code></li> </ul>"},{"location":"service-accounts/#service-account-annotations","title":"Service Account Annotations","text":"<p>You can add annotations to service accounts for additional metadata:</p> <pre><code>metadata:\n  annotations:\n    description: \"Service account for InSpec container scanning\"\n    owner: \"security-team\"\n    expires: \"2025-12-31\"\n</code></pre>"},{"location":"service-accounts/#token-related-serviceaccount-features","title":"Token-Related ServiceAccount Features","text":"<p>In Kubernetes 1.24+, service accounts no longer automatically get long-lived token secrets. You need to explicitly create tokens.</p>"},{"location":"service-accounts/#for-short-lived-tokens-recommended","title":"For Short-Lived Tokens (Recommended)","text":"<p>Use the Kubernetes API to create short-lived tokens:</p> <pre><code>kubectl create token inspec-scanner -n inspec-test\n</code></pre> <p>This creates a token with a default expiration of 1 hour.</p>"},{"location":"service-accounts/#for-long-lived-tokens-use-with-caution","title":"For Long-Lived Tokens (Use With Caution)","text":"<p>Create a token secret with an explicit reference to the service account:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: inspec-scanner-token\n  namespace: inspec-test\n  annotations:\n    kubernetes.io/service-account.name: inspec-scanner\ntype: kubernetes.io/service-account-token\n</code></pre>"},{"location":"service-accounts/#service-account-auditing","title":"Service Account Auditing","text":"<p>Regularly audit your service accounts:</p> <pre><code># List all service accounts\nkubectl get serviceaccounts --all-namespaces\n\n# Check token secrets for a service account\nkubectl get secrets -n inspec-test -o json | jq '.items[] | select(.metadata.annotations.\"kubernetes.io/service-account.name\"==\"inspec-scanner\")'\n</code></pre>"},{"location":"service-accounts/#rotating-service-accounts","title":"Rotating Service Accounts","text":"<p>For enhanced security, rotate service accounts regularly:</p> <pre><code># Create a new service account\nkubectl apply -f new-scanner-sa.yaml\n\n# Update role bindings to reference the new account\nkubectl apply -f updated-rolebinding.yaml\n\n# Delete the old service account\nkubectl delete serviceaccount old-scanner-sa -n inspec-test\n</code></pre>"},{"location":"service-accounts/#security-considerations","title":"Security Considerations","text":"<ol> <li>Use dedicated service accounts - never reuse default accounts</li> <li>Limit the number of service accounts with scanning capabilities</li> <li>Regularly review and rotate service accounts</li> <li>Use namespaces to isolate service accounts by sensitivity level</li> <li>Consider using Kubernetes PodSecurityPolicies (or Pod Security Admission in 1.25+) to constrain service account usage</li> </ol>"},{"location":"service-accounts/#references","title":"References","text":"<ul> <li>Kubernetes Service Accounts Documentation</li> <li>Managing Service Account Tokens</li> <li>Kubernetes Secret Types</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"testing/","title":"Testing Guide","text":"<p>This document provides a comprehensive guide to testing the Secure CINC Auditor Kubernetes Container Scanning solution, covering test methodology, test environments, and recommended testing practices.</p>"},{"location":"testing/#testing-overview","title":"Testing Overview","text":"<p>The testing strategy for this container scanning solution covers several key aspects:</p> <ol> <li>Functional Testing: Validating that the scanning tools correctly identify security issues</li> <li>Integration Testing: Ensuring the scanning tools work with various Kubernetes environments</li> <li>Security Testing: Verifying that the scanning implementation itself doesn't introduce security risks</li> <li>Performance Testing: Measuring scan times and resource utilization</li> <li>Compliance Testing: Validating that scanning results meet compliance requirements</li> </ol>"},{"location":"testing/#testing-environments","title":"Testing Environments","text":"<p>We recommend testing in the following environments:</p> <ul> <li>Local Minikube: For initial functional testing and development</li> <li>GitLab CI/GitHub Actions: For CI/CD pipeline integration testing</li> <li>Production-like Kubernetes: For final validation before production deployment</li> </ul>"},{"location":"testing/#testing-prerequisites","title":"Testing Prerequisites","text":"<p>Before running tests, ensure you have:</p> <ol> <li>A Kubernetes Cluster: </li> <li>For local testing: minikube with at least 2 nodes</li> <li> <p>For production testing: A Kubernetes cluster with appropriate access</p> </li> <li> <p>Required Tools:</p> </li> <li>kubectl</li> <li>CINC Auditor/InSpec</li> <li>SAF CLI for results processing</li> <li> <p>Appropriate container images for testing (standard and distroless)</p> </li> <li> <p>Access Credentials:</p> </li> <li>RBAC permissions to create service accounts, roles, and pods</li> <li>Ability to create tokens for testing</li> </ol>"},{"location":"testing/#test-categories","title":"Test Categories","text":""},{"location":"testing/#1-functional-testing","title":"1. Functional Testing","text":"<p>Tests that validate the core scanning functionality works correctly.</p> <pre><code># Basic functional test example\n./scripts/setup-minikube.sh --with-distroless\n./scripts/scan-container.sh namespace-name pod-name container-name\n</code></pre> <p>Verify that: - Scan executes without errors - Results are properly formatted - Issues are correctly identified</p>"},{"location":"testing/#2-integration-testing","title":"2. Integration Testing","text":"<p>Tests that validate integration with various Kubernetes environments and CI/CD systems.</p>"},{"location":"testing/#cicd-integration-tests","title":"CI/CD Integration Tests","text":"<p>For each CI/CD system (GitHub Actions, GitLab CI): - Verify automated scanning works in pipelines - Validate pipeline success/failure based on scan results - Check threshold validation works correctly</p>"},{"location":"testing/#environment-integration-tests","title":"Environment Integration Tests","text":"<p>For different Kubernetes distributions: - Standard Kubernetes (various versions) - AKS, EKS, GKE - OpenShift</p>"},{"location":"testing/#3-security-testing","title":"3. Security Testing","text":"<p>Tests that validate the security of the scanning implementation.</p>"},{"location":"testing/#rbac-testing","title":"RBAC Testing","text":"<pre><code># Test with restricted permissions\n./scripts/scan-container.sh namespace-name pod-name container-name --restricted-rbac\n</code></pre> <p>Verify: - Scanner operates with minimal permissions - Timeouts work correctly for tokens - Resources are properly cleaned up after scan</p>"},{"location":"testing/#container-security-testing","title":"Container Security Testing","text":"<p>For each scanning approach: - Validate that scanning doesn't introduce vulnerabilities - Verify isolation between scanner and target containers - Test scanner with various security contexts</p>"},{"location":"testing/#4-performance-testing","title":"4. Performance Testing","text":"<p>Tests that measure scanning performance.</p> <pre><code># Performance test with timing\ntime ./scripts/scan-container.sh namespace-name pod-name container-name\n</code></pre> <p>Measurements: - Scan initialization time - Scan execution time - Resource utilization (CPU, memory) - Scaling tests (scanning multiple containers)</p>"},{"location":"testing/#5-compliance-testing","title":"5. Compliance Testing","text":"<p>Tests that validate compliance requirements are met.</p> <pre><code># Compliance validation with thresholds\n./scripts/scan-container.sh namespace-name pod-name container-name --threshold-file threshold.yml\n</code></pre> <p>Verify: - Compliance checks match required standards - Threshold validation works correctly - Reports include necessary compliance data</p>"},{"location":"testing/#test-matrix-for-container-types","title":"Test Matrix for Container Types","text":"Container Type Standard Scanning Distroless Scanning Sidecar Scanning Base Images Required Required Required Java Applications Required Required Required Node.js Applications Required Required Required Python Applications Required Required Required Go Applications Required Required Required Multi-stage Builds Required Required Required Custom Distroless Required Required Required"},{"location":"testing/#automated-test-suite","title":"Automated Test Suite","text":"<p>We provide automated tests to validate core functionality:</p> <pre><code># Run automated test suite\n./scripts/run-tests.sh\n</code></pre> <p>The automated test suite includes: - Unit tests for helper scripts - Integration tests for scanning functionality - Regression tests for known issues</p>"},{"location":"testing/#test-environments-setup","title":"Test Environments Setup","text":""},{"location":"testing/#local-minikube-setup-for-testing","title":"Local Minikube Setup for Testing","text":"<pre><code># Set up minikube for testing\n./scripts/setup-minikube.sh --with-distroless\n\n# Verify minikube setup\nkubectl get nodes\nkubectl get pods -A\n</code></pre>"},{"location":"testing/#cicd-environment-setup","title":"CI/CD Environment Setup","text":"<p>For GitHub Actions: - Use the provided GitHub Actions workflows in <code>github-workflows/</code> - Configure with appropriate secrets and environment variables</p> <p>For GitLab CI: - Use the provided GitLab CI pipelines in <code>gitlab-examples/</code> - Configure with appropriate variables and runners</p>"},{"location":"testing/#troubleshooting-tests","title":"Troubleshooting Tests","text":"<p>Common issues and resolutions:</p> <ol> <li>Scanner can't access containers:</li> <li>Verify RBAC permissions are correct</li> <li>Check service account configuration</li> <li> <p>Ensure token is valid and not expired</p> </li> <li> <p>Distroless scanning fails:</p> </li> <li>Verify Kubernetes version supports ephemeral containers</li> <li>Check debug container configuration</li> <li> <p>Confirm sidecar container has shared process namespace</p> </li> <li> <p>Threshold validation fails:</p> </li> <li>Check threshold file syntax</li> <li>Verify SAF CLI is correctly configured</li> <li>Review scan results for unexpected failures</li> </ol>"},{"location":"testing/#reference-test-cases","title":"Reference Test Cases","text":""},{"location":"testing/#standard-container-test-case","title":"Standard Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: standard-test-pod\n  labels:\n    app: test-app\nspec:\n  containers:\n  - name: standard-container\n    image: nginx:latest\n    ports:\n    - containerPort: 80\n</code></pre>"},{"location":"testing/#distroless-container-test-case","title":"Distroless Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: distroless-test-pod\n  labels:\n    app: test-app\nspec:\n  containers:\n  - name: distroless-container\n    image: gcr.io/distroless/java:11\n    command: [\"java\", \"-version\"]\n</code></pre>"},{"location":"testing/#sidecar-container-test-case","title":"Sidecar Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: sidecar-test-pod\n  labels:\n    app: test-app\nspec:\n  shareProcessNamespace: true\n  containers:\n  - name: target-container\n    image: gcr.io/distroless/java:11\n    command: [\"java\", \"-version\"]\n  - name: scanner-sidecar\n    image: cinc/auditor:latest\n    securityContext:\n      privileged: false\n    volumeMounts:\n    - name: results-volume\n      mountPath: /results\n  volumes:\n  - name: results-volume\n    emptyDir: {}\n</code></pre>"},{"location":"testing/#next-steps","title":"Next Steps","text":"<p>After completing testing, refer to:</p> <ul> <li>Deployment Scenarios for production deployment</li> <li>Threshold Configuration for compliance settings</li> <li>CI/CD Integration for pipeline setup</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"tokens/","title":"Token Management","text":"<p>This guide covers the creation, usage, and lifecycle management of Kubernetes tokens for secure InSpec scanning.</p>"},{"location":"tokens/#token-types","title":"Token Types","text":""},{"location":"tokens/#short-lived-tokens-recommended","title":"Short-Lived Tokens (Recommended)","text":"<p>Short-lived tokens are created on-demand and expire automatically:</p> <pre><code># Create a token with default expiration (1 hour)\nkubectl create token inspec-scanner -n inspec-test\n\n# Create a token with custom expiration\nkubectl create token inspec-scanner -n inspec-test --duration=30m\n</code></pre> <p>Benefits: - Automatic expiration - No token storage/cleanup required - Reduced risk if token is exposed</p>"},{"location":"tokens/#bound-service-account-tokens","title":"Bound Service Account Tokens","text":"<p>For automated pipelines, you can create bound service account tokens:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: scanner-token\n  namespace: inspec-test\n  annotations:\n    kubernetes.io/service-account.name: inspec-scanner\n    kubernetes.io/service-account.expiration: \"86400\"  # 24 hours in seconds\ntype: kubernetes.io/service-account-token\n</code></pre> <p>Benefits: - Configurable expiration - Can be rotated with Kubernetes secrets rotation - Compatible with older Kubernetes tooling</p>"},{"location":"tokens/#token-generation-in-cicd-pipelines","title":"Token Generation in CI/CD Pipelines","text":""},{"location":"tokens/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>stages:\n  - scan\n\nvariables:\n  KUBE_NAMESPACE: inspec-test\n\ncreate_token:\n  stage: scan\n  script:\n    - TOKEN=$(kubectl create token inspec-scanner -n $KUBE_NAMESPACE)\n    - echo \"SCAN_TOKEN=$TOKEN\" &gt;&gt; scan_credentials.env\n  artifacts:\n    reports:\n      dotenv: scan_credentials.env\n\nrun_scan:\n  stage: scan\n  needs: [create_token]\n  script:\n    - echo \"$SCAN_TOKEN\" &gt; token.txt\n    - ./run_scan.sh token.txt\n  artifacts:\n    reports:\n      scan: scan-results.json\n</code></pre>"},{"location":"tokens/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Generate Token\n        id: generate-token\n        run: |\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test)\n          echo \"::set-output name=token::$TOKEN\"\n\n      - name: Run Scan\n        run: |\n          echo \"${{ steps.generate-token.outputs.token }}\" &gt; token.txt\n          ./run_scan.sh token.txt\n</code></pre>"},{"location":"tokens/#token-security-best-practices","title":"Token Security Best Practices","text":"<ol> <li>Short Expiration: Use the shortest practical token expiration</li> <li>Just-in-Time Creation: Generate tokens when needed, not in advance</li> <li>Secure Storage: Store tokens in secure CI/CD variables or secrets</li> <li>Mask in Logs: Ensure tokens are masked in CI/CD logs</li> <li>Single-Use: Use each token only once, then discard</li> <li>Audience Restriction: If possible, restrict token audience</li> </ol>"},{"location":"tokens/#token-expiration-testing","title":"Token Expiration Testing","text":"<p>Test token expiration to ensure your system handles it gracefully:</p> <pre><code># Create a token with short expiration\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=30s)\n\n# Save token to a file\necho \"$TOKEN\" &gt; test-token.txt\n\n# Use token immediately (should work)\nKUBECONFIG=&lt;your-config&gt; K8S_AUTH_TOKEN=$(cat test-token.txt) inspec exec ...\n\n# Wait for expiration\nsleep 35\n\n# Try again (should fail)\nKUBECONFIG=&lt;your-config&gt; K8S_AUTH_TOKEN=$(cat test-token.txt) inspec exec ...\n</code></pre>"},{"location":"tokens/#token-audit-and-troubleshooting","title":"Token Audit and Troubleshooting","text":""},{"location":"tokens/#decoding-tokens","title":"Decoding Tokens","text":"<pre><code># Get the token\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test)\n\n# Decode token payload (middle section)\necho $TOKEN | cut -d. -f2 | base64 -d 2&gt;/dev/null | jq .\n</code></pre> <p>This shows token metadata including: - Expiration time - Subject (service account) - Audience - Issuer</p>"},{"location":"tokens/#verifying-token-privileges","title":"Verifying Token Privileges","text":"<pre><code># Use auth can-i to check permissions with a token\nkubectl auth can-i get pods --namespace=inspec-test --token=$TOKEN\n\n# Check specific resource access\nkubectl auth can-i create pods/exec --namespace=inspec-test --token=$TOKEN --resource-name=target-pod\n</code></pre>"},{"location":"tokens/#references","title":"References","text":"<ul> <li>Kubernetes Authentication Documentation</li> <li>Managing Service Account Tokens</li> <li>Token Request API</li> </ul> <p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"}]}