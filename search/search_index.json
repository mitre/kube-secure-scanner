{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kube Secure Scanner","text":"Release Preview v0.90 <p>This is an ongoing joint community research effort and is currently at Release Preview (v0.90). Some examples, automation, pipelines, and scripts are still in the process of being fully tested and validated. We'll be releasing updates in v0.9.x versions as we work toward a stable v1.0.0 release.</p> View Project on GitHub \u2197"},{"location":"#overview","title":"Overview","text":"<p>A flexible, security-focused framework for scanning containers in Kubernetes environments with multiple scanning engines. Initially built with CINC Auditor (open source InSpec), the platform provides secure RBAC configurations, multiple scanning approaches, and comprehensive CI/CD integration.</p> <p>Key Features: - Multiple scanner engine support (extensible framework) - Three container scanning approaches for all Kubernetes environments - Specialized security controls with least-privilege design - Comprehensive documentation and integration examples - CI/CD pipeline integration for GitHub Actions and GitLab</p> <p>Quick Links: Quick Start Guide Approach Comparison GitHub Actions Integration GitLab CI Integration</p> <p>[CINC]: CINC Is Not Chef [SAF]: Security Automation Framework [RBAC]: Role-Based Access Control [K8s]: Kubernetes *[API]: Application Programming Interface</p>"},{"location":"#choose-your-path","title":"Choose Your Path","text":"<ul> <li> <p> Security Leader / Decision Maker</p> <p>Resources for security leaders making technology decisions:</p> <ul> <li>Executive Summary</li> <li>Security Analysis</li> <li>Compliance Documentation</li> <li>Enterprise Integration Analysis</li> </ul> </li> <li> <p> Security Professional / Compliance Officer</p> <p>Detailed security guidance and compliance information:</p> <ul> <li>Security Overview</li> <li>Security Principles</li> <li>Approach Security Comparison</li> <li>Compliance Frameworks</li> </ul> </li> <li> <p> DevOps Engineer / Implementer</p> <p>Implementation guidance and CI/CD integration examples:</p> <ul> <li>Quick Start Guide</li> <li>Approach Comparison</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> </ul> </li> <li> <p> Solution Architect</p> <p>Technical architecture and design documentation:</p> <ul> <li>Technical Overview</li> <li>Architecture Diagrams</li> <li>Workflow Processes</li> <li>Approach Decision Matrix</li> </ul> </li> </ul>"},{"location":"#scanning-approaches","title":"Scanning Approaches","text":"<p>This project offers three distinct approaches for container scanning, designed to accommodate various container types and Kubernetes environments:</p> Kubernetes API Approach (Recommended)Debug Container ApproachSidecar Container Approach <p>Direct API-based scanning approach. Most scalable solution with seamless integration.</p> <ul> <li>Works with standard containers now</li> <li>Universal solution once distroless support is complete</li> <li>No configuration changes to existing pods</li> <li>Flexible scanner engine support (roadmap)</li> </ul> <p>Learn More</p> <p>Uses ephemeral debug containers with chroot-based scanning for distroless containers.</p> <ul> <li>Requires Kubernetes 1.16+ with ephemeral containers</li> <li>Works with existing deployed containers</li> <li>Good for testing environments</li> <li>Compatible with multiple scanner engines</li> </ul> <p>Learn More</p> <p>Scanner sidecar container with shared process namespace for any container type.</p> <ul> <li>Works with any Kubernetes cluster</li> <li>Universal compatibility</li> <li>Must be deployed alongside target container</li> <li>Supports pluggable scanner engines</li> </ul> <p>Learn More</p>"},{"location":"#key-security-benefits","title":"Key Security Benefits","text":"<ul> <li> <p> Least Privilege Access   Restrict scanning to specific containers only</p> </li> <li> <p> Dynamic Access Control   Create temporary, targeted access for scanning</p> </li> <li> <p> Time-limited Tokens   Default 15-minute lifetime for security</p> </li> <li> <p> Namespace Isolation   Contain permissions within specific namespaces</p> </li> <li> <p> SAF CLI Integration   Validate scan results against compliance thresholds</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The fastest way to get started is with our Quick Start guide, which walks you through: - Setting up a testing environment - Deploying the scanning infrastructure - Running container scans - Validating compliance results</p> <p>Quick Start Guide Site Index</p> <p>Security Overview Documentation Map</p>"},{"location":"#project-roadmap","title":"Project Roadmap","text":"<p>Our active roadmap includes the following key initiatives for the path to v1.0:</p> <ul> <li> <p> NSA/CISA Kubernetes Hardening Guide</p> <p>Incorporate analysis and recommendations from the NSA/CISA Kubernetes Hardening Guide.</p> <ul> <li>Analyze official guidance</li> <li>Reference KubeArmor implementation examples</li> <li>Map hardening requirements to our implementation</li> </ul> </li> <li> <p>:material-container-outline:{ .lg .middle } Enhanced Container Support</p> <p>Expand scanning capabilities to new container types.</p> <ul> <li>Complete API-based direct scanning approach</li> <li>Improve scan performance for specialized containers</li> <li>Add universal distroless container support</li> </ul> </li> <li> <p> Multi-Scanner Engine Architecture</p> <p>Implement framework for integrating multiple scanning engines:</p> <ul> <li>Scanner engine plugin interface</li> <li>Results normalization layer</li> <li>Support for vulnerability scanners and SBOM generators</li> <li>Scanner configuration standardization</li> </ul> </li> </ul>"},{"location":"#core-documentation","title":"Core Documentation","text":"<ul> <li> <p> Approach Comparison</p> <p>Compare the three scanning approaches side-by-side</p> <p> View comparison</p> </li> <li> <p> Workflow Diagrams</p> <p>Visual workflows for all scanning approaches</p> <p> View diagrams</p> </li> <li> <p> Security Analysis</p> <p>Comprehensive security analysis with risk mitigation</p> <p> View analysis</p> </li> <li> <p> Decision Matrix</p> <p>Selection guide for the right approach</p> <p> View matrix</p> </li> </ul>"},{"location":"common-abbreviations/","title":"Common Abbreviations","text":"<p>This page provides a reference of common abbreviations and terminology used throughout the documentation.</p>"},{"location":"common-abbreviations/#kubernetes-container-security-abbreviations","title":"Kubernetes &amp; Container Security Abbreviations","text":"<ul> <li>K8s: Kubernetes</li> <li>RBAC: Role-Based Access Control</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> </ul>"},{"location":"common-abbreviations/#security-scanning-compliance","title":"Security Scanning &amp; Compliance","text":"<ul> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> </ul>"},{"location":"common-abbreviations/#security-standards-organizations","title":"Security Standards &amp; Organizations","text":"<ul> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>NSA: National Security Agency</li> <li>CISA: Cybersecurity and Infrastructure Security Agency</li> <li>DISA: Defense Information Systems Agency</li> <li>SRG: Security Requirements Guide</li> <li>STIG: Security Technical Implementation Guide</li> </ul>"},{"location":"common-abbreviations/#web-technologies","title":"Web Technologies","text":"<ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> </ul>"},{"location":"quickstart-guide/","title":"Quick Start Guide","text":"<p>This guide will help you get up and running with secure Kubernetes container scanning quickly.</p>"},{"location":"quickstart-guide/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li> Kubernetes cluster (version 1.24+)</li> <li> kubectl installed and configured</li> <li> CINC Auditor with train-k8s-container plugin</li> <li> Helm (optional, for chart deployment)</li> <li> MITRE SAF CLI (optional, for threshold validation)</li> </ul>"},{"location":"quickstart-guide/#quick-setup-automated","title":"Quick Setup (Automated)","text":"<p>For the fastest possible setup, use our automated script:</p> <pre><code># Basic setup with a 3-node minikube cluster\n./kubernetes-scripts/setup-minikube.sh\n\n# For distroless container scanning support\n./kubernetes-scripts/setup-minikube.sh --with-distroless\n\n# For a customized setup\n./kubernetes-scripts/setup-minikube.sh --nodes=2 --driver=virtualbox\n</code></pre> <p>The script will:</p> <ol> <li>Create a multi-node minikube cluster</li> <li>Deploy the necessary RBAC and service accounts</li> <li>Set up test pods</li> <li>Generate a kubeconfig file</li> <li>Provide instructions for running scans</li> </ol>"},{"location":"site-index/","title":"Site Index","text":"<p>A comprehensive index of all documentation in the Kube CINC Secure Scanner project.</p>"},{"location":"site-index/#getting-started","title":"Getting Started","text":"<ul> <li> <p> Introduction</p> <ul> <li>Executive Summary - Brief overview for decision makers</li> <li>Quick Start Guide - The fastest way to get up and running</li> <li>Technical Overview - High-level technical introduction</li> </ul> </li> <li> <p> Core Concepts</p> <ul> <li>Approach Comparison - Side-by-side comparison of scanning methods</li> <li>Decision Matrix - Choose the right approach for your environment</li> <li>Security Principles - Core security design principles</li> </ul> </li> </ul>"},{"location":"site-index/#approaches","title":"Approaches","text":"Kubernetes API ApproachDebug Container ApproachSidecar Container ApproachHelper Scripts <p>Standard Container Scanning</p> <p>The Kubernetes API approach uses the train-k8s-container plugin to perform direct API-based scanning of containers.</p> <ul> <li>Overview - Introduction to direct API scanning</li> <li>Implementation - How to implement API-based scanning</li> <li>Limitations - Current limitations</li> <li>RBAC Configuration - Role-based access control setup</li> </ul> <p>Distroless Container Scanning</p> <p>The Debug Container approach uses ephemeral debug containers to scan distroless containers.</p> <ul> <li>Overview - Introduction to debug container scanning</li> <li>Distroless Basics - Understanding distroless containers</li> <li>Implementation - How to implement debug container scanning</li> </ul> <p>Universal Container Scanning</p> <p>The Sidecar Container approach uses a shared process namespace to scan any container type.</p> <ul> <li>Overview - Introduction to sidecar container scanning</li> <li>Implementation - How to implement sidecar container scanning</li> <li>Pod Configuration - Configure pods for sidecar scanning</li> <li>Retrieving Results - Get scan results from sidecar containers</li> </ul> <p>Scripted Automation</p> <p>Helper scripts provide automated workflows to simplify scanner operations.</p> <ul> <li>Overview - Introduction to helper scripts</li> <li>Available Scripts - List of available scripts</li> <li>Scripts vs. Commands - When to use scripts vs. direct commands</li> </ul>"},{"location":"site-index/#architecture","title":"Architecture","text":""},{"location":"site-index/#components","title":"Components","text":"<ul> <li>Core Components - Essential system components</li> <li>Security Components - Security-specific components</li> <li>Communication - Component communication patterns</li> </ul>"},{"location":"site-index/#diagrams","title":"Diagrams","text":"<ul> <li>Component Diagrams - Visual component representations</li> <li>Deployment Diagrams - Deployment architecture</li> <li>Workflow Diagrams - Workflow visualizations</li> </ul>"},{"location":"site-index/#workflows","title":"Workflows","text":"<ul> <li>Standard Container - Standard container scanning workflow</li> <li>Distroless Container - Distroless container scanning workflow</li> <li>Sidecar Container - Sidecar container scanning workflow</li> <li>Security Workflows - Security-focused workflows</li> </ul>"},{"location":"site-index/#deployment","title":"Deployment","text":"<ul> <li>Script Deployment - Script-based deployment</li> <li>Helm Deployment - Helm chart deployment</li> <li>CI/CD Deployment - CI/CD pipeline deployment</li> </ul>"},{"location":"site-index/#integrations","title":"Integrations","text":"<ul> <li>GitLab CI - GitLab CI/CD integration</li> <li>GitHub Actions - GitHub Actions integration</li> <li>GitLab Services - GitLab Services integration</li> <li>Custom Integrations - Building custom integrations</li> </ul>"},{"location":"site-index/#security","title":"Security","text":""},{"location":"site-index/#principles","title":"Principles","text":"<ul> <li>Least Privilege - Implementing least privilege access</li> <li>Ephemeral Credentials - Using short-lived credentials</li> <li>Resource Isolation - Isolating security resources</li> <li>Secure Transport - Secure data transfer</li> </ul>"},{"location":"site-index/#risk-analysis","title":"Risk Analysis","text":"<ul> <li>Risk Model - Security risk model overview</li> <li>Kubernetes API Risks - Kubernetes API approach risks</li> <li>Debug Container Risks - Debug container approach risks</li> <li>Sidecar Container Risks - Sidecar container approach risks</li> <li>Mitigations - Risk mitigation strategies</li> </ul>"},{"location":"site-index/#threat-model","title":"Threat Model","text":"<ul> <li>Attack Vectors - Potential attack vectors</li> <li>Lateral Movement - Preventing lateral movement</li> <li>Token Exposure - Preventing token exposure</li> <li>Threat Mitigations - Threat mitigation strategies</li> </ul>"},{"location":"site-index/#compliance","title":"Compliance","text":"<ul> <li>Approach Comparison - Security approach comparison</li> <li>Risk Documentation - Documentation for compliance</li> <li>CIS Benchmarks - CIS benchmark compliance</li> <li>Kubernetes STIG - Kubernetes STIG compliance</li> <li>DISA SRG - DISA SRG compliance</li> <li>DoD 8500.01 - DoD 8500.01 compliance</li> </ul>"},{"location":"site-index/#configuration","title":"Configuration","text":""},{"location":"site-index/#kubeconfig","title":"Kubeconfig","text":"<ul> <li>Generation - Generate kubeconfig files</li> <li>Management - Manage kubeconfig files</li> <li>Security - Secure kubeconfig files</li> <li>Dynamic Configuration - Dynamic kubeconfig generation</li> </ul>"},{"location":"site-index/#thresholds","title":"Thresholds","text":"<ul> <li>Basic Configuration - Basic threshold configuration</li> <li>Advanced Configuration - Advanced threshold configuration</li> <li>Example Configurations - Threshold configuration examples</li> <li>CI/CD Thresholds - CI/CD-specific thresholds</li> </ul>"},{"location":"site-index/#plugins","title":"Plugins","text":"<ul> <li>Distroless Support - Distroless container support</li> <li>Implementation - Plugin implementation guide</li> <li>Testing - Plugin testing guide</li> </ul>"},{"location":"site-index/#security-configuration","title":"Security Configuration","text":"<ul> <li>Hardening - System hardening guide</li> <li>Credentials - Credential management</li> <li>RBAC - RBAC configuration guide</li> </ul>"},{"location":"site-index/#helm-charts","title":"Helm Charts","text":""},{"location":"site-index/#overview","title":"Overview","text":"<ul> <li>Architecture - Helm chart architecture</li> </ul>"},{"location":"site-index/#scanner-types","title":"Scanner Types","text":"<ul> <li>Common Scanner - Common scanner chart</li> <li>Standard Scanner - Standard scanner chart</li> <li>Distroless Scanner - Distroless scanner chart</li> <li>Sidecar Scanner - Sidecar scanner chart</li> </ul>"},{"location":"site-index/#infrastructure","title":"Infrastructure","text":"<ul> <li>RBAC - RBAC configuration</li> <li>Service Accounts - Service account setup</li> <li>Namespaces - Namespace management</li> </ul>"},{"location":"site-index/#usage","title":"Usage","text":"<ul> <li>Configuration - Chart configuration</li> <li>Customization - Chart customization</li> <li>Values - Values file reference</li> </ul>"},{"location":"site-index/#security_1","title":"Security","text":"<ul> <li>Best Practices - Helm chart security best practices</li> <li>RBAC Hardening - RBAC hardening for charts</li> <li>Risk Assessment - Chart security risk assessment</li> </ul>"},{"location":"site-index/#operations","title":"Operations","text":"<ul> <li>Troubleshooting - Chart troubleshooting</li> <li>Performance - Performance optimization</li> <li>Maintenance - Chart maintenance</li> </ul>"},{"location":"site-index/#integration","title":"Integration","text":""},{"location":"site-index/#platforms","title":"Platforms","text":"<ul> <li>GitHub Actions - GitHub Actions integration</li> <li>GitLab CI - GitLab CI integration</li> <li>GitLab Services - GitLab Services integration</li> </ul>"},{"location":"site-index/#workflows_1","title":"Workflows","text":"<ul> <li>Standard Container - Standard container CI/CD workflows</li> <li>Distroless Container - Distroless container CI/CD workflows</li> <li>Sidecar Container - Sidecar container CI/CD workflows</li> <li>Security Workflows - Security-focused CI/CD workflows</li> </ul>"},{"location":"site-index/#examples","title":"Examples","text":"<ul> <li>GitHub Examples - GitHub integration examples</li> <li>GitLab Examples - GitLab integration examples</li> </ul>"},{"location":"site-index/#configuration_1","title":"Configuration","text":"<ul> <li>Environment Variables - Environment variable configuration</li> <li>Secrets Management - Secrets management in CI/CD</li> <li>Thresholds Integration - Threshold integration in CI/CD</li> <li>Reporting - CI/CD reporting configuration</li> </ul>"},{"location":"site-index/#tasks","title":"Tasks","text":"<ul> <li> <p> Container Scanning</p> <p>Learn how to scan different types of containers:</p> <ul> <li>Standard Container Scan - Scan standard containers</li> <li>Distroless Container Scan - Scan distroless containers</li> <li>Sidecar Container Scan - Scan using sidecar containers</li> </ul> </li> <li> <p> CI/CD Integration</p> <p>Integrate scanning with your CI/CD pipelines:</p> <ul> <li>GitHub Integration - Integrate with GitHub Actions</li> <li>GitLab Integration - Integrate with GitLab CI</li> </ul> </li> <li> <p> Kubernetes Setup</p> <p>Configure your Kubernetes environment:</p> <ul> <li>Kubernetes Setup - Set up Kubernetes environment</li> <li>RBAC Setup - Configure RBAC permissions</li> </ul> </li> <li> <p> Deployment</p> <p>Deploy the scanner infrastructure:</p> <ul> <li>Helm Deployment - Deploy using Helm charts</li> <li>Script Deployment - Deploy using scripts</li> </ul> </li> <li> <p> Security Configuration</p> <p>Secure your scanner deployment:</p> <ul> <li>Token Management - Manage access tokens</li> <li>Thresholds Configuration - Configure security thresholds</li> </ul> </li> </ul>"},{"location":"site-index/#learning-paths","title":"Learning Paths","text":"<ul> <li> <p> For New Users</p> <p>Start here if you're new to the project:</p> <p>New Users Guide</p> </li> <li> <p>:fontawesome-solid-shield-alt:{ .lg .middle } Security-First Approach</p> <p>Focus on security best practices:</p> <p>Security-First Guide</p> </li> <li> <p> Implementation Guide</p> <p>Step-by-step implementation instructions:</p> <p>Implementation Guide</p> </li> <li> <p> Core Concepts</p> <p>Understand the fundamental concepts:</p> <p>Core Concepts Guide</p> </li> <li> <p> Advanced Features</p> <p>Explore advanced capabilities:</p> <p>Advanced Features Guide</p> </li> </ul>"},{"location":"site-index/#utilities-and-tools","title":"Utilities and Tools","text":""},{"location":"site-index/#documentation-utilities","title":"Documentation Utilities","text":"<ul> <li>ASCII to Mermaid - Convert ASCII diagrams to Mermaid</li> <li>MkDocs Link Fixer - Fix MkDocs links</li> </ul>"},{"location":"site-index/#contributing","title":"Contributing","text":""},{"location":"site-index/#documentation","title":"Documentation","text":"<ul> <li>Documentation Tools - Documentation tooling</li> <li>Code Snippets - Code snippet guidance</li> <li>Diagram Color Guide - Diagram color guidelines</li> <li>STIG API Tools - STIG API tooling</li> </ul>"},{"location":"site-index/#reference","title":"Reference","text":""},{"location":"site-index/#examples_1","title":"Examples","text":"<ul> <li>GitHub Workflow Examples - GitHub workflow examples</li> <li>GitLab Pipeline Examples - GitLab pipeline examples</li> <li>GitLab Services Examples - GitLab services examples</li> </ul>"},{"location":"site-index/#project-information","title":"Project Information","text":"<ul> <li>Changelog - Project changelog</li> <li>Roadmap - Project roadmap</li> </ul>"},{"location":"approaches/","title":"Scanning Approaches","text":"<p>This document provides an overview of the different scanning approaches supported by the Secure CINC Auditor Kubernetes Container Scanning platform.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Approaches Inventory.</p>"},{"location":"approaches/#available-approaches","title":"Available Approaches","text":"<p>The project implements three distinct approaches for container scanning, each with specific characteristics and use cases:</p>"},{"location":"approaches/#1-kubernetes-api-approach","title":"1. Kubernetes API Approach","text":"<p>Enterprise Recommended</p> <p>The Kubernetes API Approach uses the train-k8s-container plugin to connect directly to the Kubernetes API for container scanning. This approach:</p> <ul> <li>Works with standard containers natively</li> <li>Will provide universal container scanning once distroless support is complete</li> <li>Requires no modifications to existing pods</li> <li>Implements least-privilege security controls</li> <li>Provides the most scalable and enterprise-ready solution</li> </ul> <p>Kubernetes API Approach</p>"},{"location":"approaches/#2-debug-container-approach","title":"2. Debug Container Approach","text":"<p>Interim Solution for Distroless Containers</p> <p>The Debug Container Approach uses ephemeral debug containers with chroot-based scanning for distroless containers. This approach:</p> <ul> <li>Works with Kubernetes 1.16+ with ephemeral containers feature enabled</li> <li>Can be used with existing deployed distroless containers</li> <li>Uses temporary debug containers that are removed after scanning</li> <li>Is recommended for testing environments and interim distroless scanning</li> </ul> <p>Debug Container Approach</p>"},{"location":"approaches/#3-sidecar-container-approach","title":"3. Sidecar Container Approach","text":"<p>Universal Compatibility Solution</p> <p>The Sidecar Container Approach uses a CINC Auditor sidecar container with shared process namespace for scanning. This approach:</p> <ul> <li>Works with any Kubernetes cluster regardless of version</li> <li>Provides universal compatibility for all container types</li> <li>Requires deploying containers with the sidecar configuration</li> <li>Can access container filesystems through process namespace sharing</li> </ul> <p>Sidecar Container Approach</p>"},{"location":"approaches/#implementation-methods","title":"Implementation Methods","text":""},{"location":"approaches/#helper-scripts-vs-direct-commands","title":"Helper Scripts vs. Direct Commands","text":"<p>For users who prefer different levels of control, we offer two implementation methods:</p> <ul> <li>Helper Scripts: Easy-to-use wrapper scripts that handle the complexity</li> <li>Direct Commands: Using the underlying tools directly for more control</li> </ul> <p>Helper Scripts</p>"},{"location":"approaches/#comparison-and-decision-guidance","title":"Comparison and Decision Guidance","text":"<p>To help you select the most appropriate approach for your environment and requirements, we provide:</p> <ul> <li>Approach Comparison - Side-by-side comparison of features, requirements, and limitations</li> <li>Decision Matrix - Structured decision framework with recommendations based on specific criteria</li> </ul>"},{"location":"approaches/#next-steps","title":"Next Steps","text":"<p>See our Quickstart Guide for implementation steps or the CI/CD Integration documentation for automated scanning setups.</p>"},{"location":"approaches/comparison/","title":"Scanning Approach Comparison","text":"<p>This document provides a comprehensive comparison of the three container scanning approaches implemented in this project. This analysis will help you select the most appropriate approach based on your specific environment, requirements, and constraints.</p>"},{"location":"approaches/comparison/#approach-overview","title":"Approach Overview","text":"Approach Description Best For Kubernetes API Approach Uses train-k8s-container transport plugin directly Production environments, compliance-focused organizations, CI/CD pipelines at scale Debug Container Approach Attaches ephemeral debug containers to pods with distroless containers Interim solution for distroless containers when ephemeral containers are supported Sidecar Container Approach Deploys scanner containers alongside target containers with shared process namespace Interim solution for distroless containers with minimal Kubernetes version requirements"},{"location":"approaches/comparison/#feature-comparison-matrix","title":"Feature Comparison Matrix","text":"Feature Kubernetes API Approach Debug Container Approach Sidecar Container Approach Kubernetes Compatibility Any version 1.16+ (requires ephemeral containers) Any version Works with existing pods \u2705 Yes \u2705 Yes \u274c No (requires pod modification) Standard container support \u2705 Best approach \u2705 Supported \u2705 Supported Distroless container support \ud83d\udd04 In progress \u2705 Best interim approach \u2705 Supported No pod modification required \u2705 Yes \u274c No \u274c No Minimal privileges \u2705 Yes \u274c No \u2705 Yes Implementation complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium User experience \ud83d\udfe2 Seamless \ud83d\udfe0 Complex \ud83d\udfe0 Medium Security footprint \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Runtime dependencies kubectl, inspec kubectl, ephemeral containers kubectl, pod access CI/CD integration ease \ud83d\udfe2 Simple \ud83d\udfe0 Complex \ud83d\udfe0 Medium Development status \ud83d\udd04 In progress (for distroless) \u2705 Complete \u2705 Complete GitHub Actions support \u2705 Yes \u2705 Yes \u2705 Yes GitLab CI support \u2705 Yes \u2705 Yes \u2705 Yes GitLab Services support \u2705 Yes \u2705 Yes \u2705 Yes"},{"location":"approaches/comparison/#technical-requirements","title":"Technical Requirements","text":""},{"location":"approaches/comparison/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Standard Kubernetes cluster (any version)</li> <li>RBAC permissions to execute commands in target containers</li> <li>For distroless containers: Enhanced plugin capabilities (in development)</li> </ul>"},{"location":"approaches/comparison/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Kubernetes 1.16+ with ephemeral containers feature enabled</li> <li>Permissions to create debug containers</li> <li>Privileges to access target container filesystem</li> </ul>"},{"location":"approaches/comparison/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Standard Kubernetes cluster (any version)</li> <li>Ability to modify pod definitions to enable shared process namespace</li> <li>Permissions to create pods with sidecar containers</li> </ul>"},{"location":"approaches/comparison/#recommended-usage-scenarios","title":"Recommended Usage Scenarios","text":""},{"location":"approaches/comparison/#enterprise-production-environments","title":"Enterprise Production Environments","text":"<p>Recommended Approach: Kubernetes API Approach</p> <ul> <li>Lowest security risk profile</li> <li>Simplest implementation with minimal overhead</li> <li>Most transparent to end users</li> <li>Minimal permissions required in production clusters</li> <li>Best for multi-team environments</li> </ul>"},{"location":"approaches/comparison/#distroless-containers-interim","title":"Distroless Containers (Interim)","text":"<p>Recommended Approach: Debug Container or Sidecar Container Approach</p> <ul> <li>If on Kubernetes 1.16+: Debug Container Approach</li> <li>If needing universal compatibility: Sidecar Container Approach</li> <li>Long-term: Plan for migration to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"approaches/comparison/#local-development-and-testing","title":"Local Development and Testing","text":"<p>Recommended Approach: Any approach depending on container types</p> <ul> <li>For standard containers: Kubernetes API Approach is simplest</li> <li>For mixed container types: Sidecar Container Approach is most flexible</li> </ul>"},{"location":"approaches/comparison/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>Recommended Approach: Any approach, depending on container types</p> <ul> <li>All approaches work well with CI/CD pipelines</li> <li>For standard containers, Kubernetes API Approach is preferred</li> <li>For distroless containers, choose based on environment capabilities</li> </ul>"},{"location":"approaches/comparison/#migration-paths","title":"Migration Paths","text":""},{"location":"approaches/comparison/#to-kubernetes-api-approach-recommended","title":"To Kubernetes API Approach (Recommended)","text":"<ul> <li>For standard containers: Immediate adoption</li> <li>For distroless containers: Plan adoption as enhanced distroless support is completed</li> <li>Maintain same commands and workflows for consistent user experience</li> </ul>"},{"location":"approaches/comparison/#between-approaches","title":"Between Approaches","text":"<ul> <li>Debug Container to Sidecar: Modify pod definitions to enable shared process</li> <li>Sidecar to Debug Container: Ensure cluster supports ephemeral containers</li> <li>Either to Kubernetes API: Wait for distroless support completion</li> </ul>"},{"location":"approaches/comparison/#enterprise-adoption-strategy","title":"Enterprise Adoption Strategy","text":"<p>For enterprise environments implementing container scanning at scale:</p> <ol> <li>Phase 1: Standard Containers</li> <li>Implement Kubernetes API Approach for all standard containers</li> <li> <p>Document and train teams on standardized workflow</p> </li> <li> <p>Phase 2: Distroless Containers (Interim)</p> </li> <li>Implement appropriate fallback based on environment</li> <li> <p>Document temporary approach and plan for migration</p> </li> <li> <p>Phase 3: Complete Migration</p> </li> <li>Migrate all scanning to Kubernetes API Approach once distroless support is complete</li> <li>Standardize on universal approach for all container types</li> </ol>"},{"location":"approaches/comparison/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kubernetes API Approach</li> <li>Debug Container Approach</li> <li>Sidecar Container Approach</li> <li>Approach Decision Matrix</li> <li>Security Risk Analysis</li> <li>Enterprise Integration Analysis</li> </ul>"},{"location":"approaches/decision-matrix/","title":"Container Scanning Approach Decision Matrix","text":"<p>This decision matrix provides a comprehensive comparison of the three container scanning approaches available in this project. Use this guide to select the most appropriate approach based on your specific requirements and environment constraints.</p>"},{"location":"approaches/decision-matrix/#quick-selection-guide","title":"Quick Selection Guide","text":"If you need... Recommended Approach Enterprise-ready, scalable solution Kubernetes API Approach Simplest implementation for standard containers Kubernetes API Approach Compliance with security standards Kubernetes API Approach CI/CD pipeline for enterprise scale Kubernetes API Approach Minimal cluster permissions Kubernetes API Approach Distroless support (interim) with K8s 1.16+ Debug Container Approach Distroless support (interim) with any K8s version Sidecar Container Approach Universal solution for all container types Kubernetes API Approach (once distroless support is complete)"},{"location":"approaches/decision-matrix/#comprehensive-comparison-matrix","title":"Comprehensive Comparison Matrix","text":"Factor Kubernetes API Approach Debug Container Sidecar Container Compatibility Standard containers \u2705 Full support \u2705 Full support \u2705 Full support Distroless containers \ud83d\udd36 In development \u2705 Full support \u2705 Full support Kubernetes version requirement Any version 1.16+ (ephemeral containers) Any version Implementation Implementation complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium CI/CD integration effort \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Maintenance burden \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Setup complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Security Overall security risk \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 Medium-High Required permissions \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Isolation level \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udd34 Lower Attack surface \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Operational Scan speed \ud83d\udfe2 Fast \ud83d\udfe0 Medium \ud83d\udfe2 Fast Resource overhead \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Intrusiveness \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 Higher Runtime dependencies kubectl, inspec kubectl, ephemeral containers kubectl, pod access Enterprise Factors Multi-team adoption \ud83d\udfe2 Easy \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Learning curve \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Documentation effort \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Monitoring/observability \ud83d\udfe2 Standard logs \ud83d\udfe0 Multiple components \ud83d\udfe0 Multiple components Long-term enterprise viability \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udfe0 Medium"},{"location":"approaches/decision-matrix/#detailed-analysis-by-use-case","title":"Detailed Analysis by Use Case","text":""},{"location":"approaches/decision-matrix/#use-case-1-enterprise-environments","title":"Use Case 1: Enterprise Environments","text":"<p>Best Approach: Kubernetes API Approach</p> <p>Rationale:</p> <ul> <li>Designed for enterprise scalability and adoption</li> <li>Simplest implementation with minimal overhead</li> <li>Works well with standard containers and future distroless support</li> <li>Lowest security risk profile</li> <li>Most transparent to end users</li> <li>Same commands for both standard and distroless containers (with future enhancement)</li> <li>Minimal permissions required in production clusters</li> <li>Best for multi-team environments</li> </ul>"},{"location":"approaches/decision-matrix/#use-case-2-production-with-mixed-container-types","title":"Use Case 2: Production with Mixed Container Types","text":"<p>Best Approach: Kubernetes API Approach with Sidecar Container fallback</p> <p>Rationale:</p> <ul> <li>Kubernetes API Approach offers best enterprise integration</li> <li>For current distroless containers, Sidecar Container Approach offers:<ul> <li>Universal compatibility with all container types</li> <li>Works regardless of Kubernetes version</li> <li>Can be implemented with automated sidecar injection</li> </ul> </li> <li>Long-term plan should be migrating to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"approaches/decision-matrix/#use-case-3-advanced-kubernetes-environment-116","title":"Use Case 3: Advanced Kubernetes Environment (1.16+)","text":"<p>Best Approach: Kubernetes API Approach with Debug Container fallback</p> <p>Rationale:</p> <ul> <li>Kubernetes API Approach is the recommended long-term solution</li> <li>For current distroless containers, Debug Container Approach offers:<ul> <li>Native Kubernetes ephemeral containers feature</li> <li>More isolated than sidecar approach</li> <li>Debug containers are ephemeral (removed after scan)</li> <li>Good balance of security and capabilities</li> </ul> </li> </ul>"},{"location":"approaches/decision-matrix/#use-case-4-highly-secure-zero-trust-environment","title":"Use Case 4: Highly Secure / Zero-Trust Environment","text":"<p>Best Approach: Kubernetes API Approach (with fallback to Debug Container)</p> <p>Rationale:</p> <ul> <li>Kubernetes API Approach has the lowest risk profile</li> <li>Minimal permissions required</li> <li>Minimal attack surface</li> <li>If distroless containers are required, use Debug Container approach with strict controls until Kubernetes API Approach supports distroless</li> </ul>"},{"location":"approaches/decision-matrix/#use-case-5-cicd-pipeline-integration","title":"Use Case 5: CI/CD Pipeline Integration","text":"<p>Best Approach: Kubernetes API Approach (with appropriate interim solution for distroless containers)</p> <p>Rationale:</p> <ul> <li>While all approaches are technically possible in CI/CD pipelines, the Kubernetes API Approach offers critical advantages:<ul> <li>Compliance: Aligns with security compliance standards</li> <li>Scale: Significantly lower resource overhead and faster execution for high-volume scanning (hundreds to thousands of containers)</li> <li>Consistency: Same workflow, commands, and permissions model regardless of environment</li> <li>Enterprise adoption: Simplifies cross-team standardization and governance</li> <li>Security posture: Minimizes attack surface and privilege requirements in CI/CD environments</li> </ul> </li> <li>For distroless containers in CI/CD:<ul> <li>Use the appropriate interim solution based on cluster capabilities</li> <li>Plan migration path to Kubernetes API Approach as distroless support is completed</li> <li>Document compliance deviations if using alternative approaches</li> </ul> </li> <li>While alternative approaches may work in isolated CI/CD use cases, they are not recommended for enterprise-scale implementations</li> </ul>"},{"location":"approaches/decision-matrix/#implementation-decision-tree","title":"Implementation Decision Tree","text":"<ol> <li>Is enterprise scalability your primary concern?</li> <li>Yes: Use Kubernetes API Approach (with appropriate fallback for distroless containers until fully supported)</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Are you scanning standard containers with shell access?</p> </li> <li>Yes: Use Kubernetes API Approach</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Are you on Kubernetes 1.16+ with ephemeral containers enabled?</p> </li> <li>Yes: Use Debug Container Approach (until Kubernetes API Approach supports distroless)</li> <li> <p>No: Continue to next question</p> </li> <li> <p>Can you modify pod definitions to add shareProcessNamespace?</p> </li> <li>Yes: Use Sidecar Container Approach</li> <li> <p>No: Consider cluster upgrade to enable ephemeral containers</p> </li> <li> <p>Is security your primary concern?</p> </li> <li>Yes: Use Kubernetes API Approach where possible, with strict controls on any alternate approach</li> <li>No: Choose based on compatibility and operational factors</li> </ol>"},{"location":"approaches/decision-matrix/#migration-paths","title":"Migration Paths","text":""},{"location":"approaches/decision-matrix/#to-kubernetes-api-approach-enterprise-recommended","title":"To Kubernetes API Approach (Enterprise Recommended)","text":"<ul> <li>For standard containers: Immediate adoption</li> <li>For distroless containers: Plan adoption as enhanced distroless support is completed</li> <li>Maintain same commands and workflows across all container types for seamless user experience</li> </ul>"},{"location":"approaches/decision-matrix/#from-kubernetes-api-to-debug-container-for-distroless-containers","title":"From Kubernetes API to Debug Container (for distroless containers)","text":"<ul> <li>Implement ephemeral container support in cluster</li> <li>Add debug container configuration</li> <li>Modify scan scripts to use debug container method</li> <li>Plan migration back to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"approaches/decision-matrix/#from-kubernetes-api-to-sidecar-container-for-distroless-containers","title":"From Kubernetes API to Sidecar Container (for distroless containers)","text":"<ul> <li>Modify pod definitions to enable shareProcessNamespace</li> <li>Add sidecar container configuration</li> <li>Configure process detection and filesystem access</li> <li>Plan migration back to Kubernetes API Approach as distroless support matures</li> </ul>"},{"location":"approaches/decision-matrix/#from-debug-container-to-sidecar-container","title":"From Debug Container to Sidecar Container","text":"<ul> <li>Modify pod definitions to enable shareProcessNamespace</li> <li>Configure sidecar deployment approach</li> <li>No cluster version dependencies</li> </ul>"},{"location":"approaches/decision-matrix/#enterprise-adoption-strategy","title":"Enterprise Adoption Strategy","text":"<p>For enterprise environments planning to adopt container scanning at scale, we recommend:</p> <ol> <li>Phase 1: Standard Containers</li> <li>Implement Kubernetes API Approach for all standard containers</li> <li> <p>Document and train teams on the standardized approach</p> </li> <li> <p>Phase 2: Distroless Containers (Interim)</p> </li> <li>Implement appropriate fallback method based on environment:<ul> <li>Debug Container Approach (if ephemeral containers are supported)</li> <li>Sidecar Container Approach (for universal compatibility)</li> </ul> </li> <li> <p>Document temporary approach and plan for future migration</p> </li> <li> <p>Phase 3: Complete Migration to Universal Solution</p> </li> <li>Migrate all scanning to Kubernetes API Approach once distroless support is complete</li> <li>Standardize on a single, universal approach for all container types</li> <li>Maintain simplified user experience with consistent commands</li> <li>Eliminate the need for multiple approaches or special handling for different container types</li> </ol>"},{"location":"approaches/decision-matrix/#conclusion","title":"Conclusion","text":"<p>After comprehensive analysis of security compliance, enterprise scalability, operational efficiency, and implementation complexity, the Kubernetes API Approach emerges as the clear superior solution for container scanning in production environments.</p> <p>Our recommendation is based on thorough evaluation against:</p> <ul> <li>Security compliance frameworks (DoD 8500.01, DISA Container Platform SRG, Kubernetes STIG, CIS Benchmarks, NSA/CISA Kubernetes Hardening Guide)</li> <li>Enterprise-scale operational requirements (supporting hundreds to thousands of container scans)</li> <li>Resource efficiency and performance considerations</li> <li>CI/CD integration capabilities</li> <li>Maintainability and adoption across teams</li> </ul> <p>For enterprise deployments, the Kubernetes API Approach is not just preferred but strongly recommended as the only approach that fully satisfies enterprise security, compliance, and scale requirements. The alternative approaches, while technically functional, introduce significant compliance challenges, security considerations, and operational complexities that make them unsuitable for enterprise-scale production use.</p> <p>Strategic Direction:</p> <ol> <li>Implement Kubernetes API Approach for standard containers immediately</li> <li>Use appropriate interim solutions for distroless containers with proper risk documentation</li> <li>Prioritize completing Kubernetes API Approach support for distroless containers</li> <li>Migrate all scanning to the unified Kubernetes API Approach when complete</li> </ol> <p>This strategy provides the most secure, compliant, and scalable path forward for enterprise container security.</p> <p>For detailed implementation guidance, refer to the specific documentation:</p> <ul> <li>Kubernetes API Approach</li> <li>Debug Container Approach (interim distroless solution)</li> <li>Sidecar Container Approach (interim distroless solution)</li> </ul> <p>For comprehensive security analysis, see:</p> <ul> <li>Security Compliance Documentation</li> <li>NSA/CISA Kubernetes Hardening Guide Alignment</li> <li>Security Risk Analysis</li> <li>Enterprise Integration Analysis</li> </ul>"},{"location":"approaches/direct-commands/","title":"Helper Scripts vs. Direct Commands","text":"<p>This document explains how to use both our helper scripts and the equivalent direct commands for container scanning operations.</p>"},{"location":"approaches/direct-commands/#understanding-the-two-approaches","title":"Understanding the Two Approaches","text":"<p>Our container scanning solution can be used in two ways:</p> <ol> <li>Helper Scripts: Easy-to-use wrapper scripts that handle the complexity</li> <li>Direct Commands: Using the underlying tools directly for more control</li> </ol>"},{"location":"approaches/direct-commands/#container-scanning-with-helper-scripts-vs-direct-commands","title":"Container Scanning with Helper Scripts vs. Direct Commands","text":""},{"location":"approaches/direct-commands/#setup-minikube-for-testing","title":"Setup Minikube for Testing","text":"Helper Script Direct Commands <code>./kubernetes-scripts/setup-minikube.sh --nodes=2 --with-distroless</code> <code>bash&lt;br&gt;minikube start --nodes=2&lt;br&gt;kubectl create namespace inspec-test&lt;br&gt;kubectl -n inspec-test create serviceaccount inspec-scanner&lt;br&gt;# Create RBAC manually with kubectl apply&lt;br&gt;</code>"},{"location":"approaches/direct-commands/#creating-scanning-infrastructure","title":"Creating Scanning Infrastructure","text":""},{"location":"approaches/direct-commands/#with-helper-scripts","title":"With Helper Scripts","text":"<pre><code># Install all components with a single script\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands","title":"With Direct Commands","text":"<pre><code># Install each component separately\nkubectl create namespace inspec-test\n\n# Create the service account\nkubectl -n inspec-test create serviceaccount inspec-scanner\n\n# Create the role\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\nEOF\n\n# Create the role binding\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-scanner\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n\n# Create a test pod\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: inspec-target\n  namespace: inspec-test\n  labels:\n    app: inspec-target\n    scan-target: \"true\"\nspec:\n  containers:\n  - name: busybox\n    image: busybox:latest\n    command: [\"sleep\", \"infinity\"]\nEOF\n</code></pre>"},{"location":"approaches/direct-commands/#creating-authentication","title":"Creating Authentication","text":""},{"location":"approaches/direct-commands/#with-helper-scripts_1","title":"With Helper Scripts","text":"<pre><code># Generate kubeconfig automatically\n./kubernetes-scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands_1","title":"With Direct Commands","text":"<pre><code># Generate token\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=60m)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create kubeconfig manually\ncat &gt; ./kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: inspec-scanner\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: inspec-scanner\n  user:\n    token: ${TOKEN}\nEOF\n\nchmod 600 ./kubeconfig.yaml\n</code></pre>"},{"location":"approaches/direct-commands/#running-a-standard-container-scan","title":"Running a Standard Container Scan","text":""},{"location":"approaches/direct-commands/#with-helper-scripts_2","title":"With Helper Scripts","text":"<pre><code># One-line scan with automatic RBAC, token, and threshold validation\n./kubernetes-scripts/scan-container.sh inspec-test inspec-target busybox ../../examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands_2","title":"With Direct Commands","text":"<pre><code># Run CINC Auditor directly\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/direct-commands/#scanning-distroless-containers","title":"Scanning Distroless Containers","text":""},{"location":"approaches/direct-commands/#with-helper-scripts_3","title":"With Helper Scripts","text":"<pre><code># One-line scan of distroless container with ephemeral debug container\n./kubernetes-scripts/scan-distroless-container.sh inspec-test distroless-target app ../../examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands_3","title":"With Direct Commands","text":"<pre><code># Create debug container manually\nkubectl debug -n inspec-test distroless-target \\\n  --image=docker.io/cincproject/auditor:latest \\\n  --target=distroless \\\n  --container=debug-container \\\n  -- sleep 300 &amp;\n\n# Wait for debug container to be ready\nsleep 10\n\n# Run scan against debug container\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/distroless-target/debug-container \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/direct-commands/#using-helm-for-deployment","title":"Using Helm for Deployment","text":""},{"location":"approaches/direct-commands/#with-helper-scripts_4","title":"With Helper Scripts","text":"<pre><code># Install everything with a single command\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands_4","title":"With Direct Commands","text":"<pre><code># Install each chart separately\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"approaches/direct-commands/#saf-cli-integration","title":"SAF CLI Integration","text":""},{"location":"approaches/direct-commands/#with-helper-scripts_5","title":"With Helper Scripts","text":"<pre><code># Threshold validation is built into the scan scripts\n./kubernetes-scripts/scan-container.sh inspec-test inspec-target busybox ../../examples/cinc-profiles/container-baseline ./threshold.yml\n</code></pre>"},{"location":"approaches/direct-commands/#with-direct-commands_5","title":"With Direct Commands","text":"<pre><code># Run scan and get results\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Generate summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Apply threshold validation\nsaf threshold -i scan-results.json -t threshold.yml\nTHRESHOLD_RESULT=$?\n\nif [ $THRESHOLD_RESULT -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\n  exit $THRESHOLD_RESULT\nfi\n</code></pre>"},{"location":"approaches/direct-commands/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"approaches/direct-commands/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Run container scan\n  run: |\n    # Helper script method\n    ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/direct-commands/#gitlab-ci","title":"GitLab CI","text":"<pre><code>run_scan:\n  stage: scan\n  script:\n    # Helper script method\n    ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/direct-commands/#which-method-to-choose","title":"Which Method to Choose?","text":""},{"location":"approaches/direct-commands/#use-helper-scripts-when","title":"Use Helper Scripts When","text":"<ul> <li>You want a simpler, more streamlined experience</li> <li>You're new to Kubernetes or CINC Auditor</li> <li>You need to quickly implement scanning in CI/CD</li> <li>You want automatic cleanup of temporary resources</li> </ul>"},{"location":"approaches/direct-commands/#use-direct-commands-when","title":"Use Direct Commands When","text":"<ul> <li>You need more control over the process</li> <li>You're integrating with existing automation</li> <li>You want to understand what's happening \"under the hood\"</li> <li>You need to customize the scanning process</li> </ul>"},{"location":"approaches/direct-commands/#known-limitations","title":"Known Limitations","text":""},{"location":"approaches/direct-commands/#helper-scripts","title":"Helper Scripts","text":"<ul> <li>Less flexibility for advanced use cases</li> <li>Dependencies between scripts might not be immediately obvious</li> <li>Limited customization of RBAC without modifying the scripts</li> </ul>"},{"location":"approaches/direct-commands/#direct-commands","title":"Direct Commands","text":"<ul> <li>More complex to implement</li> <li>Requires deeper understanding of Kubernetes and CINC Auditor</li> <li>Manual cleanup of resources required</li> </ul>"},{"location":"approaches/inventory/","title":"Scanning Approaches Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains documentation about the different container scanning approaches supported by this project.</p>"},{"location":"approaches/inventory/#overview-files","title":"Overview Files","text":"File Description index.md Overview of all scanning approaches comparison.md Side-by-side comparison of all approaches decision-matrix.md Decision framework for selecting the appropriate approach"},{"location":"approaches/inventory/#approach-directories","title":"Approach Directories","text":"Directory Description kubernetes-api/index.md Kubernetes API approach for standard containers debug-container/index.md Debug Container approach for distroless containers sidecar-container/index.md Sidecar Container approach for universal compatibility helper-scripts/index.md Helper scripts vs. direct commands documentation"},{"location":"approaches/inventory/#implementation-details-by-approach","title":"Implementation Details By Approach","text":""},{"location":"approaches/inventory/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The kubernetes-api/index.md directory contains:</p> <ul> <li>index.md - Overview of the Kubernetes API approach</li> <li>implementation.md - Technical implementation details</li> <li>rbac.md - RBAC configuration</li> <li>limitations.md - Limitations and requirements</li> <li>inventory.md - Directory contents</li> </ul>"},{"location":"approaches/inventory/#debug-container-approach","title":"Debug Container Approach","text":"<p>The debug-container/index.md directory contains:</p> <ul> <li>index.md - Overview of the Debug Container approach</li> <li>distroless-basics.md - Distroless container basics</li> <li>implementation.md - Technical implementation details</li> <li>inventory.md - Directory contents</li> </ul>"},{"location":"approaches/inventory/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The sidecar-container/index.md directory contains:</p> <ul> <li>index.md - Overview of the Sidecar Container approach</li> <li>implementation.md - Technical implementation details</li> <li>inventory.md - Directory contents</li> </ul>"},{"location":"approaches/inventory/#helper-scripts-approach","title":"Helper Scripts Approach","text":"<p>The helper-scripts/index.md directory contains:</p> <ul> <li>index.md - Overview of the Helper Scripts approach</li> <li>scripts-vs-commands.md - Comparison of scripts and commands</li> <li>inventory.md - Directory contents</li> </ul>"},{"location":"approaches/inventory/#referenced-in","title":"Referenced In","text":"<p>Architecture Diagrams</p> <ul> <li>CI/CD Integration</li> <li>Helm Charts</li> <li>Quickstart Guide</li> </ul>"},{"location":"approaches/debug-container/","title":"Debug Container Approach","text":"<p>This document provides an overview of the Debug Container approach for scanning distroless containers.</p>"},{"location":"approaches/debug-container/#introduction","title":"Introduction","text":"<p>The Debug Container approach uses Kubernetes ephemeral containers to access and scan distroless containers that lack a shell and standard utilities. This approach is recommended as an interim solution for distroless containers until the Kubernetes API approach adds full distroless support.</p>"},{"location":"approaches/debug-container/#key-features","title":"Key Features","text":"<ul> <li>Works with Kubernetes 1.16+ with ephemeral containers feature enabled</li> <li>Can be used with existing deployed distroless containers</li> <li>Uses temporary debug containers that are removed after scanning</li> <li>Provides filesystem access to distroless containers</li> </ul>"},{"location":"approaches/debug-container/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Technical Implementation - How the approach works and detailed technical specifications</li> <li>Distroless Container Basics - What are distroless containers and their challenges</li> <li>RBAC Configuration - Required permissions and security considerations</li> <li>Integration - Integration with CI/CD pipelines and other systems</li> <li>Limitations and Requirements - What's needed and where the approach has constraints</li> <li>Security Considerations - Security implications and best practices</li> <li>Future Work - Planned enhancements and development roadmap</li> </ul>"},{"location":"approaches/debug-container/#related-resources","title":"Related Resources","text":"<ul> <li>Approach Comparison - Compare the Debug Container approach with other options</li> <li>Decision Matrix - Help decide which approach is best for specific scenarios</li> <li>Workflows - Visual representation of workflows</li> <li>Security Analysis - Detailed security analysis</li> </ul>"},{"location":"approaches/debug-container/distroless-basics/","title":"Distroless Container Basics","text":"<p>This document explains what distroless containers are, their benefits, and the challenges they present for security scanning.</p>"},{"location":"approaches/debug-container/distroless-basics/#what-are-distroless-containers","title":"What are Distroless Containers?","text":"<p>Distroless containers are minimalist container images that contain only the application and its runtime dependencies. They do not include:</p> <ul> <li>Shell</li> <li>Package managers</li> <li>Standard Linux utilities</li> <li>Debugging tools</li> </ul> <p>These containers are designed for improved security by reducing the attack surface, but they present challenges for traditional container debugging and scanning approaches.</p>"},{"location":"approaches/debug-container/distroless-basics/#key-characteristics-of-distroless-containers","title":"Key Characteristics of Distroless Containers","text":""},{"location":"approaches/debug-container/distroless-basics/#whats-included-in-distroless-containers","title":"What's Included in Distroless Containers","text":"<ol> <li>Application binaries and libraries: Just the executables and shared libraries needed for the application to run</li> <li>Runtime dependencies: Minimal set of files and libraries required by the runtime (e.g., Java JRE, Python interpreter)</li> <li>CA certificates: For secure network connections</li> <li>Timezone data: For correct time representation</li> <li>Non-root user: Typically configured to run as a non-privileged user</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#whats-explicitly-excluded","title":"What's Explicitly Excluded","text":"<ol> <li>Shell: No <code>/bin/sh</code>, <code>/bin/bash</code>, or other shells</li> <li>Package manager: No apt, dpkg, yum, etc.</li> <li>Common utilities: No ls, cat, grep, etc.</li> <li>Development tools: No compilers, debuggers, etc.</li> <li>Configuration tools: No init system or service managers</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#benefits-of-distroless-containers","title":"Benefits of Distroless Containers","text":"<ol> <li>Reduced Attack Surface: Fewer components mean fewer potential vulnerabilities</li> <li>Smaller Image Size: Significantly smaller images, often 10-20% the size of standard images</li> <li>Improved Security Posture: Limited capabilities for attackers if compromised</li> <li>Immutable Infrastructure: Encourages proper CI/CD practices as containers can't be modified at runtime</li> <li>Simplified Dependency Management: Clear definition of actual runtime dependencies</li> <li>Improved Performance: Less overhead, faster startup times</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#examples-of-distroless-container-images","title":"Examples of Distroless Container Images","text":"<p>Google's distroless containers project provides several base images:</p> <ul> <li>distroless/static: Ultra-minimal image for statically-linked binaries</li> <li>distroless/base: Minimal base image with glibc</li> <li>distroless/java: For Java applications</li> <li>distroless/python: For Python applications</li> <li>distroless/nodejs: For Node.js applications</li> <li>distroless/cc: For C/C++ applications</li> </ul>"},{"location":"approaches/debug-container/distroless-basics/#the-challenge-with-scanning-distroless-containers","title":"The Challenge with Scanning Distroless Containers","text":"<p>The train-k8s-container transport plugin that CINC Auditor uses relies on the ability to execute commands within the target container. It typically does this by:</p> <ol> <li>Using <code>kubectl exec</code> to run commands inside the container</li> <li>Assuming the presence of a shell (like <code>/bin/sh</code>) in the container</li> <li>Executing tests that often rely on standard Linux utilities</li> </ol> <p>In distroless containers, these requirements are not met, making traditional scanning impossible.</p>"},{"location":"approaches/debug-container/distroless-basics/#common-errors-when-attempting-to-scan-distroless","title":"Common Errors When Attempting to Scan Distroless","text":"<p>When trying to scan a distroless container with the standard approach, you'll see errors like:</p> <pre><code>Error: Failed to execute command: 'sh -c command'. Error was: executable file not found: stat /bin/sh: no such file or directory\n</code></pre> <p>Or when using InSpec directly:</p> <pre><code>No such file or directory - /bin/sh\n</code></pre>"},{"location":"approaches/debug-container/distroless-basics/#distroless-container-detection","title":"Distroless Container Detection","text":"<p>Detecting distroless containers can be done by:</p> <ol> <li>Attempting to execute a simple command and checking for failure</li> <li>Testing for the presence of common shells</li> <li>Looking at image metadata if available</li> </ol> <p>Example detection code:</p> <pre><code># Try to execute a command in the container\nkubectl exec -n $NAMESPACE $POD_NAME -c $CONTAINER_NAME -- ls /bin/sh &amp;&gt;/dev/null\nSHELL_CHECK=$?\n\n# Check for common shells\nkubectl exec -n $NAMESPACE $POD_NAME -c $CONTAINER_NAME -- which sh &amp;&gt;/dev/null || \\\nkubectl exec -n $NAMESPACE $POD_NAME -c $CONTAINER_NAME -- which bash &amp;&gt;/dev/null\nWHICH_CHECK=$?\n\n# If both checks fail, it's likely a distroless container\nif [ $SHELL_CHECK -ne 0 ] &amp;&amp; [ $WHICH_CHECK -ne 0 ]; then\n  echo \"Container appears to be distroless\"\nfi\n</code></pre>"},{"location":"approaches/debug-container/distroless-basics/#common-distroless-scanning-approaches","title":"Common Distroless Scanning Approaches","text":"<p>There are several approaches to scanning distroless containers:</p> <ol> <li>Debug Container Approach: Using Kubernetes ephemeral containers to inspect the distroless container (our recommended interim approach)</li> <li>Sidecar Approach: Deploying sidecar containers with shared process namespace</li> <li>Static Analysis: Scanning the container image rather than the running container</li> <li>Custom Tooling: Building specialized tools for distroless containers</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#base-image-influence-on-scanning-approach","title":"Base Image Influence on Scanning Approach","text":"<p>The choice of distroless base image affects the scanning approach:</p> Distroless Base Key Characteristics Scanning Considerations Static No libc, for statically-linked binaries Most restricted, needs complete external access Base Includes glibc but no shell Cannot execute commands, needs external tools Java JRE without shell or tools Can analyze JVM but not execute shell commands Python Python runtime without shell Can potentially use Python for some inspections Node.js Node runtime without shell Can potentially use Node for some inspections"},{"location":"approaches/debug-container/distroless-basics/#container-security-considerations","title":"Container Security Considerations","text":"<p>Distroless containers provide security benefits:</p> <ol> <li>Attack Surface Reduction: No shell means no easy execution for attackers</li> <li>Limited Privilege Escalation: Fewer tools available if compromised</li> <li>Vulnerability Reduction: No excess packages means fewer CVEs</li> </ol> <p>However, they also introduce security challenges:</p> <ol> <li>Limited Inspectability: Harder to debug and scan</li> <li>Specialized Knowledge Required: Teams need more advanced container expertise</li> <li>Special Handling in Security Tooling: Many security tools assume shell access</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#recommended-inspec-resources-for-distroless","title":"Recommended InSpec Resources for Distroless","text":"<p>When creating InSpec profiles for distroless containers, focus on:</p> <ol> <li>file resource: For checking file existence, permissions, content</li> <li>directory resource: For checking directory attributes</li> <li>parse_config* resources: For analyzing configuration files without commands</li> <li>packages resource: Only for language-specific package analysis (npm, pip, etc.)</li> <li>simple matchers: Resources that don't depend on command execution</li> </ol> <p>Avoid resources that rely on command execution:</p> <ol> <li>command resource: Will fail without a shell</li> <li>process resource: Often depends on ps command</li> <li>service resource: Requires service management tools</li> <li>user/group resources: Often depend on commands like id, getent</li> </ol>"},{"location":"approaches/debug-container/distroless-basics/#related-resources","title":"Related Resources","text":"<ul> <li>Google Distroless Container Images</li> <li>Debug Container Approach Implementation</li> <li>Approach Comparison</li> <li>Sidecar Container Approach</li> </ul>"},{"location":"approaches/debug-container/implementation/","title":"Debug Container Approach Implementation","text":"<p>This document outlines the technical implementation of the Debug Container approach for scanning distroless containers.</p>"},{"location":"approaches/debug-container/implementation/#core-concept","title":"Core Concept","text":"<p>The Debug Container approach leverages Kubernetes ephemeral containers to:</p> <ol> <li>Attach a temporary container with debugging tools to a pod with distroless containers</li> <li>Share process and filesystem namespaces with the target container</li> <li>Access the target container's filesystem through the process filesystem</li> <li>Execute CINC Auditor scans through the debug container</li> <li>Remove the debug container when scanning is complete</li> </ol>"},{"location":"approaches/debug-container/implementation/#technical-workflow","title":"Technical Workflow","text":""},{"location":"approaches/debug-container/implementation/#step-1-create-an-ephemeral-debug-container","title":"Step 1: Create an Ephemeral Debug Container","text":"<pre><code>kubectl debug -n &lt;namespace&gt; &lt;pod-name&gt; \\\n  --image=docker.io/cincproject/auditor:latest \\\n  --target=&lt;container-name&gt; \\\n  --container=debug-container \\\n  --share-processes \\\n  -- sleep 300\n</code></pre> <p>This command:</p> <ul> <li>Attaches a debug container running CINC Auditor to the target pod</li> <li>Targets the specific distroless container</li> <li>Shares the process namespace</li> <li>Makes the debug container sleep to keep it alive during scanning</li> </ul>"},{"location":"approaches/debug-container/implementation/#step-2-access-the-target-containers-filesystem","title":"Step 2: Access the Target Container's Filesystem","text":"<p>Once the debug container is running:</p> <ol> <li>Find the process IDs of the target container</li> </ol> <pre><code>ps aux\n</code></pre> <ol> <li>Identify the main process of the target application</li> </ol> <pre><code>ps aux | grep &lt;app-process-name&gt;\n</code></pre> <ol> <li>Access the container's filesystem through the process namespace</li> </ol> <pre><code>cd /proc/&lt;PID&gt;/root/\n</code></pre>"},{"location":"approaches/debug-container/implementation/#step-3-execute-cinc-auditor-scan","title":"Step 3: Execute CINC Auditor Scan","text":"<p>The scan can be executed in two ways:</p>"},{"location":"approaches/debug-container/implementation/#option-1-direct-filesystem-scanning","title":"Option 1: Direct Filesystem Scanning","text":"<pre><code>cinc-auditor exec &lt;profile-path&gt; \\\n  --target=/proc/&lt;PID&gt;/root \\\n  --reporter json:/tmp/results.json\n</code></pre> <p>This approach:</p> <ul> <li>Directly targets the filesystem path</li> <li>Works for filesystem-based controls</li> <li>Has limitations for process and system resource inspections</li> </ul>"},{"location":"approaches/debug-container/implementation/#option-2-chroot-based-scanning","title":"Option 2: Chroot-Based Scanning","text":"<pre><code>mkdir -p /tmp/target\nmount --bind /proc/&lt;PID&gt;/root /tmp/target\nchroot /tmp/target cinc-auditor exec &lt;profile-path&gt; \\\n  --reporter json:/tmp/results.json\n</code></pre> <p>This approach:</p> <ul> <li>Creates a more complete environment for scanning</li> <li>Makes the target filesystem appear as root</li> <li>Allows more accurate scanning of filesystem resources</li> <li>Requires elevated permissions for chroot</li> </ul>"},{"location":"approaches/debug-container/implementation/#step-4-retrieve-and-process-results","title":"Step 4: Retrieve and Process Results","text":"<pre><code>kubectl cp &lt;namespace&gt;/&lt;pod-name&gt;:/tmp/results.json ./results.json -c debug-container\n</code></pre>"},{"location":"approaches/debug-container/implementation/#step-5-clean-up-resources","title":"Step 5: Clean Up Resources","text":"<pre><code># Remove the ephemeral container\nkubectl delete pod &lt;pod-name&gt; --now\n</code></pre>"},{"location":"approaches/debug-container/implementation/#script-implementation","title":"Script Implementation","text":"<p>The project implements this approach in the <code>scan-distroless-container.sh</code> script:</p> <pre><code>#!/bin/bash\n# Usage: ./kubernetes-scripts/scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n\n# Script implementation details...\n</code></pre> <p>The script automates the following:</p> <ol> <li>Create temporary RBAC permissions</li> <li>Generate temporary kubeconfig</li> <li>Detect if the container is distroless</li> <li>Launch debug container with CINC Auditor</li> <li>Execute scan with appropriate chroot</li> <li>Retrieve and process results</li> <li>Clean up temporary resources</li> </ol>"},{"location":"approaches/debug-container/implementation/#technical-implementation-details","title":"Technical Implementation Details","text":""},{"location":"approaches/debug-container/implementation/#ephemeral-container-definition","title":"Ephemeral Container Definition","text":"<p>The ephemeral container is defined as:</p> <pre><code>ephemeralContainers:\n- name: debug-container\n  image: docker.io/cincproject/auditor:latest\n  command: [\"sleep\", \"300\"]\n  targetContainerName: &lt;container-name&gt;\n  securityContext:\n    privileged: true\n  shareProcessNamespace: true\n</code></pre> <p>Key elements:</p> <ul> <li><code>targetContainerName</code>: Specifies which container to attach to</li> <li><code>privileged: true</code>: Required for chroot operations</li> <li><code>shareProcessNamespace: true</code>: Enables access to the target container's processes</li> </ul>"},{"location":"approaches/debug-container/implementation/#rbac-requirements","title":"RBAC Requirements","text":"<p>Additional RBAC permissions are needed:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role-distroless\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"get\", \"create\", \"update\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre> <p>The key addition is the <code>pods/ephemeralcontainers</code> resource permission.</p>"},{"location":"approaches/debug-container/implementation/#chroot-implementation","title":"Chroot Implementation","text":"<p>The chroot-based scanning uses the following approach:</p> <pre><code># Find the PID of the main process\nPID=$(ps aux | grep -v grep | grep -m 1 \"&lt;app-identifier&gt;\" | awk '{print $2}')\n\n# Create mount point\nmkdir -p /tmp/target\n\n# Mount the filesystem\nmount --bind /proc/$PID/root /tmp/target\n\n# Execute scan in chroot environment\nchroot /tmp/target cinc-auditor exec &lt;profile-path&gt; \\\n  --reporter json:/tmp/results.json\n\n# Unmount when done\numount /tmp/target\n</code></pre>"},{"location":"approaches/debug-container/implementation/#technical-diagram","title":"Technical Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Script as scan-distroless-container.sh\n    participant K8sAPI as Kubernetes API\n    participant Pod as Target Pod\n    participant Debug as Debug Container\n    participant CINC as CINC Auditor\n\n    User-&gt;&gt;Script: Run script with params\n    Script-&gt;&gt;K8sAPI: Create RBAC resources\n    Script-&gt;&gt;K8sAPI: Create ephemeral debug container\n    K8sAPI-&gt;&gt;Pod: Attach debug container\n\n    Script-&gt;&gt;K8sAPI: Exec into debug container\n    K8sAPI-&gt;&gt;Debug: Execute commands\n\n    Debug-&gt;&gt;Debug: Find target process\n    Debug-&gt;&gt;Debug: Set up chroot environment\n    Debug-&gt;&gt;CINC: Run CINC Auditor in chroot\n    CINC-&gt;&gt;Debug: Generate results\n\n    Script-&gt;&gt;K8sAPI: Copy results from debug container\n    K8sAPI-&gt;&gt;Debug: Get result file\n    Debug-&gt;&gt;Script: Return results\n\n    Script-&gt;&gt;Script: Process results\n    Script-&gt;&gt;K8sAPI: Remove debug container\n    Script-&gt;&gt;K8sAPI: Clean up RBAC resources\n    Script-&gt;&gt;User: Display results summary</code></pre>"},{"location":"approaches/debug-container/implementation/#special-considerations","title":"Special Considerations","text":""},{"location":"approaches/debug-container/implementation/#detection-of-distroless-containers","title":"Detection of Distroless Containers","text":"<p>The script detects distroless containers by:</p> <ol> <li>Attempting to execute a basic command</li> <li>Checking for common shells</li> <li>Looking for specific distroless container patterns</li> </ol> <pre><code>kubectl exec -n $NAMESPACE $POD_NAME -c $CONTAINER_NAME -- ls /bin/sh &amp;&gt;/dev/null\nif [ $? -ne 0 ]; then\n  # Container is likely distroless\nfi\n</code></pre>"},{"location":"approaches/debug-container/implementation/#security-context-requirements","title":"Security Context Requirements","text":"<p>For chroot-based scanning, the debug container needs:</p> <pre><code>securityContext:\n  privileged: true\n</code></pre> <p>Without this, the chroot operation will fail.</p>"},{"location":"approaches/debug-container/implementation/#limitations-and-fallbacks","title":"Limitations and Fallbacks","text":"<p>The script implements fallbacks:</p> <ol> <li>First attempts direct filesystem scanning</li> <li>Falls back to chroot if more complete environment access is needed</li> <li>Can operate without chroot but with reduced scan capabilities</li> </ol>"},{"location":"approaches/debug-container/implementation/#related-resources","title":"Related Resources","text":"<ul> <li>Kubernetes Ephemeral Containers Documentation</li> <li>Distroless Container Basics</li> <li>Security Considerations</li> <li>RBAC Configuration</li> </ul>"},{"location":"approaches/debug-container/inventory/","title":"Debug Container Approach Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains detailed documentation about the Debug Container approach for scanning distroless containers.</p>"},{"location":"approaches/debug-container/inventory/#available-files","title":"Available Files","text":"File Description index.md Overview of the Debug Container approach implementation.md Technical implementation details distroless-basics.md What are distroless containers and their challenges rbac.md RBAC configuration and permissions integration.md CI/CD and system integration limitations.md Limitations and requirements security.md Security considerations future-work.md Planned enhancements and roadmap"},{"location":"approaches/debug-container/inventory/#related-directories","title":"Related Directories","text":"Directory Description Kubernetes API Approach Kubernetes API approach documentation Sidecar Container Approach Sidecar Container approach documentation Helper Scripts Helper Scripts approach documentation"},{"location":"approaches/debug-container/inventory/#comparison-resources","title":"Comparison Resources","text":"<ul> <li>Approach Comparison</li> <li>Decision Matrix</li> </ul>"},{"location":"approaches/helper-scripts/","title":"Helper Scripts Approach","text":"<p>This document explains how to use helper scripts for container scanning operations as an alternative to direct commands.</p>"},{"location":"approaches/helper-scripts/#introduction","title":"Introduction","text":"<p>Our container scanning solution provides helper scripts that wrap the complexity of the direct commands, making it easier to perform scanning operations with minimal expertise.</p>"},{"location":"approaches/helper-scripts/#key-features","title":"Key Features","text":"<ul> <li>Easy-to-use wrapper scripts that handle the complexity</li> <li>Automatic RBAC creation and cleanup</li> <li>Built-in integration with threshold validation</li> <li>Streamlined workflows for different container types</li> </ul>"},{"location":"approaches/helper-scripts/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Helper Scripts vs. Direct Commands - Comparison of approaches</li> <li>Available Scripts - Overview of the scripts provided</li> <li>Script Implementation - How the scripts work under the hood</li> <li>Customizing Scripts - How to modify scripts for specific requirements</li> <li>Integration - Integration with CI/CD pipelines and other systems</li> <li>Limitations and Requirements - What's needed and where the approach has constraints</li> </ul>"},{"location":"approaches/helper-scripts/#when-to-use-helper-scripts","title":"When to Use Helper Scripts","text":"<ul> <li>You want a simpler, more streamlined experience</li> <li>You're new to Kubernetes or CINC Auditor</li> <li>You need to quickly implement scanning in CI/CD</li> <li>You want automatic cleanup of temporary resources</li> </ul>"},{"location":"approaches/helper-scripts/#related-resources","title":"Related Resources","text":"<ul> <li>Direct Commands - Using the underlying tools directly</li> <li>Approach Comparison - Compare the different scanning approaches</li> <li>Decision Matrix - Help decide which approach is best for specific scenarios</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/","title":"Available Helper Scripts","text":"<p>This document provides details about the helper scripts available in the project for container scanning operations.</p>"},{"location":"approaches/helper-scripts/available-scripts/#overview-of-scripts","title":"Overview of Scripts","text":"<p>The project includes several helper scripts designed to simplify container scanning operations:</p> Script Purpose Description <code>scan-container.sh</code> Standard Container Scanning Scan standard containers with shell access <code>scan-distroless-container.sh</code> Distroless Container Scanning Scan distroless containers using ephemeral debug containers <code>scan-with-sidecar.sh</code> Sidecar Container Scanning Scan containers using the sidecar approach <code>generate-kubeconfig.sh</code> Authentication Generate a temporary kubeconfig for scanning <code>setup-minikube.sh</code> Environment Setup Set up a Minikube testing environment"},{"location":"approaches/helper-scripts/available-scripts/#script-details","title":"Script Details","text":""},{"location":"approaches/helper-scripts/available-scripts/#scan-containersh","title":"scan-container.sh","text":"<p>Purpose: Scan standard containers using the Kubernetes API approach</p> <p>Usage:</p> <pre><code>./kubernetes-scripts/scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./kubernetes-scripts/scan-container.sh default nginx-pod nginx-container examples/cinc-profiles/container-baseline\n</code></pre> <p>Features:</p> <ul> <li>Automatic RBAC creation with minimal permissions</li> <li>Short-lived token generation</li> <li>Temporary kubeconfig configuration</li> <li>CINC Auditor scan execution</li> <li>Built-in threshold validation</li> <li>Automatic cleanup of resources</li> </ul> <p>Parameters:</p> <ul> <li><code>namespace</code>: The Kubernetes namespace where the target pod is located</li> <li><code>pod-name</code>: The name of the pod containing the target container</li> <li><code>container-name</code>: The name of the container to scan</li> <li><code>profile-path</code>: Path to the InSpec profile to use for scanning</li> <li><code>threshold_file</code> (optional): Path to a threshold file for validation</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/#scan-distroless-containersh","title":"scan-distroless-container.sh","text":"<p>Purpose: Scan distroless containers using ephemeral debug containers</p> <p>Usage:</p> <pre><code>./kubernetes-scripts/scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./kubernetes-scripts/scan-distroless-container.sh default distroless-pod distroless-container examples/cinc-profiles/container-baseline\n</code></pre> <p>Features:</p> <ul> <li>Detection of distroless containers</li> <li>Creation of ephemeral debug containers</li> <li>Filesystem access through process namespace</li> <li>Chroot-based scanning</li> <li>Built-in threshold validation</li> <li>Automatic cleanup of resources</li> </ul> <p>Parameters:</p> <ul> <li><code>namespace</code>: The Kubernetes namespace where the target pod is located</li> <li><code>pod-name</code>: The name of the pod containing the distroless container</li> <li><code>container-name</code>: The name of the distroless container to scan</li> <li><code>profile-path</code>: Path to the InSpec profile to use for scanning</li> <li><code>threshold_file</code> (optional): Path to a threshold file for validation</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/#scan-with-sidecarsh","title":"scan-with-sidecar.sh","text":"<p>Purpose: Deploy and scan containers using the sidecar approach</p> <p>Usage:</p> <pre><code>./kubernetes-scripts/scan-with-sidecar.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./kubernetes-scripts/scan-with-sidecar.sh default sidecar-pod examples/cinc-profiles/container-baseline\n</code></pre> <p>Features:</p> <ul> <li>Deployment of sidecar container alongside target</li> <li>Process namespace sharing configuration</li> <li>Shared volume for result retrieval</li> <li>Built-in threshold validation</li> <li>Automatic cleanup of resources</li> </ul> <p>Parameters:</p> <ul> <li><code>namespace</code>: The Kubernetes namespace for deployment</li> <li><code>pod-name</code>: The name to give the pod with sidecar</li> <li><code>profile-path</code>: Path to the InSpec profile to use for scanning</li> <li><code>threshold_file</code> (optional): Path to a threshold file for validation</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/#generate-kubeconfigsh","title":"generate-kubeconfig.sh","text":"<p>Purpose: Generate a temporary kubeconfig file for scanning</p> <p>Usage:</p> <pre><code>./kubernetes-scripts/generate-kubeconfig.sh &lt;namespace&gt; &lt;service-account&gt; &lt;output-file&gt;\n</code></pre> <p>Example:</p> <pre><code>./kubernetes-scripts/generate-kubeconfig.sh inspec-test scanner-sa ./kubeconfig.yaml\n</code></pre> <p>Features:</p> <ul> <li>Creation of service account token</li> <li>Configuration of cluster connection details</li> <li>Proper permission settings for kubeconfig file</li> </ul> <p>Parameters:</p> <ul> <li><code>namespace</code>: The Kubernetes namespace for the service account</li> <li><code>service-account</code>: The name of the service account to use</li> <li><code>output-file</code>: Path to write the generated kubeconfig</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/#setup-minikubesh","title":"setup-minikube.sh","text":"<p>Purpose: Set up a Minikube environment for testing</p> <p>Usage:</p> <pre><code>./kubernetes-scripts/setup-minikube.sh [--nodes=N] [--with-distroless]\n</code></pre> <p>Example:</p> <pre><code>./kubernetes-scripts/setup-minikube.sh --nodes=2 --with-distroless\n</code></pre> <p>Features:</p> <ul> <li>Minikube cluster creation</li> <li>Multi-node configuration (optional)</li> <li>Deployment of test pods</li> <li>Optional deployment of distroless test pods</li> <li>Setup of basic RBAC for testing</li> </ul> <p>Parameters:</p> <ul> <li><code>--nodes</code> (optional): Number of nodes to create (default: 1)</li> <li><code>--with-distroless</code> (optional): Deploy distroless test pods</li> </ul>"},{"location":"approaches/helper-scripts/available-scripts/#script-outputs","title":"Script Outputs","text":"<p>All scripts provide feedback through:</p> <ol> <li>Standard Output: Progress and information messages</li> <li>Exit Codes: Success (0) or failure (non-zero)</li> <li>JSON Results: Scanner results in JSON format</li> <li>Threshold Validation: Pass/fail based on threshold requirements</li> </ol>"},{"location":"approaches/helper-scripts/available-scripts/#common-features","title":"Common Features","text":"<p>All helper scripts share common features:</p> <ol> <li>Error Handling: Clear error messages and graceful failure</li> <li>Resource Cleanup: Automatic cleanup of temporary resources</li> <li>Usage Help: Built-in help with <code>-h</code> or <code>--help</code> flags</li> <li>Verbose Mode: Additional debugging with <code>-v</code> or <code>--verbose</code> flags</li> <li>Consistent Interface: Similar parameter patterns across scripts</li> </ol>"},{"location":"approaches/helper-scripts/available-scripts/#using-scripts-in-cicd","title":"Using Scripts in CI/CD","text":"<p>The helper scripts are designed for CI/CD integration:</p> <pre><code># GitHub Actions example\nsteps:\n  - name: Scan container\n    run: |\n      ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD $CONTAINER ./profile ./threshold.yml\n</code></pre> <pre><code># GitLab CI example\nscan:\n  stage: test\n  script:\n    - ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD $CONTAINER ./profile ./threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/available-scripts/#related-documentation","title":"Related Documentation","text":"<ul> <li>Scripts vs. Commands - Comparison with direct commands</li> <li>Script Implementation - How the scripts work under the hood</li> <li>Customizing Scripts - How to modify scripts for specific requirements</li> </ul>"},{"location":"approaches/helper-scripts/inventory/","title":"Helper Scripts Approach Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains detailed documentation about using helper scripts for container scanning as an alternative to direct commands.</p>"},{"location":"approaches/helper-scripts/inventory/#available-files","title":"Available Files","text":"File Description index.md Overview of the Helper Scripts approach scripts-vs-commands.md Comparison of helper scripts vs. direct commands available-scripts.md Overview of the scripts provided implementation.md How the scripts work under the hood customization.md How to modify scripts for specific requirements integration.md CI/CD and system integration limitations.md Limitations and requirements"},{"location":"approaches/helper-scripts/inventory/#related-directories","title":"Related Directories","text":"Directory Description Kubernetes API Kubernetes API approach documentation Debug Container Debug Container approach documentation Sidecar Container Sidecar Container approach documentation"},{"location":"approaches/helper-scripts/inventory/#comparison-resources","title":"Comparison Resources","text":"<ul> <li>Approach Comparison</li> <li>Decision Matrix</li> </ul>"},{"location":"approaches/helper-scripts/scripts-vs-commands/","title":"Helper Scripts vs. Direct Commands","text":"<p>This document explains how to use both our helper scripts and the equivalent direct commands for container scanning operations.</p>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#understanding-the-two-approaches","title":"Understanding the Two Approaches","text":"<p>Our container scanning solution can be used in two ways:</p> <ol> <li>Helper Scripts: Easy-to-use wrapper scripts that handle the complexity</li> <li>Direct Commands: Using the underlying tools directly for more control</li> </ol>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#container-scanning-with-helper-scripts-vs-direct-commands","title":"Container Scanning with Helper Scripts vs. Direct Commands","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#setup-minikube-for-testing","title":"Setup Minikube for Testing","text":"Helper Script Direct Commands <code>./kubernetes-scripts/setup-minikube.sh --nodes=2 --with-distroless</code> ```bash minikube start --nodes=2 kubectl create namespace inspec-test kubectl -n inspec-test create serviceaccount inspec-scanner"},{"location":"approaches/helper-scripts/scripts-vs-commands/#create-rbac-manually-with-kubectl-apply","title":"Create RBAC manually with kubectl apply","text":"<p>``` |</p>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#creating-scanning-infrastructure","title":"Creating Scanning Infrastructure","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts","title":"With Helper Scripts","text":"<pre><code># Install all components with a single script\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands","title":"With Direct Commands","text":"<pre><code># Install each component separately\nkubectl create namespace inspec-test\n\n# Create the service account\nkubectl -n inspec-test create serviceaccount inspec-scanner\n\n# Create the role\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\nEOF\n\n# Create the role binding\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-scanner\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n\n# Create a test pod\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: inspec-target\n  namespace: inspec-test\n  labels:\n    app: inspec-target\n    scan-target: \"true\"\nspec:\n  containers:\n  - name: busybox\n    image: busybox:latest\n    command: [\"sleep\", \"infinity\"]\nEOF\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#creating-authentication","title":"Creating Authentication","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts_1","title":"With Helper Scripts","text":"<pre><code># Generate kubeconfig automatically\n./kubernetes-scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands_1","title":"With Direct Commands","text":"<pre><code># Generate token\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=60m)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create kubeconfig manually\ncat &gt; ./kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: inspec-scanner\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: inspec-scanner\n  user:\n    token: ${TOKEN}\nEOF\n\nchmod 600 ./kubeconfig.yaml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#running-a-standard-container-scan","title":"Running a Standard Container Scan","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts_2","title":"With Helper Scripts","text":"<pre><code># One-line scan with automatic RBAC, token, and threshold validation\n./kubernetes-scripts/scan-container.sh inspec-test inspec-target busybox ../../examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands_2","title":"With Direct Commands","text":"<pre><code># Run CINC Auditor directly\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#scanning-distroless-containers","title":"Scanning Distroless Containers","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts_3","title":"With Helper Scripts","text":"<pre><code># One-line scan of distroless container with ephemeral debug container\n./kubernetes-scripts/scan-distroless-container.sh inspec-test distroless-target app ../../examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands_3","title":"With Direct Commands","text":"<pre><code># Create debug container manually\nkubectl debug -n inspec-test distroless-target \\\n  --image=docker.io/cincproject/auditor:latest \\\n  --target=distroless \\\n  --container=debug-container \\\n  -- sleep 300 &amp;\n\n# Wait for debug container to be ready\nsleep 10\n\n# Run scan against debug container\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/distroless-target/debug-container \\\n  --reporter cli json:scan-results.json\n\n# Process results with SAF CLI\nsaf summary --input scan-results.json --output-md scan-summary.md\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#using-helm-for-deployment","title":"Using Helm for Deployment","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts_4","title":"With Helper Scripts","text":"<pre><code># Install everything with a single command\n./helm-charts/install-all.sh --namespace inspec-test\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands_4","title":"With Direct Commands","text":"<pre><code># Install each chart separately\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#saf-cli-integration","title":"SAF CLI Integration","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-helper-scripts_5","title":"With Helper Scripts","text":"<pre><code># Threshold validation is built into the scan scripts\n./kubernetes-scripts/scan-container.sh inspec-test inspec-target busybox ../../examples/cinc-profiles/container-baseline ./threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#with-direct-commands_5","title":"With Direct Commands","text":"<pre><code># Run scan and get results\ncinc-auditor exec ../../examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target/busybox \\\n  --reporter cli json:scan-results.json\n\n# Generate summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Apply threshold validation\nsaf threshold -i scan-results.json -t threshold.yml\nTHRESHOLD_RESULT=$?\n\nif [ $THRESHOLD_RESULT -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\n  exit $THRESHOLD_RESULT\nfi\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Run container scan\n  run: |\n    # Helper script method\n    ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#gitlab-ci","title":"GitLab CI","text":"<pre><code>run_scan:\n  stage: scan\n  script:\n    # Helper script method\n    ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD_NAME $CONTAINER_NAME ./profile ./threshold.yml\n\n    # OR direct method\n    KUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profile \\\n      -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n      --reporter cli json:scan-results.json\n\n    saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#which-method-to-choose","title":"Which Method to Choose?","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#use-helper-scripts-when","title":"Use Helper Scripts When","text":"<ul> <li>You want a simpler, more streamlined experience</li> <li>You're new to Kubernetes or CINC Auditor</li> <li>You need to quickly implement scanning in CI/CD</li> <li>You want automatic cleanup of temporary resources</li> </ul>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#use-direct-commands-when","title":"Use Direct Commands When","text":"<ul> <li>You need more control over the process</li> <li>You're integrating with existing automation</li> <li>You want to understand what's happening \"under the hood\"</li> <li>You need to customize the scanning process</li> </ul>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#known-limitations","title":"Known Limitations","text":""},{"location":"approaches/helper-scripts/scripts-vs-commands/#helper-scripts","title":"Helper Scripts","text":"<ul> <li>Less flexibility for advanced use cases</li> <li>Dependencies between scripts might not be immediately obvious</li> <li>Limited customization of RBAC without modifying the scripts</li> </ul>"},{"location":"approaches/helper-scripts/scripts-vs-commands/#direct-commands","title":"Direct Commands","text":"<ul> <li>More complex to implement</li> <li>Requires deeper understanding of Kubernetes and CINC Auditor</li> <li>Manual cleanup of resources required</li> </ul>"},{"location":"approaches/kubernetes-api/","title":"Kubernetes API Approach","text":"<p>This document provides an overview of the Kubernetes API approach for container scanning using CINC Auditor.</p>"},{"location":"approaches/kubernetes-api/#introduction","title":"Introduction","text":"<p>The Kubernetes API approach utilizes the <code>train-k8s-container</code> InSpec transport plugin to scan containers by connecting directly to the Kubernetes API. This approach is the primary recommended method for enterprise environments.</p>"},{"location":"approaches/kubernetes-api/#key-features","title":"Key Features","text":"<ul> <li>No modifications to existing pods or containers</li> <li>Minimal permissions using least privilege principle</li> <li>Easy integration with CI/CD pipelines</li> <li>Simple, consistent user experience</li> </ul>"},{"location":"approaches/kubernetes-api/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Technical Implementation - How the approach works and detailed technical specifications</li> <li>RBAC Configuration - Required permissions and security considerations</li> <li>Integration - Integration with CI/CD pipelines and other systems</li> <li>Limitations and Requirements - What's needed and where the approach has constraints</li> <li>Security Considerations - Security implications and best practices</li> <li>Future Work - Planned enhancements and development roadmap</li> </ul>"},{"location":"approaches/kubernetes-api/#related-resources","title":"Related Resources","text":"<ul> <li>Approach Comparison - Compare the Kubernetes API approach with other options</li> <li>Decision Matrix - Help decide which approach is best for specific scenarios</li> <li>Workflows - Visual representation of workflows</li> <li>Security Analysis - Detailed security analysis</li> </ul>"},{"location":"approaches/kubernetes-api/implementation/","title":"Kubernetes API Approach Implementation","text":"<p>This document outlines the technical implementation of container scanning using the Kubernetes API approach with CINC Auditor.</p>"},{"location":"approaches/kubernetes-api/implementation/#how-it-works","title":"How It Works","text":"<p>The <code>train-k8s-container</code> transport connects to pods using the Kubernetes API:</p> <pre><code>inspec exec my-profile -t k8s-container://namespace/pod-name/container-name\n</code></pre> <p>This transport:</p> <ol> <li>Uses <code>kubectl exec</code> to run commands inside target containers</li> <li>Accesses container filesystem and system information</li> <li>Executes InSpec controls based on command output and file analysis</li> <li>Generates compliance reports in multiple formats</li> </ol>"},{"location":"approaches/kubernetes-api/implementation/#implementation-steps","title":"Implementation Steps","text":"<p>Our implemented workflow consists of:</p> <ol> <li>Setup minimal RBAC permissions:</li> <li>Create a temporary service account</li> <li>Assign role with minimal permissions (get, list pods; exec into specific pod)</li> <li> <p>Bind role to service account</p> </li> <li> <p>Generate temporary access credentials:</p> </li> <li>Create short-lived token (typically 1-hour expiration)</li> <li> <p>Generate minimal kubeconfig file</p> </li> <li> <p>Execute scan:</p> </li> <li>Run CINC Auditor with the k8s-container transport</li> <li>Pass namespace, pod, and container information</li> <li> <p>Utilize InSpec profiles appropriate for the target</p> </li> <li> <p>Process results:</p> </li> <li>Generate standard InSpec reports</li> <li>Apply compliance thresholds</li> <li> <p>Integrate with reporting systems</p> </li> <li> <p>Cleanup:</p> </li> <li>Remove temporary RBAC resources</li> <li>Delete temporary kubeconfig</li> </ol>"},{"location":"approaches/kubernetes-api/implementation/#script-implementation","title":"Script Implementation","text":"<p>The project includes the <code>scan-container.sh</code> script that implements this approach with the following capabilities:</p> <ul> <li>Dynamic RBAC creation with minimal permissions</li> <li>Short-lived token generation</li> <li>Configuration of temporary kubeconfig</li> <li>Execution of CINC Auditor scan</li> <li>Integration with MITRE SAF-CLI for threshold validation</li> <li>Automatic cleanup of resources</li> </ul> <pre><code># Example usage:\n./kubernetes-scripts/scan-container.sh my-namespace my-pod my-container ./profiles/linux-baseline\n</code></pre>"},{"location":"approaches/kubernetes-api/implementation/#transport-plugin-details","title":"Transport Plugin Details","text":"<p>The train-k8s-container transport plugin operates as follows:</p> <ol> <li>Connection Initialization:</li> <li>Load kubeconfig from KUBECONFIG environment variable or default path</li> <li>Create connection to Kubernetes API server</li> <li> <p>Validate access to target namespace and pod</p> </li> <li> <p>Command Execution:</p> </li> <li> <p>For each InSpec resource that needs to execute a command:</p> <ul> <li>Create an exec request to the Kubernetes API</li> <li>Execute the command in the target container</li> <li>Capture and return the command output</li> </ul> </li> <li> <p>File Access:</p> </li> <li> <p>When InSpec needs to access file content or attributes:</p> <ul> <li>Use exec with cat or appropriate commands</li> <li>Process the data as needed for the InSpec resource</li> </ul> </li> <li> <p>Resource Mapping:</p> </li> <li>Map standard InSpec resources to Kubernetes exec calls</li> <li>Handle special cases like process inspection and package management</li> </ol> <p>This approach allows InSpec to \"see\" the container as if it were directly connected while maintaining the security boundaries of the Kubernetes API.</p>"},{"location":"approaches/kubernetes-api/implementation/#technical-diagram","title":"Technical Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Script as scan-container.sh\n    participant K8sAPI as Kubernetes API\n    participant CINC as CINC Auditor\n    participant Pod as Target Pod/Container\n\n    User-&gt;&gt;Script: Run scan-container.sh\n    Script-&gt;&gt;K8sAPI: Create temporary service account\n    Script-&gt;&gt;K8sAPI: Create role with minimal permissions\n    Script-&gt;&gt;K8sAPI: Create role binding\n    Script-&gt;&gt;K8sAPI: Generate short-lived token\n    Script-&gt;&gt;Script: Create temporary kubeconfig\n\n    Script-&gt;&gt;CINC: Execute CINC Auditor with k8s-container transport\n\n    loop For each InSpec control\n        CINC-&gt;&gt;K8sAPI: Request exec in target container\n        K8sAPI-&gt;&gt;Pod: Execute command\n        Pod-&gt;&gt;K8sAPI: Return results\n        K8sAPI-&gt;&gt;CINC: Return command output\n    end\n\n    CINC-&gt;&gt;Script: Return scan results\n    Script-&gt;&gt;Script: Process results with threshold validation\n    Script-&gt;&gt;User: Display results summary\n\n    Script-&gt;&gt;K8sAPI: Remove temporary resources\n    Script-&gt;&gt;Script: Remove temporary kubeconfig</code></pre>"},{"location":"approaches/kubernetes-api/implementation/#advanced-options","title":"Advanced Options","text":"<p>The train-k8s-container plugin supports several advanced options:</p> <ul> <li>Command Timeout: Adjust timeout for long-running commands</li> <li>Error Handling: Configure how to handle command execution errors</li> <li>Transport Configuration: Specify custom kubectl path or options</li> <li>Authentication: Multiple authentication methods (cert, token, username/password)</li> </ul> <p>For additional options, refer to the InSpec train-k8s-container transport documentation.</p>"},{"location":"approaches/kubernetes-api/inventory/","title":"Kubernetes API Approach Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains detailed documentation about the Kubernetes API approach for container scanning.</p>"},{"location":"approaches/kubernetes-api/inventory/#available-files","title":"Available Files","text":"File Description index.md Overview of the Kubernetes API approach implementation.md Technical implementation details rbac.md RBAC configuration and permissions integration.md CI/CD and system integration limitations.md Limitations and requirements security.md Security considerations future-work.md Planned enhancements and roadmap"},{"location":"approaches/kubernetes-api/inventory/#related-directories","title":"Related Directories","text":"Directory Description Debug Container Debug Container approach documentation Sidecar Container Sidecar Container approach documentation Helper Scripts Helper Scripts approach documentation"},{"location":"approaches/kubernetes-api/inventory/#comparison-resources","title":"Comparison Resources","text":"<ul> <li>Approach Comparison</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/","title":"Limitations and Requirements for Kubernetes API Approach","text":"<p>This document outlines the requirements and limitations of the Kubernetes API approach for container scanning.</p>"},{"location":"approaches/kubernetes-api/limitations/#technical-requirements","title":"Technical Requirements","text":"<p>The Kubernetes API approach requires:</p> <ul> <li>Standard shell in the target container (typically <code>/bin/sh</code> or <code>/bin/bash</code>)</li> <li>Command execution capability in the target container</li> <li>Proper RBAC permissions to execute commands in containers</li> <li>Access to the Kubernetes API server</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#environment-requirements","title":"Environment Requirements","text":"<ul> <li>Kubernetes Cluster: Any version of Kubernetes is supported</li> <li>kubectl: For script-based scanning</li> <li>CINC Auditor/InSpec: For executing compliance controls</li> <li>Kubeconfig: Properly configured for cluster access</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#container-requirements","title":"Container Requirements","text":"<ul> <li>Shell Access: Target container must have a shell</li> <li>Command Execution: Target container must allow command execution</li> <li>Standard Utilities: Many InSpec resources rely on standard commands (<code>ps</code>, <code>ls</code>, etc.)</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#known-limitations","title":"Known Limitations","text":""},{"location":"approaches/kubernetes-api/limitations/#distroless-containers","title":"Distroless Containers","text":"<p>The primary limitation is with distroless containers, which:</p> <ul> <li>Lack a shell (<code>/bin/sh</code> or <code>/bin/bash</code>)</li> <li>Don't have standard utilities</li> <li>Cannot execute arbitrary commands</li> </ul> <p>For distroless containers, consider:</p> <ul> <li>Debug Container Approach as an interim solution</li> <li>Sidecar Container Approach as an alternative</li> <li>Wait for the planned distroless support in the train-k8s-container plugin</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#windows-containers","title":"Windows Containers","text":"<ul> <li>Limited support for Windows containers</li> <li>Requires Windows-specific profiles</li> <li>Command execution may work differently than in Linux containers</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#container-security-constraints","title":"Container Security Constraints","text":"<p>Containers with certain security constraints may not work:</p> <ul> <li>Containers running without shell access</li> <li>Containers with AppArmor/SELinux profiles that block command execution</li> <li>Containers with restricted capabilities</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#network-considerations","title":"Network Considerations","text":"<ul> <li>Requires network access to the Kubernetes API server</li> <li>May be impacted by network policies restricting pod communication</li> <li>Can be affected by firewall rules between scanning client and Kubernetes API</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#workarounds-for-limitations","title":"Workarounds for Limitations","text":""},{"location":"approaches/kubernetes-api/limitations/#for-distroless-containers","title":"For Distroless Containers","text":"<ol> <li>Short-Term: Use the Debug Container or Sidecar Container approach</li> <li>Long-Term: Monitor project progress for native distroless container support</li> </ol>"},{"location":"approaches/kubernetes-api/limitations/#for-network-restrictions","title":"For Network Restrictions","text":"<ol> <li>API Access: Ensure network policies allow access to the Kubernetes API</li> <li>Proxy Configuration: Configure kubectl to use appropriate proxy settings if required</li> <li>VPN/Tunnel: Set up secure tunneling if operating across network boundaries</li> </ol>"},{"location":"approaches/kubernetes-api/limitations/#planned-solutions","title":"Planned Solutions","text":"<p>Work is in progress to address these limitations:</p> <ol> <li>Enhanced Plugin: Modifying the train-k8s-container plugin to support distroless containers</li> <li>Special Handlers: Creating special resource handlers for non-standard containers</li> <li>Alternative Access Methods: Developing alternative filesystem access methods</li> </ol>"},{"location":"approaches/kubernetes-api/limitations/#compatibility-matrix","title":"Compatibility Matrix","text":"Container Type Compatible Notes Standard Linux containers \u2705 Yes Fully supported Alpine containers \u2705 Yes Requires sh shell (default in Alpine) Minimal containers \u2705 Yes As long as they have a shell Distroless containers \u274c No Currently unsupported, in development Windows containers \u26a0\ufe0f Limited Limited functionality Secure sandbox containers \u26a0\ufe0f Limited Depends on security constraints"},{"location":"approaches/kubernetes-api/limitations/#performance-considerations","title":"Performance Considerations","text":"<p>The Kubernetes API approach may have performance limitations:</p> <ul> <li>Command Round-Trips: Each command requires a round-trip to the Kubernetes API</li> <li>Large File Transfers: Reading large files via exec can be slow</li> <li>API Rate Limiting: Possible API server rate limiting on high-volume scanning</li> </ul>"},{"location":"approaches/kubernetes-api/limitations/#related-resources","title":"Related Resources","text":"<ul> <li>Debug Container Approach - Alternative for distroless containers</li> <li>Sidecar Container Approach - Alternative universal approach</li> <li>Approach Comparison - Compare approaches for different scenarios</li> <li>Future Work - Planned enhancements to address limitations</li> </ul>"},{"location":"approaches/kubernetes-api/rbac/","title":"RBAC Permissions for Kubernetes API Approach","text":"<p>This document details the RBAC permissions required for the Kubernetes API scanning approach.</p>"},{"location":"approaches/kubernetes-api/rbac/#minimum-rbac-requirements","title":"Minimum RBAC Requirements","text":"<p>The minimum RBAC permissions required are:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre> <p>These permissions follow the principle of least privilege by:</p> <ul> <li>Limiting access to a specific namespace</li> <li>Restricting exec access to only the target pod</li> <li>Providing only the necessary permissions for scanning</li> </ul>"},{"location":"approaches/kubernetes-api/rbac/#rolebinding-configuration","title":"RoleBinding Configuration","text":"<p>The Role must be bound to a service account:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-rolebinding\n  namespace: ${NAMESPACE}\nsubjects:\n- kind: ServiceAccount\n  name: scanner-service-account\n  namespace: ${NAMESPACE}\nroleRef:\n  kind: Role\n  name: scanner-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"approaches/kubernetes-api/rbac/#service-account-creation","title":"Service Account Creation","text":"<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-service-account\n  namespace: ${NAMESPACE}\n</code></pre>"},{"location":"approaches/kubernetes-api/rbac/#security-advantages","title":"Security Advantages","text":"<p>This RBAC configuration offers significant security advantages:</p> <ol> <li>Limited Scope: Access is constrained to only the required resources</li> <li>Pod-Specific Restrictions: The <code>resourceNames</code> field restricts exec access to only the target pod</li> <li>Namespace Isolation: Permissions are limited to a specific namespace</li> <li>Temporary Nature: The service account can be created just before scanning and removed afterwards</li> <li>No Privileged Access: No elevated permissions are required</li> </ol>"},{"location":"approaches/kubernetes-api/rbac/#dynamic-rbac-generation","title":"Dynamic RBAC Generation","text":"<p>The <code>scan-container.sh</code> script dynamically generates:</p> <ol> <li>A temporary service account</li> <li>A role with minimal permissions tailored to the target pod</li> <li>A role binding to connect the two</li> <li>A short-lived authentication token</li> </ol> <p>This ensures that:</p> <ul> <li>Each scan uses fresh credentials</li> <li>Credentials expire automatically (typically after 1 hour)</li> <li>Only the minimum required permissions are granted</li> </ul>"},{"location":"approaches/kubernetes-api/rbac/#rbac-templates","title":"RBAC Templates","text":"<p>The following template is used by the <code>scan-container.sh</code> script:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-sa-${RANDOM_SUFFIX}\n  namespace: ${NAMESPACE}\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role-${RANDOM_SUFFIX}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-binding-${RANDOM_SUFFIX}\n  namespace: ${NAMESPACE}\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa-${RANDOM_SUFFIX}\n  namespace: ${NAMESPACE}\nroleRef:\n  kind: Role\n  name: scanner-role-${RANDOM_SUFFIX}\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"approaches/kubernetes-api/rbac/#cluster-wide-alternative","title":"Cluster-Wide Alternative","text":"<p>For scanning across multiple namespaces, a more permissive but still restricted ClusterRole can be used:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: multi-namespace-scanner-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n</code></pre> <p>Security Consideration</p> <p>The cluster-wide approach is less secure than the namespace-specific approach since it grants broader access. Use only when necessary and implement additional controls like:</p> <ul> <li>Short-lived tokens</li> <li>Audit logging</li> <li>Pod security policies to restrict which pods can be executed in</li> </ul>"},{"location":"approaches/kubernetes-api/rbac/#label-based-rbac","title":"Label-Based RBAC","text":"<p>For more advanced scenarios, label-based RBAC can be used:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: label-based-scanner-role\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\", \"pods/log\"]\n  verbs: [\"create\", \"get\"]\n  resourceNames: []\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: label-based-scanner-binding\n  namespace: ${NAMESPACE}\nsubjects:\n- kind: ServiceAccount\n  name: scanner-service-account\n  namespace: ${NAMESPACE}\nroleRef:\n  kind: Role\n  name: label-based-scanner-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>This can be combined with label selectors in your scanning tools to only scan pods with specific labels.</p>"},{"location":"approaches/kubernetes-api/rbac/#related-resources","title":"Related Resources","text":"<ul> <li>Security Considerations</li> <li>Kubernetes RBAC Documentation</li> <li>Label-based RBAC</li> </ul>"},{"location":"approaches/sidecar-container/","title":"Sidecar Container Approach","text":"<p>This document provides an overview of the Sidecar Container approach for scanning containers.</p>"},{"location":"approaches/sidecar-container/#introduction","title":"Introduction","text":"<p>The Sidecar Container approach involves deploying a CINC Auditor container alongside the target container within the same pod. This allows the scanner container to access the target container's filesystem through the shared process namespace.</p>"},{"location":"approaches/sidecar-container/#key-features","title":"Key Features","text":"<ul> <li>Works with any Kubernetes cluster regardless of version</li> <li>Provides universal compatibility for all container types</li> <li>Requires deploying containers with the sidecar configuration</li> <li>Can access container filesystems through process namespace sharing</li> </ul>"},{"location":"approaches/sidecar-container/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Technical Implementation - How the approach works, pod configuration, and retrieving results</li> <li>RBAC Configuration - Required permissions and security considerations</li> <li>Integration - Integration with CI/CD pipelines and other systems</li> <li>Limitations and Requirements - What's needed and where the approach has constraints</li> <li>Security Considerations - Security implications and best practices</li> <li>Future Work - Planned enhancements and development roadmap</li> </ul>"},{"location":"approaches/sidecar-container/#related-resources","title":"Related Resources","text":"<ul> <li>Approach Comparison - Compare the Sidecar Container approach with other options</li> <li>Decision Matrix - Help decide which approach is best for specific scenarios</li> <li>Workflow Diagrams - Visual representation of workflows</li> <li>Security Analysis - Detailed security analysis</li> </ul>"},{"location":"approaches/sidecar-container/implementation/","title":"CINC Auditor Sidecar Container Approach","text":"<p>This document outlines an alternative approach for container scanning using a CINC Auditor sidecar container. This approach is particularly useful for scanning distroless containers and can be an alternative to the ephemeral container approach.</p>"},{"location":"approaches/sidecar-container/implementation/#overview","title":"Overview","text":"<p>The sidecar container approach involves deploying a CINC Auditor container alongside the target container within the same pod. This allows the CINC Auditor container to access the target container's filesystem through the shared process namespace.</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Deploy Pod with Sidecar]\n\n    subgraph \"Target Pod\"\n    C1[Target Container]\n    C2[CINC Auditor Sidecar]\n    end\n\n    B --&gt; D[Mount Shared Volume]\n    D --&gt; E[Share Process Namespace]\n    E --&gt; F[Run CINC Auditor in Sidecar]\n    F --&gt; G[Access Target Filesystem via /proc]\n    G --&gt; H[Execute Compliance Controls]\n    H --&gt; I[Write Results to Shared Volume]\n    I --&gt; J[Container or Scheduler Retrieves Results]\n    J --&gt; K[Generate Reports]\n    K --&gt; L[Validate Against Thresholds]\n    L --&gt; M[End]\n\n    C1 --- C2\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C1 fill:#fbb,stroke:#333,stroke-width:2px\n    style C2 fill:#bbf,stroke:#333,stroke-width:2px\n    style F fill:#bbf,stroke:#333,stroke-width:2px\n    style L fill:#bfb,stroke:#333,stroke-width:2px\n    style M fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"approaches/sidecar-container/implementation/#key-components","title":"Key Components","text":"<ol> <li>Target Container: The container to be scanned, which could be a regular container or a distroless container.</li> <li>CINC Auditor Sidecar: A container with CINC Auditor pre-installed, deployed in the same pod.</li> <li>Shared Process Namespace: Enables the sidecar to access the target container's filesystem through /proc.</li> <li>Shared Volume: Optional component to make it easier to retrieve scan results.</li> </ol>"},{"location":"approaches/sidecar-container/implementation/#implementation","title":"Implementation","text":""},{"location":"approaches/sidecar-container/implementation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with support for shared process namespaces (v1.17+)</li> <li>RBAC permissions to create pods with shared process namespaces</li> <li>A CINC Auditor container image</li> </ul>"},{"location":"approaches/sidecar-container/implementation/#pod-definition","title":"Pod Definition","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-with-scanner\n  namespace: inspec-test\nspec:\n  shareProcessNamespace: true  # Enable shared process namespace\n  containers:\n  - name: app\n    image: your-app-image:latest\n    # Application container configuration\n    volumeMounts:\n    - name: shared-results\n      mountPath: /results\n\n  - name: cinc-scanner\n    image: cinc-auditor:latest\n    command: \n    - \"/bin/sh\"\n    - \"-c\"\n    - |\n      # Wait for the main container to start\n      sleep 5\n\n      # Find the main process of the target container\n      TARGET_PID=$(ps aux | grep -v grep | grep -m 1 \"app process identifier\" | awk '{print $2}')\n\n      # Run CINC Auditor against the target filesystem\n      cd /\n      cinc-auditor exec /opt/profiles/container-baseline \\\n        -b os=linux \\\n        --target=/proc/$TARGET_PID/root \\\n        --reporter json:/results/scan-results.json\n\n      # Indicate completion\n      touch /results/scan-complete\n\n      # Keep the container running to allow result retrieval\n      sleep 3600\n    volumeMounts:\n    - name: shared-results\n      mountPath: /results\n    - name: profiles\n      mountPath: /opt/profiles\n\n  volumes:\n  - name: shared-results\n    emptyDir: {}\n  - name: profiles\n    configMap:\n      name: inspec-profiles\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#retrieving-results","title":"Retrieving Results","text":"<p>Results can be retrieved in several ways:</p> <ol> <li>Kubernetes API: Retrieve the results from the shared volume using the API</li> <li>kubectl cp: Copy results from the pod to the local filesystem</li> <li>Result Collection Container: Add a third container to the pod that processes and uploads the results</li> </ol> <p>Example:</p> <pre><code># Wait for scan to complete\nkubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\n\n# Check if scan is complete\nkubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls -la /results\n\n# Copy results if scan-complete file exists\nkubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\n\n# Process results with SAF CLI\nsaf summary --input ./scan-results.json --output-md ./summary.md\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#advantages-over-other-approaches","title":"Advantages Over Other Approaches","text":"<ol> <li>No Modifications to Train-k8s-container Plugin: Works with standard CINC Auditor installations.</li> <li>Deployed Alongside Application: Can be included in application deployment pipelines.</li> <li>Works with Any Container Type: Effective for both standard and distroless containers.</li> <li>No Need for Ephemeral Containers: Works with older Kubernetes clusters.</li> <li>Simpler Implementation: Requires less custom code than the transport plugin modification approach.</li> </ol>"},{"location":"approaches/sidecar-container/implementation/#limitations","title":"Limitations","text":"<ol> <li>Pod Modification Required: The target pod must be defined with the sidecar and shared process namespace.</li> <li>Security Implications: Sharing process namespaces has security implications that should be considered.</li> <li>Not Suitable for Existing Pods: The approach requires creating a new pod with the sidecar, not modifying existing pods.</li> <li>More Resource Intensive: Running an additional container consumes more resources than other approaches.</li> </ol>"},{"location":"approaches/sidecar-container/implementation/#example-implementation","title":"Example Implementation","text":""},{"location":"approaches/sidecar-container/implementation/#step-1-create-a-configmap-with-inspec-profiles","title":"Step 1: Create a ConfigMap with InSpec Profiles","text":"<pre><code>kubectl create configmap inspec-profiles --from-file=container-baseline=/path/to/profiles/container-baseline -n inspec-test\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#step-2-deploy-the-pod-with-sidecar","title":"Step 2: Deploy the Pod with Sidecar","text":"<pre><code>kubectl apply -f sidecar-scanner-pod.yaml -n inspec-test\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#step-3-wait-for-the-scan-to-complete","title":"Step 3: Wait for the Scan to Complete","text":"<pre><code>kubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\nuntil kubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls /results/scan-complete 2&gt;/dev/null; do\n  echo \"Waiting for scan to complete...\"\n  sleep 5\ndone\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#step-4-retrieve-and-process-results","title":"Step 4: Retrieve and Process Results","text":"<pre><code>kubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\nsaf summary --input ./scan-results.json --output-md ./summary.md\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#cicd-integration","title":"CI/CD Integration","text":"<p>For CI/CD environments, the sidecar approach can be integrated as follows:</p> <ol> <li>Build Stage: Build and push the application container.</li> <li>Test Stage: Deploy the application with the CINC Auditor sidecar.</li> <li>Scan Stage: Wait for the scan to complete and retrieve results.</li> <li>Validation Stage: Process results against thresholds.</li> <li>Cleanup Stage: Remove the test pod.</li> </ol> <p>Example GitLab CI configuration:</p> <pre><code>stages:\n  - build\n  - test\n  - scan\n  - validate\n  - cleanup\n\nbuild:\n  stage: build\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n\ndeploy_with_sidecar:\n  stage: test\n  script:\n    - envsubst &lt; sidecar-scanner-pod.yaml | kubectl apply -f -\n\nscan:\n  stage: scan\n  script:\n    - kubectl wait --for=condition=ready pod/app-with-scanner -n inspec-test\n    - |\n      until kubectl exec -it app-with-scanner -n inspec-test -c cinc-scanner -- ls /results/scan-complete 2&gt;/dev/null; do\n        echo \"Waiting for scan to complete...\"\n        sleep 5\n      done\n    - kubectl cp inspec-test/app-with-scanner:/results/scan-results.json ./scan-results.json -c cinc-scanner\n\nvalidate:\n  stage: validate\n  script:\n    - saf threshold -i ./scan-results.json -t threshold.yml\n    - saf summary --input ./scan-results.json --output-md ./summary.md\n\ncleanup:\n  stage: cleanup\n  script:\n    - kubectl delete pod app-with-scanner -n inspec-test\n</code></pre>"},{"location":"approaches/sidecar-container/implementation/#security-considerations","title":"Security Considerations","text":"<p>When implementing the sidecar container approach, consider the following security implications:</p> <ol> <li>Shared Process Namespace: All containers in the pod can see each other's processes, which could be a security concern.</li> <li>Temporary Deployments: For production environments, consider using this approach only for temporary test deployments.</li> <li>RBAC Restrictions: Implement strict RBAC to limit which users/systems can deploy pods with shared process namespaces.</li> <li>Resource Isolation: Ensure the sidecar container has appropriate resource limits.</li> </ol>"},{"location":"approaches/sidecar-container/implementation/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements to this approach:</p> <ol> <li>Automated Sidecar Injection: Use a mutating webhook to automatically inject the scanner sidecar.</li> <li>Results Aggregation: Implement a results collector that aggregates results from multiple scanned pods.</li> <li>Optimized CINC Image: Create a minimal CINC Auditor image specifically designed for sidecars.</li> <li>Integration with Helm: Add support for this approach in our Helm charts.</li> </ol>"},{"location":"approaches/sidecar-container/implementation/#references","title":"References","text":"<ul> <li>Kubernetes Shared Process Namespace Documentation</li> <li>CINC Auditor Documentation</li> <li>Sidecar Container Pattern</li> </ul>"},{"location":"approaches/sidecar-container/inventory/","title":"Sidecar Container Approach Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains detailed documentation about the Sidecar Container approach for container scanning.</p>"},{"location":"approaches/sidecar-container/inventory/#available-files","title":"Available Files","text":"File Description index.md Overview of the Sidecar Container approach implementation.md Technical implementation details, pod configuration, and retrieving results rbac.md RBAC configuration and permissions integration.md CI/CD and system integration limitations.md Limitations and requirements security.md Security considerations future-work.md Planned enhancements and roadmap"},{"location":"approaches/sidecar-container/inventory/#related-directories","title":"Related Directories","text":"Directory Description Kubernetes API Kubernetes API approach documentation Debug Container Debug Container approach documentation Helper Scripts Helper Scripts approach documentation"},{"location":"approaches/sidecar-container/inventory/#comparison-resources","title":"Comparison Resources","text":"<ul> <li>Approach Comparison</li> <li>Decision Matrix</li> </ul>"},{"location":"approaches/sidecar-container/pod-configuration/","title":"Pod Configuration for Sidecar Container Scanning","text":"<p>This document explains how to configure Kubernetes pods to use the sidecar container scanning approach.</p>"},{"location":"approaches/sidecar-container/pod-configuration/#overview","title":"Overview","text":"<p>When using the sidecar container approach, you need to configure your pods to include the CINC Auditor scanner container alongside your target container. The two containers share the same pod, allowing the scanner to access the target container's filesystem.</p>"},{"location":"approaches/sidecar-container/pod-configuration/#configuration-requirements","title":"Configuration Requirements","text":"<p>To enable sidecar scanning, your pod configuration needs:</p> <ol> <li>The main application container</li> <li>A CINC Auditor scanner container in the same pod</li> <li>Shared process namespace between containers</li> <li>Appropriate volume mounts for results storage</li> </ol>"},{"location":"approaches/sidecar-container/pod-configuration/#example-pod-configuration","title":"Example Pod Configuration","text":"<p>Here is an example pod configuration with a sidecar scanner:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-with-scanner-sidecar\nspec:\n  # Enable shared process namespace\n  shareProcessNamespace: true\n  # Configure containers\n  containers:\n  # Your application container\n  - name: app\n    image: your-application-image:tag\n    # Container configuration...\n\n  # Scanner sidecar container\n  - name: scanner\n    image: cinc-auditor-scanner:latest\n    # Mount volumes for scan results\n    volumeMounts:\n    - name: results-volume\n      mountPath: /opt/scan-results\n    # Scanner environment variables\n    env:\n    - name: TARGET_CONTAINER\n      value: \"app\"\n    - name: PROFILE_PATH\n      value: \"/opt/profiles/container-baseline\"\n    - name: RESULT_PATH\n      value: \"/opt/scan-results\"\n\n  # Volumes for storing results\n  volumes:\n  - name: results-volume\n    emptyDir: {}\n</code></pre>"},{"location":"approaches/sidecar-container/pod-configuration/#using-with-deployments-and-statefulsets","title":"Using with Deployments and StatefulSets","text":"<p>To apply this pattern to Deployments or StatefulSets, add the sidecar configuration to the pod template spec:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-with-scanner\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      shareProcessNamespace: true\n      containers:\n      - name: app\n        # Application container config...\n      - name: scanner\n        # Scanner container config...\n</code></pre>"},{"location":"approaches/sidecar-container/pod-configuration/#helm-chart-support","title":"Helm Chart Support","text":"<p>For simplified deployment using Helm, use the provided <code>sidecar-scanner</code> chart:</p> <pre><code>helm install scanner-sidecar ./helm-charts/sidecar-scanner/ \\\n  --set targetPod.name=your-app-pod \\\n  --set targetContainer.name=app\n</code></pre> <p>The Helm chart handles the sidecar configuration automatically.</p>"},{"location":"approaches/sidecar-container/pod-configuration/#configuration-parameters","title":"Configuration Parameters","text":"Parameter Description Default <code>shareProcessNamespace</code> Enables process namespace sharing <code>true</code> <code>TARGET_CONTAINER</code> Name of the container to scan None (required) <code>PROFILE_PATH</code> Path to InSpec profile <code>/opt/profiles/container-baseline</code> <code>RESULT_PATH</code> Path to store results <code>/opt/scan-results</code>"},{"location":"approaches/sidecar-container/pod-configuration/#next-steps","title":"Next Steps","text":"<p>After configuring your pods, learn about:</p> <ul> <li>Retrieving Results - How to access and use scan results</li> <li>Implementation Details - How the sidecar scanning works</li> </ul>"},{"location":"approaches/sidecar-container/retrieving-results/","title":"Retrieving Results from Sidecar Container Scans","text":"<p>This document explains how to retrieve and process scan results from the sidecar container scanning approach.</p>"},{"location":"approaches/sidecar-container/retrieving-results/#overview","title":"Overview","text":"<p>When using the sidecar container approach, scan results are generated within the scanner container. There are several methods for retrieving these results for analysis and reporting.</p>"},{"location":"approaches/sidecar-container/retrieving-results/#result-storage-locations","title":"Result Storage Locations","text":"<p>Scan results are typically stored in a predetermined location within the sidecar container. By default, this might be configured as <code>/opt/scan-results</code> or a similar path defined in your deployment configuration.</p> <p>The scanner generates results in JSON format, which is already in Heimdall Data Format (HDF) when using InSpec/CINC Auditor.</p>"},{"location":"approaches/sidecar-container/retrieving-results/#methods-for-retrieving-results","title":"Methods for Retrieving Results","text":""},{"location":"approaches/sidecar-container/retrieving-results/#1-volume-mounts","title":"1. Volume Mounts","text":"<p>The most straightforward method is to mount a volume that both the scanner container and an external process can access:</p> <pre><code>volumes:\n- name: results-volume\n  persistentVolumeClaim:\n    claimName: scan-results-pvc\n</code></pre> <p>Then mount this volume to your scanner container:</p> <pre><code>volumeMounts:\n- name: results-volume\n  mountPath: /opt/scan-results\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#2-using-kubectl-cp","title":"2. Using kubectl cp","text":"<p>You can copy files from the scanner container using <code>kubectl cp</code>:</p> <pre><code>kubectl cp &lt;namespace&gt;/&lt;pod-name&gt;:&lt;path-in-container&gt; &lt;local-path&gt; -c scanner\n</code></pre> <p>Example:</p> <pre><code>kubectl cp default/app-with-scanner:/opt/scan-results/results.json ./results/\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#processing-results-with-saf-cli","title":"Processing Results with SAF CLI","text":"<p>The Security Automation Framework (SAF) CLI is a powerful tool for processing and analyzing security scan results.</p>"},{"location":"approaches/sidecar-container/retrieving-results/#working-with-inspeccinc-auditor-results","title":"Working with InSpec/CINC Auditor Results","text":"<p>InSpec/CINC Auditor JSON results are already in Heimdall Data Format (HDF), so no conversion is needed for use with SAF CLI.</p>"},{"location":"approaches/sidecar-container/retrieving-results/#threshold-evaluation","title":"Threshold Evaluation","text":"<p>Validate results against defined thresholds:</p> <pre><code>saf validate threshold -i results.json -t threshold.yaml\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#viewing-results","title":"Viewing Results","text":"<p>View a summary of scan results directly from the command line:</p> <pre><code>saf view summary -i results.json\n</code></pre> <p>Launch Heimdall Lite for visual analysis:</p> <pre><code>saf view heimdall -i results.json\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#creating-threshold-files","title":"Creating Threshold Files","text":"<p>Generate a threshold template based on your results:</p> <pre><code>saf generate threshold -i results.json -o threshold.yaml\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>For CI/CD integration, you can:</p> <ol> <li>Extract results using volume mounts or kubectl cp</li> <li>Use SAF CLI to validate against thresholds</li> <li>Fail the pipeline if thresholds aren't met</li> </ol> <p>Example CI/CD script:</p> <pre><code>#!/bin/bash\n# Copy results from container\nkubectl cp default/scanner-pod:/opt/scan-results/results.json ./results.json\n\n# Validate against thresholds using SAF CLI\nsaf validate threshold -i results.json -t threshold.yaml\n\n# Check exit code\nif [ $? -ne 0 ]; then\n  echo \"Scan failed to meet security thresholds\"\n  exit 1\nfi\n</code></pre>"},{"location":"approaches/sidecar-container/retrieving-results/#next-steps","title":"Next Steps","text":"<ul> <li>Pod Configuration - Learn how to configure pods with sidecars</li> <li>Implementation Details - Understand how the sidecar scanning works</li> </ul>"},{"location":"architecture/","title":"Architecture &amp; Workflows","text":"<p>This document provides an overview of the architecture, system components, and workflows for the Secure CINC Auditor Kubernetes Container Scanning platform.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Architecture Documentation Inventory.</p>"},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<p>The architecture of the platform is designed with the following principles:</p> <ol> <li>Security-First Approach: Implementing least-privilege access controls and temporary credentials</li> <li>Modularity: Supporting multiple scanning approaches through a pluggable design</li> <li>Flexibility: Accommodating different container types and Kubernetes environments</li> <li>Integration: Seamless integration with CI/CD systems and compliance frameworks</li> </ol>"},{"location":"architecture/#architecture-documentation-structure","title":"Architecture Documentation Structure","text":"<p>The architecture documentation is organized into the following sections:</p> <ul> <li>Components: Core architectural components and their relationships</li> <li>Workflows: End-to-end workflow processes for different scanning approaches</li> <li>Diagrams: Visual representations of the architecture using WCAG-compliant Mermaid diagrams</li> <li>Deployment: Deployment architectures for different environments</li> <li>Integrations: Integration architectures for CI/CD platforms</li> </ul>"},{"location":"architecture/#system-architecture-diagram","title":"System Architecture Diagram","text":"<pre><code>flowchart TD\n    subgraph Components[\"CORE COMPONENTS\"]\n        direction TB\n        cinc[\"CINC Auditor\\nScanning Engine\"]\n        transport[\"train-k8s-container\\nTransport Plugin\"]\n        threshold[\"Threshold Validation\\nSAF CLI\"]\n    end\n\n    subgraph Security[\"SECURITY COMPONENTS\"]\n        direction TB\n        sa[\"Service Accounts\\nIdentity\"]\n        rbac[\"RBAC Rules\\nAccess Control\"]\n        token[\"Token Management\\nAuthentication\"]\n    end\n\n    subgraph Adapters[\"CONTAINER ADAPTERS\"]\n        direction TB\n        standard[\"Standard Container\\nAdapter\"]\n        debug[\"Debug Container\\nAdapter\"]\n        sidecar[\"Sidecar Container\\nAdapter\"]\n    end\n\n    subgraph External[\"EXTERNAL SYSTEMS\"]\n        direction TB\n        k8s[\"Kubernetes API\"]\n        ci[\"CI/CD Systems\"]\n        compliance[\"Compliance Systems\"]\n    end\n\n    %% Component relationships\n    Components --&gt;|uses| Security\n    Components --&gt;|implements| Adapters\n    Adapters --&gt;|interacts with| External\n    Security --&gt;|configures| External\n\n    %% WCAG-compliant styling\n    style Components fill:none,stroke:#0066CC,stroke-width:4px\n    style Security fill:none,stroke:#DD6100,stroke-width:4px\n    style Adapters fill:none,stroke:#217645,stroke-width:4px\n    style External fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style cinc fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style transport fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style threshold fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sa fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ci fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style compliance fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/#core-functionality","title":"Core Functionality","text":"<p>The scanning platform provides several key capabilities:</p> <ol> <li>Container Scanning: Security scanning of containers in Kubernetes environments</li> <li>Compliance Validation: Validation against security benchmarks and compliance requirements</li> <li>Multiple Container Support: Scanning of both standard and distroless containers</li> <li>CI/CD Integration: Integration with CI/CD pipelines for automated security validation</li> <li>Threshold-based Validation: Pass/fail determination based on configurable thresholds</li> </ol>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<p>To explore the architecture in more detail, see these documents:</p> <ul> <li>Core Components: Details on the main system components</li> <li>Workflow Processes: End-to-end workflows for different scanning scenarios</li> <li>Workflow Diagrams: Visual representations of system workflows</li> <li>Deployment Options: Different deployment architectures</li> <li>CI/CD Integrations: Integration with CI/CD platforms</li> </ul>"},{"location":"architecture/inventory/","title":"Architecture &amp; Workflows Documentation Inventory","text":"<p>This directory contains documentation about the architecture, components, workflows, diagrams, deployment options, and integrations for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"architecture/inventory/#contents","title":"Contents","text":""},{"location":"architecture/inventory/#components","title":"Components","text":"<ul> <li>Components Overview - Core architectural components</li> <li>Components Inventory - Components documentation inventory</li> <li>Core Components - Details of main system components</li> <li>Security Components - Security-focused components</li> <li>Communication Patterns - Component communication patterns</li> </ul>"},{"location":"architecture/inventory/#workflows","title":"Workflows","text":"<ul> <li>Workflows Overview - End-to-end workflow processes</li> <li>Workflows Inventory - Workflows documentation inventory</li> <li>Standard Container Workflow - Workflow for standard containers</li> <li>Distroless Container Workflow - Workflow for distroless containers</li> <li>Sidecar Container Workflow - Workflow using sidecar approach</li> <li>Security Workflows - Security-focused workflows</li> </ul>"},{"location":"architecture/inventory/#diagrams","title":"Diagrams","text":"<ul> <li>Diagrams Overview - WCAG-compliant architecture diagrams</li> <li>Diagrams Inventory - Diagrams documentation inventory</li> <li>Component Diagrams - Component visualization diagrams</li> <li>Workflow Diagrams - Workflow visualization diagrams</li> <li>Deployment Diagrams - Deployment visualization diagrams</li> </ul>"},{"location":"architecture/inventory/#deployment","title":"Deployment","text":"<ul> <li>Deployment Overview - Deployment architecture options</li> <li>Deployment Inventory - Deployment documentation inventory</li> <li>Script Deployment - Script-based deployment architecture</li> <li>Helm Deployment - Helm chart deployment architecture</li> <li>CI/CD Deployment - CI/CD integration deployment architecture</li> </ul>"},{"location":"architecture/inventory/#integrations","title":"Integrations","text":"<ul> <li>Integrations Overview - CI/CD integration architecture</li> <li>Integrations Inventory - Integrations documentation inventory</li> <li>GitHub Actions Integration - GitHub Actions integration architecture</li> <li>GitLab CI Integration - GitLab CI integration architecture</li> <li>GitLab Services Integration - GitLab Services integration architecture</li> <li>Custom Integrations - Custom integration architecture</li> </ul>"},{"location":"architecture/inventory/#overview","title":"Overview","text":"<p>The architecture documentation provides a comprehensive understanding of how the scanning system is designed, how the components interact, and the various workflows supported by the system. This information is valuable for both users seeking to understand how the system operates and for developers looking to extend or modify the system.</p> <p>The documentation uses Mermaid diagrams extensively to visualize complex architectures, workflows, and system interactions, making it easier to understand the relationships between different components.</p>"},{"location":"architecture/components/","title":"Architectural Components","text":"<p>This section provides detailed information about the core architectural components of the Kubernetes CINC Secure Scanner.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Components Documentation Inventory.</p>"},{"location":"architecture/components/#core-components-overview","title":"Core Components Overview","text":"<p>The Kubernetes CINC Secure Scanner is built on several key components that work together to provide a secure container scanning solution:</p> <ol> <li>CINC Auditor - The open-source security scanning engine based on InSpec</li> <li>Transport Plugin - The train-k8s-container plugin for Kubernetes communication</li> <li>Service Accounts - Identity management for secure scanner access</li> <li>RBAC Rules - Access control mechanisms for least-privilege scanning</li> <li>Container Adapters - Specialized adapters for different container types</li> <li>Threshold Validation - MITRE SAF CLI integration for compliance checking</li> </ol>"},{"location":"architecture/components/#component-documentation","title":"Component Documentation","text":"<p>For detailed information about specific components, see these documents:</p> <ul> <li>Core Components - Detailed information about the main system components</li> <li>Security Components - Security-focused components and their roles</li> <li>Communication Patterns - How components communicate with each other</li> </ul>"},{"location":"architecture/components/#component-relationship-diagram","title":"Component Relationship Diagram","text":"<pre><code>graph TD\n    CI[\"CI/CD System\"] --&gt;|triggers| SCAN[Container Scan]\n    SCAN --&gt;|uses| SA[Service Account]\n    SCAN --&gt;|runs| CINC[CINC Auditor]\n    CINC --&gt;|uses| TRANSPORT[Transport Plugin]\n    TRANSPORT --&gt;|connects to| K8S[Kubernetes API]\n    K8S --&gt;|validates| RBAC[RBAC Rules]\n    K8S --&gt;|accesses| CONTAINER[Target Container]\n    CINC --&gt;|produces| RESULTS[Scan Results]\n    RESULTS --&gt;|validated by| SAF[MITRE SAF CLI]\n    SAF --&gt;|checks against| THRESHOLD[Threshold Config]\n    THRESHOLD --&gt;|success/failure| CI</code></pre>"},{"location":"architecture/components/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Workflows to understand how these components interact</li> <li>See Diagram Visualizations for visual representations of system architecture</li> <li>Review Deployment Architectures to learn about deployment options</li> </ul>"},{"location":"architecture/components/communication/","title":"Component Communication Patterns","text":"<p>This document details how the components of the Kubernetes CINC Secure Scanner communicate with each other and with external systems.</p>"},{"location":"architecture/components/communication/#communication-flow-overview","title":"Communication Flow Overview","text":"<p>The scanning system uses several communication patterns to enable secure container scanning:</p> <ol> <li>API-Based Communication: Interaction with the Kubernetes API server</li> <li>Container Exec Communication: Direct communication with containers</li> <li>Filesystem Access: Reading container filesystems</li> <li>Results Communication: Transferring scan results</li> <li>External Integration: Communication with CI/CD systems</li> </ol>"},{"location":"architecture/components/communication/#kubernetes-api-communication","title":"Kubernetes API Communication","text":"<p>The scanner communicates with the Kubernetes API server to access containers and manage resources.</p> <ul> <li>Protocol: HTTPS with TLS encryption</li> <li>Authentication: Service account tokens with limited lifespan</li> <li>Authorization: RBAC-enforced least-privilege access</li> <li>Communication Flow:</li> <li>Scanner authenticates to Kubernetes API</li> <li>API validates token and permissions</li> <li>Scanner requests container access</li> <li>API grants or denies access based on RBAC</li> <li>Scanner performs operations within permission constraints</li> </ul>"},{"location":"architecture/components/communication/#container-access-patterns","title":"Container Access Patterns","text":"<p>Different container types require different access patterns:</p>"},{"location":"architecture/components/communication/#standard-container-access","title":"Standard Container Access","text":"<pre><code>sequenceDiagram\n    participant Scanner\n    participant API as Kubernetes API\n    participant Container\n\n    Scanner-&gt;&gt;API: Request container exec\n    API-&gt;&gt;Container: Execute command\n    Container-&gt;&gt;API: Return command output\n    API-&gt;&gt;Scanner: Forward output\n\n    Scanner-&gt;&gt;API: Request file read\n    API-&gt;&gt;Container: Read file\n    Container-&gt;&gt;API: Return file content\n    API-&gt;&gt;Scanner: Forward content</code></pre>"},{"location":"architecture/components/communication/#distroless-container-access","title":"Distroless Container Access","text":"<pre><code>sequenceDiagram\n    participant Scanner\n    participant API as Kubernetes API\n    participant Debug as Debug Container\n    participant Target as Target Container\n\n    Scanner-&gt;&gt;API: Create debug container\n    API-&gt;&gt;Debug: Initialize container\n    Scanner-&gt;&gt;API: Request debug container exec\n    API-&gt;&gt;Debug: Execute command\n    Debug-&gt;&gt;Target: Access via shared namespace\n    Target-&gt;&gt;Debug: Return data\n    Debug-&gt;&gt;API: Return command output\n    API-&gt;&gt;Scanner: Forward output</code></pre>"},{"location":"architecture/components/communication/#sidecar-container-access","title":"Sidecar Container Access","text":"<pre><code>sequenceDiagram\n    participant Orchestrator\n    participant API as Kubernetes API\n    participant Sidecar\n    participant Target\n\n    Orchestrator-&gt;&gt;API: Deploy pod with sidecar\n    API-&gt;&gt;Sidecar: Initialize sidecar\n    API-&gt;&gt;Target: Initialize target\n    Sidecar-&gt;&gt;Target: Access via shared namespace\n    Sidecar-&gt;&gt;Sidecar: Run scan\n    Sidecar-&gt;&gt;API: Report results\n    API-&gt;&gt;Orchestrator: Forward results</code></pre>"},{"location":"architecture/components/communication/#results-communication","title":"Results Communication","text":"<p>Scan results are communicated through several mechanisms:</p> <ul> <li>File-Based: Results written to files in JSON format</li> <li>Standard Output: Results streamed through standard output</li> <li>API-Based: Results sent to configured endpoints</li> <li>Volume-Based: Results stored in shared volumes (for sidecar approach)</li> </ul>"},{"location":"architecture/components/communication/#external-communication","title":"External Communication","text":"<p>The scanning system communicates with external systems for integration:</p> <ul> <li>CI/CD Systems: Sending scan status and results</li> <li>Compliance Systems: Reporting compliance status</li> <li>Monitoring Systems: Reporting scan metrics</li> <li>Alert Systems: Sending security alerts</li> </ul>"},{"location":"architecture/components/communication/#security-considerations","title":"Security Considerations","text":"<p>Communication security is ensured through:</p> <ol> <li>Encryption: All API communications are encrypted with TLS</li> <li>Authentication: Service account tokens authenticate all requests</li> <li>Authorization: RBAC enforces least-privilege access</li> <li>Isolation: Communication is isolated to specific namespaces</li> <li>Ephemeral Credentials: Communication credentials have limited lifespans</li> <li>Clean Up: Communication channels are properly closed after use</li> </ol>"},{"location":"architecture/components/communication/#communication-failure-handling","title":"Communication Failure Handling","text":"<p>The system handles communication failures through:</p> <ol> <li>Retry Mechanisms: Failed communications are retried with backoff</li> <li>Timeout Handling: Communications have appropriate timeouts</li> <li>Graceful Degradation: Partial results are handled appropriately</li> <li>Error Reporting: Communication errors are properly logged</li> <li>Circuit Breaking: Repeated failures lead to circuit breaking</li> </ol>"},{"location":"architecture/components/core-components/","title":"Core Architectural Components","text":"<p>This document details the core components of the Kubernetes CINC Secure Scanner architecture and their functions within the system.</p>"},{"location":"architecture/components/core-components/#cinc-auditor","title":"CINC Auditor","text":"<p>CINC Auditor is the primary scanning engine used by the platform.</p> <ul> <li>Purpose: Execute security and compliance checks against container targets</li> <li>Features:<ul> <li>Open-source InSpec-compatible scanner</li> <li>Supports custom security profiles</li> <li>Produces structured JSON outputs for compliance reporting</li> <li>Can be extended with custom resources and plugins</li> </ul> </li> </ul>"},{"location":"architecture/components/core-components/#transport-plugin-train-k8s-container","title":"Transport Plugin (train-k8s-container)","text":"<p>The train-k8s-container transport plugin is a critical component for Kubernetes communication.</p> <ul> <li>Purpose: Provide secure access to container filesystems and commands within Kubernetes</li> <li>Features:<ul> <li>Connects to Kubernetes API securely</li> <li>Uses pod exec API for container command execution</li> <li>Supports filesystem inspection</li> <li>Modified to support multiple container types including distroless</li> </ul> </li> </ul>"},{"location":"architecture/components/core-components/#container-adapters","title":"Container Adapters","text":"<p>Container adapters provide specialized access mechanisms for different container types.</p> <ul> <li>Purpose: Enable scanning of various container types including distroless containers</li> <li>Types:<ul> <li>Standard Container Adapter: Uses direct exec into container</li> <li>Distroless Container Adapter: Uses debug container approach</li> <li>Sidecar Container Adapter: Uses shared process namespace</li> </ul> </li> </ul>"},{"location":"architecture/components/core-components/#threshold-validation","title":"Threshold Validation","text":"<p>Threshold validation is implemented through MITRE SAF CLI integration.</p> <ul> <li>Purpose: Evaluate scan results against predefined compliance thresholds</li> <li>Features:<ul> <li>Configurable threshold levels</li> <li>Support for multiple threshold configurations</li> <li>Integration with CI/CD pipelines</li> <li>Fail/pass determination for automated workflows</li> </ul> </li> </ul>"},{"location":"architecture/components/core-components/#component-interaction-model","title":"Component Interaction Model","text":"<p>The core components interact in a hierarchical manner:</p> <ol> <li>Scanning Initiation: Triggered by script, Helm chart, or CI/CD system</li> <li>Authentication Setup: Service accounts and RBAC are configured for least privilege</li> <li>Transport Configuration: The train-k8s-container plugin connects to the Kubernetes API</li> <li>Scanning Execution: CINC Auditor executes the specified profile against the target</li> <li>Results Processing: Scan results are processed and validated against thresholds</li> <li>Cleanup: Temporary resources are removed to maintain security</li> </ol>"},{"location":"architecture/components/core-components/#component-dependencies","title":"Component Dependencies","text":"Component Dependencies Purpose CINC Auditor Ruby Runtime, InSpec Profiles Security scanning engine Transport Plugin Kubernetes API access, kubeconfig Container access mechanism Container Adapters Kubernetes permissions, container runtime Type-specific access Threshold Validation SAF CLI, Ruby Runtime Compliance evaluation"},{"location":"architecture/components/core-components/#technology-choices","title":"Technology Choices","text":"<p>The components were selected and designed with the following considerations:</p> <ol> <li>Open Source: All core components are open source</li> <li>Extensibility: Components can be extended or modified as needed</li> <li>Security: Security is built into each component design</li> <li>Interoperability: Components work together seamlessly</li> <li>Kubernetes Native: Designed to work within Kubernetes environments</li> </ol>"},{"location":"architecture/components/inventory/","title":"Components Documentation Inventory","text":"<p>This directory contains documentation about the core architectural components of the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/components/inventory/#contents","title":"Contents","text":"<ul> <li>Core Components - Detailed information about the main system components</li> <li>Security Components - Security-focused components and their roles</li> <li>Communication Patterns - How components communicate with each other</li> </ul>"},{"location":"architecture/components/inventory/#overview","title":"Overview","text":"<p>The components documentation provides detailed information about the individual elements that make up the scanning system architecture. This includes both the technical components that perform the scanning operations and the security components that ensure the scanning process is secure.</p> <p>Understanding these components is essential for users who want to customize or extend the scanning system, as well as for administrators who need to troubleshoot issues or optimize performance.</p>"},{"location":"architecture/components/security-components/","title":"Security Components","text":"<p>This document details the security-focused components of the Kubernetes CINC Secure Scanner architecture.</p>"},{"location":"architecture/components/security-components/#service-accounts","title":"Service Accounts","text":"<p>Service accounts provide identity management for secure scanner access.</p> <ul> <li>Purpose: Establish a secure identity for the scanner within Kubernetes</li> <li>Features:<ul> <li>Temporary/ephemeral accounts for scanning operations</li> <li>Limited lifespan to reduce potential attack surface</li> <li>Namespace-specific isolation</li> <li>No permanent elevated privileges</li> </ul> </li> </ul>"},{"location":"architecture/components/security-components/#rbac-rules","title":"RBAC Rules","text":"<p>RBAC (Role-Based Access Control) rules enforce least-privilege access for scanning operations.</p> <ul> <li>Purpose: Restrict scanner access to only what is necessary</li> <li>Features:<ul> <li>Granular permission control</li> <li>Namespace-specific permissions</li> <li>Time-limited access</li> <li>Resource-specific limitations</li> <li>Label-based selection for targeted scanning</li> </ul> </li> </ul>"},{"location":"architecture/components/security-components/#security-token-management","title":"Security Token Management","text":"<p>Security token management provides controlled access to Kubernetes resources.</p> <ul> <li>Purpose: Secure authentication for scanning operations</li> <li>Features:<ul> <li>Short-lived token generation</li> <li>Automatic token expiration</li> <li>No persistent credential storage</li> <li>Rotation mechanisms for long-running scans</li> </ul> </li> </ul>"},{"location":"architecture/components/security-components/#kubeconfig-security","title":"Kubeconfig Security","text":"<p>Kubeconfig security ensures that Kubernetes configuration is properly secured.</p> <ul> <li>Purpose: Secure storage and management of Kubernetes access configurations</li> <li>Features:<ul> <li>Temporary kubeconfig generation</li> <li>Restricted permissions</li> <li>No shared kubeconfig files</li> <li>Context-specific configurations</li> </ul> </li> </ul>"},{"location":"architecture/components/security-components/#secure-plugin-configuration","title":"Secure Plugin Configuration","text":"<p>Secure plugin configuration ensures that the transport plugin operates securely.</p> <ul> <li>Purpose: Configure the transport plugin with secure defaults</li> <li>Features:<ul> <li>No privilege escalation</li> <li>Restricted filesystem access</li> <li>Command execution limitations</li> <li>Secure parameter handling</li> </ul> </li> </ul>"},{"location":"architecture/components/security-components/#security-component-interaction-diagram","title":"Security Component Interaction Diagram","text":"<pre><code>flowchart TD\n    A[Start Scan Process] --&gt; B[Create Temporary Service Account]\n    B --&gt; C[Apply Least-Privilege RBAC]\n    C --&gt; D[Generate Short-lived Token]\n    D --&gt; E[Create Restricted Kubeconfig]\n    E --&gt; F[Configure Transport Plugin Security]\n    F --&gt; G[Execute Scanner with Security Constraints]\n    G --&gt; H[Process Results Securely]\n    H --&gt; I[Clean Up Security Resources]\n    I --&gt; J[End Scan Process]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style J fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/components/security-components/#security-component-design-principles","title":"Security Component Design Principles","text":"<p>The security components adhere to the following design principles:</p> <ol> <li>Least Privilege: Components only have access to the resources they need</li> <li>Defense in Depth: Multiple security layers protect the system</li> <li>Ephemeral Access: Temporary access reduces attack surface</li> <li>Audit Trail: Security operations are logged for accountability</li> <li>Isolation: Components are isolated to prevent lateral movement</li> <li>Clean Up: Security resources are reliably removed after use</li> </ol>"},{"location":"architecture/components/security-components/#security-component-configuration","title":"Security Component Configuration","text":"<p>For detailed information about configuring security components, see:</p> <ul> <li>RBAC Configuration</li> <li>Service Account Configuration</li> <li>Token Management</li> <li>Security Configuration</li> </ul>"},{"location":"architecture/deployment/","title":"Deployment Architectures","text":"<p>This section provides detailed information about the different deployment architectures supported by the Kubernetes CINC Secure Scanner.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Deployment Documentation Inventory.</p>"},{"location":"architecture/deployment/#deployment-options","title":"Deployment Options","text":"<p>The scanning system can be deployed using several different architectures:</p> <ol> <li>Script-based Deployment - Using shell scripts for direct execution</li> <li>Helm Chart Deployment - Using Helm charts for production environments</li> <li>CI/CD Integration - Embedded in CI/CD pipelines</li> </ol>"},{"location":"architecture/deployment/#common-deployment-characteristics","title":"Common Deployment Characteristics","text":"<p>While specific implementations differ, all deployment architectures share these characteristics:</p> <ol> <li>Security-First Approach: All deployments implement least-privilege access controls</li> <li>Modular Design: Components can be deployed independently as needed</li> <li>Configuration Flexibility: Extensive configuration options for all deployment types</li> <li>Cleanup Mechanisms: Automatic cleanup of temporary resources</li> <li>Threshold Validation: Integration with the MITRE SAF CLI for compliance validation</li> </ol>"},{"location":"architecture/deployment/#deployment-documentation","title":"Deployment Documentation","text":"<p>For detailed information about specific deployment architectures, see these documents:</p> <ul> <li>Script Deployment - Using shell scripts for direct execution</li> <li>Helm Deployment - Using Helm charts for production environments</li> <li>CI/CD Deployment - Integrating with CI/CD pipelines</li> </ul>"},{"location":"architecture/deployment/#deployment-architecture-diagram","title":"Deployment Architecture Diagram","text":"<pre><code>flowchart TD\n    subgraph User[\"USER ENVIRONMENT\"]\n        direction TB\n        scripts[\"Scanning Scripts\"]\n        helm[\"Helm Deployment\"]\n        cicd[\"CI/CD Integration\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        direction TB\n        subgraph Resources[\"SCANNER RESOURCES\"]\n            components[\"Scanner Components\"]\n            rbac[\"RBAC Resources\"]\n            credentials[\"Credentials\"]\n        end\n\n        subgraph Targets[\"TARGET RESOURCES\"]\n            containers[\"Target Containers\"]\n        end\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        reports[\"Compliance Reports\"]\n        thresholds[\"Threshold Validation\"]\n    end\n\n    %% Component relationships\n    User --&gt;|deploys to| Kubernetes\n    scripts --&gt;|creates| Resources\n    helm --&gt;|installs| Resources\n    cicd --&gt;|manages| Resources\n    Resources --&gt;|scans| Targets\n    Resources --&gt;|produces| Results\n\n    %% WCAG-compliant styling\n    style User fill:none,stroke:#0066CC,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Resources fill:none,stroke:#DD6100,stroke-width:4px\n    style Targets fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style helm fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cicd fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style components fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style credentials fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style containers fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Component Architecture documentation</li> <li>Review the Workflow Processes documentation</li> <li>See the Integration Options documentation</li> </ul>"},{"location":"architecture/deployment/ci-cd-deployment/","title":"CI/CD Integration Deployment Architecture","text":"<p>This document details the CI/CD integration deployment architecture for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/deployment/ci-cd-deployment/#architecture-overview","title":"Architecture Overview","text":"<p>The CI/CD integration deployment architecture embeds container scanning into continuous integration and continuous deployment (CI/CD) pipelines. This approach is ideal for implementing security checks as part of the development workflow.</p>"},{"location":"architecture/deployment/ci-cd-deployment/#supported-cicd-platforms","title":"Supported CI/CD Platforms","text":"<p>The scanner supports integration with several CI/CD platforms:</p> Platform Integration Method Example GitHub Actions Workflow YAML files <code>github-workflow-examples/</code> GitLab CI Pipeline configuration <code>gitlab-pipeline-examples/</code> GitLab Services Services integration <code>gitlab-services-examples/</code> Jenkins Pipeline scripts Custom integration Any CI/CD Direct script execution Script-based approach"},{"location":"architecture/deployment/ci-cd-deployment/#key-components","title":"Key Components","text":""},{"location":"architecture/deployment/ci-cd-deployment/#1-workflow-configuration","title":"1. Workflow Configuration","text":"<p>Configuration files that define the CI/CD workflow:</p> Component Purpose Workflow Definitions Define scanning steps and conditions Environment Configuration Set up scanner environment Trigger Definitions Specify when scanning occurs Result Handling Define how results are processed"},{"location":"architecture/deployment/ci-cd-deployment/#2-scanner-integration","title":"2. Scanner Integration","text":"<p>Components that execute the scanning process:</p> Component Purpose Scanner Scripts Execute scanning operations CINC Profiles Define security controls Threshold Configuration Define compliance thresholds Report Formatting Format and present results"},{"location":"architecture/deployment/ci-cd-deployment/#3-cicd-pipeline-steps","title":"3. CI/CD Pipeline Steps","text":"<p>Typical scanning pipeline steps:</p> Step Purpose Environment Setup Prepare Kubernetes environment RBAC Creation Create necessary RBAC resources Scan Execution Run scanner against containers Results Processing Process and validate results Results Publication Publish results as artifacts Pass/Fail Determination Determine pipeline success/failure"},{"location":"architecture/deployment/ci-cd-deployment/#github-actions-deployment-architecture","title":"GitHub Actions Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph GitHub[\"GITHUB ACTIONS\"]\n        direction TB\n        workflow[\"Workflow YAML\"]\n        triggers[\"Workflow Triggers\"]\n        jobs[\"Scanning Jobs\"]\n        steps[\"Job Steps\"]\n    end\n\n    subgraph Environment[\"SCANNING ENVIRONMENT\"]\n        direction TB\n        k8s_setup[\"Kubernetes Setup\"]\n        cinc_setup[\"CINC Auditor Setup\"]\n        profiles[\"Security Profiles\"]\n        scripts[\"Scanner Scripts\"]\n    end\n\n    subgraph Execution[\"SCAN EXECUTION\"]\n        direction TB\n        rbac[\"RBAC Creation\"]\n        token[\"Token Generation\"]\n        kubeconfig[\"Kubeconfig Creation\"]\n        scan[\"Scan Execution\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        processing[\"Results Processing\"]\n        validation[\"Threshold Validation\"]\n        artifacts[\"Create Artifacts\"]\n        status[\"Job Status\"]\n    end\n\n    %% Component relationships\n    GitHub --&gt;|configures| Environment\n    workflow --&gt;|defines| jobs\n    triggers --&gt;|activate| workflow\n    jobs --&gt;|contain| steps\n    steps --&gt;|execute| Environment\n    Environment --&gt;|enables| Execution\n    k8s_setup --&gt;|prepares for| rbac\n    cinc_setup --&gt;|prepares for| scan\n    profiles --&gt;|used by| scan\n    scripts --&gt;|implement| Execution\n    Execution --&gt;|produces| Results\n    scan --&gt;|generates| processing\n    processing --&gt;|enables| validation\n    validation --&gt;|determines| status\n    processing --&gt;|creates| artifacts\n\n    %% WCAG-compliant styling\n    style GitHub fill:none,stroke:#0066CC,stroke-width:4px\n    style Environment fill:none,stroke:#DD6100,stroke-width:4px\n    style Execution fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style workflow fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style triggers fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style steps fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubeconfig fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processing fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#gitlab-ci-deployment-architecture","title":"GitLab CI Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph GitLab[\"GITLAB CI\"]\n        direction TB\n        ci_config[\".gitlab-ci.yml\"]\n        stages[\"Pipeline Stages\"]\n        jobs[\"Scanning Jobs\"]\n        scripts[\"Job Scripts\"]\n    end\n\n    subgraph Environment[\"SCANNING ENVIRONMENT\"]\n        direction TB\n        k8s_setup[\"Kubernetes Setup\"]\n        cinc_setup[\"CINC Auditor Setup\"]\n        profiles[\"Security Profiles\"]\n        scanner_scripts[\"Scanner Scripts\"]\n    end\n\n    subgraph Execution[\"SCAN EXECUTION\"]\n        direction TB\n        rbac[\"RBAC Creation\"]\n        token[\"Token Generation\"]\n        kubeconfig[\"Kubeconfig Creation\"]\n        scan[\"Scan Execution\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        processing[\"Results Processing\"]\n        validation[\"Threshold Validation\"]\n        artifacts[\"Create Artifacts\"]\n        status[\"Job Status\"]\n    end\n\n    %% Component relationships\n    GitLab --&gt;|configures| Environment\n    ci_config --&gt;|defines| stages\n    stages --&gt;|contain| jobs\n    jobs --&gt;|execute| scripts\n    scripts --&gt;|invoke| Environment\n    Environment --&gt;|enables| Execution\n    k8s_setup --&gt;|prepares for| rbac\n    cinc_setup --&gt;|prepares for| scan\n    profiles --&gt;|used by| scan\n    scanner_scripts --&gt;|implement| Execution\n    Execution --&gt;|produces| Results\n    scan --&gt;|generates| processing\n    processing --&gt;|enables| validation\n    validation --&gt;|determines| status\n    processing --&gt;|creates| artifacts\n\n    %% WCAG-compliant styling\n    style GitLab fill:none,stroke:#0066CC,stroke-width:4px\n    style Environment fill:none,stroke:#DD6100,stroke-width:4px\n    style Execution fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style ci_config fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style stages fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubeconfig fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processing fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#gitlab-ci-services-deployment-architecture","title":"GitLab CI Services Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph GitLab[\"GITLAB CI WITH SERVICES\"]\n        direction TB\n        ci_config[\".gitlab-ci.yml\"]\n        services[\"CI/CD Services\"]\n        jobs[\"Scanning Jobs\"]\n        scripts[\"Job Scripts\"]\n    end\n\n    subgraph Services[\"SCANNER SERVICES\"]\n        direction TB\n        cinc_service[\"CINC Auditor Service\"]\n        saf_service[\"SAF CLI Service\"]\n        scanner_service[\"Container Scanner Service\"]\n    end\n\n    subgraph Execution[\"SCAN EXECUTION\"]\n        direction TB\n        rbac[\"RBAC Creation\"]\n        token[\"Token Generation\"]\n        kubeconfig[\"Kubeconfig Creation\"]\n        scan[\"Scan Execution\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        processing[\"Results Processing\"]\n        validation[\"Threshold Validation\"]\n        artifacts[\"Create Artifacts\"]\n        status[\"Job Status\"]\n    end\n\n    %% Component relationships\n    GitLab --&gt;|defines| Services\n    ci_config --&gt;|configures| services\n    services --&gt;|include| cinc_service\n    services --&gt;|include| saf_service\n    services --&gt;|include| scanner_service\n    jobs --&gt;|use| Services\n    Services --&gt;|perform| Execution\n    scanner_service --&gt;|creates| rbac\n    scanner_service --&gt;|generates| token\n    scanner_service --&gt;|creates| kubeconfig\n    cinc_service --&gt;|performs| scan\n    Execution --&gt;|produces| Results\n    scan --&gt;|generates| processing\n    saf_service --&gt;|performs| validation\n    validation --&gt;|determines| status\n    processing --&gt;|creates| artifacts\n\n    %% WCAG-compliant styling\n    style GitLab fill:none,stroke:#0066CC,stroke-width:4px\n    style Services fill:none,stroke:#DD6100,stroke-width:4px\n    style Execution fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style ci_config fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style services fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc_service fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf_service fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_service fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubeconfig fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scan fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processing fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#example-cicd-configurations","title":"Example CI/CD Configurations","text":""},{"location":"architecture/deployment/ci-cd-deployment/#github-actions-workflow-example","title":"GitHub Actions Workflow Example","text":"<pre><code>name: Container Security Scanning\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  container-scan:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Set up Kubernetes\n      uses: helm/kind-action@v1.2.0\n\n    - name: Deploy test container\n      run: kubectl apply -f test-pod.yaml\n\n    - name: Set up CINC Auditor\n      run: |\n        # Install CINC Auditor and dependencies\n        curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n\n    - name: Scan container\n      run: ./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n\n    - name: Upload results\n      uses: actions/upload-artifact@v2\n      with:\n        name: scan-results\n        path: results/\n</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#gitlab-ci-pipeline-example","title":"GitLab CI Pipeline Example","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n\nvariables:\n  KUBE_CONTEXT: my-kubernetes-context\n  TARGET_NAMESPACE: default\n  TARGET_POD: web-app\n  TARGET_CONTAINER: web-container\n  PROFILE_PATH: examples/cinc-profiles/container-baseline\n  THRESHOLD_FILE: examples/thresholds/moderate.yml\n\ndeploy-test-container:\n  stage: deploy\n  script:\n    - kubectl --context $KUBE_CONTEXT apply -f test-pod.yaml\n\nscan-container:\n  stage: scan\n  script:\n    - ./kubernetes-scripts/scan-container.sh $TARGET_NAMESPACE $TARGET_POD $TARGET_CONTAINER $PROFILE_PATH $THRESHOLD_FILE\n  artifacts:\n    paths:\n      - results/\n\nreport-results:\n  stage: report\n  script:\n    - cat results/summary.json\n    - |\n      if [ $(jq '.failure_count' results/summary.json) -gt 0 ]; then\n        exit 1\n      fi\n</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#gitlab-ci-with-services-example","title":"GitLab CI with Services Example","text":"<pre><code>services:\n  - name: registry.example.com/cinc-auditor:latest\n    alias: cinc\n  - name: registry.example.com/saf-cli:latest\n    alias: saf\n\nstages:\n  - scan\n\ncontainer-scan:\n  stage: scan\n  script:\n    - kubectl create namespace scanner-system\n    - kubectl apply -f kubernetes/templates/rbac.yaml\n    - kubectl apply -f kubernetes/templates/service-account.yaml\n    - |\n      cinc exec -t k8s-container://default/test-pod/test-container \\\n        --input examples/cinc-profiles/container-baseline \\\n        --reporter json:results.json\n    - saf validate results.json -c $THRESHOLD_FILE\n  artifacts:\n    paths:\n      - results.json\n</code></pre>"},{"location":"architecture/deployment/ci-cd-deployment/#security-considerations","title":"Security Considerations","text":"<p>The CI/CD integration deployment implements these security measures:</p> <ol> <li>Pipeline Isolation: Scanning runs in isolated CI/CD environments</li> <li>Secret Management: Sensitive values stored as protected variables</li> <li>Least Privilege: Minimal permissions for CI/CD jobs</li> <li>Ephemeral Resources: All resources are temporary and cleaned up</li> <li>Result Protection: Scan results stored as protected artifacts</li> </ol>"},{"location":"architecture/deployment/ci-cd-deployment/#deployment-scenarios","title":"Deployment Scenarios","text":"<p>The CI/CD integration deployment is ideal for:</p> <ol> <li>Automated Testing: Automatic scanning in CI/CD pipelines</li> <li>Pre-deployment Checks: Security validation before deployment</li> <li>Pull Request Validation: Scanning code changes in PRs</li> <li>Compliance Enforcement: Enforcing security standards</li> <li>Continuous Security: Regular security validation</li> </ol>"},{"location":"architecture/deployment/ci-cd-deployment/#integration-pattern-options","title":"Integration Pattern Options","text":"<p>Several integration patterns are available:</p>"},{"location":"architecture/deployment/ci-cd-deployment/#1-direct-script-execution","title":"1. Direct Script Execution","text":"<ul> <li>Scripts executed directly in CI/CD jobs</li> <li>Simple integration with minimal dependencies</li> <li>Flexible but requires more configuration</li> </ul>"},{"location":"architecture/deployment/ci-cd-deployment/#2-container-based-execution","title":"2. Container-based Execution","text":"<ul> <li>Scanner runs in containers</li> <li>Consistent environment across CI/CD systems</li> <li>Reduced dependency management</li> </ul>"},{"location":"architecture/deployment/ci-cd-deployment/#3-service-based-integration","title":"3. Service-based Integration","text":"<ul> <li>Scanner provided as a service</li> <li>Clean separation of responsibilities</li> <li>Simplified job configuration</li> </ul>"},{"location":"architecture/deployment/ci-cd-deployment/#4-hybrid-execution","title":"4. Hybrid Execution","text":"<ul> <li>Combination of direct execution and services</li> <li>Different components used as needed</li> <li>Maximum flexibility for complex workflows</li> </ul>"},{"location":"architecture/deployment/ci-cd-deployment/#advanced-configuration","title":"Advanced Configuration","text":"<p>For detailed information on advanced CI/CD integration, see:</p> <ul> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>GitLab Services Integration</li> </ul>"},{"location":"architecture/deployment/helm-deployment/","title":"Helm Chart Deployment Architecture","text":"<p>This document details the Helm chart deployment architecture for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/deployment/helm-deployment/#architecture-overview","title":"Architecture Overview","text":"<p>The Helm chart deployment architecture uses Helm charts to deploy and manage scanning resources in a Kubernetes cluster. This approach is ideal for production environments, providing a more structured and manageable deployment mechanism.</p>"},{"location":"architecture/deployment/helm-deployment/#helm-chart-structure","title":"Helm Chart Structure","text":"<p>The scanning system is organized into a collection of modular Helm charts:</p> <pre><code>flowchart TD\n    infrastructure[\"scanner-infrastructure Chart\"] --&gt;|infrastructure base| common[\"common-scanner Chart\"]\n    common --&gt;|extends| standard[\"standard-scanner Chart\"]\n    common --&gt;|extends| distroless[\"distroless-scanner Chart\"]\n    common --&gt;|extends| sidecar[\"sidecar-scanner Chart\"]\n\n    style infrastructure fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style common fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style distroless fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/helm-deployment/#key-components","title":"Key Components","text":""},{"location":"architecture/deployment/helm-deployment/#1-scanner-infrastructure-chart","title":"1. Scanner Infrastructure Chart","text":"<p>The <code>scanner-infrastructure</code> chart creates the base infrastructure required for scanning:</p> Component Purpose Namespace Dedicated namespace for scanner resources Service Account Identity for scanner operations RBAC Resources Access control for scanner ConfigMap Shared configuration for scanners"},{"location":"architecture/deployment/helm-deployment/#2-common-scanner-chart","title":"2. Common Scanner Chart","text":"<p>The <code>common-scanner</code> chart provides shared functionality used by all scanner types:</p> Component Purpose Helper Scripts Common scripts used by scanners Threshold Configuration Threshold validation settings Value Definitions Common value definitions"},{"location":"architecture/deployment/helm-deployment/#3-scanner-implementation-charts","title":"3. Scanner Implementation Charts","text":"<p>Three specialized charts implement different scanning approaches:</p> Chart Purpose Best For <code>standard-scanner</code> For scanning standard containers Containers with shell access <code>distroless-scanner</code> For scanning distroless containers Minimal containers without shell <code>sidecar-scanner</code> For sidecar container approach Mixed container environments"},{"location":"architecture/deployment/helm-deployment/#deployment-architecture-diagram","title":"Deployment Architecture Diagram","text":"<pre><code>flowchart TD\n    subgraph User[\"USER ENVIRONMENT\"]\n        helm[\"Helm CLI\"]\n        values[\"Values Files\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Helm[\"HELM DEPLOYMENT\"]\n        install[\"Helm Install/Upgrade\"]\n        template[\"Helm Template Generation\"]\n        release[\"Helm Release Management\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        subgraph Infrastructure[\"INFRASTRUCTURE RESOURCES\"]\n            ns[\"Scanner Namespace\"]\n            sa[\"Service Account\"]\n            rbac[\"RBAC Resources\"]\n        end\n\n        subgraph Scanner[\"SCANNER RESOURCES\"]\n            config[\"ConfigMaps\"]\n            secrets[\"Secrets\"]\n            pods[\"Scanner Pods\"]\n        end\n\n        subgraph Target[\"TARGET RESOURCES\"]\n            target_ns[\"Target Namespace\"]\n            target_pods[\"Target Pods\"]\n        end\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        processing[\"SAF CLI Processing\"]\n        thresholds[\"Threshold Validation\"]\n        reports[\"Compliance Reports\"]\n    end\n\n    %% Component relationships\n    User --&gt;|uses| Helm\n    helm --&gt;|executes| install\n    values --&gt;|configures| template\n    profiles --&gt;|provided to| Scanner\n    install --&gt;|creates| Infrastructure\n    install --&gt;|creates| Scanner\n    template --&gt;|generates| Infrastructure\n    template --&gt;|generates| Scanner\n    release --&gt;|manages| Infrastructure\n    release --&gt;|manages| Scanner\n    Infrastructure --&gt;|supports| Scanner\n    Scanner --&gt;|scans| Target\n    Scanner --&gt;|produces| Results\n\n    %% WCAG-compliant styling\n    style User fill:none,stroke:#0066CC,stroke-width:4px\n    style Helm fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Infrastructure fill:none,stroke:#217645,stroke-width:4px\n    style Scanner fill:none,stroke:#217645,stroke-width:4px\n    style Target fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style helm fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style values fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style install fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style template fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style release fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ns fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sa fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style config fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style secrets fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target_ns fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target_pods fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processing fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/helm-deployment/#deployment-workflow","title":"Deployment Workflow","text":"<p>The Helm chart deployment follows this general workflow:</p> <ol> <li>Setup Phase:</li> <li>User selects appropriate scanner chart</li> <li>User configures values file with specific settings</li> <li> <p>User prepares security profiles</p> </li> <li> <p>Installation Phase:</p> </li> <li>Helm installs infrastructure chart if not already present</li> <li>Helm installs selected scanner chart</li> <li> <p>Helm manages dependencies between charts</p> </li> <li> <p>Execution Phase:</p> </li> <li>Scanner pods are deployed according to configuration</li> <li>Scanner executes against target containers</li> <li> <p>Results are collected and processed</p> </li> <li> <p>Reporting Phase:</p> </li> <li>Results validated against thresholds</li> <li>Reports generated according to configuration</li> <li>Compliance status determined</li> </ol>"},{"location":"architecture/deployment/helm-deployment/#configuration-options","title":"Configuration Options","text":"<p>Helm charts provide extensive configuration through values files:</p>"},{"location":"architecture/deployment/helm-deployment/#infrastructure-configuration","title":"Infrastructure Configuration","text":"<pre><code># Example scanner-infrastructure values\nnamespace:\n  name: scanner-system\n  create: true\n\nserviceAccount:\n  name: scanner-sa\n  create: true\n\nrbac:\n  create: true\n  rules:\n    - apiGroups: [\"\"]\n      resources: [\"pods\", \"pods/exec\"]\n      verbs: [\"get\", \"list\", \"create\"]\n\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 10001\n</code></pre>"},{"location":"architecture/deployment/helm-deployment/#scanner-configuration","title":"Scanner Configuration","text":"<pre><code># Example standard-scanner values\ntarget:\n  namespace: default\n  podSelector:\n    matchLabels:\n      app: web-service\n\nscan:\n  profile: container-baseline\n  thresholds:\n    critical: 0\n    high: 2\n    medium: 5\n    low: 10\n\nresults:\n  format: json\n  reportDir: /reports\n</code></pre>"},{"location":"architecture/deployment/helm-deployment/#security-considerations","title":"Security Considerations","text":"<p>The Helm chart deployment implements these security measures:</p> <ol> <li>Security Contexts: Non-root execution with minimal capabilities</li> <li>Resource Limits: CPU and memory limits for scanner pods</li> <li>RBAC Isolation: Namespace-specific RBAC with least privilege</li> <li>Secret Management: Secure handling of sensitive values</li> <li>Ephemeral Resources: Scanner pods are temporary and cleaned up after use</li> </ol>"},{"location":"architecture/deployment/helm-deployment/#deployment-scenarios","title":"Deployment Scenarios","text":"<p>The Helm chart deployment is ideal for:</p> <ol> <li>Production Environments: Structured, repeatable deployment</li> <li>Multi-Cluster Environments: Consistent deployment across clusters</li> <li>GitOps Workflows: Integration with GitOps tools</li> <li>Regular Scanning: Scheduled or triggered scanning</li> <li>Complex Environments: When customization and flexibility are needed</li> </ol>"},{"location":"architecture/deployment/helm-deployment/#chart-installation","title":"Chart Installation","text":""},{"location":"architecture/deployment/helm-deployment/#basic-installation","title":"Basic Installation","text":"<pre><code># Install infrastructure chart\nhelm install scanner-infra ./helm-charts/scanner-infrastructure\n\n# Install standard scanner\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set target.namespace=default \\\n  --set target.podName=web-pod \\\n  --set target.containerName=web-container\n</code></pre>"},{"location":"architecture/deployment/helm-deployment/#using-values-files","title":"Using Values Files","text":"<pre><code># Install with custom values\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  -f ./helm-charts/standard-scanner/examples/values-ci.yaml\n</code></pre>"},{"location":"architecture/deployment/helm-deployment/#complete-environment-installation","title":"Complete Environment Installation","text":"<pre><code># Install all charts with script\n./helm-charts/install-all.sh\n</code></pre>"},{"location":"architecture/deployment/helm-deployment/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>The Helm chart deployment can be integrated with:</p> <ol> <li>GitOps Systems: ArgoCD, Flux for declarative deployment</li> <li>CI/CD Pipelines: Automated deployment in CI/CD workflows</li> <li>Kubernetes Operators: Custom operators for advanced automation</li> <li>Monitoring Systems: Integration with monitoring for event-driven scanning</li> </ol>"},{"location":"architecture/deployment/helm-deployment/#chart-dependencies-and-relationships","title":"Chart Dependencies and Relationships","text":"<pre><code>graph TD\n    A[scanner-infrastructure Chart] --&gt; B[Common Resources]\n    B --&gt; C[Service Account]\n    B --&gt; D[RBAC Rules]\n    B --&gt; E[Namespace]\n\n    F[common-scanner Chart] --&gt; G[Shared Components]\n    G --&gt; H[Helper Scripts]\n    G --&gt; I[Threshold Configs]\n\n    J[standard-scanner Chart] --&gt; F\n    K[distroless-scanner Chart] --&gt; F\n    L[sidecar-scanner Chart] --&gt; F\n\n    J --&gt; M[Standard Container Scanning]\n    K --&gt; N[Distroless Container Scanning]\n    L --&gt; O[Sidecar Container Scanning]\n\n    style A fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style J fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style K fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style L fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/helm-deployment/#advanced-configuration","title":"Advanced Configuration","text":"<p>For detailed information on advanced configuration options, see:</p> <ul> <li>Helm Chart Customization</li> <li>Helm Chart Values Reference</li> <li>Helm Chart Security</li> </ul>"},{"location":"architecture/deployment/inventory/","title":"Deployment Documentation Inventory","text":"<p>This directory contains documentation about the deployment architectures for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/deployment/inventory/#contents","title":"Contents","text":"<ul> <li>Script Deployment - Using shell scripts for direct execution</li> <li>Helm Deployment - Using Helm charts for production environments</li> <li>CI/CD Deployment - Integrating with CI/CD pipelines</li> </ul>"},{"location":"architecture/deployment/inventory/#overview","title":"Overview","text":"<p>The deployment documentation provides detailed information about the different ways the scanning system can be deployed and operated. Each deployment architecture has its own strengths and is suited to different use cases.</p> <p>Understanding these deployment options is essential for users who want to implement container scanning in their environment, as it helps them choose the most appropriate deployment architecture for their specific needs.</p>"},{"location":"architecture/deployment/script-deployment/","title":"Script-based Deployment Architecture","text":"<p>This document details the script-based deployment architecture for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/deployment/script-deployment/#architecture-overview","title":"Architecture Overview","text":"<p>The script-based deployment architecture uses shell scripts to directly execute scanning operations against a Kubernetes cluster. This approach is ideal for testing, development, and environments where Helm is not available.</p>"},{"location":"architecture/deployment/script-deployment/#key-components","title":"Key Components","text":""},{"location":"architecture/deployment/script-deployment/#1-shell-scripts","title":"1. Shell Scripts","text":"<p>The core scripts that implement the scanning functionality:</p> Script Purpose Usage <code>scan-container.sh</code> Scan standard containers <code>./kubernetes-scripts/scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]</code> <code>scan-distroless-container.sh</code> Scan distroless containers <code>./kubernetes-scripts/scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]</code> <code>scan-with-sidecar.sh</code> Scan using sidecar approach <code>./kubernetes-scripts/scan-with-sidecar.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;profile-path&gt; [threshold_file]</code> <code>setup-minikube.sh</code> Set up test environment <code>./kubernetes-scripts/setup-minikube.sh [--with-distroless]</code> <code>generate-kubeconfig.sh</code> Generate secure kubeconfig <code>./kubernetes-scripts/generate-kubeconfig.sh &lt;namespace&gt; &lt;service-account&gt; &lt;output-file&gt;</code>"},{"location":"architecture/deployment/script-deployment/#2-rbac-templates","title":"2. RBAC Templates","text":"<p>Kubernetes YAML templates for creating RBAC resources:</p> Template Purpose <code>kubernetes/templates/rbac.yaml</code> Base RBAC rules for scanner <code>kubernetes/templates/service-account.yaml</code> Service account for scanner <code>kubernetes/templates/namespace.yaml</code> Namespace creation template <code>kubernetes/templates/label-rbac.yaml</code> Label-based RBAC for targeted scanning"},{"location":"architecture/deployment/script-deployment/#3-test-resources","title":"3. Test Resources","text":"<p>Resources for testing the scanner:</p> Resource Purpose <code>test-pod.yaml</code> Sample pod for testing scanner <code>kubernetes/templates/test-pod.yaml</code> Parametrized test pod template"},{"location":"architecture/deployment/script-deployment/#deployment-architecture","title":"Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph User[\"USER ENVIRONMENT\"]\n        scripts[\"Scanner Scripts\"]\n        profiles[\"Security Profiles\"]\n        thresholds[\"Threshold Configuration\"]\n    end\n\n    subgraph Execution[\"SCRIPT EXECUTION\"]\n        rbac_creation[\"RBAC Resource Creation\"]\n        token_gen[\"Token Generation\"]\n        kubeconfig[\"Kubeconfig Creation\"]\n        scanner_exec[\"Scanner Execution\"]\n        results_process[\"Results Processing\"]\n        cleanup[\"Resource Cleanup\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        api[\"Kubernetes API\"]\n        sa[\"Service Account\"]\n        role[\"RBAC Role\"]\n        binding[\"RoleBinding\"]\n        containers[\"Target Containers\"]\n    end\n\n    %% Component relationships\n    User --&gt;|invokes| Execution\n    scripts --&gt;|implements| Execution\n    profiles --&gt;|used by| scanner_exec\n    thresholds --&gt;|used by| results_process\n    rbac_creation --&gt;|creates| sa\n    rbac_creation --&gt;|creates| role\n    rbac_creation --&gt;|creates| binding\n    token_gen --&gt;|generates for| sa\n    token_gen --&gt;|produces for| kubeconfig\n    kubeconfig --&gt;|configures| scanner_exec\n    scanner_exec --&gt;|connects to| api\n    scanner_exec --&gt;|scans| containers\n    scanner_exec --&gt;|produces for| results_process\n    results_process --&gt;|returns to| User\n    cleanup --&gt;|removes| sa\n    cleanup --&gt;|removes| role\n    cleanup --&gt;|removes| binding\n\n    %% WCAG-compliant styling\n    style User fill:none,stroke:#0066CC,stroke-width:4px\n    style Execution fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac_creation fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token_gen fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubeconfig fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_exec fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style results_process fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sa fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style role fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style binding fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style containers fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/deployment/script-deployment/#workflow-process","title":"Workflow Process","text":"<p>The script-based deployment follows this general workflow:</p> <ol> <li>Setup:</li> <li>User selects appropriate scanning script</li> <li>User provides target container details</li> <li>User provides security profile path</li> <li> <p>User optionally provides threshold configuration</p> </li> <li> <p>Execution:</p> </li> <li>Script creates necessary RBAC resources</li> <li>Script generates short-lived token</li> <li>Script creates temporary kubeconfig</li> <li>Script executes CINC Auditor with appropriate transport plugin</li> <li> <p>Script collects scan results</p> </li> <li> <p>Processing:</p> </li> <li>Script processes results with SAF CLI</li> <li>Script validates results against thresholds</li> <li> <p>Script produces formatted reports</p> </li> <li> <p>Cleanup:</p> </li> <li>Script removes temporary kubeconfig</li> <li>Script removes RBAC resources</li> <li>Script ensures clean state</li> </ol>"},{"location":"architecture/deployment/script-deployment/#security-considerations","title":"Security Considerations","text":"<p>The script-based deployment implements these security measures:</p> <ol> <li>Temporary Resources: All RBAC resources are created for the scan and then deleted</li> <li>Short-lived Tokens: Authentication tokens have minimal lifespan</li> <li>Least Privilege: RBAC permissions are limited to only what is necessary</li> <li>Secure Cleanup: Reliable resource cleanup even in failure scenarios</li> <li>Configuration Validation: Input validation to prevent misconfigurations</li> </ol>"},{"location":"architecture/deployment/script-deployment/#deployment-scenarios","title":"Deployment Scenarios","text":"<p>The script-based deployment is ideal for:</p> <ol> <li>Development Environments: Quick setup and testing</li> <li>CI/CD Pipelines: Direct integration into pipeline steps</li> <li>Testing New Features: Experimenting with scanning options</li> <li>Environments Without Helm: When Helm is not available or allowed</li> <li>One-off Scans: When regular scanning is not required</li> </ol>"},{"location":"architecture/deployment/script-deployment/#customization-options","title":"Customization Options","text":"<p>Scripts can be customized in several ways:</p> <ol> <li>Profile Selection: Any InSpec-compatible profile can be used</li> <li>Threshold Configuration: Custom threshold files can be provided</li> <li>RBAC Templates: RBAC templates can be modified for specific environments</li> <li>Timeout Settings: Scan timeouts can be adjusted</li> <li>Output Formatting: Result formatting can be customized</li> </ol>"},{"location":"architecture/deployment/script-deployment/#example-usage","title":"Example Usage","text":""},{"location":"architecture/deployment/script-deployment/#basic-container-scanning","title":"Basic Container Scanning","text":"<pre><code># Standard container scan\n./kubernetes-scripts/scan-container.sh default nginx-pod nginx-container examples/cinc-profiles/container-baseline\n\n# Distroless container scan\n./kubernetes-scripts/scan-distroless-container.sh default distroless-pod distroless-container examples/cinc-profiles/container-baseline\n\n# Sidecar approach scan\n./kubernetes-scripts/scan-with-sidecar.sh default target-pod examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"architecture/deployment/script-deployment/#with-threshold-validation","title":"With Threshold Validation","text":"<pre><code># Standard container scan with threshold validation\n./kubernetes-scripts/scan-container.sh default nginx-pod nginx-container examples/cinc-profiles/container-baseline examples/thresholds/moderate.yml\n</code></pre>"},{"location":"architecture/deployment/script-deployment/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<pre><code># Setup Minikube for testing\n./kubernetes-scripts/setup-minikube.sh --with-distroless\n</code></pre>"},{"location":"architecture/deployment/script-deployment/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>The script-based deployment can be integrated with:</p> <ol> <li>CI/CD Systems: Scripts can be called directly from CI/CD jobs</li> <li>Monitoring Systems: Scripts can be triggered by monitoring alerts</li> <li>Scheduled Jobs: Scripts can be run as cron jobs for periodic scanning</li> <li>Custom Workflows: Scripts can be incorporated into custom workflows</li> </ol>"},{"location":"architecture/diagrams/","title":"Architecture Diagrams","text":"<p>This section provides WCAG-compliant Mermaid diagrams that visualize key aspects of the Kubernetes CINC Secure Scanner architecture.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Diagrams Documentation Inventory.</p>"},{"location":"architecture/diagrams/#diagram-types","title":"Diagram Types","text":"<p>The architecture diagrams are organized into the following categories:</p> <ol> <li>Component Diagrams - Visualizing system components and their relationships</li> <li>Workflow Diagrams - Illustrating end-to-end workflow processes</li> <li>Deployment Diagrams - Showing different deployment architectures</li> </ol>"},{"location":"architecture/diagrams/#diagram-standards","title":"Diagram Standards","text":"<p>All diagrams follow these standards:</p> <ul> <li>WCAG Compliance: Colors chosen for accessibility</li> <li>Consistent Styling: Uniform node and edge styles</li> <li>Clarity: Clear labels and relationships</li> <li>Light/Dark Mode Support: Visibility in both light and dark themes</li> <li>Mermaid Syntax: Using Mermaid for rendering in GitHub and MkDocs</li> </ul>"},{"location":"architecture/diagrams/#sample-component-diagram","title":"Sample Component Diagram","text":"<pre><code>flowchart TD\n    subgraph MiniKubeCluster[\"MINIKUBE CLUSTER\"]\n        direction TB\n        subgraph ControlNode[\"CONTROL NODE\"]\n            direction TB\n            apiserver[\"kube-apiserver\"]\n            etcd[\"etcd\"]\n        end\n\n        subgraph WorkerNode1[\"WORKER NODE 1\"]\n            direction TB\n            containers[\"Target Containers\"]\n            scanner_pods[\"Scanner Pods\"]\n        end\n\n        subgraph WorkerNode2[\"WORKER NODE 2\"]\n            direction TB\n            debug_containers[\"Debug Containers\"]\n            sidecar_pods[\"Sidecar Pods\"]\n        end\n    end\n\n    MiniKubeCluster --- cinc[\"CINC Profiles\\n(Compliance Controls)\"]\n    MiniKubeCluster --- rbac[\"Service Accounts\\nand RBAC\\n(Access Control)\"]\n    MiniKubeCluster --- saf[\"SAF CLI\\n(Reporting &amp;\\nThresholds)\"]\n\n    %% WCAG-compliant styling for subgraph labels - works in both light/dark\n    style MiniKubeCluster fill:none,stroke:#505050,stroke-width:4px\n    style ControlNode fill:none,stroke:#0066CC,stroke-width:4px\n    style WorkerNode1 fill:none,stroke:#0066CC,stroke-width:4px\n    style WorkerNode2 fill:none,stroke:#0066CC,stroke-width:4px\n\n    %% Component styling\n    style apiserver fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style etcd fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style containers fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug_containers fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar_pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/#diagram-documentation","title":"Diagram Documentation","text":"<p>For detailed diagrams of specific aspects of the architecture, see these documents:</p> <ul> <li>Component Diagrams - Visualization of system components</li> <li>Workflow Diagrams - Visualization of workflow processes</li> <li>Deployment Diagrams - Visualization of deployment architectures</li> </ul>"},{"location":"architecture/diagrams/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Component Architecture documentation</li> <li>Review the Workflow Processes documentation</li> <li>See the Deployment Options documentation</li> </ul>"},{"location":"architecture/diagrams/component-diagrams/","title":"Component Architecture Diagrams","text":"<p>This document provides visual representations of the architectural components that make up the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/diagrams/component-diagrams/#system-architecture-overview","title":"System Architecture Overview","text":"<p>The following diagram shows the high-level architecture of the scanning system:</p> <pre><code>flowchart TD\n    subgraph CoreComponents[\"CORE COMPONENTS\"]\n        direction TB\n        cinc[\"CINC Auditor\\nScanning Engine\"]\n        transport[\"train-k8s-container\\nTransport Plugin\"]\n        threshold[\"Threshold Validation\\nSAF CLI\"]\n    end\n\n    subgraph SecurityComponents[\"SECURITY COMPONENTS\"]\n        direction TB\n        sa[\"Service Accounts\\nIdentity\"]\n        rbac[\"RBAC Rules\\nAccess Control\"]\n        token[\"Token Management\\nAuthentication\"]\n    end\n\n    subgraph AdapterComponents[\"CONTAINER ADAPTERS\"]\n        direction TB\n        standard[\"Standard Container\\nAdapter\"]\n        debug[\"Debug Container\\nAdapter\"]\n        sidecar[\"Sidecar Container\\nAdapter\"]\n    end\n\n    subgraph ExternalSystems[\"EXTERNAL SYSTEMS\"]\n        direction TB\n        k8s[\"Kubernetes API\"]\n        ci[\"CI/CD Systems\"]\n        compliance[\"Compliance Systems\"]\n    end\n\n    %% Component relationships\n    CoreComponents --&gt;|uses| SecurityComponents\n    CoreComponents --&gt;|implements| AdapterComponents\n    AdapterComponents --&gt;|interacts with| ExternalSystems\n    SecurityComponents --&gt;|configures| ExternalSystems\n\n    %% WCAG-compliant styling\n    style CoreComponents fill:none,stroke:#0066CC,stroke-width:4px\n    style SecurityComponents fill:none,stroke:#DD6100,stroke-width:4px\n    style AdapterComponents fill:none,stroke:#217645,stroke-width:4px\n    style ExternalSystems fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style cinc fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style transport fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style threshold fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sa fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ci fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style compliance fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/component-diagrams/#cinc-auditor-component-architecture","title":"CINC Auditor Component Architecture","text":"<p>The following diagram shows the CINC Auditor component architecture:</p> <pre><code>flowchart TD\n    subgraph CINC[\"CINC AUDITOR\"]\n        direction TB\n        inspec[\"InSpec Core\"]\n        profiles[\"Security Profiles\"]\n        resources[\"InSpec Resources\"]\n        reporter[\"Results Reporter\"]\n    end\n\n    subgraph Transport[\"TRANSPORT PLUGIN\"]\n        direction TB\n        connection[\"Kubernetes Connection\"]\n        exec[\"Command Execution\"]\n        fs[\"Filesystem Access\"]\n        adapter[\"Container Type Adapter\"]\n    end\n\n    subgraph Target[\"TARGET CONTAINER\"]\n        direction TB\n        filesystem[\"Filesystem\"]\n        processes[\"Processes\"]\n        users[\"Users\"]\n        config[\"Configuration\"]\n    end\n\n    %% Component relationships\n    CINC --&gt;|uses| Transport\n    Transport --&gt;|accesses| Target\n    inspec --&gt;|loads| profiles\n    inspec --&gt;|uses| resources\n    inspec --&gt;|generates| reporter\n    connection --&gt;|connects to| filesystem\n    exec --&gt;|runs commands in| processes\n    fs --&gt;|reads| filesystem\n    adapter --&gt;|detects| Target\n\n    %% WCAG-compliant styling\n    style CINC fill:none,stroke:#4C366B,stroke-width:4px\n    style Transport fill:none,stroke:#DD6100,stroke-width:4px\n    style Target fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style inspec fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style resources fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reporter fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style connection fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style exec fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style fs fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style adapter fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style filesystem fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processes fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style users fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style config fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/component-diagrams/#security-component-architecture","title":"Security Component Architecture","text":"<p>The following diagram shows the security component architecture:</p> <pre><code>flowchart TD\n    subgraph ServiceAccount[\"SERVICE ACCOUNT MANAGEMENT\"]\n        direction TB\n        creation[\"Service Account Creation\"]\n        permissions[\"Permission Assignment\"]\n        lifecycle[\"Lifecycle Management\"]\n    end\n\n    subgraph RBAC[\"RBAC CONTROLS\"]\n        direction TB\n        role[\"Role Definition\"]\n        binding[\"Role Binding\"]\n        scope[\"Scope Limitation\"]\n    end\n\n    subgraph TokenMgmt[\"TOKEN MANAGEMENT\"]\n        direction TB\n        generation[\"Token Generation\"]\n        expiration[\"Token Expiration\"]\n        revocation[\"Token Revocation\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES SECURITY\"]\n        direction TB\n        apiserver[\"API Server Authentication\"]\n        authorization[\"Authorization Check\"]\n        audit[\"Audit Logging\"]\n    end\n\n    %% Component relationships\n    ServiceAccount --&gt;|creates| RBAC\n    RBAC --&gt;|controls| Kubernetes\n    TokenMgmt --&gt;|authenticates| Kubernetes\n    ServiceAccount --&gt;|manages| TokenMgmt\n\n    %% WCAG-compliant styling\n    style ServiceAccount fill:none,stroke:#DD6100,stroke-width:4px\n    style RBAC fill:none,stroke:#DD6100,stroke-width:4px\n    style TokenMgmt fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style creation fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style permissions fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style lifecycle fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style role fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style binding fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scope fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generation fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style expiration fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style revocation fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style apiserver fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style authorization fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style audit fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/component-diagrams/#container-adapter-architecture","title":"Container Adapter Architecture","text":"<p>The following diagram shows the container adapter architecture:</p> <pre><code>flowchart TD\n    subgraph Adapters[\"CONTAINER ADAPTERS\"]\n        direction TB\n        detector[\"Container Type Detector\"]\n        selector[\"Adapter Selector\"]\n    end\n\n    subgraph StandardAdapter[\"STANDARD ADAPTER\"]\n        direction TB\n        std_exec[\"Direct Exec\"]\n        std_fs[\"Direct Filesystem Access\"]\n    end\n\n    subgraph DebugAdapter[\"DEBUG CONTAINER ADAPTER\"]\n        direction TB\n        debug_container[\"Debug Container Creation\"]\n        debug_chroot[\"Chroot to Target Filesystem\"]\n        debug_exec[\"Command Execution in Debug\"]\n    end\n\n    subgraph SidecarAdapter[\"SIDECAR ADAPTER\"]\n        direction TB\n        shared_process[\"Shared Process Namespace\"]\n        proc_fs[\"/proc Filesystem Access\"]\n        sidecar_exec[\"Command Execution in Sidecar\"]\n    end\n\n    %% Component relationships\n    Adapters --&gt;|selects| StandardAdapter\n    Adapters --&gt;|selects| DebugAdapter\n    Adapters --&gt;|selects| SidecarAdapter\n\n    %% WCAG-compliant styling\n    style Adapters fill:none,stroke:#217645,stroke-width:4px\n    style StandardAdapter fill:none,stroke:#217645,stroke-width:4px\n    style DebugAdapter fill:none,stroke:#217645,stroke-width:4px\n    style SidecarAdapter fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style detector fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style selector fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style std_exec fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style std_fs fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug_container fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug_chroot fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug_exec fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style proc_fs fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar_exec fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/component-diagrams/#threshold-validation-architecture","title":"Threshold Validation Architecture","text":"<p>The following diagram shows the threshold validation architecture:</p> <pre><code>flowchart TD\n    subgraph SAF[\"SAF CLI INTEGRATION\"]\n        direction TB\n        parser[\"Results Parser\"]\n        validator[\"Threshold Validator\"]\n        reporter[\"Compliance Reporter\"]\n    end\n\n    subgraph Threshold[\"THRESHOLD CONFIGURATION\"]\n        direction TB\n        rules[\"Compliance Rules\"]\n        levels[\"Severity Levels\"]\n        thresholds[\"Compliance Thresholds\"]\n    end\n\n    subgraph Results[\"SCAN RESULTS\"]\n        direction TB\n        json[\"JSON Results\"]\n        summary[\"Results Summary\"]\n        details[\"Control Details\"]\n    end\n\n    subgraph Output[\"OUTPUT PROCESSING\"]\n        direction TB\n        status[\"Compliance Status\"]\n        report[\"Detailed Report\"]\n        feedback[\"CI/CD Feedback\"]\n    end\n\n    %% Component relationships\n    Results --&gt;|processed by| SAF\n    Threshold --&gt;|configures| SAF\n    SAF --&gt;|generates| Output\n\n    %% WCAG-compliant styling\n    style SAF fill:none,stroke:#4C366B,stroke-width:4px\n    style Threshold fill:none,stroke:#DD6100,stroke-width:4px\n    style Results fill:none,stroke:#505050,stroke-width:4px\n    style Output fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style parser fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validator fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reporter fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rules fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style levels fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style json fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style summary fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style details fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style report fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style feedback fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/deployment-diagrams/","title":"Deployment Architecture Diagrams","text":"<p>This document provides visual representations of the different deployment architectures supported by the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/diagrams/deployment-diagrams/#script-based-deployment-architecture","title":"Script-based Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph User[\"USER ENVIRONMENT\"]\n        direction TB\n        scripts[\"Scanning Scripts\"]\n        profiles[\"Security Profiles\"]\n        thresholds[\"Threshold Configuration\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        direction TB\n        subgraph ControlPlane[\"CONTROL PLANE\"]\n            api[\"Kubernetes API\"]\n            rbac[\"RBAC Controller\"]\n        end\n\n        subgraph Workers[\"WORKER NODES\"]\n            pods[\"Target Pods\"]\n            debug[\"Debug Containers\"]\n        end\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        saf[\"SAF CLI\"]\n        reports[\"Compliance Reports\"]\n    end\n\n    %% Component relationships\n    User --&gt;|executes against| Kubernetes\n    scripts --&gt;|creates| rbac\n    scripts --&gt;|connects to| api\n    api --&gt;|controls| pods\n    api --&gt;|creates| debug\n    scripts --&gt;|runs CINC in| debug\n    debug --&gt;|scans| pods\n    scripts --&gt;|collects results from| debug\n    scripts --&gt;|processes with| saf\n    saf --&gt;|validates against| thresholds\n    saf --&gt;|generates| reports\n\n    %% WCAG-compliant styling\n    style User fill:none,stroke:#0066CC,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style ControlPlane fill:none,stroke:#DD6100,stroke-width:4px\n    style Workers fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/deployment-diagrams/#helm-chart-deployment-architecture","title":"Helm Chart Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph User[\"USER ENVIRONMENT\"]\n        direction TB\n        helm[\"Helm CLI\"]\n        values[\"Values Configuration\"]\n    end\n\n    subgraph Charts[\"HELM CHARTS\"]\n        direction TB\n        infrastructure[\"scanner-infrastructure Chart\"]\n        common[\"common-scanner Chart\"]\n        standard[\"standard-scanner Chart\"]\n        distroless[\"distroless-scanner Chart\"]\n        sidecar[\"sidecar-scanner Chart\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        direction TB\n        subgraph Resources[\"DEPLOYED RESOURCES\"]\n            sa[\"Service Accounts\"]\n            roles[\"RBAC Roles &amp; Bindings\"]\n            ns[\"Namespaces\"]\n            pods[\"Scanner Pods\"]\n            config[\"ConfigMaps\"]\n        end\n\n        subgraph Target[\"TARGET RESOURCES\"]\n            target_pods[\"Target Pods\"]\n        end\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        saf[\"SAF CLI\"]\n        reports[\"Compliance Reports\"]\n        ci[\"CI/CD Integration\"]\n    end\n\n    %% Component relationships\n    User --&gt;|deploys| Charts\n    helm --&gt;|installs| infrastructure\n    helm --&gt;|installs| common\n    helm --&gt;|selects and installs| standard\n    helm --&gt;|selects and installs| distroless\n    helm --&gt;|selects and installs| sidecar\n    values --&gt;|configures| Charts\n    Charts --&gt;|create| Resources\n    infrastructure --&gt;|establishes| sa\n    infrastructure --&gt;|establishes| roles\n    infrastructure --&gt;|establishes| ns\n    standard --&gt;|scans| target_pods\n    distroless --&gt;|scans| target_pods\n    sidecar --&gt;|scans| target_pods\n    pods --&gt;|produce| reports\n    reports --&gt;|fed to| ci\n\n    %% WCAG-compliant styling\n    style User fill:none,stroke:#0066CC,stroke-width:4px\n    style Charts fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Resources fill:none,stroke:#217645,stroke-width:4px\n    style Target fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style helm fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style values fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style infrastructure fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style common fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style distroless fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sa fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style roles fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ns fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pods fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style config fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target_pods fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ci fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/deployment-diagrams/#github-actions-deployment-architecture","title":"GitHub Actions Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph GitHub[\"GITHUB ENVIRONMENT\"]\n        direction TB\n        actions[\"GitHub Actions\"]\n        workflows[\"Workflow YAML\"]\n        repo[\"Code Repository\"]\n    end\n\n    subgraph Runner[\"GITHUB RUNNER\"]\n        direction TB\n        action_runner[\"Action Runner\"]\n        scripts[\"Scanner Scripts\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        direction TB\n        api[\"Kubernetes API\"]\n        rbac[\"RBAC Resources\"]\n        pods[\"Target Pods\"]\n        debug[\"Debug Containers\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        saf[\"SAF CLI\"]\n        reports[\"Compliance Reports\"]\n        artifacts[\"GitHub Artifacts\"]\n    end\n\n    %% Component relationships\n    GitHub --&gt;|triggers| Runner\n    workflows --&gt;|configures| action_runner\n    repo --&gt;|contains| profiles\n    action_runner --&gt;|executes| scripts\n    scripts --&gt;|connects to| api\n    scripts --&gt;|creates| rbac\n    scripts --&gt;|scans| pods\n    scripts --&gt;|uses| debug\n    scripts --&gt;|processes with| saf\n    saf --&gt;|produces| reports\n    reports --&gt;|stored as| artifacts\n    artifacts --&gt;|published to| GitHub\n\n    %% WCAG-compliant styling\n    style GitHub fill:none,stroke:#0066CC,stroke-width:4px\n    style Runner fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style actions fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style workflows fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style repo fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style action_runner fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pods fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/deployment-diagrams/#gitlab-ci-deployment-architecture","title":"GitLab CI Deployment Architecture","text":"<pre><code>flowchart TD\n    subgraph GitLab[\"GITLAB ENVIRONMENT\"]\n        direction TB\n        ci[\"GitLab CI/CD\"]\n        pipeline[\"Pipeline Configuration\"]\n        repo[\"Code Repository\"]\n    end\n\n    subgraph Runner[\"GITLAB RUNNER\"]\n        direction TB\n        jobs[\"CI Jobs\"]\n        services[\"Scanner Services\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTER\"]\n        direction TB\n        api[\"Kubernetes API\"]\n        rbac[\"RBAC Resources\"]\n        pods[\"Target Pods\"]\n        sidecars[\"Sidecar Containers\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        saf[\"SAF CLI\"]\n        reports[\"Compliance Reports\"]\n        artifacts[\"GitLab Artifacts\"]\n        security_dashboard[\"Security Dashboard\"]\n    end\n\n    %% Component relationships\n    GitLab --&gt;|triggers| Runner\n    pipeline --&gt;|configures| jobs\n    repo --&gt;|contains| profiles\n    jobs --&gt;|use| services\n    services --&gt;|connect to| api\n    services --&gt;|create| rbac\n    services --&gt;|scan| pods\n    services --&gt;|deploy| sidecars\n    services --&gt;|process with| saf\n    saf --&gt;|produces| reports\n    reports --&gt;|stored as| artifacts\n    artifacts --&gt;|published to| GitLab\n    reports --&gt;|displayed in| security_dashboard\n\n    %% WCAG-compliant styling\n    style GitLab fill:none,stroke:#0066CC,stroke-width:4px\n    style Runner fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style ci fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pipeline fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style repo fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style services fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style pods fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecars fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style security_dashboard fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/deployment-diagrams/#enterprise-integration-architecture","title":"Enterprise Integration Architecture","text":"<pre><code>flowchart TD\n    subgraph Enterprise[\"ENTERPRISE ENVIRONMENT\"]\n        direction TB\n        cicd[\"CI/CD Systems\"]\n        security[\"Security Systems\"]\n        monitoring[\"Monitoring Systems\"]\n        compliance[\"Compliance Systems\"]\n    end\n\n    subgraph Scanner[\"SCANNER DEPLOYMENT\"]\n        direction TB\n        helm[\"Helm Deployment\"]\n        scripts[\"Script Deployment\"]\n        sidecar[\"Sidecar Deployment\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES CLUSTERS\"]\n        direction TB\n        prod[\"Production Cluster\"]\n        staging[\"Staging Cluster\"]\n        dev[\"Development Cluster\"]\n    end\n\n    subgraph Integration[\"INTEGRATION POINTS\"]\n        triggers[\"Scan Triggers\"]\n        results[\"Results Processing\"]\n        reports[\"Reporting Systems\"]\n        alerts[\"Alert Systems\"]\n    end\n\n    %% Component relationships\n    Enterprise --&gt;|manages| Scanner\n    Enterprise --&gt;|contains| Kubernetes\n    Enterprise --&gt;|configures| Integration\n    cicd --&gt;|triggers| triggers\n    security --&gt;|consumes| results\n    monitoring --&gt;|watches| Scanner\n    compliance --&gt;|receives| reports\n    Scanner --&gt;|deployed to| Kubernetes\n    helm --&gt;|installs in| prod\n    helm --&gt;|installs in| staging\n    scripts --&gt;|runs against| dev\n    sidecar --&gt;|embeds in| prod\n    triggers --&gt;|activates| Scanner\n    Scanner --&gt;|produces| results\n    results --&gt;|generates| reports\n    results --&gt;|may create| alerts\n\n    %% WCAG-compliant styling\n    style Enterprise fill:none,stroke:#0066CC,stroke-width:4px\n    style Scanner fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Integration fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style cicd fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style security fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style monitoring fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style compliance fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style helm fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style sidecar fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style prod fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style staging fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style dev fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style triggers fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style alerts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/inventory/","title":"Architecture Diagrams Inventory","text":"<p>This directory contains diagram-based documentation that visually represents the architecture, workflows, and deployment options for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/diagrams/inventory/#contents","title":"Contents","text":"<ul> <li>Component Diagrams - Visualization of system components and their relationships</li> <li>Workflow Diagrams - Visualization of end-to-end workflow processes</li> <li>Deployment Diagrams - Visualization of different deployment architectures</li> </ul>"},{"location":"architecture/diagrams/inventory/#overview","title":"Overview","text":"<p>The diagram documentation provides visual representations of the scanning system's architecture, making it easier to understand how components interact, how workflows execute, and how the system can be deployed in different environments.</p> <p>All diagrams follow WCAG compliance standards and are rendered using Mermaid syntax, ensuring they are accessible and compatible with both GitHub and MkDocs environments.</p>"},{"location":"architecture/diagrams/workflow-diagrams/","title":"Workflow Diagrams","text":"<p>This document provides visual representations of the workflow processes used by the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/diagrams/workflow-diagrams/#standard-container-scanning-workflow","title":"Standard Container Scanning Workflow","text":"<pre><code>flowchart TD\n    start([START KUBERNETES API APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: SETUP &amp; PREPARATION\"]\n        direction TB\n        identify[\"Identify Target Container\"] --&gt; create_rbac[\"Create RBAC and Service Account\"]\n        create_rbac --&gt; generate_token[\"Generate Short-lived Security Token\"]\n        generate_token --&gt; create_kubeconfig[\"Create Restricted Kubeconfig File\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: SCANNING EXECUTION\"]\n        direction TB\n        run_cinc[\"Run CINC Auditor with k8s-container Transport\"] --&gt; process[\"Process with SAF CLI &amp; Check Threshold\"]\n        process --&gt; generate_reports[\"Generate Reports and Validations\"]\n        generate_reports --&gt; cleanup[\"Clean up RBAC &amp; Service Account\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_kubeconfig fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style generate_reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#distroless-container-scanning-workflow","title":"Distroless Container Scanning Workflow","text":"<pre><code>flowchart TD\n    start([START DEBUG CONTAINER APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: ATTACH DEBUG CONTAINER\"]\n        direction TB\n        identify[\"Identify Distroless Target Container\"] --&gt; create_debug[\"Create Ephemeral Debug Container\"]\n        create_debug --&gt; deploy_cinc[\"Deploy CINC Auditor in Debug Container\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER\"]\n        direction TB\n        chroot[\"Chroot to Target Container Filesystem\"] --&gt; run_cinc[\"Run CINC Auditor Against Target\"]\n        run_cinc --&gt; export_results[\"Export Scan Results to Host System\"]\n        export_results --&gt; process[\"Process Results with SAF CLI\"]\n        process --&gt; terminate[\"Terminate Debug Container &amp; Clean Up\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling with WCAG-compliant colors\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_debug fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_cinc fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style chroot fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style export_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style terminate fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#sidecar-container-scanning-workflow","title":"Sidecar Container Scanning Workflow","text":"<pre><code>flowchart TD\n    start([START SIDECAR APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        direction TB\n        deploy_target[\"Deploy Target Container in Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        direction TB\n        find_process[\"Sidecar Finds Target Process\"] --&gt; access_fs[\"Access Target via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar\"]\n    end\n\n    step2 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#enhanced-kubernetes-api-workflow","title":"Enhanced Kubernetes API Workflow","text":"<pre><code>flowchart TD\n    start([START ENHANCED KUBERNETES API APPROACH]) --&gt; step1\n\n    subgraph step1[\"STEP 1: CONTAINER DETECTION AND SETUP\"]\n        direction TB\n        identify[\"Target Container Identification\"] --&gt; plugin[\"Modified train-k8s-container Plugin\"]\n        plugin --&gt; detect[\"Auto-Detect if Container is Distroless\"]\n        detect --&gt;|Regular| standard[\"Use Standard Direct Exec Connection\"]\n        detect --&gt;|Distroless| debug[\"Use Debug Container Fallback\"]\n        debug --&gt; create_debug[\"Create Temporary Debug Container\"]\n    end\n\n    standard --&gt; step2\n    create_debug --&gt; step2\n\n    subgraph step2[\"STEP 2: SCANNING EXECUTION\"]\n        direction TB\n        run_cinc[\"Run CINC Auditor Scan\"] --&gt; process[\"Process Results with SAF CLI\"]\n    end\n\n    step2 --&gt; step3\n\n    subgraph step3[\"STEP 3: CLEANUP (FOR DISTROLESS)\"]\n        direction TB\n        cleanup[\"Terminate and Clean Up Resources\"]\n    end\n\n    step3 --&gt; complete([SCAN COMPLETE])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step styling with WCAG-compliant colors - works in both light/dark\n    style step1 fill:none,stroke:#DD6100,stroke-width:4px\n    style step2 fill:none,stroke:#DD6100,stroke-width:4px\n    style step3 fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style identify fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style plugin fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style detect fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style standard fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style debug fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style create_debug fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#cicd-integration-workflow","title":"CI/CD Integration Workflow","text":"<pre><code>flowchart TD\n    A[Start CI/CD Pipeline] --&gt; B[Deploy Test Container]\n    B --&gt; C[Create Minimal RBAC]\n    C --&gt; D[Generate Short-lived Token]\n    D --&gt; E[Create Scanner Kubeconfig]\n    E --&gt; F{Container Type}\n    F --&gt;|Standard| G1[Run Standard Scan]\n    F --&gt;|Distroless| G2[Run Distroless Scan]\n    G1 --&gt; H[Generate Reports]\n    G2 --&gt; H\n    H --&gt; I[Validate Against Thresholds]\n    I --&gt; J{Threshold Met?}\n    J --&gt;|Yes| K[Mark as Passed]\n    J --&gt;|No| L[Mark as Failed]\n    K --&gt; M[Cleanup Resources]\n    L --&gt; M\n    M --&gt; N[End Pipeline]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#fbb,stroke:#333,stroke-width:2px\n    style J fill:#fbb,stroke:#333,stroke-width:2px\n    style K fill:#bfb,stroke:#333,stroke-width:2px\n    style L fill:#fbb,stroke:#333,stroke-width:2px\n    style N fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#minikube-setup-and-scanning-workflow","title":"Minikube Setup and Scanning Workflow","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Run setup-minikube.sh]\n    B --&gt; C{With Distroless Flag?}\n\n    C --&gt;|No| D1[Create Standard Minikube Cluster]\n    C --&gt;|Yes| D2[Create Minikube with Distroless Support]\n\n    D1 --&gt; E1[Deploy Standard RBAC]\n    D2 --&gt; E2[Deploy Extended RBAC with Ephemeral Container Support]\n\n    E1 --&gt; F1[Deploy Test Containers]\n    E2 --&gt; F2[Deploy Test Containers + Distroless Containers]\n\n    F1 --&gt; G1[Generate Scanner Kubeconfig]\n    F2 --&gt; G2[Generate Scanner Kubeconfig]\n\n    G1 --&gt; H1[Run scan-container.sh]\n    G2 --&gt; H2{Container Type?}\n\n    H2 --&gt;|Standard| H3[Run scan-container.sh]\n    H2 --&gt;|Distroless| H4[Run scan-distroless-container.sh]\n\n    H1 --&gt; I1[Generate Reports]\n    H3 --&gt; I1\n    H4 --&gt; I1\n\n    I1 --&gt; J[Validate with SAF-CLI]\n    J --&gt; K[Clean Up Resources]\n    K --&gt; L[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px\n    style H2 fill:#fbb,stroke:#333,stroke-width:2px\n    style J fill:#bfb,stroke:#333,stroke-width:2px\n    style L fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/diagrams/workflow-diagrams/#security-focused-workflow","title":"Security-Focused Workflow","text":"<pre><code>flowchart TD\n    start([START]) --&gt; principles\n\n    subgraph principles[\"SECURITY PRINCIPLES\"]\n        direction TB\n        least_privilege[\"Principle of Least Privilege\"] --&gt; token[\"Short-lived Token Generation\"]\n        namespace[\"Namespace Isolation\"] --&gt; no_privileges[\"No Permanent Elevated Privileges\"]\n    end\n\n    principles --&gt; controls\n\n    subgraph controls[\"IMPLEMENTATION CONTROLS\"]\n        direction TB\n        rbac[\"Resource-specific RBAC Controls\"] --&gt; security_first[\"Security First Design\"]\n        audit[\"Audit Trail of Scan Access\"] --&gt; cleanup[\"Automatic Cleanup\"]\n    end\n\n    controls --&gt; compliance\n\n    subgraph compliance[\"COMPLIANCE VALIDATION\"]\n        direction TB\n        threshold[\"Threshold-based Validation with SAF CLI\"]\n    end\n\n    compliance --&gt; complete([END])\n\n    %% WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Section styling with WCAG-compliant colors - works in both light/dark\n    style principles fill:none,stroke:#DD6100,stroke-width:4px\n    style controls fill:none,stroke:#DD6100,stroke-width:4px\n    style compliance fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Process styling\n    style least_privilege fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style token fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style namespace fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style no_privileges fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style security_first fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style audit fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cleanup fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style threshold fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/","title":"CI/CD Integration Architecture","text":"<p>This section provides detailed information about the CI/CD integration architecture for the Kubernetes CINC Secure Scanner.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Integrations Documentation Inventory.</p>"},{"location":"architecture/integrations/#integration-overview","title":"Integration Overview","text":"<p>The scanning system is designed to integrate seamlessly with various CI/CD platforms and external systems:</p> <ol> <li>GitHub Actions Integration - For GitHub-based workflows</li> <li>GitLab CI Integration - For GitLab-based pipelines</li> <li>GitLab Services Integration - For GitLab with service containers</li> <li>Custom Integration - For other CI/CD platforms</li> </ol>"},{"location":"architecture/integrations/#integration-architecture-patterns","title":"Integration Architecture Patterns","text":"<p>While specific implementations differ, all integrations follow these general patterns:</p> <ol> <li>Environment Setup: Configure the scanning environment</li> <li>Security Configuration: Establish secure access to the Kubernetes cluster</li> <li>Scanning Execution: Execute the appropriate scanner</li> <li>Results Processing: Process and validate scan results</li> <li>Pipeline Integration: Integrate results into the CI/CD workflow</li> </ol>"},{"location":"architecture/integrations/#integration-documentation","title":"Integration Documentation","text":"<p>For detailed information about specific integrations, see these documents:</p> <ul> <li>GitHub Actions Integration - Integration with GitHub Actions</li> <li>GitLab CI Integration - Integration with GitLab CI pipelines</li> <li>GitLab Services Integration - Integration with GitLab Services</li> <li>Custom Integrations - Integration with other platforms</li> </ul>"},{"location":"architecture/integrations/#integration-diagram","title":"Integration Diagram","text":"<pre><code>flowchart TD\n    subgraph CI[\"CI/CD SYSTEMS\"]\n        direction TB\n        github[\"GitHub Actions\"]\n        gitlab[\"GitLab CI\"]\n        jenkins[\"Jenkins\"]\n        other[\"Other CI/CD\"]\n    end\n\n    subgraph Scanner[\"SCANNER COMPONENTS\"]\n        direction TB\n        scripts[\"Scanner Scripts\"]\n        profiles[\"Security Profiles\"]\n        thresholds[\"Threshold Configurations\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES ENVIRONMENT\"]\n        direction TB\n        cluster[\"Kubernetes Cluster\"]\n        containers[\"Target Containers\"]\n    end\n\n    subgraph Results[\"RESULTS INTEGRATION\"]\n        direction TB\n        reports[\"Scan Reports\"]\n        artifacts[\"CI/CD Artifacts\"]\n        dashboards[\"Security Dashboards\"]\n        checks[\"Status Checks\"]\n    end\n\n    %% Relationship connections\n    CI --&gt;|triggers| Scanner\n    Scanner --&gt;|scans| Kubernetes\n    Scanner --&gt;|produces| Results\n    Results --&gt;|feedback to| CI\n\n    %% WCAG-compliant styling\n    style CI fill:none,stroke:#0066CC,stroke-width:4px\n    style Scanner fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style github fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style gitlab fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jenkins fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style other fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style thresholds fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cluster fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style containers fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reports fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style dashboards fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style checks fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Component Architecture documentation</li> <li>Review the Workflow Processes documentation</li> <li>See the Deployment Options documentation</li> </ul>"},{"location":"architecture/integrations/custom-integrations/","title":"Custom Integrations Architecture","text":"<p>This document details the architecture for integrating the Kubernetes CINC Secure Scanner with custom CI/CD platforms and external systems.</p>"},{"location":"architecture/integrations/custom-integrations/#integration-overview","title":"Integration Overview","text":"<p>The custom integrations architecture provides guidance for integrating the scanning system with CI/CD platforms beyond GitHub Actions and GitLab CI, as well as with other external systems.</p>"},{"location":"architecture/integrations/custom-integrations/#integration-architecture","title":"Integration Architecture","text":"<p>The general architecture for custom integrations follows this pattern:</p> <pre><code>flowchart TD\n    subgraph Platform[\"EXTERNAL PLATFORM\"]\n        direction TB\n        workflow[\"Workflow Definition\"]\n        execution[\"Execution Environment\"]\n        triggers[\"Triggering Mechanism\"]\n    end\n\n    subgraph Scanner[\"SCANNER COMPONENTS\"]\n        direction TB\n        scripts[\"Scanner Scripts\"]\n        profiles[\"Security Profiles\"]\n        configuration[\"Scanner Configuration\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES ENVIRONMENT\"]\n        direction TB\n        api[\"Kubernetes API\"]\n        rbac[\"RBAC Resources\"]\n        target[\"Target Containers\"]\n    end\n\n    subgraph Results[\"RESULTS HANDLING\"]\n        direction TB\n        processing[\"Results Processing\"]\n        storage[\"Results Storage\"]\n        reporting[\"Results Reporting\"]\n    end\n\n    %% Component relationships\n    Platform --&gt;|integrates with| Scanner\n    workflow --&gt;|defines| execution\n    triggers --&gt;|activate| workflow\n    execution --&gt;|runs| scripts\n    scripts --&gt;|use| profiles\n    scripts --&gt;|apply| configuration\n    Scanner --&gt;|interacts with| Kubernetes\n    scripts --&gt;|create| rbac\n    scripts --&gt;|access| api\n    scripts --&gt;|scan| target\n    Scanner --&gt;|produces| Results\n    processing --&gt;|stores in| storage\n    processing --&gt;|generates| reporting\n\n    %% WCAG-compliant styling\n    style Platform fill:none,stroke:#0066CC,stroke-width:4px\n    style Scanner fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style workflow fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style execution fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style triggers fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style configuration fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style processing fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style storage fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reporting fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#supported-integration-platforms","title":"Supported Integration Platforms","text":"<p>The scanning system can be integrated with various platforms:</p> Platform Integration Type Key Components Jenkins Pipeline script Jenkins Pipeline DSL, shared library CircleCI Config file .circleci/config.yml, orbs Bamboo Build plan Build tasks, deployment projects TeamCity Build configuration Build steps, parameters Azure DevOps Pipeline file azure-pipelines.yml, tasks AWS CodePipeline Pipeline definition CodeBuild projects, buildspec.yml Spinnaker Pipeline definition Stages, triggers, notifications Custom scripts Direct execution Bash/Python scripts, cron jobs"},{"location":"architecture/integrations/custom-integrations/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/integrations/custom-integrations/#1-direct-script-execution","title":"1. Direct Script Execution","text":"<p>The simplest pattern involves direct execution of scanner scripts:</p> <pre><code>flowchart TD\n    A[Start Integration] --&gt; B[Setup Environment]\n    B --&gt; C[Execute Scanner Scripts]\n    C --&gt; D[Process Results]\n    D --&gt; E[Report Status]\n    E --&gt; F[End Integration]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#2-container-based-integration","title":"2. Container-based Integration","text":"<p>Using containers to package and run the scanner:</p> <pre><code>flowchart TD\n    A[Start Integration] --&gt; B[Pull Scanner Container]\n    B --&gt; C[Configure Container]\n    C --&gt; D[Run Container]\n    D --&gt; E[Extract Results]\n    E --&gt; F[Process Results]\n    F --&gt; G[End Integration]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#3-api-based-integration","title":"3. API-based Integration","text":"<p>Integrating through a custom API layer:</p> <pre><code>flowchart TD\n    A[Start Integration] --&gt; B[API Request]\n    B --&gt; C[API Service]\n    C --&gt; D[Scanner Service]\n    D --&gt; E[Kubernetes]\n    D --&gt; F[Results Service]\n    F --&gt; G[API Response]\n    G --&gt; H[End Integration]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#example-integrations","title":"Example Integrations","text":""},{"location":"architecture/integrations/custom-integrations/#jenkins-pipeline-integration","title":"Jenkins Pipeline Integration","text":"<pre><code>pipeline {\n    agent {\n        kubernetes {\n            yaml \"\"\"\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: cinc\n    image: registry.example.com/cinc-auditor:latest\n    command:\n    - cat\n    tty: true\n  - name: kubectl\n    image: bitnami/kubectl:latest\n    command:\n    - cat\n    tty: true\n\"\"\"\n        }\n    }\n\n    environment {\n        PROFILE_PATH = 'examples/cinc-profiles/container-baseline'\n        TARGET_NAMESPACE = 'default'\n        TARGET_POD = 'web-app'\n        TARGET_CONTAINER = 'web-container'\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                container('kubectl') {\n                    sh 'kubectl apply -f test-pod.yaml'\n                    sh 'kubectl wait --for=condition=Ready pod/$TARGET_POD --timeout=60s'\n                }\n            }\n        }\n\n        stage('Scan') {\n            steps {\n                container('cinc') {\n                    sh \"\"\"\n                        cinc exec -t k8s-container://${TARGET_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n                            --input ${PROFILE_PATH} \\\n                            --reporter json:results.json\n                    \"\"\"\n                }\n            }\n        }\n\n        stage('Validate') {\n            steps {\n                container('cinc') {\n                    sh \"\"\"\n                        if jq -e '.profiles[0].controls[] | select(.status == \"failed\")' results.json &gt; /dev/null; then\n                            echo \"Security scan failed\"\n                            exit 1\n                        else\n                            echo \"Security scan passed\"\n                        fi\n                    \"\"\"\n                }\n            }\n        }\n    }\n\n    post {\n        always {\n            archiveArtifacts artifacts: 'results.json', allowEmptyArchive: true\n        }\n    }\n}\n</code></pre>"},{"location":"architecture/integrations/custom-integrations/#circleci-integration","title":"CircleCI Integration","text":"<pre><code>version: 2.1\n\njobs:\n  scan:\n    docker:\n      - image: registry.example.com/scanner:latest\n    steps:\n      - checkout\n      - setup_remote_docker\n      - run:\n          name: Setup Kubernetes\n          command: |\n            echo \"${KUBECONFIG_CONTENT}\" &gt; kubeconfig.yaml\n            export KUBECONFIG=kubeconfig.yaml\n      - run:\n          name: Deploy Target Container\n          command: kubectl apply -f test-pod.yaml\n      - run:\n          name: Scan Container\n          command: |\n            ./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n      - run:\n          name: Validate Results\n          command: |\n            if jq -e '.failure_count &gt; 0' results/summary.json; then\n              echo \"Security scan failed\"\n              exit 1\n            else\n              echo \"Security scan passed\"\n            fi\n      - store_artifacts:\n          path: results/\n          destination: scan-results\n\nworkflows:\n  security-scan:\n    jobs:\n      - scan\n</code></pre>"},{"location":"architecture/integrations/custom-integrations/#aws-codebuild-integration","title":"AWS CodeBuild Integration","text":"<pre><code>version: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      ruby: 2.7\n    commands:\n      - curl -LO \"https://dl.k8s.io/release/v1.23.0/bin/linux/amd64/kubectl\"\n      - chmod +x kubectl &amp;&amp; mv kubectl /usr/local/bin/\n      - gem install cinc-auditor-bin saf\n\n  pre_build:\n    commands:\n      - mkdir -p ~/.kube\n      - echo \"${KUBECONFIG_CONTENT}\" &gt; ~/.kube/config\n      - chmod 600 ~/.kube/config\n      - kubectl apply -f test-pod.yaml\n      - kubectl wait --for=condition=Ready pod/test-pod --timeout=60s\n\n  build:\n    commands:\n      - cinc exec -t k8s-container://default/test-pod/test-container --input examples/cinc-profiles/container-baseline --reporter json:results.json\n\n  post_build:\n    commands:\n      - saf validate results.json -c examples/thresholds/moderate.yml --reporter cli\n      - |\n        if [ $(jq '.failure_count' results.json) -gt 0 ]; then\n          echo \"Security scan failed\"\n          exit 1\n        else\n          echo \"Security scan passed\"\n        fi\n\nartifacts:\n  files:\n    - results.json\n    - validation.json\n  name: scan-results\n</code></pre>"},{"location":"architecture/integrations/custom-integrations/#custom-api-integration","title":"Custom API Integration","text":"<p>For programmatic integration, a custom API layer can be implemented:</p> <pre><code>flowchart TD\n    subgraph API[\"CUSTOM API LAYER\"]\n        direction TB\n        endpoints[\"API Endpoints\"]\n        auth[\"Authentication\"]\n        validation[\"Input Validation\"]\n    end\n\n    subgraph Service[\"SCANNER SERVICE\"]\n        direction TB\n        queue[\"Scan Queue\"]\n        worker[\"Scanner Worker\"]\n        storage[\"Result Storage\"]\n    end\n\n    subgraph Clients[\"CLIENT INTEGRATIONS\"]\n        direction TB\n        ci[\"CI/CD Systems\"]\n        scripts[\"Custom Scripts\"]\n        dashboards[\"Security Dashboards\"]\n    end\n\n    Clients --&gt;|request scan| API\n    API --&gt;|validates| validation\n    API --&gt;|authenticates| auth\n    API --&gt;|submits to| Service\n    endpoints --&gt;|defines| queue\n    worker --&gt;|processes from| queue\n    worker --&gt;|writes to| storage\n    API --&gt;|retrieves from| storage\n    API --&gt;|returns to| Clients\n\n    %% WCAG-compliant styling\n    style API fill:none,stroke:#0066CC,stroke-width:4px\n    style Service fill:none,stroke:#DD6100,stroke-width:4px\n    style Clients fill:none,stroke:#505050,stroke-width:4px\n\n    %% Component styling\n    style endpoints fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style auth fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style queue fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style worker fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style storage fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ci fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style dashboards fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#api-endpoints","title":"API Endpoints","text":"<p>Example API endpoints for custom integration:</p> Endpoint Method Purpose <code>/api/v1/scans</code> POST Create new scan <code>/api/v1/scans/{id}</code> GET Get scan status <code>/api/v1/scans/{id}/results</code> GET Get scan results <code>/api/v1/profiles</code> GET List available profiles <code>/api/v1/thresholds</code> GET List available thresholds"},{"location":"architecture/integrations/custom-integrations/#example-api-request","title":"Example API Request","text":"<pre><code>{\n  \"target\": {\n    \"namespace\": \"default\",\n    \"pod\": \"web-app\",\n    \"container\": \"web-container\"\n  },\n  \"scan\": {\n    \"profile\": \"container-baseline\",\n    \"threshold\": \"moderate\"\n  },\n  \"options\": {\n    \"timeout\": 300,\n    \"reportFormat\": \"json\"\n  },\n  \"callback\": {\n    \"url\": \"https://ci-system.example.com/callbacks/scan-123\",\n    \"authentication\": {\n      \"type\": \"bearer\",\n      \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/integrations/custom-integrations/#event-driven-integration","title":"Event-Driven Integration","text":"<p>For event-driven architectures, the scanner can be triggered by events:</p> <pre><code>flowchart TD\n    subgraph Sources[\"EVENT SOURCES\"]\n        direction TB\n        container_deploy[\"Container Deployment\"]\n        image_publish[\"Image Publication\"]\n        scheduled_event[\"Scheduled Event\"]\n    end\n\n    subgraph Bus[\"EVENT BUS\"]\n        direction TB\n        events[\"Events\"]\n        routing[\"Event Routing\"]\n    end\n\n    subgraph Handler[\"EVENT HANDLERS\"]\n        direction TB\n        scanner_trigger[\"Scanner Trigger\"]\n        scanner_executor[\"Scanner Executor\"]\n    end\n\n    subgraph Results[\"RESULTS HANDLERS\"]\n        direction TB\n        notification[\"Notification Service\"]\n        storage[\"Storage Service\"]\n        remediation[\"Remediation Service\"]\n    end\n\n    Sources --&gt;|emit events to| Bus\n    Bus --&gt;|routes to| Handler\n    Handler --&gt;|produces| Results\n    container_deploy --&gt;|container.deployed| events\n    image_publish --&gt;|image.published| events\n    scheduled_event --&gt;|scan.scheduled| events\n    events --&gt;|matched by| routing\n    routing --&gt;|triggers| scanner_trigger\n    scanner_trigger --&gt;|initiates| scanner_executor\n    scanner_executor --&gt;|generates| notification\n    scanner_executor --&gt;|saves to| storage\n    scanner_executor --&gt;|may trigger| remediation\n\n    %% WCAG-compliant styling\n    style Sources fill:none,stroke:#0066CC,stroke-width:4px\n    style Bus fill:none,stroke:#DD6100,stroke-width:4px\n    style Handler fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style container_deploy fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style image_publish fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scheduled_event fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style events fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style routing fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_trigger fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_executor fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style notification fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style storage fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style remediation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/custom-integrations/#security-considerations","title":"Security Considerations","text":"<p>When implementing custom integrations, consider these security aspects:</p> <ol> <li>Authentication: Secure authentication mechanisms for API access</li> <li>Authorization: Proper permission controls for scanning operations</li> <li>Credential Management: Secure handling of Kubernetes credentials</li> <li>Network Security: Secure communication between components</li> <li>Result Protection: Protection of sensitive scan results</li> </ol>"},{"location":"architecture/integrations/custom-integrations/#integration-best-practices","title":"Integration Best Practices","text":"<p>Follow these best practices for custom integrations:</p> <ol> <li>Modularity: Keep integration components modular for flexibility</li> <li>Configuration: Use configuration files for environment-specific settings</li> <li>Error Handling: Implement robust error handling and reporting</li> <li>Scalability: Design for scalability to handle multiple concurrent scans</li> <li>Monitoring: Include monitoring and logging for visibility</li> <li>Documentation: Maintain clear documentation for custom integrations</li> <li>Testing: Thoroughly test integrations before production use</li> <li>Maintenance: Plan for ongoing maintenance and updates</li> </ol>"},{"location":"architecture/integrations/custom-integrations/#custom-integration-tools","title":"Custom Integration Tools","text":"<p>Several tools and libraries can help with custom integrations:</p> Tool Purpose Integration Use REST APIs Service communication Build API integrations Webhooks Event notification Trigger scans on events Message Queues Asynchronous processing Queue scan requests Docker Containerization Package scanner components Kubernetes CRDs Custom resources Define scan specifications OAuth/OIDC Authentication Secure API access OpenAPI API documentation Document integration APIs"},{"location":"architecture/integrations/custom-integrations/#additional-resources","title":"Additional Resources","text":"<p>For more information on custom integrations, see:</p> <ul> <li>Enterprise Integration Analysis</li> <li>Integration Overview</li> <li>Approach Mapping</li> </ul>"},{"location":"architecture/integrations/github-actions/","title":"GitHub Actions Integration Architecture","text":"<p>This document details the architecture for integrating the Kubernetes CINC Secure Scanner with GitHub Actions.</p>"},{"location":"architecture/integrations/github-actions/#integration-overview","title":"Integration Overview","text":"<p>GitHub Actions integration enables container scanning to be performed as part of GitHub CI/CD workflows. This allows for security validation of containers during pull requests, deployments, or scheduled scans.</p>"},{"location":"architecture/integrations/github-actions/#architectural-components","title":"Architectural Components","text":""},{"location":"architecture/integrations/github-actions/#1-github-workflow-configuration","title":"1. GitHub Workflow Configuration","text":"<p>The integration uses GitHub workflow YAML files to define the scanning process:</p> <pre><code>flowchart TD\n    subgraph Workflow[\"GITHUB WORKFLOW CONFIGURATION\"]\n        direction TB\n        workflow_file[\".github/workflows/container-scan.yml\"]\n        triggers[\"Workflow Triggers\"]\n        jobs[\"Workflow Jobs\"]\n        steps[\"Job Steps\"]\n    end\n\n    subgraph Configuration[\"SCAN CONFIGURATION\"]\n        direction TB\n        environment[\"Environment Variables\"]\n        inputs[\"Workflow Inputs\"]\n        secrets[\"GitHub Secrets\"]\n    end\n\n    Workflow --&gt;|configured by| Configuration\n\n    %% WCAG-compliant styling\n    style Workflow fill:none,stroke:#0066CC,stroke-width:4px\n    style Configuration fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Component styling\n    style workflow_file fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style triggers fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style steps fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style environment fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style inputs fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style secrets fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#2-integration-architecture","title":"2. Integration Architecture","text":"<p>The overall architecture integrates GitHub Actions with the scanning system:</p> <pre><code>flowchart TD\n    subgraph GitHub[\"GITHUB ENVIRONMENT\"]\n        direction TB\n        repo[\"GitHub Repository\"]\n        actions[\"GitHub Actions\"]\n        runner[\"GitHub Runner\"]\n    end\n\n    subgraph Setup[\"ENVIRONMENT SETUP\"]\n        direction TB\n        k8s_setup[\"Kubernetes Setup\"]\n        cinc_setup[\"CINC Auditor Setup\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Execution[\"SCAN EXECUTION\"]\n        direction TB\n        scanner[\"Container Scanner\"]\n        rbac[\"RBAC Resources\"]\n        target[\"Target Container\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        validation[\"Threshold Validation\"]\n        artifacts[\"GitHub Artifacts\"]\n        status[\"Check Status\"]\n    end\n\n    %% Component relationships\n    GitHub --&gt;|runs| Setup\n    repo --&gt;|contains| profiles\n    actions --&gt;|executes on| runner\n    runner --&gt;|prepares| Setup\n    Setup --&gt;|enables| Execution\n    k8s_setup --&gt;|provides access to| target\n    cinc_setup --&gt;|configures| scanner\n    profiles --&gt;|used by| scanner\n    Execution --&gt;|produces| Results\n    scanner --&gt;|generates| validation\n    validation --&gt;|determines| status\n    validation --&gt;|produces| artifacts\n    artifacts --&gt;|stored in| GitHub\n    status --&gt;|reported to| GitHub\n\n    %% WCAG-compliant styling\n    style GitHub fill:none,stroke:#0066CC,stroke-width:4px\n    style Setup fill:none,stroke:#DD6100,stroke-width:4px\n    style Execution fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style repo fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style actions fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style runner fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#integration-workflow","title":"Integration Workflow","text":"<p>The GitHub Actions integration follows this workflow process:</p>"},{"location":"architecture/integrations/github-actions/#1-workflow-triggering","title":"1. Workflow Triggering","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B{Trigger Type}\n    B --&gt;|Push| C1[Push to Branch]\n    B --&gt;|Pull Request| C2[PR Created/Updated]\n    B --&gt;|Schedule| C3[Scheduled Run]\n    B --&gt;|Manual| C4[Manual Trigger]\n    C1 --&gt; D[Load Workflow]\n    C2 --&gt; D\n    C3 --&gt; D\n    C4 --&gt; D\n    D --&gt; E[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C1 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C2 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C3 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C4 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#2-environment-setup","title":"2. Environment Setup","text":"<pre><code>flowchart TD\n    A[Start Setup] --&gt; B[Checkout Repository]\n    B --&gt; C[Configure Kubernetes]\n    C --&gt; D[Install CINC Auditor]\n    D --&gt; E[Prepare Security Profiles]\n    E --&gt; F[Deploy Test Container]\n    F --&gt; G[Setup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#3-scan-execution","title":"3. Scan Execution","text":"<pre><code>flowchart TD\n    A[Start Scan] --&gt; B{Container Type}\n    B --&gt;|Standard| C1[Execute Standard Scan]\n    B --&gt;|Distroless| C2[Execute Distroless Scan]\n    B --&gt;|Sidecar| C3[Execute Sidecar Scan]\n    C1 --&gt; D[Collect Scan Results]\n    C2 --&gt; D\n    C3 --&gt; D\n    D --&gt; E[Scan Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C2 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C3 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#4-results-processing","title":"4. Results Processing","text":"<pre><code>flowchart TD\n    A[Start Processing] --&gt; B[Process with SAF CLI]\n    B --&gt; C[Validate Against Thresholds]\n    C --&gt; D{Thresholds Met?}\n    D --&gt;|Yes| E1[Set Success Status]\n    D --&gt;|No| E2[Set Failure Status]\n    E1 --&gt; F[Upload Artifacts]\n    E2 --&gt; F\n    F --&gt; G[Processing Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#example-github-actions-workflow","title":"Example GitHub Actions Workflow","text":"<pre><code>name: Kubernetes Container Security Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly on Sundays at midnight\n\njobs:\n  container-scan:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Repository\n      uses: actions/checkout@v2\n\n    - name: Set up Kubernetes\n      uses: helm/kind-action@v1.2.0\n\n    - name: Set up CINC Auditor\n      run: |\n        curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n\n    - name: Deploy Test Container\n      run: |\n        kubectl apply -f test-pod.yaml\n        kubectl wait --for=condition=Ready pod/test-pod --timeout=60s\n\n    - name: Scan Standard Container\n      run: |\n        ./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n\n    - name: Process Results\n      run: |\n        if [ -f \"results/summary.json\" ]; then\n          FAILURES=$(jq '.failure_count' results/summary.json)\n          if [ \"$FAILURES\" -gt 0 ]; then\n            echo \"::error::Security scan failed with $FAILURES failures\"\n            exit 1\n          else\n            echo \"::notice::Security scan passed\"\n          fi\n        else\n          echo \"::error::Results file not found\"\n          exit 1\n        fi\n\n    - name: Upload Scan Results\n      uses: actions/upload-artifact@v2\n      with:\n        name: security-scan-results\n        path: results/\n</code></pre>"},{"location":"architecture/integrations/github-actions/#github-specific-integration-features","title":"GitHub-Specific Integration Features","text":""},{"location":"architecture/integrations/github-actions/#1-status-checks","title":"1. Status Checks","text":"<p>GitHub Actions integration allows for status checks on pull requests:</p> <pre><code>flowchart TD\n    A[PR Created/Updated] --&gt; B[GitHub Action Triggered]\n    B --&gt; C[Container Scan Executed]\n    C --&gt; D[Results Evaluated]\n    D --&gt;|Success| E1[Green Check Mark]\n    D --&gt;|Failure| E2[Red X Mark]\n    E1 --&gt; F1[PR Can Be Merged]\n    E2 --&gt; F2[PR Blocked]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#2-workflow-matrices","title":"2. Workflow Matrices","text":"<p>Complex scanning configurations can utilize workflow matrices:</p> <pre><code>jobs:\n  scan-matrix:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        container-type: [standard, distroless, sidecar]\n        profile: [container-baseline, container-cis]\n\n    steps:\n    # Setup steps...\n\n    - name: Scan Container\n      run: |\n        case \"${{ matrix.container-type }}\" in\n          standard)\n            ./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/${{ matrix.profile }}\n            ;;\n          distroless)\n            ./kubernetes-scripts/scan-distroless-container.sh default distroless-pod distroless-container examples/cinc-profiles/${{ matrix.profile }}\n            ;;\n          sidecar)\n            ./kubernetes-scripts/scan-with-sidecar.sh default target-pod examples/cinc-profiles/${{ matrix.profile }}\n            ;;\n        esac\n</code></pre>"},{"location":"architecture/integrations/github-actions/#3-github-security-features","title":"3. GitHub Security Features","text":"<p>Integration with GitHub security features:</p> <pre><code>flowchart TD\n    A[Container Scan] --&gt; B[Generate SARIF]\n    B --&gt; C[Upload to GitHub]\n    C --&gt; D[GitHub Security Tab]\n    C --&gt; E[Code Scanning Alerts]\n    C --&gt; F[Security Overview]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#security-considerations","title":"Security Considerations","text":"<p>The GitHub Actions integration implements these security measures:</p> <ol> <li>Secret Management: Kubernetes credentials stored as GitHub Secrets</li> <li>Runner Isolation: Scans run in isolated GitHub Runners</li> <li>Temporary Resources: All resources created during workflow are temporary</li> <li>Limited Scope: Workflow has access only to what is necessary</li> <li>Artifact Protection: Scan results stored as protected artifacts</li> </ol>"},{"location":"architecture/integrations/github-actions/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/integrations/github-actions/#1-standard-pattern","title":"1. Standard Pattern","text":"<p>Direct execution of scanning scripts in GitHub Actions:</p> <pre><code>flowchart LR\n    A[GitHub Actions] --&gt;|executes| B[Scanning Scripts]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#2-container-pattern","title":"2. Container Pattern","text":"<p>Using containerized scanners in GitHub Actions:</p> <pre><code>flowchart LR\n    A[GitHub Actions] --&gt;|runs| B[Scanner Container]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#3-reusable-workflow-pattern","title":"3. Reusable Workflow Pattern","text":"<p>Using reusable workflows for standardized scanning:</p> <pre><code>flowchart LR\n    A[Main Workflow] --&gt;|calls| B[Reusable Scan Workflow]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/github-actions/#additional-resources","title":"Additional Resources","text":"<p>For more detailed GitHub Actions examples, see:</p> <ul> <li>GitHub Workflow Examples</li> <li>CI/CD Pipeline Example</li> <li>Setup and Scan Example</li> <li>Sidecar Scanner Example</li> <li>Dynamic RBAC Scanning Example</li> <li>Existing Cluster Scanning Example</li> </ul>"},{"location":"architecture/integrations/gitlab-ci/","title":"GitLab CI Integration Architecture","text":"<p>This document details the architecture for integrating the Kubernetes CINC Secure Scanner with GitLab CI pipelines.</p>"},{"location":"architecture/integrations/gitlab-ci/#integration-overview","title":"Integration Overview","text":"<p>GitLab CI integration enables container scanning to be performed as part of GitLab CI/CD pipelines. This allows for security validation of containers during merge requests, deployments, or scheduled scans.</p>"},{"location":"architecture/integrations/gitlab-ci/#architectural-components","title":"Architectural Components","text":""},{"location":"architecture/integrations/gitlab-ci/#1-gitlab-ci-configuration","title":"1. GitLab CI Configuration","text":"<p>The integration uses GitLab CI configuration files to define the scanning process:</p> <pre><code>flowchart TD\n    subgraph Configuration[\"GITLAB CI CONFIGURATION\"]\n        direction TB\n        ci_file[\".gitlab-ci.yml\"]\n        stages[\"Pipeline Stages\"]\n        jobs[\"Pipeline Jobs\"]\n        scripts[\"Job Scripts\"]\n    end\n\n    subgraph Settings[\"PIPELINE SETTINGS\"]\n        direction TB\n        variables[\"CI/CD Variables\"]\n        triggers[\"Pipeline Triggers\"]\n        schedules[\"Pipeline Schedules\"]\n    end\n\n    Configuration --&gt;|configured by| Settings\n\n    %% WCAG-compliant styling\n    style Configuration fill:none,stroke:#0066CC,stroke-width:4px\n    style Settings fill:none,stroke:#DD6100,stroke-width:4px\n\n    %% Component styling\n    style ci_file fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style stages fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style variables fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style triggers fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style schedules fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#2-integration-architecture","title":"2. Integration Architecture","text":"<p>The overall architecture integrates GitLab CI with the scanning system:</p> <pre><code>flowchart TD\n    subgraph GitLab[\"GITLAB ENVIRONMENT\"]\n        direction TB\n        repo[\"GitLab Repository\"]\n        ci[\"GitLab CI\"]\n        runner[\"GitLab Runner\"]\n    end\n\n    subgraph Setup[\"ENVIRONMENT SETUP\"]\n        direction TB\n        k8s_setup[\"Kubernetes Setup\"]\n        cinc_setup[\"CINC Auditor Setup\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Execution[\"SCAN EXECUTION\"]\n        direction TB\n        scanner[\"Container Scanner\"]\n        rbac[\"RBAC Resources\"]\n        target[\"Target Container\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        validation[\"Threshold Validation\"]\n        artifacts[\"Job Artifacts\"]\n        status[\"Job Status\"]\n    end\n\n    %% Component relationships\n    GitLab --&gt;|runs| Setup\n    repo --&gt;|contains| profiles\n    ci --&gt;|executes on| runner\n    runner --&gt;|prepares| Setup\n    Setup --&gt;|enables| Execution\n    k8s_setup --&gt;|provides access to| target\n    cinc_setup --&gt;|configures| scanner\n    profiles --&gt;|used by| scanner\n    Execution --&gt;|produces| Results\n    scanner --&gt;|generates| validation\n    validation --&gt;|determines| status\n    validation --&gt;|produces| artifacts\n    artifacts --&gt;|stored in| GitLab\n    status --&gt;|reported to| GitLab\n\n    %% WCAG-compliant styling\n    style GitLab fill:none,stroke:#0066CC,stroke-width:4px\n    style Setup fill:none,stroke:#DD6100,stroke-width:4px\n    style Execution fill:none,stroke:#217645,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style repo fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ci fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style runner fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style k8s_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc_setup fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style artifacts fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style status fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#integration-workflow","title":"Integration Workflow","text":"<p>The GitLab CI integration follows this workflow process:</p>"},{"location":"architecture/integrations/gitlab-ci/#1-pipeline-triggering","title":"1. Pipeline Triggering","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B{Trigger Type}\n    B --&gt;|Push| C1[Push to Branch]\n    B --&gt;|Merge Request| C2[MR Created/Updated]\n    B --&gt;|Schedule| C3[Scheduled Run]\n    B --&gt;|Manual| C4[Manual Trigger]\n    C1 --&gt; D[Load Pipeline]\n    C2 --&gt; D\n    C3 --&gt; D\n    C4 --&gt; D\n    D --&gt; E[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C1 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C2 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C3 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C4 fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#2-environment-setup","title":"2. Environment Setup","text":"<pre><code>flowchart TD\n    A[Start Setup] --&gt; B[Clone Repository]\n    B --&gt; C[Configure Kubernetes]\n    C --&gt; D[Install CINC Auditor]\n    D --&gt; E[Prepare Security Profiles]\n    E --&gt; F[Deploy Test Container]\n    F --&gt; G[Setup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#3-scan-execution","title":"3. Scan Execution","text":"<pre><code>flowchart TD\n    A[Start Scan] --&gt; B{Container Type}\n    B --&gt;|Standard| C1[Execute Standard Scan]\n    B --&gt;|Distroless| C2[Execute Distroless Scan]\n    B --&gt;|Sidecar| C3[Execute Sidecar Scan]\n    C1 --&gt; D[Collect Scan Results]\n    C2 --&gt; D\n    C3 --&gt; D\n    D --&gt; E[Scan Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C2 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C3 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#4-results-processing","title":"4. Results Processing","text":"<pre><code>flowchart TD\n    A[Start Processing] --&gt; B[Process with SAF CLI]\n    B --&gt; C[Validate Against Thresholds]\n    C --&gt; D{Thresholds Met?}\n    D --&gt;|Yes| E1[Set Success Status]\n    D --&gt;|No| E2[Set Failure Status]\n    E1 --&gt; F[Archive Artifacts]\n    E2 --&gt; F\n    F --&gt; G[Processing Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#example-gitlab-ci-configuration","title":"Example GitLab CI Configuration","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - validate\n\nvariables:\n  KUBE_CONTEXT: my-kubernetes-context\n  TARGET_NAMESPACE: default\n  TARGET_POD: web-app\n  TARGET_CONTAINER: web-container\n  PROFILE_PATH: examples/cinc-profiles/container-baseline\n  THRESHOLD_FILE: examples/thresholds/moderate.yml\n\n.setup_cinc: &amp;setup_cinc\n  - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P auditor\n  - cinc-auditor --version\n\ndeploy-test-container:\n  stage: deploy\n  script:\n    - kubectl --context $KUBE_CONTEXT apply -f test-pod.yaml\n    - kubectl --context $KUBE_CONTEXT wait --for=condition=Ready pod/$TARGET_POD --timeout=60s\n\nscan-container:\n  stage: scan\n  before_script:\n    - *setup_cinc\n  script:\n    - ./kubernetes-scripts/scan-container.sh $TARGET_NAMESPACE $TARGET_POD $TARGET_CONTAINER $PROFILE_PATH\n  artifacts:\n    paths:\n      - results/\n    expire_in: 1 week\n\nvalidate-results:\n  stage: validate\n  script:\n    - if [ ! -f \"results/summary.json\" ]; then echo \"Results file missing\"; exit 1; fi\n    - FAILURES=$(jq '.failure_count' results/summary.json)\n    - if [ \"$FAILURES\" -gt 0 ]; then\n        echo \"Security scan failed with $FAILURES failures\";\n        exit 1;\n      else\n        echo \"Security scan passed\";\n      fi\n  dependencies:\n    - scan-container\n</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#gitlab-specific-integration-features","title":"GitLab-Specific Integration Features","text":""},{"location":"architecture/integrations/gitlab-ci/#1-merge-request-status","title":"1. Merge Request Status","text":"<p>GitLab CI integration provides status checks on merge requests:</p> <pre><code>flowchart TD\n    A[MR Created/Updated] --&gt; B[GitLab Pipeline Triggered]\n    B --&gt; C[Container Scan Executed]\n    C --&gt; D[Results Evaluated]\n    D --&gt;|Success| E1[Green Check Mark]\n    D --&gt;|Failure| E2[Red X Mark]\n    E1 --&gt; F1[MR Can Be Merged]\n    E2 --&gt; F2[MR Blocked]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#2-pipeline-matrix","title":"2. Pipeline Matrix","text":"<p>Using GitLab's parallel matrix feature for complex scanning:</p> <pre><code>scan-matrix:\n  stage: scan\n  parallel:\n    matrix:\n      - CONTAINER_TYPE: [standard, distroless, sidecar]\n        PROFILE: [container-baseline, container-cis]\n  script:\n    - |\n      case \"$CONTAINER_TYPE\" in\n        standard)\n          ./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/$PROFILE\n          ;;\n        distroless)\n          ./kubernetes-scripts/scan-distroless-container.sh default distroless-pod distroless-container examples/cinc-profiles/$PROFILE\n          ;;\n        sidecar)\n          ./kubernetes-scripts/scan-with-sidecar.sh default target-pod examples/cinc-profiles/$PROFILE\n          ;;\n      esac\n</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#3-gitlab-security-dashboard","title":"3. GitLab Security Dashboard","text":"<p>Integration with GitLab security features:</p> <pre><code>flowchart TD\n    A[Container Scan] --&gt; B[Generate GitLab Security Report]\n    B --&gt; C[Submit to GitLab API]\n    C --&gt; D[Security Dashboard]\n    C --&gt; E[Vulnerability Report]\n    C --&gt; F[Compliance Dashboard]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#security-considerations","title":"Security Considerations","text":"<p>The GitLab CI integration implements these security measures:</p> <ol> <li>Secret Management: Kubernetes credentials stored as GitLab CI/CD Variables</li> <li>Runner Isolation: Scans run in isolated GitLab Runners</li> <li>Temporary Resources: All resources created during pipeline are temporary</li> <li>Limited Scope: Pipeline has access only to what is necessary</li> <li>Artifact Protection: Scan results stored as protected artifacts</li> </ol>"},{"location":"architecture/integrations/gitlab-ci/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/integrations/gitlab-ci/#1-standard-pattern","title":"1. Standard Pattern","text":"<p>Direct execution of scanning scripts in GitLab CI:</p> <pre><code>flowchart LR\n    A[GitLab CI] --&gt;|executes| B[Scanning Scripts]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#2-docker-executor-pattern","title":"2. Docker Executor Pattern","text":"<p>Using GitLab's Docker executor for containerized scanning:</p> <pre><code>flowchart LR\n    A[GitLab CI] --&gt;|runs| B[Scanner Container]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#3-include-pattern","title":"3. Include Pattern","text":"<p>Using GitLab's include feature for reusable scanning configurations:</p> <pre><code>flowchart LR\n    A[Main CI File] --&gt;|includes| B[Scanner CI Template]\n    B --&gt;|scan| C[Kubernetes]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-ci/#additional-resources","title":"Additional Resources","text":"<p>For more detailed GitLab CI examples, see:</p> <ul> <li>GitLab Pipeline Examples</li> <li>GitLab CI Example</li> <li>GitLab CI with Services Example</li> <li>GitLab CI Sidecar Example</li> <li>Dynamic RBAC Scanning Example</li> <li>Existing Cluster Scanning Example</li> </ul>"},{"location":"architecture/integrations/gitlab-services/","title":"GitLab Services Integration Architecture","text":"<p>This document details the architecture for integrating the Kubernetes CINC Secure Scanner with GitLab CI using the services approach.</p>"},{"location":"architecture/integrations/gitlab-services/#integration-overview","title":"Integration Overview","text":"<p>The GitLab Services integration uses GitLab's services feature to run the scanning components as separate services alongside the main CI/CD pipeline. This provides better isolation and reusability compared to the standard GitLab CI approach.</p>"},{"location":"architecture/integrations/gitlab-services/#architectural-components","title":"Architectural Components","text":""},{"location":"architecture/integrations/gitlab-services/#1-gitlab-services","title":"1. GitLab Services","text":"<p>The integration defines several services to support scanning:</p> <pre><code>flowchart TD\n    subgraph Services[\"GITLAB SERVICES\"]\n        direction TB\n        cinc_service[\"CINC Auditor Service\"]\n        saf_service[\"SAF CLI Service\"]\n        scanner_service[\"Container Scanner Service\"]\n    end\n\n    subgraph Interfaces[\"SERVICE INTERFACES\"]\n        direction TB\n        volumes[\"Shared Volumes\"]\n        network[\"Service Network\"]\n        aliases[\"Service Aliases\"]\n    end\n\n    subgraph Interaction[\"SERVICE INTERACTION\"]\n        direction TB\n        execution[\"Command Execution\"]\n        communication[\"Inter-service Communication\"]\n        result_sharing[\"Result Sharing\"]\n    end\n\n    Services --&gt;|connected via| Interfaces\n    Services --&gt;|perform| Interaction\n\n    %% WCAG-compliant styling\n    style Services fill:none,stroke:#0066CC,stroke-width:4px\n    style Interfaces fill:none,stroke:#DD6100,stroke-width:4px\n    style Interaction fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style cinc_service fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf_service fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner_service fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style volumes fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style network fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style aliases fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style execution fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style communication fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style result_sharing fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#2-integration-architecture","title":"2. Integration Architecture","text":"<p>The overall architecture integrates GitLab services with the scanning system:</p> <pre><code>flowchart TD\n    subgraph GitLab[\"GITLAB ENVIRONMENT\"]\n        direction TB\n        pipeline[\".gitlab-ci.yml\"]\n        jobs[\"Pipeline Jobs\"]\n        services[\"Service Definitions\"]\n    end\n\n    subgraph Services[\"SCANNER SERVICES\"]\n        direction TB\n        cinc[\"CINC Auditor Container\"]\n        saf[\"SAF CLI Container\"]\n        scanner[\"Scanner Container\"]\n    end\n\n    subgraph Kubernetes[\"KUBERNETES ENVIRONMENT\"]\n        direction TB\n        api[\"Kubernetes API\"]\n        rbac[\"RBAC Resources\"]\n        target[\"Target Containers\"]\n    end\n\n    subgraph Results[\"RESULTS PROCESSING\"]\n        direction TB\n        collection[\"Result Collection\"]\n        validation[\"Threshold Validation\"]\n        reporting[\"Result Reporting\"]\n    end\n\n    %% Component relationships\n    GitLab --&gt;|defines| Services\n    pipeline --&gt;|configures| services\n    jobs --&gt;|interact with| Services\n    Services --&gt;|access| Kubernetes\n    scanner --&gt;|creates| rbac\n    cinc --&gt;|scans| target\n    scanner --&gt;|configures| api\n    Services --&gt;|produce| Results\n    cinc --&gt;|generates| collection\n    saf --&gt;|performs| validation\n    validation --&gt;|creates| reporting\n    reporting --&gt;|sent to| GitLab\n\n    %% WCAG-compliant styling\n    style GitLab fill:none,stroke:#0066CC,stroke-width:4px\n    style Services fill:none,stroke:#DD6100,stroke-width:4px\n    style Kubernetes fill:none,stroke:#505050,stroke-width:4px\n    style Results fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style pipeline fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style jobs fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style services fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style cinc fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scanner fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style api fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style collection fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reporting fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#service-components","title":"Service Components","text":""},{"location":"architecture/integrations/gitlab-services/#1-cinc-auditor-service","title":"1. CINC Auditor Service","text":"<pre><code>flowchart TD\n    subgraph CINCService[\"CINC AUDITOR SERVICE\"]\n        direction TB\n        cinc_image[\"Container Image\"]\n        inspec_core[\"InSpec Core\"]\n        transport[\"Transport Plugins\"]\n        profiles[\"Security Profiles\"]\n    end\n\n    subgraph Interface[\"SERVICE INTERFACE\"]\n        direction TB\n        commands[\"Command Interface\"]\n        volume_mounts[\"Volume Mounts\"]\n        network[\"Service Network\"]\n    end\n\n    subgraph Functions[\"SERVICE FUNCTIONS\"]\n        direction TB\n        execution[\"Profile Execution\"]\n        result_generation[\"Result Generation\"]\n        filesystem_access[\"Filesystem Access\"]\n    end\n\n    CINCService --&gt;|exposes| Interface\n    CINCService --&gt;|performs| Functions\n\n    %% WCAG-compliant styling\n    style CINCService fill:none,stroke:#DD6100,stroke-width:4px\n    style Interface fill:none,stroke:#0066CC,stroke-width:4px\n    style Functions fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style cinc_image fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style inspec_core fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style transport fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style profiles fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style commands fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style volume_mounts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style network fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style execution fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style result_generation fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style filesystem_access fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#2-saf-cli-service","title":"2. SAF CLI Service","text":"<pre><code>flowchart TD\n    subgraph SAFService[\"SAF CLI SERVICE\"]\n        direction TB\n        saf_image[\"Container Image\"]\n        saf_cli[\"SAF CLI Tool\"]\n        ruby_runtime[\"Ruby Runtime\"]\n        threshold_configs[\"Threshold Configurations\"]\n    end\n\n    subgraph Interface[\"SERVICE INTERFACE\"]\n        direction TB\n        commands[\"Command Interface\"]\n        volume_mounts[\"Volume Mounts\"]\n        network[\"Service Network\"]\n    end\n\n    subgraph Functions[\"SERVICE FUNCTIONS\"]\n        direction TB\n        validation[\"Threshold Validation\"]\n        reporting[\"Report Generation\"]\n        conversion[\"Format Conversion\"]\n    end\n\n    SAFService --&gt;|exposes| Interface\n    SAFService --&gt;|performs| Functions\n\n    %% WCAG-compliant styling\n    style SAFService fill:none,stroke:#DD6100,stroke-width:4px\n    style Interface fill:none,stroke:#0066CC,stroke-width:4px\n    style Functions fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style saf_image fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style saf_cli fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ruby_runtime fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style threshold_configs fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style commands fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style volume_mounts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style network fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style validation fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style reporting fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style conversion fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#3-scanner-service","title":"3. Scanner Service","text":"<pre><code>flowchart TD\n    subgraph ScannerService[\"SCANNER SERVICE\"]\n        direction TB\n        scanner_image[\"Container Image\"]\n        kubectl[\"Kubectl Tool\"]\n        scripts[\"Scanner Scripts\"]\n        kubernetes_tools[\"Kubernetes Tools\"]\n    end\n\n    subgraph Interface[\"SERVICE INTERFACE\"]\n        direction TB\n        commands[\"Command Interface\"]\n        volume_mounts[\"Volume Mounts\"]\n        network[\"Service Network\"]\n    end\n\n    subgraph Functions[\"SERVICE FUNCTIONS\"]\n        direction TB\n        rbac_creation[\"RBAC Creation\"]\n        kubeconfig[\"Kubeconfig Generation\"]\n        scan_orchestration[\"Scan Orchestration\"]\n    end\n\n    ScannerService --&gt;|exposes| Interface\n    ScannerService --&gt;|performs| Functions\n\n    %% WCAG-compliant styling\n    style ScannerService fill:none,stroke:#DD6100,stroke-width:4px\n    style Interface fill:none,stroke:#0066CC,stroke-width:4px\n    style Functions fill:none,stroke:#217645,stroke-width:4px\n\n    %% Component styling\n    style scanner_image fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubectl fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scripts fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubernetes_tools fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style commands fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style volume_mounts fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style network fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style rbac_creation fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style kubeconfig fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style scan_orchestration fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#integration-workflow","title":"Integration Workflow","text":"<p>The GitLab Services integration follows this workflow process:</p>"},{"location":"architecture/integrations/gitlab-services/#1-service-initialization","title":"1. Service Initialization","text":"<pre><code>flowchart TD\n    A[Start Pipeline] --&gt; B[Start Services]\n    B --&gt; C1[Initialize CINC Auditor Service]\n    B --&gt; C2[Initialize SAF CLI Service]\n    B --&gt; C3[Initialize Scanner Service]\n    C1 --&gt; D[Services Ready]\n    C2 --&gt; D\n    C3 --&gt; D\n    D --&gt; E[Start Pipeline Jobs]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C1 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C3 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#2-scan-execution","title":"2. Scan Execution","text":"<pre><code>flowchart TD\n    A[Start Scan Job] --&gt; B[Prepare Kubernetes Access]\n    B --&gt; C[Deploy Target Container]\n    C --&gt; D[Create RBAC Resources]\n    D --&gt; E[Execute Scan Command]\n    E --&gt; F1[CINC Auditor Service Runs]\n    F1 --&gt; G[Collect Scan Results]\n    G --&gt; H[Store Results in Shared Volume]\n    H --&gt; I[Scan Job Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F1 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#3-results-processing","title":"3. Results Processing","text":"<pre><code>flowchart TD\n    A[Start Validation Job] --&gt; B[Retrieve Results from Volume]\n    B --&gt; C[Execute SAF CLI Command]\n    C --&gt; D[SAF CLI Service Runs]\n    D --&gt; E[Validate Against Thresholds]\n    E --&gt; F{Thresholds Met?}\n    F --&gt;|Yes| G1[Set Success Status]\n    F --&gt;|No| G2[Set Failure Status]\n    G1 --&gt; H[Archive Results as Artifacts]\n    G2 --&gt; H\n    H --&gt; I[Validation Job Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G1 fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G2 fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#example-gitlab-ci-with-services-configuration","title":"Example GitLab CI with Services Configuration","text":"<pre><code>services:\n  - name: registry.example.com/cinc-auditor:latest\n    alias: cinc\n  - name: registry.example.com/saf-cli:latest\n    alias: saf\n  - name: registry.example.com/kubernetes-scanner:latest\n    alias: scanner\n\nvariables:\n  KUBE_CONFIG: ${CI_PROJECT_DIR}/.kube/config\n  RESULTS_DIR: ${CI_PROJECT_DIR}/results\n  PROFILE_PATH: /profiles/container-baseline\n  THRESHOLD_FILE: /thresholds/moderate.yml\n\nstages:\n  - setup\n  - scan\n  - validate\n\nprepare-environment:\n  stage: setup\n  script:\n    - mkdir -p ${CI_PROJECT_DIR}/.kube\n    - echo \"${KUBECONFIG_CONTENT}\" &gt; ${KUBE_CONFIG}\n    - chmod 600 ${KUBE_CONFIG}\n    - mkdir -p ${RESULTS_DIR}\n    - scanner setup-environment\n\nscan-container:\n  stage: scan\n  script:\n    - scanner deploy-test-container\n    - |\n      cinc exec -t k8s-container://default/test-pod/test-container \\\n        --input ${PROFILE_PATH} \\\n        --reporter json:${RESULTS_DIR}/results.json\n  artifacts:\n    paths:\n      - ${RESULTS_DIR}/\n\nvalidate-results:\n  stage: validate\n  script:\n    - |\n      saf validate ${RESULTS_DIR}/results.json \\\n        -c ${THRESHOLD_FILE} \\\n        --reporter json:${RESULTS_DIR}/validation.json\n    - |\n      if grep -q '\"status\":\"failed\"' ${RESULTS_DIR}/validation.json; then\n        echo \"Security validation failed\"\n        exit 1\n      else\n        echo \"Security validation passed\"\n      fi\n  dependencies:\n    - scan-container\n</code></pre>"},{"location":"architecture/integrations/gitlab-services/#service-communication-architecture","title":"Service Communication Architecture","text":"<p>The services communicate with each other and with the GitLab jobs through several mechanisms:</p> <pre><code>flowchart TD\n    subgraph CI[\"GITLAB CI JOB\"]\n        direction TB\n        job_script[\"Job Script\"]\n        environment[\"Environment Variables\"]\n    end\n\n    subgraph Network[\"SERVICE NETWORK\"]\n        direction TB\n        dns[\"Service DNS\"]\n        ports[\"Service Ports\"]\n    end\n\n    subgraph Volumes[\"SHARED VOLUMES\"]\n        direction TB\n        results_volume[\"Results Volume\"]\n        config_volume[\"Configuration Volume\"]\n    end\n\n    subgraph Commands[\"COMMAND EXECUTION\"]\n        direction TB\n        direct_command[\"Direct Command\"]\n        service_command[\"Service-specific Command\"]\n    end\n\n    CI --&gt;|uses| Network\n    CI --&gt;|accesses| Volumes\n    CI --&gt;|executes| Commands\n\n    job_script --&gt;|references service by| dns\n    job_script --&gt;|reads/writes to| results_volume\n    environment --&gt;|configures| config_volume\n    job_script --&gt;|runs| direct_command\n    direct_command --&gt;|executes in| service_command\n\n    %% WCAG-compliant styling\n    style CI fill:none,stroke:#0066CC,stroke-width:4px\n    style Network fill:none,stroke:#DD6100,stroke-width:4px\n    style Volumes fill:none,stroke:#217645,stroke-width:4px\n    style Commands fill:none,stroke:#4C366B,stroke-width:4px\n\n    %% Component styling\n    style job_script fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style environment fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style dns fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style ports fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style results_volume fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style config_volume fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style direct_command fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style service_command fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#security-considerations","title":"Security Considerations","text":"<p>The GitLab Services integration implements these security measures:</p> <ol> <li>Service Isolation: Each component runs in an isolated container</li> <li>Reduced Attack Surface: Services only expose necessary interfaces</li> <li>Shared Volume Security: Volumes have appropriate permissions</li> <li>Service Network Isolation: Services only communicate with each other</li> <li>Command Validation: Input validation for service commands</li> </ol>"},{"location":"architecture/integrations/gitlab-services/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/integrations/gitlab-services/#1-direct-service-execution","title":"1. Direct Service Execution","text":"<p>Running commands directly in the service containers:</p> <pre><code>flowchart LR\n    A[GitLab Job] --&gt;|\"cinc exec ...\"| B[CINC Service]\n    B --&gt;|executes| C[Scan]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#2-service-orchestration","title":"2. Service Orchestration","text":"<p>Using the scanner service to orchestrate operations:</p> <pre><code>flowchart LR\n    A[GitLab Job] --&gt;|\"scanner scan\"| B[Scanner Service]\n    B --&gt;|coordinates| C[CINC Service]\n    B --&gt;|coordinates| D[SAF Service]\n\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#3-shared-volume-communication","title":"3. Shared Volume Communication","text":"<p>Services communicate through shared volumes:</p> <pre><code>flowchart LR\n    A[CINC Service] --&gt;|writes to| B[Shared Volume]\n    C[SAF Service] --&gt;|reads from| B\n\n    style A fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/integrations/gitlab-services/#service-configuration","title":"Service Configuration","text":""},{"location":"architecture/integrations/gitlab-services/#cinc-auditor-service","title":"CINC Auditor Service","text":"<pre><code>FROM ruby:2.7-alpine\n\nRUN apk add --no-cache build-base libxml2-dev libxslt-dev\nRUN gem install cinc-auditor-bin -v 4.38.9\n\nWORKDIR /workspace\n\nENTRYPOINT [\"cinc-auditor\"]\nCMD [\"--help\"]\n</code></pre>"},{"location":"architecture/integrations/gitlab-services/#saf-cli-service","title":"SAF CLI Service","text":"<pre><code>FROM ruby:2.7-alpine\n\nRUN apk add --no-cache build-base git\nRUN gem install saf -v 1.1.0\n\nWORKDIR /workspace\n\nENTRYPOINT [\"saf\"]\nCMD [\"--help\"]\n</code></pre>"},{"location":"architecture/integrations/gitlab-services/#scanner-service","title":"Scanner Service","text":"<pre><code>FROM alpine:3.14\n\nRUN apk add --no-cache curl bash jq\n\n# Install kubectl\nRUN curl -LO \"https://dl.k8s.io/release/v1.23.0/bin/linux/amd64/kubectl\" &amp;&amp; \\\n    chmod +x kubectl &amp;&amp; \\\n    mv kubectl /usr/local/bin/\n\nCOPY scripts/ /usr/local/bin/\n\nWORKDIR /workspace\n\nENTRYPOINT [\"/bin/bash\"]\nCMD [\"--help\"]\n</code></pre>"},{"location":"architecture/integrations/gitlab-services/#additional-resources","title":"Additional Resources","text":"<p>For more detailed GitLab Services examples, see:</p> <ul> <li>GitLab Services Examples</li> <li>GitLab CI with Services Example</li> <li>GitLab CI Sidecar with Services Example</li> </ul>"},{"location":"architecture/integrations/inventory/","title":"Integrations Documentation Inventory","text":"<p>This directory contains documentation about the CI/CD integration architecture for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/integrations/inventory/#contents","title":"Contents","text":"<ul> <li>GitHub Actions Integration - Architecture for GitHub Actions integration</li> <li>GitLab CI Integration - Architecture for GitLab CI integration</li> <li>GitLab Services Integration - Architecture for GitLab Services integration</li> <li>Custom Integrations - Architecture for other CI/CD integrations</li> </ul>"},{"location":"architecture/integrations/inventory/#overview","title":"Overview","text":"<p>The integrations documentation provides detailed information about how the scanning system integrates with various CI/CD platforms and external systems. This helps users understand how to implement container scanning as part of their continuous integration and deployment workflows.</p> <p>Each integration document outlines the architecture specific to a particular CI/CD platform, including configuration patterns, workflow designs, and best practices for implementation.</p>"},{"location":"architecture/workflows/","title":"Architecture Workflow Processes","text":"<p>This section provides detailed information about the workflow processes for the Kubernetes CINC Secure Scanner.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Workflows Documentation Inventory.</p>"},{"location":"architecture/workflows/#workflow-overview","title":"Workflow Overview","text":"<p>The scanner supports several workflow processes to accommodate different container types and scanning requirements:</p> <ol> <li>Standard Container Workflow - For containers with a shell and common utilities</li> <li>Distroless Container Workflow - For minimal containers without a shell</li> <li>Sidecar Container Workflow - Using a sidecar container with shared process namespace</li> <li>Security-Focused Workflows - Workflows with enhanced security controls</li> </ol>"},{"location":"architecture/workflows/#common-workflow-steps","title":"Common Workflow Steps","text":"<p>While the specific implementations differ, all workflows follow these general steps:</p> <ol> <li>Setup Phase: Create necessary Kubernetes resources and security controls</li> <li>Access Phase: Establish secure access to the target container</li> <li>Scanning Phase: Execute CINC Auditor against the target</li> <li>Reporting Phase: Process and validate scan results</li> <li>Cleanup Phase: Remove temporary resources and credentials</li> </ol>"},{"location":"architecture/workflows/#workflow-documentation","title":"Workflow Documentation","text":"<p>For detailed information about specific workflows, see these documents:</p> <ul> <li>Standard Container Workflow - For standard containers with a shell</li> <li>Distroless Container Workflow - For minimal containers without a shell</li> <li>Sidecar Container Workflow - Using a sidecar container approach</li> <li>Security Workflows - Security-focused scanning workflows</li> </ul>"},{"location":"architecture/workflows/#standard-workflow-diagram","title":"Standard Workflow Diagram","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Run CINC Auditor Scan]\n    E --&gt; F[Generate Reports]\n    F --&gt; G[Validate Against Thresholds]\n    G --&gt; H[Cleanup Resources]\n    H --&gt; I[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n    style G fill:#bfb,stroke:#333,stroke-width:2px\n    style I fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Component Architecture to understand the system components</li> <li>See Diagram Visualizations for detailed workflow diagrams</li> <li>Review Deployment Options for different deployment architectures</li> </ul>"},{"location":"architecture/workflows/distroless-container/","title":"Distroless Container Workflow","text":"<p>This document details the workflow for scanning distroless containers, which are minimal containers without a shell or common utilities.</p>"},{"location":"architecture/workflows/distroless-container/#workflow-overview","title":"Workflow Overview","text":"<p>The distroless container workflow uses a debug container approach to access containers that lack a shell or common utilities. It employs ephemeral debug containers with chroot to scan the target container's filesystem.</p>"},{"location":"architecture/workflows/distroless-container/#detailed-workflow-steps","title":"Detailed Workflow Steps","text":""},{"location":"architecture/workflows/distroless-container/#1-setup-phase","title":"1. Setup Phase","text":"<pre><code>flowchart TD\n    A[Start Setup] --&gt; B[Identify Distroless Target Container]\n    B --&gt; C[Create Service Account]\n    C --&gt; D[Apply Extended RBAC]\n    D --&gt; E[Generate Short-lived Token]\n    E --&gt; F[Create Restricted Kubeconfig]\n    F --&gt; G[Setup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/distroless-container/#setup-tasks","title":"Setup Tasks","text":"<ol> <li>Identify Target Container:</li> <li>Namespace, pod name, and container name are identified</li> <li>Container status verified to ensure it's running</li> <li> <p>Container verified as distroless or minimal</p> </li> <li> <p>Create Service Account:</p> </li> <li>Temporary service account created in target namespace</li> <li> <p>Account is marked for cleanup after scan completion</p> </li> <li> <p>Apply Extended RBAC:</p> </li> <li>Role created with permissions for:<ul> <li><code>pods/exec</code> permission for target pod</li> <li><code>pods/ephemeralcontainers</code> permission for debug container</li> <li><code>pods</code> GET permission for target pod</li> </ul> </li> <li> <p>RoleBinding created to link service account to role</p> </li> <li> <p>Generate Token:</p> </li> <li>Short-lived token generated for service account</li> <li> <p>Token expiration set to minimal required time</p> </li> <li> <p>Create Kubeconfig:</p> </li> <li>Restricted kubeconfig file created with token</li> <li>File permissions set to restrict access</li> </ol>"},{"location":"architecture/workflows/distroless-container/#2-debug-container-deployment-phase","title":"2. Debug Container Deployment Phase","text":"<pre><code>flowchart TD\n    A[Start Debug Deployment] --&gt; B[Create Debug Container Spec]\n    B --&gt; C[Apply Debug Container to Target Pod]\n    C --&gt; D[Wait for Debug Container Ready]\n    D --&gt; E[Verify Debug Container Access]\n    E --&gt; F[Debug Container Ready]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/distroless-container/#debug-container-tasks","title":"Debug Container Tasks","text":"<ol> <li>Create Debug Container:</li> <li> <p>Debug container specification created with:</p> <ul> <li>CINC Auditor image</li> <li>Target process namespace sharing</li> <li>Required security context</li> </ul> </li> <li> <p>Apply Debug Container:</p> </li> <li>Debug container added to target pod</li> <li> <p>Container configured to access target filesystem</p> </li> <li> <p>Wait for Readiness:</p> </li> <li>Debug container availability checked</li> <li>Connection tested</li> </ol>"},{"location":"architecture/workflows/distroless-container/#3-scanning-phase","title":"3. Scanning Phase","text":"<pre><code>flowchart TD\n    A[Start Scanning] --&gt; B[Initialize CINC Auditor in Debug Container]\n    B --&gt; C[Chroot to Target Container Filesystem]\n    C --&gt; D[Execute Compliance Profile]\n    D --&gt; E[Collect Scan Results]\n    E --&gt; F[Export Results from Debug Container]\n    F --&gt; G[Scanning Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/distroless-container/#scanning-tasks","title":"Scanning Tasks","text":"<ol> <li>Initialize CINC Auditor:</li> <li>CINC Auditor (InSpec) initialized in debug container</li> <li> <p>Scanner configured with appropriate profile</p> </li> <li> <p>Chroot to Target:</p> </li> <li> <p>Target container filesystem accessed via:</p> <ul> <li>Process filesystem (<code>/proc/&lt;pid&gt;/root</code>)</li> <li>Or bind-mounted directory</li> </ul> </li> <li> <p>Execute Profile:</p> </li> <li>Compliance profile run against target filesystem</li> <li> <p>Profile execution constrained to target context</p> </li> <li> <p>Collect Results:</p> </li> <li>Scan results collected in structured JSON format</li> <li> <p>Results stored in debug container</p> </li> <li> <p>Export Results:</p> </li> <li>Results exported from debug container</li> <li>Results saved for processing</li> </ol>"},{"location":"architecture/workflows/distroless-container/#4-results-processing-phase","title":"4. Results Processing Phase","text":"<pre><code>flowchart TD\n    A[Start Processing] --&gt; B[Format Raw Results]\n    B --&gt; C[Generate JSON Report]\n    C --&gt; D[Process with SAF CLI]\n    D --&gt; E[Apply Threshold Validation]\n    E --&gt; F{Thresholds Met?}\n    F --&gt;|Yes| G[Mark as Passed]\n    F --&gt;|No| H[Mark as Failed]\n    G --&gt; I[Processing Complete]\n    H --&gt; I\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/distroless-container/#processing-tasks","title":"Processing Tasks","text":"<ol> <li>Format Results:</li> <li>Raw scan results formatted for readability</li> <li> <p>Results organized by control</p> </li> <li> <p>Generate Reports:</p> </li> <li>JSON report generated with full scan details</li> <li> <p>Additional report formats created as needed</p> </li> <li> <p>Process with SAF CLI:</p> </li> <li>MITRE SAF CLI processes scan results</li> <li> <p>Results evaluated against compliance standards</p> </li> <li> <p>Threshold Validation:</p> </li> <li>Results compared to configured thresholds</li> <li>Pass/fail status determined</li> </ol>"},{"location":"architecture/workflows/distroless-container/#5-cleanup-phase","title":"5. Cleanup Phase","text":"<pre><code>flowchart TD\n    A[Start Cleanup] --&gt; B[Remove Debug Container]\n    B --&gt; C[Delete Kubeconfig]\n    C --&gt; D[Delete Service Account]\n    D --&gt; E[Delete Role and RoleBinding]\n    E --&gt; F[Verify Resource Removal]\n    F --&gt; G[Cleanup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/distroless-container/#cleanup-tasks","title":"Cleanup Tasks","text":"<ol> <li>Remove Debug Container:</li> <li>Debug container removed from target pod</li> <li> <p>Removal verified</p> </li> <li> <p>Delete Kubeconfig:</p> </li> <li>Temporary kubeconfig file securely deleted</li> <li> <p>File permissions verified during deletion</p> </li> <li> <p>Delete Kubernetes Resources:</p> </li> <li>Service account removed</li> <li>Role and RoleBinding removed</li> <li> <p>Any other temporary resources removed</p> </li> <li> <p>Verify Cleanup:</p> </li> <li>Resource deletion confirmed</li> <li>No leftover resources remain</li> </ol>"},{"location":"architecture/workflows/distroless-container/#implementation-details","title":"Implementation Details","text":"<p>The distroless container workflow is implemented in the <code>scan-distroless-container.sh</code> script with the following parameters:</p> <pre><code>./kubernetes-scripts/scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre>"},{"location":"architecture/workflows/distroless-container/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>namespace</code>: Kubernetes namespace containing the target container</li> <li><code>pod-name</code>: Name of the pod containing the target container</li> <li><code>container-name</code>: Name of the target container</li> <li><code>profile-path</code>: Path to the InSpec profile to run</li> </ul>"},{"location":"architecture/workflows/distroless-container/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>threshold_file</code>: Path to threshold configuration file for validation</li> </ul>"},{"location":"architecture/workflows/distroless-container/#kubernetes-version-requirements","title":"Kubernetes Version Requirements","text":"<p>This workflow requires:</p> <ul> <li>Kubernetes v1.16+ for ephemeral container support</li> <li>Feature gate <code>EphemeralContainers=true</code> enabled in the cluster</li> </ul>"},{"location":"architecture/workflows/distroless-container/#error-handling","title":"Error Handling","text":"<p>The workflow includes specialized error handling for distroless containers:</p> <ol> <li>Feature Detection: Checks for ephemeral container support</li> <li>Alternative Fallbacks: Can use other methods if ephemeral containers unavailable</li> <li>Filesystem Access: Validates access to target filesystem</li> <li>Resource Cleanup: Ensures debug containers are removed even after failures</li> </ol>"},{"location":"architecture/workflows/distroless-container/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>For CI/CD integration, the workflow can be adapted to run as part of:</p> <ul> <li>GitHub Actions workflows with special ephemeral container permissions</li> <li>GitLab CI pipelines with extended RBAC</li> <li>Other CI/CD systems with appropriate configuration</li> </ul> <p>See CI/CD Integration for Distroless Containers for specific integration examples.</p>"},{"location":"architecture/workflows/inventory/","title":"Workflows Documentation Inventory","text":"<p>This directory contains documentation about the workflow processes for the Kubernetes CINC Secure Scanner.</p>"},{"location":"architecture/workflows/inventory/#contents","title":"Contents","text":"<ul> <li>Standard Container Workflow - Workflow for scanning standard containers</li> <li>Distroless Container Workflow - Workflow for scanning distroless containers</li> <li>Sidecar Container Workflow - Workflow using the sidecar approach</li> <li>Security Workflows - Security-focused scanning workflows</li> </ul>"},{"location":"architecture/workflows/inventory/#overview","title":"Overview","text":"<p>The workflows documentation provides detailed information about the scanning processes for different container types and security requirements. Each workflow document outlines the steps involved in the process, from setting up the necessary resources to cleaning up after the scan is complete.</p> <p>Understanding these workflows is essential for users who want to implement container scanning in their environment, as it helps them choose the appropriate workflow for their specific needs and understand how the scanner interacts with their Kubernetes environment.</p>"},{"location":"architecture/workflows/security-workflows/","title":"Security-Focused Workflows","text":"<p>This document details the security-focused workflows that emphasize enhanced security controls for container scanning.</p>"},{"location":"architecture/workflows/security-workflows/#security-workflow-overview","title":"Security Workflow Overview","text":"<p>The security-focused workflows build upon the standard, distroless, and sidecar approaches with additional security controls to meet stringent security requirements.</p>"},{"location":"architecture/workflows/security-workflows/#enhanced-security-controls","title":"Enhanced Security Controls","text":"<p>Security-focused workflows implement the following enhanced controls:</p>"},{"location":"architecture/workflows/security-workflows/#1-least-privilege-rbac","title":"1. Least Privilege RBAC","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Create Namespace-scoped Service Account]\n    B --&gt; C[Create Minimal Role with Specific Resources]\n    C --&gt; D[Limit Role to Specific Pods via Labels]\n    D --&gt; E[Create Time-limited RoleBinding]\n    E --&gt; F[Validate RBAC Configuration]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#controls","title":"Controls","text":"<ol> <li>Target-Specific Permissions:</li> <li>Role limited to specific pod by name or label</li> <li>Exact resource permissions defined</li> <li> <p>No wildcard permissions</p> </li> <li> <p>Time-Limited Access:</p> </li> <li>RoleBinding created with time-limited validity</li> <li>Automatic expiration of permissions</li> </ol>"},{"location":"architecture/workflows/security-workflows/#2-ephemeral-credentials","title":"2. Ephemeral Credentials","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Generate Short-lived Service Account Token]\n    B --&gt; C[Set Minimal Token Expiration]\n    C --&gt; D[Create Single-use Kubeconfig]\n    D --&gt; E[Apply File Security Controls]\n    E --&gt; F[Validate Token Restrictions]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#controls_1","title":"Controls","text":"<ol> <li>Token Security:</li> <li>Token generated with minimal lifespan</li> <li>Token intended for single use only</li> <li> <p>No persistent token storage</p> </li> <li> <p>Credential Protection:</p> </li> <li>Kubeconfig stored with restricted permissions</li> <li>Kubeconfig created in memory when possible</li> <li>Kubeconfig deleted immediately after use</li> </ol>"},{"location":"architecture/workflows/security-workflows/#3-secure-network-communication","title":"3. Secure Network Communication","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Enforce TLS for API Communication]\n    B --&gt; C[Verify API Server Certificate]\n    C --&gt; D[Use Secure Network Policies]\n    D --&gt; E[Restrict Egress Traffic]\n    E --&gt; F[Validate Connection Security]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#controls_2","title":"Controls","text":"<ol> <li>Transport Security:</li> <li>TLS enforced for all API communication</li> <li>Certificate validation required</li> <li> <p>No insecure connections allowed</p> </li> <li> <p>Network Isolation:</p> </li> <li>Network policies restrict scanner traffic</li> <li>Egress limited to required endpoints</li> <li>Communication isolation between namespaces</li> </ol>"},{"location":"architecture/workflows/security-workflows/#4-automated-resource-cleanup","title":"4. Automated Resource Cleanup","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Register Cleanup Handlers]\n    B --&gt; C[Implement Timed Cleanup Fallback]\n    C --&gt; D[Verify Resource Deletion]\n    D --&gt; E[Secure Deletion of Credentials]\n    E --&gt; F[Log Cleanup Operations]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#controls_3","title":"Controls","text":"<ol> <li>Reliable Cleanup:</li> <li>Multiple cleanup mechanisms (trap handlers)</li> <li>Fallback cleanup processes</li> <li> <p>Verification of resource removal</p> </li> <li> <p>Secure Deletion:</p> </li> <li>Secure credential wiping</li> <li>Complete removal of all temporary resources</li> <li>Cleanup logs for audit trail</li> </ol>"},{"location":"architecture/workflows/security-workflows/#security-enhanced-standard-container-workflow","title":"Security-Enhanced Standard Container Workflow","text":"<p>The security-enhanced standard container workflow adds these additional steps to the standard container workflow:</p>"},{"location":"architecture/workflows/security-workflows/#1-pre-scan-security-verification","title":"1. Pre-Scan Security Verification","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Verify Target Container Integrity]\n    B --&gt; C[Check for Privileged Status]\n    C --&gt; D[Validate Container Image Source]\n    D --&gt; E[Scan Network Connections]\n    E --&gt; F{Security Checks Pass?}\n    F --&gt;|Yes| G[Proceed with Scan]\n    F --&gt;|No| H[Abort with Security Alert]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#2-enhanced-rbac-with-label-targeting","title":"2. Enhanced RBAC with Label Targeting","text":"<pre><code># Example of label-targeted RBAC for enhanced security\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: ${NAMESPACE}\nspec:\n  rules:\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"get\"]\n    resourceNames: [\"${POD_NAME}\"]\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"create\"]\n    resourceNames: [\"${POD_NAME}\"]\nEOF\n</code></pre>"},{"location":"architecture/workflows/security-workflows/#3-post-scan-security-audit","title":"3. Post-Scan Security Audit","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Record Scanning Activity in Audit Log]\n    B --&gt; C[Validate Resource Cleanup Completion]\n    C --&gt; D[Verify No Credential Artifacts]\n    D --&gt; E[Scan for Unintended Side Effects]\n    E --&gt; F[Generate Security Report]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#security-enhanced-distroless-container-workflow","title":"Security-Enhanced Distroless Container Workflow","text":"<p>The security-enhanced distroless container workflow adds these additional steps to the distroless container workflow:</p>"},{"location":"architecture/workflows/security-workflows/#1-enhanced-debug-container-controls","title":"1. Enhanced Debug Container Controls","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Apply SecurityContext Restrictions]\n    B --&gt; C[Set Non-root User for Debug Container]\n    C --&gt; D[Apply Pod Security Policies]\n    D --&gt; E[Limit Debug Container Capabilities]\n    E --&gt; F[Mount Volumes Read-Only]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#2-debug-container-isolation","title":"2. Debug Container Isolation","text":"<pre><code># Example of security-enhanced debug container configuration\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 10001\n  capabilities:\n    drop:\n    - ALL\n    add:\n    - CHOWN\n    - DAC_OVERRIDE\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n</code></pre>"},{"location":"architecture/workflows/security-workflows/#security-enhanced-sidecar-workflow","title":"Security-Enhanced Sidecar Workflow","text":"<p>The security-enhanced sidecar workflow adds these additional steps to the sidecar container workflow:</p>"},{"location":"architecture/workflows/security-workflows/#1-secure-sidecar-configuration","title":"1. Secure Sidecar Configuration","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Apply Pod Security Policy]\n    B --&gt; C[Set Non-root User for Sidecar]\n    C --&gt; D[Limit Sidecar Container Capabilities]\n    D --&gt; E[Apply Seccomp Profile]\n    E --&gt; F[Implement AppArmor Profile]\n    F --&gt; G[End]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/security-workflows/#2-secure-pod-manifest","title":"2. Secure Pod Manifest","text":"<pre><code># Example of security-enhanced sidecar pod configuration\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 10001\n  seccompProfile:\n    type: RuntimeDefault\n</code></pre>"},{"location":"architecture/workflows/security-workflows/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>To implement security-focused workflows:</p> <ol> <li>Baseline Identification:</li> <li>Identify baseline security requirements</li> <li> <p>Choose appropriate scanning approach based on security needs</p> </li> <li> <p>RBAC Enhancement:</p> </li> <li>Use label-based targeting for specific pods</li> <li>Implement time-limited RoleBindings</li> <li> <p>Apply namespace isolation</p> </li> <li> <p>Credential Hardening:</p> </li> <li>Generate shortest-lived tokens possible</li> <li>Implement secure credential handling</li> <li> <p>Use in-memory credential storage when available</p> </li> <li> <p>Network Security:</p> </li> <li>Apply network policies for scanner isolation</li> <li>Restrict egress traffic</li> <li> <p>Enforce TLS for all communication</p> </li> <li> <p>Automated Security Processes:</p> </li> <li>Implement pre-scan security verification</li> <li>Configure post-scan security auditing</li> <li>Enable automated cleanup with verification</li> </ol>"},{"location":"architecture/workflows/security-workflows/#security-enhanced-script-example","title":"Security-Enhanced Script Example","text":"<p>The security-enhanced scripts are available in the <code>/scripts/security-enhanced/</code> directory:</p> <ul> <li><code>secure-scan-container.sh</code> - Enhanced standard container scanning</li> <li><code>secure-scan-distroless-container.sh</code> - Enhanced distroless container scanning</li> <li><code>secure-scan-with-sidecar.sh</code> - Enhanced sidecar container scanning</li> </ul> <p>These scripts implement all the security controls described in this document.</p>"},{"location":"architecture/workflows/sidecar-container/","title":"Sidecar Container Workflow","text":"<p>This document details the sidecar container workflow, which uses a sidecar container with shared process namespace to scan both standard and distroless containers.</p>"},{"location":"architecture/workflows/sidecar-container/#workflow-overview","title":"Workflow Overview","text":"<p>The sidecar container workflow deploys a CINC Auditor sidecar container within the same pod as the target container, using a shared process namespace to access the target container's filesystem and processes.</p>"},{"location":"architecture/workflows/sidecar-container/#detailed-workflow-steps","title":"Detailed Workflow Steps","text":""},{"location":"architecture/workflows/sidecar-container/#1-deployment-phase","title":"1. Deployment Phase","text":"<pre><code>flowchart TD\n    A[Start Deployment] --&gt; B[Create Pod with Target and Sidecar]\n    B --&gt; C[Configure Shared Process Namespace]\n    C --&gt; D[Define Shared Volume]\n    D --&gt; E[Set Security Context]\n    E --&gt; F[Deploy Pod]\n    F --&gt; G[Wait for Pod Ready]\n    G --&gt; H[Verify Containers Running]\n    H --&gt; I[Deployment Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#deployment-tasks","title":"Deployment Tasks","text":"<ol> <li>Create Pod Specification:</li> <li>Pod spec includes target container and scanner sidecar</li> <li><code>shareProcessNamespace: true</code> enabled in pod spec</li> <li> <p>Shared volume defined for results storage</p> </li> <li> <p>Configure Scanner Sidecar:</p> </li> <li> <p>Sidecar container configured with:</p> <ul> <li>CINC Auditor image</li> <li>Access to shared volume</li> <li>Appropriate security context</li> </ul> </li> <li> <p>Deploy Pod:</p> </li> <li>Pod deployed to specified namespace</li> <li>Pod status monitored until ready</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#2-target-identification-phase","title":"2. Target Identification Phase","text":"<pre><code>flowchart TD\n    A[Start Target Identification] --&gt; B[List Processes in Sidecar]\n    B --&gt; C[Identify Target Process ID]\n    C --&gt; D[Locate Target Root Filesystem]\n    D --&gt; E[Verify Target Filesystem Access]\n    E --&gt; F[Target Identification Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#identification-tasks","title":"Identification Tasks","text":"<ol> <li>Process Identification:</li> <li>Sidecar lists all processes in shared namespace</li> <li>Target container processes identified</li> <li> <p>Main process ID (PID) determined</p> </li> <li> <p>Filesystem Location:</p> </li> <li>Target filesystem located via <code>/proc/&lt;pid&gt;/root</code></li> <li>Filesystem access verified</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#3-scanning-phase","title":"3. Scanning Phase","text":"<pre><code>flowchart TD\n    A[Start Scanning] --&gt; B[Initialize CINC Auditor in Sidecar]\n    B --&gt; C[Configure Scanner for Target Filesystem]\n    C --&gt; D[Execute Compliance Profile]\n    D --&gt; E[Collect Scan Results]\n    E --&gt; F[Store Results in Shared Volume]\n    F --&gt; G[Scanning Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#scanning-tasks","title":"Scanning Tasks","text":"<ol> <li>Initialize CINC Auditor:</li> <li>CINC Auditor started in sidecar container</li> <li> <p>Scanner configured with appropriate profile</p> </li> <li> <p>Configure Target Access:</p> </li> <li>Scanner configured to use target filesystem path</li> <li> <p>Access to target processes enabled</p> </li> <li> <p>Execute Profile:</p> </li> <li>Compliance profile run against target filesystem</li> <li> <p>Commands executed in target context</p> </li> <li> <p>Store Results:</p> </li> <li>Scan results stored in JSON format</li> <li>Results saved to shared volume</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#4-results-retrieval-phase","title":"4. Results Retrieval Phase","text":"<pre><code>flowchart TD\n    A[Start Retrieval] --&gt; B[Retrieve Results from Shared Volume]\n    B --&gt; C[Extract Results from Pod]\n    C --&gt; D[Format Results]\n    D --&gt; E[Generate Report]\n    E --&gt; F[Retrieval Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#retrieval-tasks","title":"Retrieval Tasks","text":"<ol> <li>Access Shared Volume:</li> <li>Results accessed from shared volume</li> <li> <p>Results copied from pod to local storage</p> </li> <li> <p>Format and Extract:</p> </li> <li>Raw results formatted for readability</li> <li>Results prepared for processing</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#5-results-processing-phase","title":"5. Results Processing Phase","text":"<pre><code>flowchart TD\n    A[Start Processing] --&gt; B[Process with SAF CLI]\n    B --&gt; C[Apply Threshold Validation]\n    C --&gt; D{Thresholds Met?}\n    D --&gt;|Yes| E[Mark as Passed]\n    D --&gt;|No| F[Mark as Failed]\n    E --&gt; G[Processing Complete]\n    F --&gt; G\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style B fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style C fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#processing-tasks","title":"Processing Tasks","text":"<ol> <li>Process with SAF CLI:</li> <li>MITRE SAF CLI processes scan results</li> <li> <p>Results evaluated against compliance standards</p> </li> <li> <p>Threshold Validation:</p> </li> <li>Results compared to configured thresholds</li> <li>Pass/fail status determined</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#6-cleanup-phase","title":"6. Cleanup Phase","text":"<pre><code>flowchart TD\n    A[Start Cleanup] --&gt; B[Delete Pod]\n    B --&gt; C[Verify Pod Deletion]\n    C --&gt; D[Remove Any Temporary Files]\n    D --&gt; E[Cleanup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/sidecar-container/#cleanup-tasks","title":"Cleanup Tasks","text":"<ol> <li>Delete Pod:</li> <li>Pod containing target and sidecar deleted</li> <li> <p>Deletion verified</p> </li> <li> <p>Remove Temporary Files:</p> </li> <li>Any temporary files removed</li> <li>Clean state ensured</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#implementation-details","title":"Implementation Details","text":"<p>The sidecar container workflow is implemented in the <code>scan-with-sidecar.sh</code> script with the following parameters:</p> <pre><code>./kubernetes-scripts/scan-with-sidecar.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre>"},{"location":"architecture/workflows/sidecar-container/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>namespace</code>: Kubernetes namespace for deploying the pod</li> <li><code>pod-name</code>: Name to give the pod with sidecar</li> <li><code>profile-path</code>: Path to the InSpec profile to run</li> </ul>"},{"location":"architecture/workflows/sidecar-container/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>threshold_file</code>: Path to threshold configuration file for validation</li> </ul>"},{"location":"architecture/workflows/sidecar-container/#usage-scenarios","title":"Usage Scenarios","text":"<p>The sidecar approach is particularly useful for:</p> <ol> <li>CI/CD Integration: When scanning container images during CI/CD</li> <li>Mixed Container Types: Environments with both standard and distroless containers</li> <li>Access Restrictions: Environments where direct pod exec is restricted</li> <li>Consistent Approach: When a unified approach for all container types is preferred</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#advantages","title":"Advantages","text":"<p>The sidecar approach offers several advantages:</p> <ol> <li>Universal Compatibility: Works with both standard and distroless containers</li> <li>Simplified RBAC: Doesn't require special ephemeral container permissions</li> <li>Process Visibility: Full visibility into target processes</li> <li>Deployment Flexibility: Can be deployed as part of the application pod or separately</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#limitations","title":"Limitations","text":"<p>Some limitations to consider:</p> <ol> <li>Pod Recreation: Requires creating a new pod or modifying existing pod spec</li> <li>Privilege Requirements: Requires shared process namespace capability</li> <li>Resource Usage: Additional resource consumption for sidecar container</li> </ol>"},{"location":"architecture/workflows/sidecar-container/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>For CI/CD integration, the workflow can be adapted to run as part of:</p> <ul> <li>GitHub Actions using a dedicated scanning job</li> <li>GitLab CI using services containers</li> <li>Other CI/CD systems with appropriate Kubernetes access</li> </ul> <p>See Sidecar CI/CD Integration for specific integration examples.</p>"},{"location":"architecture/workflows/standard-container/","title":"Standard Container Workflow","text":"<p>This document details the standard container scanning workflow, which is the primary method for scanning containers with a shell and common utilities.</p>"},{"location":"architecture/workflows/standard-container/#workflow-overview","title":"Workflow Overview","text":"<p>The standard container workflow uses the Kubernetes API approach with the train-k8s-container transport plugin to directly access the target container.</p>"},{"location":"architecture/workflows/standard-container/#detailed-workflow-steps","title":"Detailed Workflow Steps","text":""},{"location":"architecture/workflows/standard-container/#1-setup-phase","title":"1. Setup Phase","text":"<pre><code>flowchart TD\n    A[Start Setup] --&gt; B[Identify Target Container]\n    B --&gt; C[Create Service Account]\n    C --&gt; D[Apply RBAC Roles and Bindings]\n    D --&gt; E[Generate Short-lived Token]\n    E --&gt; F[Create Restricted Kubeconfig]\n    F --&gt; G[Setup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/standard-container/#setup-tasks","title":"Setup Tasks","text":"<ol> <li>Identify Target Container:</li> <li>Namespace, pod name, and container name are identified</li> <li> <p>Container status is verified to ensure it's running</p> </li> <li> <p>Create Service Account:</p> </li> <li>Temporary service account created in target namespace</li> <li> <p>Account is marked for cleanup after scan completion</p> </li> <li> <p>Apply RBAC:</p> </li> <li>Role created with minimal permissions:<ul> <li><code>pods/exec</code> permission for target container</li> <li><code>pods</code> GET permission for target pod</li> </ul> </li> <li> <p>RoleBinding created to link service account to role</p> </li> <li> <p>Generate Token:</p> </li> <li>Short-lived token generated for service account</li> <li> <p>Token expiration set to minimal required time</p> </li> <li> <p>Create Kubeconfig:</p> </li> <li>Restricted kubeconfig file created with token</li> <li>File permissions set to restrict access</li> </ol>"},{"location":"architecture/workflows/standard-container/#2-scanning-phase","title":"2. Scanning Phase","text":"<pre><code>flowchart TD\n    A[Start Scanning] --&gt; B[Initialize CINC Auditor]\n    B --&gt; C[Configure train-k8s-container Transport]\n    C --&gt; D[Connect to Target Container]\n    D --&gt; E[Verify Container Access]\n    E --&gt; F[Execute Compliance Profile]\n    F --&gt; G[Collect Scan Results]\n    G --&gt; H[Scanning Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/standard-container/#scanning-tasks","title":"Scanning Tasks","text":"<ol> <li>Initialize CINC Auditor:</li> <li>CINC Auditor (InSpec) initialized with appropriate profile</li> <li> <p>Scanner configuration loaded</p> </li> <li> <p>Configure Transport:</p> </li> <li> <p>train-k8s-container transport configured with:</p> <ul> <li>Target namespace</li> <li>Pod name</li> <li>Container name</li> <li>Kubeconfig file path</li> </ul> </li> <li> <p>Connect to Container:</p> </li> <li>Transport plugin establishes connection to container</li> <li> <p>Connection validated with simple command</p> </li> <li> <p>Execute Profile:</p> </li> <li>Compliance profile run against target container</li> <li>Commands executed within container context</li> <li> <p>Filesystem examined as needed</p> </li> <li> <p>Collect Results:</p> </li> <li>Scan results collected in structured JSON format</li> <li>Results stored for processing</li> </ol>"},{"location":"architecture/workflows/standard-container/#3-results-processing-phase","title":"3. Results Processing Phase","text":"<pre><code>flowchart TD\n    A[Start Processing] --&gt; B[Format Raw Results]\n    B --&gt; C[Generate JSON Report]\n    C --&gt; D[Process with SAF CLI]\n    D --&gt; E[Apply Threshold Validation]\n    E --&gt; F{Thresholds Met?}\n    F --&gt;|Yes| G[Mark as Passed]\n    F --&gt;|No| H[Mark as Failed]\n    G --&gt; I[Processing Complete]\n    H --&gt; I\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/standard-container/#processing-tasks","title":"Processing Tasks","text":"<ol> <li>Format Results:</li> <li>Raw scan results formatted for readability</li> <li> <p>Results organized by control</p> </li> <li> <p>Generate Reports:</p> </li> <li>JSON report generated with full scan details</li> <li> <p>Additional report formats created as needed</p> </li> <li> <p>Process with SAF CLI:</p> </li> <li>MITRE SAF CLI processes scan results</li> <li> <p>Results evaluated against compliance standards</p> </li> <li> <p>Threshold Validation:</p> </li> <li>Results compared to configured thresholds</li> <li>Pass/fail status determined</li> </ol>"},{"location":"architecture/workflows/standard-container/#4-cleanup-phase","title":"4. Cleanup Phase","text":"<pre><code>flowchart TD\n    A[Start Cleanup] --&gt; B[Delete Kubeconfig]\n    B --&gt; C[Delete Service Account]\n    C --&gt; D[Delete Role and RoleBinding]\n    D --&gt; E[Verify Resource Removal]\n    E --&gt; F[Cleanup Complete]\n\n    style A fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"architecture/workflows/standard-container/#cleanup-tasks","title":"Cleanup Tasks","text":"<ol> <li>Delete Kubeconfig:</li> <li>Temporary kubeconfig file securely deleted</li> <li> <p>File permissions verified during deletion</p> </li> <li> <p>Delete Kubernetes Resources:</p> </li> <li>Service account removed</li> <li>Role and RoleBinding removed</li> <li> <p>Any other temporary resources removed</p> </li> <li> <p>Verify Cleanup:</p> </li> <li>Resource deletion confirmed</li> <li>No leftover resources remain</li> </ol>"},{"location":"architecture/workflows/standard-container/#implementation-details","title":"Implementation Details","text":"<p>The standard container workflow is implemented in the <code>scan-container.sh</code> script with the following parameters:</p> <pre><code>./kubernetes-scripts/scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre>"},{"location":"architecture/workflows/standard-container/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>namespace</code>: Kubernetes namespace containing the target container</li> <li><code>pod-name</code>: Name of the pod containing the target container</li> <li><code>container-name</code>: Name of the target container</li> <li><code>profile-path</code>: Path to the InSpec profile to run</li> </ul>"},{"location":"architecture/workflows/standard-container/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>threshold_file</code>: Path to threshold configuration file for validation</li> </ul>"},{"location":"architecture/workflows/standard-container/#error-handling","title":"Error Handling","text":"<p>The workflow includes robust error handling:</p> <ol> <li>Connection Failures: Detected and reported with clear error messages</li> <li>Permission Issues: Identified with troubleshooting guidance</li> <li>Container Availability: Checked before attempting scan</li> <li>Resource Cleanup: Attempted even after scan failures</li> </ol>"},{"location":"architecture/workflows/standard-container/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>For CI/CD integration, the workflow can be adapted to run as part of:</p> <ul> <li>GitHub Actions workflows</li> <li>GitLab CI pipelines</li> <li>Other CI/CD systems</li> </ul> <p>See CI/CD Integration for specific integration examples.</p>"},{"location":"configuration/","title":"Configuration Overview","text":"<p>Directory Inventory</p> <p>See the Configuration Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides comprehensive documentation for configuring the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"configuration/#configuration-areas","title":"Configuration Areas","text":"<p>The configuration documentation is organized into several key areas:</p> <ol> <li>Kubeconfig Configuration: Authentication and access configuration for Kubernetes</li> <li>Threshold Configuration: Compliance validation and quality gates</li> <li>Plugin Customization: Modifications to scanning plugins</li> <li>Integration Configuration: Configuration for CI/CD and other integrations</li> <li>Security Configuration: Security-focused configurations</li> </ol>"},{"location":"configuration/#common-configuration-scenarios","title":"Common Configuration Scenarios","text":"Scenario Configuration Area Description Basic Authentication Kubeconfig Setting up authentication for the scanner Quality Gates Thresholds Configuring pass/fail criteria for scans Distroless Support Plugins Configuring scanning for distroless containers CI/CD Pipeline Integration Setting up scanner in CI/CD environments Hardened Environment Security Security-focused configuration options"},{"location":"configuration/#getting-started","title":"Getting Started","text":"<p>Most users should begin with the Kubeconfig Configuration to set up basic authentication, followed by Threshold Configuration to establish quality gates for compliance validation.</p>"},{"location":"configuration/#advanced-configuration","title":"Advanced Configuration","text":"<p>For specialized needs, explore the Plugin Customization documentation, which includes guidance on modifying scanner behavior for specific container types.</p>"},{"location":"configuration/#related-topics","title":"Related Topics","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> <li>Security Considerations</li> </ul>"},{"location":"configuration/inventory/","title":"Configuration Directory Inventory","text":"<p>This document provides a directory overview of the configuration resources and documentation.</p>"},{"location":"configuration/inventory/#directory-structure","title":"Directory Structure","text":"<p>The configuration directory is organized into the following subdirectories:</p> <ul> <li>kubeconfig/: Documentation for Kubernetes authentication configuration</li> <li>thresholds/: Documentation for compliance threshold configuration</li> <li>plugins/: Documentation for scanner plugin customization</li> <li>integration/: Documentation for CI/CD and other integration configuration</li> <li>security/: Documentation for security-focused configuration</li> <li>advanced/: Legacy directory (content moved to new structure)</li> </ul>"},{"location":"configuration/inventory/#main-files","title":"Main Files","text":"<ul> <li>index.md: Main configuration overview page</li> <li>inventory.md: This directory listing file</li> </ul>"},{"location":"configuration/inventory/#subdirectory-contents","title":"Subdirectory Contents","text":""},{"location":"configuration/inventory/#kubeconfig-configuration","title":"Kubeconfig Configuration","text":"<ul> <li>index.md: Overview of Kubernetes authentication configuration</li> <li>inventory.md: Directory listing for kubeconfig documentation</li> <li>generation.md: Guide for generating secure kubeconfig files</li> <li>management.md: Best practices for managing kubeconfig files</li> <li>security.md: Security considerations for kubeconfig files</li> <li>dynamic.md: Dynamic kubeconfig generation for CI/CD</li> </ul>"},{"location":"configuration/inventory/#threshold-configuration","title":"Threshold Configuration","text":"<ul> <li>index.md: Overview of threshold configuration</li> <li>inventory.md: Directory listing for threshold documentation</li> <li>basic.md: Basic threshold configuration</li> <li>advanced.md: Advanced threshold configuration</li> <li>examples.md: Example threshold configurations for different environments</li> <li>cicd.md: Using thresholds in CI/CD pipelines</li> </ul>"},{"location":"configuration/inventory/#plugin-customization","title":"Plugin Customization","text":"<ul> <li>index.md: Overview of plugin customization</li> <li>inventory.md: Directory listing for plugin documentation</li> <li>distroless.md: Modifications for distroless container support</li> <li>implementation.md: Implementation guide for plugin modifications</li> <li>testing.md: Testing modified plugins</li> </ul>"},{"location":"configuration/inventory/#integration-configuration","title":"Integration Configuration","text":"<ul> <li>index.md: Overview of integration configuration</li> <li>inventory.md: Directory listing for integration documentation</li> <li>saf-cli.md: SAF CLI integration configuration</li> <li>github.md: GitHub Actions integration configuration</li> <li>gitlab.md: GitLab CI integration configuration</li> </ul>"},{"location":"configuration/inventory/#security-configuration","title":"Security Configuration","text":"<ul> <li>index.md: Overview of security configuration</li> <li>inventory.md: Directory listing for security documentation</li> <li>hardening.md: Security hardening configuration</li> <li>credentials.md: Secure credential management</li> <li>rbac.md: RBAC configuration for scanners</li> </ul>"},{"location":"configuration/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> <li>Security Framework</li> </ul>"},{"location":"configuration/advanced/","title":"Scanner Configuration","text":"<p>Directory Inventory</p> <p>See the Advanced Configuration Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides documentation for configuring the scanning behavior of the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"configuration/advanced/#overview","title":"Overview","text":"<p>The scanner configuration documentation provides detailed information about configuring the scanning solution's behavior, results processing, and validation. These configurations focus on how the scanner interprets findings, validates compliance, and integrates with workflow tools.</p> <p>Key aspects of scanner configuration include:</p> <ol> <li>Threshold Configuration: Setting passing thresholds for compliance scores</li> <li>Plugin Customization: Modifying scanning plugins for specific containers or environments</li> <li>SAF CLI Integration: Using the MITRE SAF CLI for advanced results processing and reporting</li> </ol> <p>These configurations are typically used in enterprise environments or scenarios requiring specialized scanning behavior, thresholds, or integrations. Users should be familiar with the basic Kubernetes setup before exploring these scanner configuration options.</p>"},{"location":"configuration/advanced/#available-configuration-options","title":"Available Configuration Options","text":"<ul> <li>Scanning Thresholds - Configuration of compliance threshold validation</li> <li>Plugin Modifications - Customizing the behavior of scanning plugins</li> <li>SAF CLI Integration - Integration with MITRE SAF CLI for enhanced functionality</li> </ul>"},{"location":"configuration/advanced/#common-configurations","title":"Common Configurations","text":""},{"location":"configuration/advanced/#setting-compliance-thresholds","title":"Setting Compliance Thresholds","text":"<p>The most common configuration is setting appropriate compliance thresholds for your environment:</p> <pre><code># threshold.yml\ncompliance:\n  min: 80\n  max: 100\nfailed_critical:\n  max: 0\nfailed_high:\n  max: 0\n</code></pre>"},{"location":"configuration/advanced/#saf-cli-integration","title":"SAF CLI Integration","text":"<p>Integrate with the MITRE SAF CLI for enhanced reporting:</p> <pre><code># Generate a summary report\nsaf summary --input scan-results.json --output-md summary.md\n\n# Validate against threshold requirements\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/advanced/#next-steps","title":"Next Steps","text":"<p>After configuring your scanner, review the CI/CD Integration documentation to incorporate scanning into your deployment pipelines.</p>"},{"location":"configuration/advanced/inventory/","title":"Advanced Configuration Directory Inventory","text":"<p>This document provides a directory overview of the advanced scanner configuration resources and documentation.</p>"},{"location":"configuration/advanced/inventory/#directory-contents","title":"Directory Contents","text":"<p>The advanced configuration directory contains documentation for customizing scanner behavior:</p> <ul> <li>README.md: Original documentation (being migrated to this structure)</li> <li>index.md: Main MkDocs documentation page for advanced configuration</li> <li>thresholds.md: Documentation for setting compliance thresholds</li> <li>plugin-modifications.md: Guide for customizing InSpec plugins</li> <li>saf-cli-integration.md: Documentation for MITRE SAF CLI integration</li> </ul>"},{"location":"configuration/advanced/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Threshold Configuration: Settings for compliance score validation</li> <li>Plugin Customization: Modifications to scanning plugins for specific environments</li> <li>SAF CLI Integration: Advanced results processing with the MITRE Security Automation Framework</li> </ul>"},{"location":"configuration/advanced/inventory/#example-configurations","title":"Example Configurations","text":"<ul> <li>Standard threshold configurations for different compliance levels</li> <li>Plugin modification patterns for distroless containers</li> <li>Integration examples with SAF CLI for reporting and validation</li> </ul>"},{"location":"configuration/advanced/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Basic Configuration</li> <li>CI/CD Integration</li> <li>Security Framework</li> </ul>"},{"location":"configuration/integration/","title":"Integration Configuration","text":"<p>Directory Inventory</p> <p>See the Integration Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides documentation for integrating the CINC Auditor container scanning solution with external tools and systems.</p>"},{"location":"configuration/integration/#integration-overview","title":"Integration Overview","text":"<p>Integrating the scanning solution with external tools enhances its capabilities and enables it to fit into larger workflows. Key integrations include:</p> <ol> <li>SAF CLI Integration: Enhanced reporting and validation with MITRE's Security Automation Framework CLI</li> <li>GitHub Actions Integration: Configuration for GitHub CI/CD pipelines</li> <li>GitLab CI Integration: Configuration for GitLab CI/CD pipelines</li> </ol>"},{"location":"configuration/integration/#integration-guides","title":"Integration Guides","text":"<ul> <li>SAF CLI Integration - Integration with MITRE's Security Automation Framework CLI</li> <li>GitHub Actions Integration - Configuration for GitHub workflows</li> <li>GitLab CI Integration - Configuration for GitLab pipelines</li> </ul>"},{"location":"configuration/integration/#common-use-cases","title":"Common Use Cases","text":"Use Case Guide Description Enhanced Reporting SAF CLI Generate rich reports from scan results Quality Gates SAF CLI Validate results against thresholds GitHub CI/CD GitHub Actions Integrate scanning into GitHub workflows GitLab CI/CD GitLab CI Integrate scanning into GitLab pipelines"},{"location":"configuration/integration/#getting-started","title":"Getting Started","text":"<p>Most users should begin with SAF CLI Integration to enhance the reporting and validation capabilities of the scanning solution, followed by integration with their specific CI/CD platform.</p>"},{"location":"configuration/integration/#related-topics","title":"Related Topics","text":"<ul> <li>Threshold Configuration</li> <li>CI/CD Integration</li> <li>GitHub Workflows</li> <li>GitLab Pipelines</li> </ul>"},{"location":"configuration/integration/github/","title":"GitHub Actions Integration","text":"<p>This guide covers configuring GitHub Actions for integration with our CINC Auditor container scanning solution.</p>"},{"location":"configuration/integration/github/#overview","title":"Overview","text":"<p>GitHub Actions allows you to automate container scanning as part of your CI/CD pipeline. This provides several benefits:</p> <ol> <li>Automated security checks on every pull request or push</li> <li>Consistent security validation across all environments</li> <li>Integration with your existing GitHub workflows</li> <li>Rich reporting and feedback directly in GitHub</li> </ol>"},{"location":"configuration/integration/github/#basic-configuration","title":"Basic Configuration","text":"<p>Create a GitHub Actions workflow in <code>.github/workflows/container-scan.yml</code>:</p> <pre><code>name: Container Security Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n          cinc-auditor --version\n\n      - name: Set up Kubernetes\n        uses: azure/k8s-set-context@v3\n        with:\n          kubeconfig: ${{ secrets.KUBECONFIG }}\n\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profiles/container-baseline \\\n            -t k8s-container://default/nginx-pod/nginx \\\n            --reporter json:scan-results.json\n\n      - name: Install SAF CLI\n        run: npm install -g @mitre/saf\n\n      - name: Generate reports\n        run: |\n          saf summary --input scan-results.json --output-md summary.md\n          echo \"::group::Scan Summary\"\n          cat summary.md\n          echo \"::endgroup::\"\n\n      - name: Validate thresholds\n        run: |\n          saf threshold -i scan-results.json -t threshold.yml\n          if [ $? -ne 0 ]; then\n            echo \"Security scan failed to meet threshold requirements\"\n            exit 1\n          fi\n</code></pre>"},{"location":"configuration/integration/github/#required-secrets","title":"Required Secrets","text":"<p>You'll need to configure these GitHub secrets:</p> <ul> <li><code>KUBECONFIG</code>: Base64-encoded kubeconfig file for accessing your Kubernetes cluster</li> </ul> <p>To set up these secrets:</p> <ol> <li>Navigate to your repository on GitHub</li> <li>Go to Settings &gt; Secrets &gt; Actions</li> <li>Click \"New repository secret\"</li> <li>Add the required secrets</li> </ol>"},{"location":"configuration/integration/github/#customizing-the-workflow","title":"Customizing the Workflow","text":""},{"location":"configuration/integration/github/#using-different-target-containers","title":"Using Different Target Containers","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        container:\n          - { namespace: \"default\", pod: \"nginx-pod\", container: \"nginx\" }\n          - { namespace: \"default\", pod: \"redis-pod\", container: \"redis\" }\n    steps:\n      # ... other steps ...\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profiles/container-baseline \\\n            -t k8s-container://${{ matrix.container.namespace }}/${{ matrix.container.pod }}/${{ matrix.container.container }} \\\n            --reporter json:scan-results-${{ matrix.container.container }}.json\n</code></pre>"},{"location":"configuration/integration/github/#environment-specific-thresholds","title":"Environment-Specific Thresholds","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [development, staging, production]\n    steps:\n      # ... other steps ...\n      - name: Select threshold file\n        run: cp ./thresholds/${{ matrix.environment }}.yml ./threshold.yml\n\n      - name: Validate thresholds\n        run: saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/integration/github/#pull-request-comments","title":"Pull Request Comments","text":"<pre><code>- name: Comment on PR\n  if: github.event_name == 'pull_request'\n  uses: actions/github-script@v6\n  with:\n    github-token: ${{ secrets.GITHUB_TOKEN }}\n    script: |\n      const fs = require('fs');\n      const summary = fs.readFileSync('summary.md', 'utf8');\n\n      github.rest.issues.createComment({\n        issue_number: context.issue.number,\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        body: `## Security Scan Results\\n\\n${summary}`\n      });\n</code></pre>"},{"location":"configuration/integration/github/#advanced-configurations","title":"Advanced Configurations","text":""},{"location":"configuration/integration/github/#testing-with-a-kind-cluster","title":"Testing with a Kind Cluster","text":"<p>This configuration sets up a local Kind cluster for testing:</p> <pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P auditor\n          cinc-auditor --version\n\n      - name: Create Kind Cluster\n        uses: helm/kind-action@v1.5.0\n\n      - name: Deploy test containers\n        run: |\n          kubectl create deployment nginx --image=nginx\n          kubectl wait --for=condition=available deployment/nginx --timeout=60s\n          export POD_NAME=$(kubectl get pods -l app=nginx -o name | cut -d/ -f2)\n          echo \"POD_NAME=$POD_NAME\" &gt;&gt; $GITHUB_ENV\n\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profiles/container-baseline \\\n            -t k8s-container://default/${{ env.POD_NAME }}/nginx \\\n            --reporter json:scan-results.json\n</code></pre>"},{"location":"configuration/integration/github/#using-different-profiles","title":"Using Different Profiles","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        profile:\n          - container-baseline\n          - kubernetes-cis\n    steps:\n      # ... other steps ...\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profiles/${{ matrix.profile }} \\\n            -t k8s-container://default/nginx-pod/nginx \\\n            --reporter json:scan-results-${{ matrix.profile }}.json\n</code></pre>"},{"location":"configuration/integration/github/#examples","title":"Examples","text":"<p>See our GitHub workflow examples for complete implementations:</p> <ul> <li>Basic CI/CD Pipeline</li> <li>Dynamic RBAC Scanning</li> <li>Existing Cluster Scanning</li> <li>Setup and Scan</li> <li>Sidecar Scanner</li> </ul>"},{"location":"configuration/integration/github/#related-topics","title":"Related Topics","text":"<ul> <li>SAF CLI Integration</li> <li>Threshold Configuration</li> <li>GitHub Workflows</li> <li>CI/CD Integration</li> </ul>"},{"location":"configuration/integration/gitlab/","title":"GitLab CI Integration","text":"<p>This guide covers configuring GitLab CI for integration with our CINC Auditor container scanning solution.</p>"},{"location":"configuration/integration/gitlab/#overview","title":"Overview","text":"<p>GitLab CI/CD allows you to automate container scanning as part of your pipeline. This provides several benefits:</p> <ol> <li>Automated security checks on every merge request or commit</li> <li>Consistent security validation across all environments</li> <li>Integration with your existing GitLab pipelines</li> <li>Rich reporting and feedback directly in GitLab</li> </ol>"},{"location":"configuration/integration/gitlab/#basic-configuration","title":"Basic Configuration","text":"<p>Create a GitLab CI configuration in <code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n  - scan\n\ncontainer-security-scan:\n  stage: scan\n  image: ruby:3.1-alpine\n  before_script:\n    # Install dependencies\n    - apk add --no-cache curl bash nodejs npm\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P auditor\n    - npm install -g @mitre/saf\n\n    # Set up kubeconfig\n    - mkdir -p $HOME/.kube\n    - echo \"$KUBECONFIG\" &gt; $HOME/.kube/config\n    - chmod 600 $HOME/.kube/config\n  script:\n    # Run the scan\n    - cinc-auditor exec ./profiles/container-baseline \\\n        -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n        --reporter json:scan-results.json\n\n    # Generate reports\n    - saf summary --input scan-results.json --output-md summary.md\n    - cat summary.md\n\n    # Validate thresholds\n    - saf threshold -i scan-results.json -t threshold.yml\n  variables:\n    NAMESPACE: default\n    POD_NAME: nginx-pod\n    CONTAINER_NAME: nginx\n  artifacts:\n    paths:\n      - scan-results.json\n      - summary.md\n    when: always\n</code></pre>"},{"location":"configuration/integration/gitlab/#required-variables","title":"Required Variables","text":"<p>You'll need to configure these GitLab CI/CD variables:</p> <ul> <li><code>KUBECONFIG</code>: Base64-encoded kubeconfig file for accessing your Kubernetes cluster</li> </ul> <p>To set up these variables:</p> <ol> <li>Navigate to your project on GitLab</li> <li>Go to Settings &gt; CI/CD &gt; Variables</li> <li>Click \"Add Variable\"</li> <li>Add the required variables (mark sensitive ones as \"Protected\" and \"Masked\")</li> </ol>"},{"location":"configuration/integration/gitlab/#customizing-the-pipeline","title":"Customizing the Pipeline","text":""},{"location":"configuration/integration/gitlab/#using-different-target-containers","title":"Using Different Target Containers","text":"<pre><code>container-security-scan:\n  parallel:\n    matrix:\n      - NAMESPACE: [default, kube-system]\n        POD_NAME: [nginx-pod, redis-pod]\n        CONTAINER_NAME: [nginx, redis]\n  # ... other configuration ...\n  script:\n    - cinc-auditor exec ./profiles/container-baseline \\\n        -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n        --reporter json:scan-results-${CONTAINER_NAME}.json\n</code></pre>"},{"location":"configuration/integration/gitlab/#environment-specific-thresholds","title":"Environment-Specific Thresholds","text":"<pre><code>container-security-scan:\n  # ... other configuration ...\n  script:\n    # ... scan script ...\n\n    # Select threshold based on environment\n    - |\n      if [ \"$CI_ENVIRONMENT_NAME\" == \"production\" ]; then\n        cp ./thresholds/production.yml ./threshold.yml\n      elif [ \"$CI_ENVIRONMENT_NAME\" == \"staging\" ]; then\n        cp ./thresholds/staging.yml ./threshold.yml\n      else\n        cp ./thresholds/development.yml ./threshold.yml\n      fi\n\n    # Validate thresholds\n    - saf threshold -i scan-results.json -t threshold.yml\n  environment:\n    name: development\n</code></pre>"},{"location":"configuration/integration/gitlab/#merge-request-comments","title":"Merge Request Comments","text":"<pre><code>container-security-scan:\n  # ... other configuration ...\n  script:\n    # ... scan and validation ...\n\n    # Add comment to merge request\n    - |\n      if [ -n \"$CI_MERGE_REQUEST_IID\" ]; then\n        SUMMARY=$(cat summary.md)\n        curl --request POST \\\n          --header \"PRIVATE-TOKEN: $GITLAB_API_TOKEN\" \\\n          --header \"Content-Type: application/json\" \\\n          --data \"{ \\\"body\\\": \\\"## Security Scan Results\\n\\n${SUMMARY}\\\" }\" \\\n          \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\"\n      fi\n</code></pre>"},{"location":"configuration/integration/gitlab/#advanced-configurations","title":"Advanced Configurations","text":""},{"location":"configuration/integration/gitlab/#using-gitlab-kubernetes-integration","title":"Using GitLab Kubernetes Integration","text":"<p>This configuration uses GitLab's Kubernetes integration:</p> <pre><code>container-security-scan:\n  image: ruby:3.1-alpine\n  before_script:\n    - apk add --no-cache curl bash nodejs npm\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P auditor\n    - npm install -g @mitre/saf\n  script:\n    - cinc-auditor exec ./profiles/container-baseline \\\n        -t k8s-container://${KUBE_NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n        --reporter json:scan-results.json\n    - saf threshold -i scan-results.json -t threshold.yml\n  environment:\n    name: review/$CI_COMMIT_REF_SLUG\n    kubernetes:\n      namespace: $KUBE_NAMESPACE\n</code></pre>"},{"location":"configuration/integration/gitlab/#using-docker-in-docker-services","title":"Using Docker-in-Docker Services","text":"<p>This configuration uses Docker-in-Docker to run a local Kubernetes cluster:</p> <pre><code>container-security-scan:\n  image: docker:20.10.16\n  services:\n    - docker:20.10.16-dind\n  variables:\n    DOCKER_HOST: tcp://docker:2376\n    DOCKER_TLS_CERTDIR: \"/certs\"\n  before_script:\n    - apk add --no-cache curl bash nodejs npm git\n    - curl -LO \"https://dl.k8s.io/release/v1.25.0/bin/linux/amd64/kubectl\"\n    - chmod +x kubectl &amp;&amp; mv kubectl /usr/local/bin/\n    - curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3\n    - chmod +x get_helm.sh &amp;&amp; ./get_helm.sh\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P auditor\n    - npm install -g @mitre/saf\n\n    # Set up kind cluster\n    - apk add --no-cache python3 py3-pip\n    - pip install kind\n    - kind create cluster\n    - kind get kubeconfig &gt; $HOME/.kube/config\n\n    # Deploy test container\n    - kubectl create deployment nginx --image=nginx\n    - kubectl wait --for=condition=available deployment/nginx --timeout=60s\n    - export POD_NAME=$(kubectl get pods -l app=nginx -o name | cut -d/ -f2)\n    - echo \"POD_NAME=$POD_NAME\" &gt;&gt; $BASH_ENV\n  script:\n    - cinc-auditor exec ./profiles/container-baseline \\\n        -t k8s-container://default/$POD_NAME/nginx \\\n        --reporter json:scan-results.json\n    - saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/integration/gitlab/#using-different-profiles","title":"Using Different Profiles","text":"<pre><code>container-security-scan:\n  parallel:\n    matrix:\n      - PROFILE: [container-baseline, kubernetes-cis]\n  # ... other configuration ...\n  script:\n    - cinc-auditor exec ./profiles/${PROFILE} \\\n        -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n        --reporter json:scan-results-${PROFILE}.json\n</code></pre>"},{"location":"configuration/integration/gitlab/#examples","title":"Examples","text":"<p>See our GitLab CI examples for complete implementations:</p> <ul> <li>Basic GitLab CI</li> <li>GitLab CI with Services</li> <li>Dynamic RBAC Scanning</li> <li>Existing Cluster Scanning</li> <li>Sidecar Scanner</li> <li>Sidecar Scanner with Services</li> </ul>"},{"location":"configuration/integration/gitlab/#related-topics","title":"Related Topics","text":"<ul> <li>SAF CLI Integration</li> <li>Threshold Configuration</li> <li>GitLab Pipelines</li> <li>CI/CD Integration</li> </ul>"},{"location":"configuration/integration/inventory/","title":"Integration Configuration Directory Inventory","text":"<p>This document provides a directory overview of the integration configuration resources and documentation.</p>"},{"location":"configuration/integration/inventory/#directory-contents","title":"Directory Contents","text":"<p>The integration directory contains documentation for integrating with external tools and systems:</p> <ul> <li>index.md: Main MkDocs documentation page for integration configuration</li> <li>inventory.md: This directory listing file</li> <li>saf-cli.md: Documentation for MITRE SAF CLI integration</li> <li>github.md: Documentation for GitHub Actions integration</li> <li>gitlab.md: Documentation for GitLab CI integration</li> </ul>"},{"location":"configuration/integration/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>SAF CLI Integration: Integration with MITRE's Security Automation Framework CLI</li> <li>GitHub Actions Configuration: Configuration for GitHub CI/CD workflows</li> <li>GitLab CI Configuration: Configuration for GitLab CI/CD pipelines</li> </ul>"},{"location":"configuration/integration/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Threshold Configuration</li> <li>CI/CD Integration</li> <li>GitHub Workflows</li> <li>GitLab Pipelines</li> </ul>"},{"location":"configuration/integration/saf-cli/","title":"SAF CLI Integration","text":"<p>This guide covers the integration of MITRE's Security Automation Framework (SAF) CLI with our CINC Auditor container scanning solution.</p>"},{"location":"configuration/integration/saf-cli/#overview","title":"Overview","text":"<p>The SAF CLI provides powerful capabilities for processing InSpec/CINC Auditor results, including:</p> <ol> <li>Generating human-readable summaries</li> <li>Creating compliance threshold validation</li> <li>Visualizing results</li> <li>Producing standardized reports</li> </ol>"},{"location":"configuration/integration/saf-cli/#installation","title":"Installation","text":"<p>SAF CLI requires Node.js and can be installed via npm:</p> <pre><code># Install SAF-CLI globally\nnpm install -g @mitre/saf\n\n# Verify installation\nsaf --version\n</code></pre>"},{"location":"configuration/integration/saf-cli/#using-saf-cli-with-scan-results","title":"Using SAF CLI with Scan Results","text":""},{"location":"configuration/integration/saf-cli/#basic-usage","title":"Basic Usage","text":"<p>After running a CINC Auditor scan, the JSON output can be processed with SAF CLI:</p> <pre><code># Run CINC Auditor scan with JSON output\ncinc-auditor exec my-profile -t k8s-container://namespace/pod/container --reporter json:results.json\n\n# Generate a summary in markdown format\nsaf summary --input results.json --output-md summary.md\n\n# Check against thresholds\nsaf threshold -i results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/integration/saf-cli/#threshold-validation","title":"Threshold Validation","text":"<p>Thresholds are defined using YAML or JSON files with the following structure:</p> <pre><code># threshold.yml example\ncompliance:\n  min: 70   # Minimum compliance score (0-100)\nfailed:\n  critical:\n    max: 0  # Maximum critical failures allowed\n  high:\n    max: 2  # Maximum high failures allowed\nskipped:\n  total:\n    max: 5  # Maximum skipped controls allowed\nerror:\n  total:\n    max: 0  # Maximum error controls allowed\n</code></pre> <p>To validate against a threshold file:</p> <pre><code>saf threshold -i results.json -t threshold.yml\n</code></pre> <p>The command returns:</p> <ul> <li>Exit code 0 if all thresholds are met</li> <li>Non-zero exit code if any threshold is not met</li> </ul>"},{"location":"configuration/integration/saf-cli/#report-generation","title":"Report Generation","text":"<p>SAF CLI can generate various report formats:</p> <pre><code># Generate HTML report\nsaf view -i results.json --output report.html\n\n# Generate JSON summary\nsaf summary --input results.json --output summary.json\n\n# Generate markdown summary\nsaf summary --input results.json --output-md summary.md\n</code></pre>"},{"location":"configuration/integration/saf-cli/#integration-in-cicd-pipelines","title":"Integration in CI/CD Pipelines","text":""},{"location":"configuration/integration/saf-cli/#threshold-as-quality-gate","title":"Threshold as Quality Gate","text":"<p>Use threshold validation as a quality gate in CI/CD pipelines:</p> <pre><code># Run validation\nsaf threshold -i results.json -t threshold.yml\nTHRESHOLD_RESULT=$?\n\n# Fail the pipeline if thresholds not met\nif [ $THRESHOLD_RESULT -ne 0 ]; then\n  echo \"Security scan failed to meet threshold requirements\"\n  exit $THRESHOLD_RESULT\nfi\n</code></pre>"},{"location":"configuration/integration/saf-cli/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code>name: Security Scan\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install SAF CLI\n        run: npm install -g @mitre/saf\n\n      - name: Run Container Scan\n        run: |\n          cinc-auditor exec profile -t k8s-container://namespace/pod/container --reporter json:results.json\n\n          # Generate markdown summary\n          saf summary --input results.json --output-md summary.md\n\n          # Check threshold\n          saf threshold -i results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/integration/saf-cli/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<pre><code>security-scan:\n  stage: scan\n  script:\n    - npm install -g @mitre/saf\n    - cinc-auditor exec ${PROFILE_PATH} -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} --reporter json:results.json\n    - saf summary --input results.json --output-md summary.md\n    - saf threshold -i results.json -t threshold.yml\n  artifacts:\n    paths:\n      - results.json\n      - summary.md\n    reports:\n      junit: report.xml\n</code></pre>"},{"location":"configuration/integration/saf-cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"configuration/integration/saf-cli/#creating-custom-reporters","title":"Creating Custom Reporters","text":"<p>SAF CLI allows custom reporters:</p> <pre><code># Create a filtered summary showing only failed controls\nsaf summary --input results.json --output-md summary-failed.md --failed-only\n\n# Create a summary grouped by impact\nsaf summary --input results.json --output-md summary-impact.md --impact-only\n</code></pre>"},{"location":"configuration/integration/saf-cli/#multi-file-processing","title":"Multi-File Processing","text":"<p>Process multiple result files:</p> <pre><code># Combine and analyze multiple result files\nsaf summary --input \"results-*.json\" --output-md combined-summary.md\n</code></pre>"},{"location":"configuration/integration/saf-cli/#advanced-filtering","title":"Advanced Filtering","text":"<p>Filter results for specific needs:</p> <pre><code># Filter by control ID pattern\nsaf filter --input results.json --control-id \"container-*\" --output filtered.json\n\n# Filter by impact\nsaf filter --input results.json --impact high,critical --output high-impact.json\n</code></pre>"},{"location":"configuration/integration/saf-cli/#integration-with-our-scanner-scripts","title":"Integration with Our Scanner Scripts","text":"<p>Our scanning scripts include built-in SAF CLI integration:</p> <pre><code># Run scan with SAF CLI processing\n./scan-container.sh my-namespace my-pod my-container my-profile ./threshold.yml\n</code></pre>"},{"location":"configuration/integration/saf-cli/#helm-chart-integration","title":"Helm Chart Integration","text":"<p>Our Helm charts include SAF CLI integration through values:</p> <pre><code># values.yaml\nsafCli:\n  enabled: true\n  reportFormats:\n    - json\n    - md\n    - html\n  thresholdConfig:\n    compliance:\n      min: 85\n    failed:\n      critical:\n        max: 0\n</code></pre>"},{"location":"configuration/integration/saf-cli/#related-topics","title":"Related Topics","text":"<ul> <li>Threshold Configuration</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>CI/CD Integration</li> </ul>"},{"location":"configuration/kubeconfig/","title":"Kubeconfig Configuration","text":"<p>Directory Inventory</p> <p>See the Kubeconfig Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section covers creating and managing secure kubeconfig files for InSpec container scanning.</p>"},{"location":"configuration/kubeconfig/#what-is-a-kubeconfig","title":"What is a Kubeconfig?","text":"<p>A kubeconfig file is a Kubernetes configuration file that provides client programs with the information needed to connect to a Kubernetes cluster. It contains:</p> <ul> <li>Cluster information (API server address, certificate authority)</li> <li>User authentication details (tokens, client certificates)</li> <li>Context definitions (combinations of cluster, user, and namespace)</li> </ul>"},{"location":"configuration/kubeconfig/#key-components","title":"Key Components","text":"<p>A kubeconfig file for InSpec scanning contains:</p> <ol> <li>Cluster configuration: Server address and certificate authority</li> <li>User authentication: Service account token</li> <li>Context: Binding a cluster and user with a namespace</li> </ol>"},{"location":"configuration/kubeconfig/#configuration-guides","title":"Configuration Guides","text":"<ul> <li>Kubeconfig Generation - Creating secure kubeconfig files</li> <li>Kubeconfig Management - Best practices for managing kubeconfig files</li> <li>Security Considerations - Security aspects of kubeconfig configuration</li> <li>Dynamic Configuration - Dynamic kubeconfig generation for CI/CD</li> </ul>"},{"location":"configuration/kubeconfig/#common-use-cases","title":"Common Use Cases","text":"Use Case Guide Description Basic Setup Generation Generate a basic kubeconfig file for scanning CI/CD Pipelines Dynamic Configuration Generate kubeconfig files dynamically Multiple Environments Management Manage kubeconfig files for different environments Secure Handling Security Secure handling of kubeconfig files"},{"location":"configuration/kubeconfig/#testing-your-configuration","title":"Testing Your Configuration","text":"<p>Once you have created a kubeconfig file, you can test it to ensure it works correctly.</p>"},{"location":"configuration/kubeconfig/#related-topics","title":"Related Topics","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> <li>Security Considerations</li> </ul>"},{"location":"configuration/kubeconfig/dynamic/","title":"Dynamic Kubeconfig Generation","text":"<p>This document covers methods for dynamically generating kubeconfig files in CI/CD pipelines and automated environments.</p>"},{"location":"configuration/kubeconfig/dynamic/#script-based-generation","title":"Script-Based Generation","text":"<p>For CI/CD pipelines, you can generate configurations dynamically using a script:</p> <pre><code>#!/bin/bash\n# generate-kubeconfig.sh\nNAMESPACE=$1\nSA_NAME=$2\nOUTPUT_FILE=${3:-\"./kubeconfig.yaml\"}\n\n# Get cluster information\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create token\nTOKEN=$(kubectl create token ${SA_NAME} -n ${NAMESPACE})\n\n# Generate kubeconfig\ncat &gt; ${OUTPUT_FILE} &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: ${NAMESPACE}\n    user: ${SA_NAME}\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: ${SA_NAME}\n  user:\n    token: ${TOKEN}\nEOF\n\necho \"Generated kubeconfig at ${OUTPUT_FILE}\"\n</code></pre> <p>Usage:</p> <pre><code>./generate-kubeconfig.sh inspec-test inspec-scanner ./my-kubeconfig.yaml\n</code></pre>"},{"location":"configuration/kubeconfig/dynamic/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>For GitHub Actions, you can include dynamic kubeconfig generation in your workflow:</p> <pre><code>name: Kubernetes Scanner\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Kubernetes\n        uses: azure/k8s-set-context@v3\n        with:\n          kubeconfig: ${{ secrets.KUBECONFIG }}\n\n      - name: Generate scanning kubeconfig\n        run: |\n          # Create service account if it doesn't exist\n          kubectl get sa inspec-scanner -n inspec-test || \\\n            kubectl create sa inspec-scanner -n inspec-test\n\n          # Generate kubeconfig for scanner\n          ./kubernetes-scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./scanner-kubeconfig.yaml\n\n          # Run scan with generated kubeconfig\n          KUBECONFIG=./scanner-kubeconfig.yaml cinc-auditor exec profile -t k8s-container://inspec-test/target-pod/container\n</code></pre>"},{"location":"configuration/kubeconfig/dynamic/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>For GitLab CI, you can integrate dynamic kubeconfig generation:</p> <pre><code>stages:\n  - scan\n\ncontainer-scan:\n  stage: scan\n  image: registry.gitlab.com/my-org/container-scanner:latest\n  script:\n    - |\n      # Generate kubeconfig\n      ./kubernetes-scripts/generate-kubeconfig.sh $NAMESPACE $SERVICE_ACCOUNT ./scanner-kubeconfig.yaml\n\n      # Run scan with generated kubeconfig\n      KUBECONFIG=./scanner-kubeconfig.yaml cinc-auditor exec $PROFILE_PATH \\\n        -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME \\\n        --reporter json:scan-results.json\n  variables:\n    NAMESPACE: inspec-test\n    SERVICE_ACCOUNT: inspec-scanner\n    POD_NAME: target-pod\n    CONTAINER_NAME: container\n    PROFILE_PATH: profiles/container-baseline\n</code></pre>"},{"location":"configuration/kubeconfig/dynamic/#token-expiration","title":"Token Expiration","text":"<p>When generating kubeconfig files dynamically, be aware of token expiration:</p> <pre><code># Create a kubeconfig with a short-lived token (5 minutes)\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=5m)\n# ... create kubeconfig ...\n\n# After token expiration, kubeconfig must be regenerated\n</code></pre> <p>For CI/CD pipelines, you should ensure the token duration is appropriate for your job's expected execution time.</p>"},{"location":"configuration/kubeconfig/dynamic/#multiple-environments","title":"Multiple Environments","text":"<p>Dynamic generation allows easy configuration for different environments:</p> <pre><code># Development\n./generate-kubeconfig.sh dev-namespace inspec-scanner ./kubeconfig-dev.yaml\n\n# Staging\n./generate-kubeconfig.sh staging-namespace inspec-scanner ./kubeconfig-staging.yaml\n\n# Production\n./generate-kubeconfig.sh prod-namespace inspec-scanner ./kubeconfig-prod.yaml\n</code></pre> <p>This approach is particularly useful for automated scanning across multiple environments.</p>"},{"location":"configuration/kubeconfig/dynamic/#related-topics","title":"Related Topics","text":"<ul> <li>Kubeconfig Generation</li> <li>Kubeconfig Management</li> <li>Security Considerations</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> </ul>"},{"location":"configuration/kubeconfig/generation/","title":"Kubeconfig Generation","text":"<p>This guide covers creating secure kubeconfig files for InSpec container scanning.</p>"},{"location":"configuration/kubeconfig/generation/#basic-kubeconfig-structure","title":"Basic Kubeconfig Structure","text":"<p>A kubeconfig file for InSpec scanning contains three primary sections:</p>"},{"location":"configuration/kubeconfig/generation/#cluster-section","title":"Cluster Section","text":"<p>The cluster section defines the Kubernetes API server and its certificate authority:</p> <pre><code>clusters:\n- cluster:\n    server: https://kubernetes.api.server:6443\n    certificate-authority-data: BASE64_ENCODED_CA_DATA\n  name: scanner-cluster\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#user-section","title":"User Section","text":"<p>The user section defines authentication details for the service account:</p> <pre><code>users:\n- name: scanner-user\n  user:\n    token: SERVICE_ACCOUNT_TOKEN\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#context-section","title":"Context Section","text":"<p>The context section binds a cluster and user with a namespace:</p> <pre><code>contexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#creating-a-secure-kubeconfig","title":"Creating a Secure Kubeconfig","text":"<p>There are several methods to create a kubeconfig file. Choose the one that best fits your environment.</p>"},{"location":"configuration/kubeconfig/generation/#manual-generation","title":"Manual Generation","text":"<pre><code>TOKEN=$(kubectl create token inspec-scanner -n inspec-test)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\ncat &lt;&lt; EOF &gt; secure-kubeconfig.yaml\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: inspec-test\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#using-kubectl-tools","title":"Using kubectl Tools","text":"<pre><code># Create a new kubeconfig file\nKUBECONFIG=new-config.yaml kubectl config set-cluster scanner-cluster \\\n  --server=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}') \\\n  --certificate-authority-data=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}') \\\n  --embed-certs=true\n\n# Set the user with token\nKUBECONFIG=new-config.yaml kubectl config set-credentials scanner-user \\\n  --token=$(kubectl create token inspec-scanner -n inspec-test)\n\n# Set the context\nKUBECONFIG=new-config.yaml kubectl config set-context scanner-context \\\n  --cluster=scanner-cluster \\\n  --namespace=inspec-test \\\n  --user=scanner-user\n\n# Use the context\nKUBECONFIG=new-config.yaml kubectl config use-context scanner-context\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#testing-a-kubeconfig","title":"Testing a Kubeconfig","text":"<p>Verify your kubeconfig works correctly:</p> <pre><code># Check basic access\nKUBECONFIG=./kubeconfig.yaml kubectl get pods\n\n# Check specific permissions\nKUBECONFIG=./kubeconfig.yaml kubectl auth can-i create pods/exec --resource-name=inspec-target\n</code></pre>"},{"location":"configuration/kubeconfig/generation/#related-topics","title":"Related Topics","text":"<ul> <li>Kubeconfig Management</li> <li>Security Considerations</li> <li>Dynamic Configuration</li> <li>RBAC Configuration</li> <li>Service Accounts</li> </ul>"},{"location":"configuration/kubeconfig/inventory/","title":"Kubeconfig Configuration Directory Inventory","text":"<p>This document provides a directory overview of the kubeconfig configuration resources and documentation.</p>"},{"location":"configuration/kubeconfig/inventory/#directory-contents","title":"Directory Contents","text":"<p>The kubeconfig directory contains documentation for Kubernetes authentication configuration:</p> <ul> <li>index.md: Main MkDocs documentation page for kubeconfig configuration</li> <li>inventory.md: This directory listing file</li> <li>generation.md: Guide for generating secure kubeconfig files</li> <li>management.md: Best practices for managing kubeconfig files</li> <li>security.md: Security considerations for kubeconfig files</li> <li>dynamic.md: Dynamic kubeconfig generation for CI/CD</li> </ul>"},{"location":"configuration/kubeconfig/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Kubeconfig Generation: Scripts and guidelines for creating secure kubeconfig files</li> <li>Configuration Management: Best practices for managing kubeconfig files</li> <li>Security Hardening: Security considerations for kubeconfig files</li> <li>Dynamic Configuration: Guidance for CI/CD and automated environments</li> </ul>"},{"location":"configuration/kubeconfig/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> <li>Security Framework</li> </ul>"},{"location":"configuration/kubeconfig/management/","title":"Kubeconfig Management","text":"<p>This document covers best practices for managing kubeconfig files across different environments and scenarios.</p>"},{"location":"configuration/kubeconfig/management/#basic-management-principles","title":"Basic Management Principles","text":"<p>Follow these core principles when managing kubeconfig files:</p> <ol> <li>Isolation: Use separate kubeconfig files for different environments</li> <li>Least Privilege: Configure each kubeconfig with minimal required permissions</li> <li>Expiration: Use short-lived tokens and rotate them regularly</li> <li>Security: Apply proper file permissions and secure storage</li> <li>Automation: Automate kubeconfig generation where possible</li> </ol>"},{"location":"configuration/kubeconfig/management/#file-organization","title":"File Organization","text":"<p>Organize kubeconfig files sensibly:</p> <pre><code>/secure-configs/\n  \u251c\u2500\u2500 dev/\n  \u2502   \u251c\u2500\u2500 kubeconfig-team1.yaml\n  \u2502   \u2514\u2500\u2500 kubeconfig-team2.yaml\n  \u251c\u2500\u2500 staging/\n  \u2502   \u251c\u2500\u2500 kubeconfig-team1.yaml\n  \u2502   \u2514\u2500\u2500 kubeconfig-team2.yaml\n  \u2514\u2500\u2500 prod/\n      \u251c\u2500\u2500 kubeconfig-teamA.yaml\n      \u2514\u2500\u2500 kubeconfig-teamB.yaml\n</code></pre> <p>Ensure proper permissions on all files and directories:</p> <pre><code>chmod -R 700 /secure-configs\nfind /secure-configs -type f -name \"*.yaml\" -exec chmod 600 {} \\;\n</code></pre>"},{"location":"configuration/kubeconfig/management/#multiple-environments","title":"Multiple Environments","text":"<p>Manage configurations for different environments:</p> <pre><code># Development\n./generate-kubeconfig.sh dev-namespace inspec-scanner-dev ./kubeconfig-dev.yaml\n\n# Staging\n./generate-kubeconfig.sh staging-namespace inspec-scanner-staging ./kubeconfig-staging.yaml\n\n# Production\n./generate-kubeconfig.sh prod-namespace inspec-scanner-prod ./kubeconfig-prod.yaml\n</code></pre> <p>Use naming conventions that clearly indicate the environment to prevent confusion.</p>"},{"location":"configuration/kubeconfig/management/#using-environment-variables","title":"Using Environment Variables","text":"<p>Set the <code>KUBECONFIG</code> environment variable to specify which configuration file to use:</p> <pre><code># Use development configuration\nexport KUBECONFIG=/secure-configs/dev/kubeconfig-team1.yaml\ncinc-auditor exec profile -t k8s-container://dev-namespace/pod/container\n\n# Use production configuration\nexport KUBECONFIG=/secure-configs/prod/kubeconfig-teamA.yaml\ncinc-auditor exec profile -t k8s-container://prod-namespace/pod/container\n</code></pre>"},{"location":"configuration/kubeconfig/management/#merging-kubeconfig-files","title":"Merging Kubeconfig Files","text":"<p>You can merge multiple kubeconfig files when needed:</p> <pre><code>KUBECONFIG=config1.yaml:config2.yaml:config3.yaml kubectl config view --flatten &gt; merged-config.yaml\n</code></pre> <p>This creates a single file with all contexts, which can be useful for managing multiple clusters.</p>"},{"location":"configuration/kubeconfig/management/#cicd-pipeline-management","title":"CI/CD Pipeline Management","text":"<p>For CI/CD pipelines, manage kubeconfig files carefully:</p>"},{"location":"configuration/kubeconfig/management/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Scan Container\n\non:\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: 'Environment to scan (dev/staging/prod)'\n        required: true\n        default: 'dev'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      # Set up the appropriate kubeconfig based on environment\n      - name: Configure Kubernetes\n        run: |\n          mkdir -p $HOME/.kube\n          if [ \"${{ github.event.inputs.environment }}\" == \"prod\" ]; then\n            echo \"$PROD_KUBECONFIG\" &gt; $HOME/.kube/config\n          elif [ \"${{ github.event.inputs.environment }}\" == \"staging\" ]; then\n            echo \"$STAGING_KUBECONFIG\" &gt; $HOME/.kube/config\n          else\n            echo \"$DEV_KUBECONFIG\" &gt; $HOME/.kube/config\n          fi\n          chmod 600 $HOME/.kube/config\n        env:\n          DEV_KUBECONFIG: ${{ secrets.DEV_KUBECONFIG }}\n          STAGING_KUBECONFIG: ${{ secrets.STAGING_KUBECONFIG }}\n          PROD_KUBECONFIG: ${{ secrets.PROD_KUBECONFIG }}\n</code></pre>"},{"location":"configuration/kubeconfig/management/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>scan_job:\n  stage: scan\n  script:\n    - mkdir -p $HOME/.kube\n    - |\n      if [ \"$CI_ENVIRONMENT_NAME\" == \"production\" ]; then\n        echo \"$PROD_KUBECONFIG\" &gt; $HOME/.kube/config\n      elif [ \"$CI_ENVIRONMENT_NAME\" == \"staging\" ]; then\n        echo \"$STAGING_KUBECONFIG\" &gt; $HOME/.kube/config\n      else\n        echo \"$DEV_KUBECONFIG\" &gt; $HOME/.kube/config\n      fi\n    - chmod 600 $HOME/.kube/config\n    - cinc-auditor exec profile -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME\n  variables:\n    NAMESPACE: inspec-test\n  environment:\n    name: $CI_ENVIRONMENT_NAME\n</code></pre>"},{"location":"configuration/kubeconfig/management/#token-rotation","title":"Token Rotation","text":"<p>Implement regular token rotation for better security:</p> <pre><code>#!/bin/bash\n# rotate-kubeconfig.sh\nNAMESPACE=$1\nSA_NAME=$2\nCONFIG_FILE=$3\n\n# Backup existing config\nif [ -f \"$CONFIG_FILE\" ]; then\n  cp \"$CONFIG_FILE\" \"${CONFIG_FILE}.bak\"\nfi\n\n# Generate new config with fresh token\n./generate-kubeconfig.sh \"$NAMESPACE\" \"$SA_NAME\" \"$CONFIG_FILE\"\n\necho \"Rotated kubeconfig for $SA_NAME in $NAMESPACE\"\n</code></pre> <p>Schedule this script to run regularly via cron or CI/CD pipelines.</p>"},{"location":"configuration/kubeconfig/management/#related-topics","title":"Related Topics","text":"<ul> <li>Kubeconfig Generation</li> <li>Security Considerations</li> <li>Dynamic Configuration</li> <li>RBAC Configuration</li> <li>Service Accounts</li> </ul>"},{"location":"configuration/kubeconfig/security/","title":"Kubeconfig Security Considerations","text":"<p>This document outlines important security considerations when working with kubeconfig files for InSpec container scanning.</p>"},{"location":"configuration/kubeconfig/security/#file-permissions","title":"File Permissions","text":"<p>Always set restrictive permissions on kubeconfig files:</p> <pre><code>chmod 600 kubeconfig.yaml\n</code></pre> <p>This ensures only the file owner can read or write to the file, preventing unauthorized access.</p>"},{"location":"configuration/kubeconfig/security/#token-expiration","title":"Token Expiration","text":"<p>Service account tokens have expiration times. For enhanced security, use shorter-lived tokens:</p> <pre><code># Create a kubeconfig with a short-lived token (5 minutes)\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=5m)\n# ... create kubeconfig ...\n\n# After token expiration, kubeconfig must be regenerated\n</code></pre> <p>In CI/CD environments, generate tokens with just enough time for the scanning job to complete.</p>"},{"location":"configuration/kubeconfig/security/#namespace-limitation","title":"Namespace Limitation","text":"<p>The kubeconfig sets a default namespace, but doesn't restrict access to that namespace. Access control still relies on the RBAC configuration. For proper security:</p> <ol> <li>Apply appropriate RBAC rules to limit service accounts</li> <li>Use label-based RBAC for fine-grained access control</li> <li>Specify the namespace in the context to set a default, but don't rely on it for security</li> </ol>"},{"location":"configuration/kubeconfig/security/#environment-variable-security","title":"Environment Variable Security","text":"<p>When using the <code>KUBECONFIG</code> environment variable:</p> <pre><code>KUBECONFIG=./secure-kubeconfig.yaml kubectl get pods\n</code></pre> <p>Be aware that environment variables may be visible in process listings or logs. In shared environments, prefer file-based configuration with proper permissions.</p>"},{"location":"configuration/kubeconfig/security/#secret-management","title":"Secret Management","text":"<p>In CI/CD environments, store kubeconfig files as secrets:</p>"},{"location":"configuration/kubeconfig/security/#github-actions","title":"GitHub Actions","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Configure Kubernetes\n        run: |\n          mkdir -p $HOME/.kube\n          echo \"$KUBE_CONFIG\" &gt; $HOME/.kube/config\n          chmod 600 $HOME/.kube/config\n        env:\n          KUBE_CONFIG: ${{ secrets.KUBECONFIG }}\n</code></pre>"},{"location":"configuration/kubeconfig/security/#gitlab-ci","title":"GitLab CI","text":"<pre><code>container-scan:\n  stage: scan\n  script:\n    - mkdir -p $HOME/.kube\n    - echo \"$KUBE_CONFIG\" &gt; $HOME/.kube/config\n    - chmod 600 $HOME/.kube/config\n    - cinc-auditor exec profile -t k8s-container://namespace/pod/container\n  variables:\n    KUBE_CONFIG: ${{ secrets.KUBECONFIG }}\n</code></pre>"},{"location":"configuration/kubeconfig/security/#multiple-environments","title":"Multiple Environments","text":"<p>For different environments (dev, test, prod), create separate kubeconfig files with appropriate RBAC permissions:</p> <pre><code># Development - may have more permissive rights\n./generate-kubeconfig.sh dev-namespace inspec-scanner-dev ./kubeconfig-dev.yaml\n\n# Production - should have more restricted rights\n./generate-kubeconfig.sh prod-namespace inspec-scanner-prod ./kubeconfig-prod.yaml\n</code></pre> <p>This approach prevents development credentials from accessing production systems.</p>"},{"location":"configuration/kubeconfig/security/#audit-and-rotation","title":"Audit and Rotation","text":"<p>Regularly rotate service account tokens and audit kubeconfig usage:</p> <pre><code># Recreate the service account to invalidate all existing tokens\nkubectl delete sa inspec-scanner -n inspec-test\nkubectl create sa inspec-scanner -n inspec-test\n\n# Generate new kubeconfig\n./generate-kubeconfig.sh inspec-test inspec-scanner ./new-kubeconfig.yaml\n</code></pre>"},{"location":"configuration/kubeconfig/security/#related-topics","title":"Related Topics","text":"<ul> <li>Kubeconfig Generation</li> <li>Kubeconfig Management</li> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> </ul>"},{"location":"configuration/plugins/","title":"Plugin Customization","text":"<p>Directory Inventory</p> <p>See the Plugins Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides documentation for customizing InSpec plugins for specialized container scanning needs.</p>"},{"location":"configuration/plugins/#plugin-customization-overview","title":"Plugin Customization Overview","text":"<p>InSpec uses plugins for transport-specific operations. The <code>train-k8s-container</code> plugin enables scanning Kubernetes containers via the Kubernetes API. This section covers how to modify and extend this plugin for advanced scanning scenarios.</p> <p>STRATEGIC PRIORITY: Enhancing the train-k8s-container plugin to support distroless containers through the Kubernetes API Approach represents our highest strategic priority for enterprise container scanning. This is the recommended approach for production environments and is essential for comprehensive security compliance.</p>"},{"location":"configuration/plugins/#customization-guides","title":"Customization Guides","text":"<ul> <li>Distroless Container Support - Modifications for scanning distroless containers</li> <li>Implementation Guide - Detailed implementation steps</li> <li>Testing Guide - Testing modifications and customizations</li> </ul>"},{"location":"configuration/plugins/#common-use-cases","title":"Common Use Cases","text":"Use Case Guide Description Distroless Containers Distroless Support Enable scanning for containers without shells Implementation Implementation Step-by-step implementation guide Testing Testing Test your modifications thoroughly"},{"location":"configuration/plugins/#getting-started","title":"Getting Started","text":"<p>Before customizing plugins, you should understand the current architecture. The train-k8s-container plugin works by:</p> <ol> <li>Creating a connection to a Kubernetes cluster via kubeconfig</li> <li>Using <code>kubectl exec</code> to execute commands in the target container</li> <li>Running CINC Auditor controls that rely on command execution</li> </ol> <p>Key files in the plugin that would need modification:</p> <ol> <li><code>lib/train/k8s/container/connection.rb</code> - Main connection class</li> <li><code>lib/train/k8s/container/kubectl_exec_client.rb</code> - Handles command execution</li> <li><code>lib/train/transport/k8s_container.rb</code> - Transport entry point</li> </ol>"},{"location":"configuration/plugins/#strategic-importance","title":"Strategic Importance","text":"<p>Plugin customization, particularly for distroless container support, is a top strategic priority because:</p> <ol> <li>Consistent User Experience: Users will use identical commands for all container types</li> <li>Maximum Security Compliance: The Kubernetes API Approach maintains all security boundaries</li> <li>Enterprise Scalability: One solution for all container types simplifies deployment</li> <li>Simplified CI/CD Integration: CI/CD pipelines can use a single approach for all workloads</li> <li>Unified Documentation: Streamlined documentation and training</li> </ol>"},{"location":"configuration/plugins/#related-topics","title":"Related Topics","text":"<ul> <li>Kubernetes API Approach</li> <li>Debug Container Approach</li> <li>Distroless Container Basics</li> </ul>"},{"location":"configuration/plugins/distroless/","title":"Distroless Container Support","text":"<p>This document outlines the modifications needed in the CINC Auditor train-k8s-container plugin to support scanning distroless containers using Kubernetes ephemeral containers.</p>"},{"location":"configuration/plugins/distroless/#what-are-distroless-containers","title":"What are Distroless Containers?","text":"<p>Distroless containers are minimal container images that don't contain a shell or package managers, only the application and its runtime dependencies. This reduces the attack surface but makes traditional scanning more difficult.</p>"},{"location":"configuration/plugins/distroless/#current-plugin-limitations","title":"Current Plugin Limitations","text":"<p>The current train-k8s-container plugin has these limitations with distroless containers:</p> <ol> <li>Relies on shell execution (not available in distroless containers)</li> <li>Cannot execute commands directly in the container</li> <li>Has no fallback mechanism for containers without shells</li> </ol>"},{"location":"configuration/plugins/distroless/#required-modifications","title":"Required Modifications","text":""},{"location":"configuration/plugins/distroless/#1-distroless-detection","title":"1. Distroless Detection","text":"<p>Add capability to detect distroless containers by attempting to execute a simple shell command and checking for failure:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef distroless?(namespace, pod, container)\n  cmd = [\"kubectl\", \"exec\", \"-n\", namespace, pod, \"-c\", container, \"--\", \"/bin/sh\", \"-c\", \"echo test\"]\n  begin\n    result = Train::Extras::CommandWrapper.run(cmd.join(\" \"), nil)\n    return false # Container has shell\n  rescue Train::Errors::CommandExecutionError\n    return true # Container is likely distroless\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/distroless/#2-ephemeral-container-creation","title":"2. Ephemeral Container Creation","text":"<p>Add functionality to create and connect to an ephemeral container:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef setup_ephemeral_container(namespace, pod, target_container)\n  debug_container_name = \"inspec-debug-#{SecureRandom.hex(4)}\"\n  debug_image = \"alpine:latest\" # or a custom image with needed tools\n\n  # Create ephemeral container\n  cmd = [\n    \"kubectl\", \"debug\", pod, \n    \"-n\", namespace, \n    \"--image=#{debug_image}\", \n    \"--target=#{target_container}\", \n    \"--container=#{debug_container_name}\", \n    \"--quiet\", \"-it\", \"--\", \"sleep\", \"3600\"\n  ]\n\n  # Run in background\n  pid = Process.spawn(cmd.join(\" \"), [:out, :err] =&gt; \"/dev/null\")\n  Process.detach(pid)\n\n  # Wait for ephemeral container to be ready\n  sleep 5\n\n  # Return ephemeral container info\n  {\n    name: debug_container_name,\n    pid: pid\n  }\nend\n</code></pre>"},{"location":"configuration/plugins/distroless/#3-connection-strategy-switching","title":"3. Connection Strategy Switching","text":"<p>Modify the connection logic to choose between standard and ephemeral container approaches:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef initialize(options)\n  @options = options\n  @namespace = options[:namespace]\n  @pod = options[:pod]\n  @container = options[:container]\n\n  # Detect if container is distroless\n  if distroless?(@namespace, @pod, @container)\n    @ephemeral = setup_ephemeral_container(@namespace, @pod, @container)\n    @container = @ephemeral[:name] # Use ephemeral container for commands\n    @using_ephemeral = true\n  else\n    @using_ephemeral = false\n  end\n\n  # Initialize kubernetes client\n  @k8s_client = KubectlExecClient.new(\n    namespace: @namespace,\n    pod: @pod,\n    container: @container,\n    kubeconfig: @options[:kubeconfig]\n  )\nend\n\ndef close\n  # Clean up ephemeral container if used\n  if @using_ephemeral &amp;&amp; @ephemeral[:pid]\n    Process.kill('TERM', @ephemeral[:pid])\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/distroless/#4-file-access-for-distroless-containers","title":"4. File Access for Distroless Containers","text":"<p>Modify file access methods to work through the ephemeral container:</p> <pre><code># in lib/train/k8s/container/connection.rb\n\ndef file(path)\n  if @using_ephemeral\n    # For distroless containers, access target container filesystem via /proc\n    # First, get the process ID of the target container's entrypoint\n    target_pid_cmd = \"ps -ef | grep #{@options[:container]} | grep -v grep | awk '{print $2}' | head -1\"\n    target_pid = @k8s_client.run_command(target_pid_cmd).stdout.strip\n\n    # Access target container's filesystem via /proc\n    modified_path = \"/proc/#{target_pid}/root#{path}\"\n    Train::File::Local.new(self, modified_path)\n  else\n    # Standard file access\n    Train::File::Remote.new(self, path)\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/distroless/#5-command-execution-handling","title":"5. Command Execution Handling","text":"<p>Update command execution to handle the distroless case:</p> <pre><code># in lib/train/k8s/container/kubectl_exec_client.rb\n\ndef run_command(command)\n  if @connection.using_ephemeral?\n    # In ephemeral container, we might need to modify commands to access the target container\n    # This depends on how exactly we want to interact with the target container\n    modified_command = command\n    super(modified_command)\n  else\n    # Standard command execution\n    super(command)\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/distroless/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Fork the Repository: Create a fork of the train-k8s-container plugin</li> <li>Create Branch: Create a feature branch for distroless support</li> <li>Implement Changes: Make the modifications outlined above</li> <li>Add Tests: Create tests for distroless container detection and scanning</li> <li>Document: Document the new capabilities and how to use them</li> <li>Submit PR: Consider submitting a pull request to the upstream repository</li> </ol>"},{"location":"configuration/plugins/distroless/#integration-with-our-project","title":"Integration with Our Project","text":"<p>After modifying the plugin, we would need to:</p> <ol> <li>Update our Gemfile to point to our fork of the plugin</li> <li>Update our scan-container.sh script to handle the new capabilities</li> <li>Create documentation on how to scan distroless containers</li> <li>Update our Helm chart to include the new plugin version</li> <li>Test with various distroless container types</li> </ol>"},{"location":"configuration/plugins/distroless/#example-usage","title":"Example Usage","text":"<p>With the modified plugin, the command to scan a distroless container would remain the same:</p> <pre><code>cinc-auditor exec my-profile -t k8s-container://namespace/pod/container\n</code></pre> <p>The plugin would automatically:</p> <ol> <li>Detect the container is distroless</li> <li>Create an ephemeral container</li> <li>Execute the scan through the ephemeral container</li> <li>Clean up the ephemeral container when done</li> </ol>"},{"location":"configuration/plugins/distroless/#potential-limitations","title":"Potential Limitations","text":"<ol> <li>Permissions: Requires permissions to create ephemeral containers</li> <li>Kubernetes Version: Requires Kubernetes v1.18+ for ephemeral containers</li> <li>Image Compatibility: The debug image must have required tools</li> <li>Process Isolation: May have issues with certain container runtimes</li> </ol>"},{"location":"configuration/plugins/distroless/#related-topics","title":"Related Topics","text":"<ul> <li>Implementation Guide</li> <li>Testing Guide</li> <li>Kubernetes API Approach</li> <li>Debug Container Approach</li> <li>Distroless Container Basics</li> </ul>"},{"location":"configuration/plugins/implementation/","title":"Plugin Modifications Implementation Guide","text":"<p>This document provides a detailed step-by-step guide for implementing the modifications to the train-k8s-container plugin to support distroless containers.</p>"},{"location":"configuration/plugins/implementation/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"configuration/plugins/implementation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ruby development environment (Ruby 2.7+)</li> <li>Bundler (for dependency management)</li> <li>Git</li> <li>Kubernetes cluster with ephemeral container support</li> <li>kubectl configured with appropriate permissions</li> </ul>"},{"location":"configuration/plugins/implementation/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/your-username/train-k8s-container.git\ncd train-k8s-container\n\n# Create a feature branch\ngit checkout -b feature/distroless-support\n\n# Install dependencies\nbundle install\n</code></pre>"},{"location":"configuration/plugins/implementation/#file-structure","title":"File Structure","text":"<p>The key files to modify are:</p> <pre><code>lib/\n  train/\n    k8s/\n      container/\n        connection.rb         # Main connection class\n        kubectl_exec_client.rb # Handles command execution\n    transport/\n      k8s_container.rb       # Transport entry point\nspec/\n  k8s_container/\n    connection_spec.rb       # Tests for connection class\n</code></pre>"},{"location":"configuration/plugins/implementation/#implementation-steps","title":"Implementation Steps","text":""},{"location":"configuration/plugins/implementation/#step-1-add-distroless-detection","title":"Step 1: Add Distroless Detection","text":"<p>Modify <code>lib/train/k8s/container/connection.rb</code> to add distroless detection:</p> <pre><code>module Train::K8s\n  class Container\n    class Connection &lt; Train::Plugins::Transport::BaseConnection\n      # Add this method to the Connection class\n      def distroless?(namespace, pod, container)\n        cmd = [\"kubectl\", \"exec\", \"-n\", namespace, pod, \"-c\", container, \"--\", \"/bin/sh\", \"-c\", \"echo test\"]\n        begin\n          result = Train::Extras::CommandWrapper.run(cmd.join(\" \"), nil)\n          return false # Container has shell\n        rescue Train::Errors::CommandExecutionError\n          return true # Container is likely distroless\n        end\n      end\n\n      # Rest of the class...\n    end\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#step-2-add-ephemeral-container-support","title":"Step 2: Add Ephemeral Container Support","text":"<p>Add the ephemeral container setup method to the Connection class:</p> <pre><code>def setup_ephemeral_container(namespace, pod, target_container)\n  require 'securerandom'\n  debug_container_name = \"inspec-debug-#{SecureRandom.hex(4)}\"\n  debug_image = \"alpine:latest\" # or a custom image with needed tools\n\n  # Create ephemeral container\n  cmd = [\n    \"kubectl\", \"debug\", pod, \n    \"-n\", namespace, \n    \"--image=#{debug_image}\", \n    \"--target=#{target_container}\", \n    \"--container=#{debug_container_name}\", \n    \"--quiet\", \"-it\", \"--\", \"sleep\", \"3600\"\n  ]\n\n  # Run in background\n  pid = Process.spawn(cmd.join(\" \"), [:out, :err] =&gt; \"/dev/null\")\n  Process.detach(pid)\n\n  # Wait for ephemeral container to be ready\n  sleep 5\n\n  # Return ephemeral container info\n  {\n    name: debug_container_name,\n    pid: pid\n  }\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#step-3-modify-the-connection-initialization","title":"Step 3: Modify the Connection Initialization","text":"<p>Update the <code>initialize</code> and <code>close</code> methods in the Connection class:</p> <pre><code>def initialize(options)\n  super(options)\n  @options = options\n  @namespace = options[:namespace]\n  @pod = options[:pod]\n  @container = options[:container]\n\n  # Detect if container is distroless\n  if distroless?(@namespace, @pod, @container)\n    @ephemeral = setup_ephemeral_container(@namespace, @pod, @container)\n    @container = @ephemeral[:name] # Use ephemeral container for commands\n    @using_ephemeral = true\n  else\n    @using_ephemeral = false\n  end\n\n  # Initialize kubernetes client\n  @k8s_client = KubectlExecClient.new(\n    namespace: @namespace,\n    pod: @pod,\n    container: @container,\n    kubeconfig: @options[:kubeconfig]\n  )\nend\n\ndef close\n  # Clean up ephemeral container if used\n  if @using_ephemeral &amp;&amp; @ephemeral[:pid]\n    Process.kill('TERM', @ephemeral[:pid])\n  end\nend\n\n# Add an accessor for the ephemeral container flag\ndef using_ephemeral?\n  @using_ephemeral\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#step-4-modify-file-access-for-distroless-containers","title":"Step 4: Modify File Access for Distroless Containers","text":"<p>Update the <code>file</code> method to work with distroless containers:</p> <pre><code>def file(path)\n  if @using_ephemeral\n    # For distroless containers, access target container filesystem via /proc\n    # First, get the process ID of the target container's entrypoint\n    target_pid_cmd = \"ps -ef | grep #{@options[:container]} | grep -v grep | awk '{print $2}' | head -1\"\n    target_pid = @k8s_client.run_command(target_pid_cmd).stdout.strip\n\n    if target_pid.empty?\n      logger.warn(\"Could not find PID for target container #{@options[:container]}\")\n      # Fallback to standard file access\n      Train::File::Remote.new(self, path)\n    else\n      # Access target container's filesystem via /proc\n      modified_path = \"/proc/#{target_pid}/root#{path}\"\n      logger.debug(\"Accessing #{path} via #{modified_path}\")\n      # Use Local file implementation since we're inside the ephemeral container\n      Train::File::Local.new(self, modified_path)\n    end\n  else\n    # Standard file access\n    Train::File::Remote.new(self, path)\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#step-5-update-the-command-execution-client","title":"Step 5: Update the Command Execution Client","text":"<p>Modify <code>lib/train/k8s/container/kubectl_exec_client.rb</code> to handle distroless containers:</p> <pre><code>module Train::K8s\n  class Container\n    class KubectlExecClient\n      # Add a reference to the connection\n      attr_reader :connection\n\n      # Update the initializer to store the connection reference\n      def initialize(options)\n        @namespace = options[:namespace]\n        @pod = options[:pod]\n        @container = options[:container]\n        @kubeconfig = options[:kubeconfig]\n        @connection = options[:connection]\n      end\n\n      # Modify the run_command method\n      def run_command(command)\n        # Build the kubectl exec command\n        cmd = build_kubectl_exec_command(command)\n\n        # Execute the command and handle the result\n        result = execute_cmd(cmd)\n\n        # Return the result as a CommandResult\n        CommandResult.new(result.stdout, result.stderr, result.exit_status)\n      end\n\n      private\n\n      def build_kubectl_exec_command(command)\n        # Build kubectl exec command with proper options\n        [\"kubectl\", \"exec\", \"-n\", @namespace, @pod, \"-c\", @container, \"--\", \"/bin/sh\", \"-c\", command]\n      end\n\n      def execute_cmd(cmd)\n        # Execute the command and handle errors\n        begin\n          Train::Extras::CommandWrapper.run(cmd.join(\" \"), nil)\n        rescue Train::Errors::CommandExecutionError =&gt; e\n          # Return the failed command result\n          OpenStruct.new(\n            stdout: e.stdout,\n            stderr: e.stderr,\n            exit_status: e.exit_status\n          )\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#step-6-update-the-transport-class","title":"Step 6: Update the Transport Class","text":"<p>Modify <code>lib/train/transport/k8s_container.rb</code> to pass the connection reference to the exec client:</p> <pre><code>module Train::Transport\n  class K8sContainer &lt; Train.plugin(1)\n    name \"k8s-container\"\n\n    # ... existing code ...\n\n    def connection(options = {})\n      @connection ||= Train::K8s::Container::Connection.new(options)\n    end\n  end\nend\n</code></pre> <p>Make sure the KubectlExecClient receives the connection reference in the Connection class:</p> <pre><code># In lib/train/k8s/container/connection.rb\n\ndef initialize(options)\n  # ... existing code ...\n\n  # Initialize kubernetes client with reference to this connection\n  @k8s_client = KubectlExecClient.new(\n    namespace: @namespace,\n    pod: @pod,\n    container: @container,\n    kubeconfig: @options[:kubeconfig],\n    connection: self  # Add this line\n  )\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#adding-tests","title":"Adding Tests","text":"<p>Add tests for the new functionality in <code>spec/k8s_container/connection_spec.rb</code>:</p> <pre><code>require 'spec_helper'\n\ndescribe Train::K8s::Container::Connection do\n  let(:options) do\n    {\n      namespace: 'default',\n      pod: 'test-pod',\n      container: 'test-container',\n      kubeconfig: '/path/to/kubeconfig'\n    }\n  end\n\n  subject { described_class.new(options) }\n\n  describe '#distroless?' do\n    context 'when container has a shell' do\n      before do\n        allow(Train::Extras::CommandWrapper).to receive(:run).and_return(double(stdout: \"test\\n\", stderr: \"\", exit_status: 0))\n      end\n\n      it 'returns false' do\n        expect(subject.distroless?('default', 'test-pod', 'test-container')).to be false\n      end\n    end\n\n    context 'when container does not have a shell' do\n      before do\n        allow(Train::Extras::CommandWrapper).to receive(:run).and_raise(Train::Errors::CommandExecutionError.new('Error', '', '', 1))\n      end\n\n      it 'returns true' do\n        expect(subject.distroless?('default', 'test-pod', 'test-container')).to be true\n      end\n    end\n  end\n\n  # Add more tests for other functionality\nend\n</code></pre>"},{"location":"configuration/plugins/implementation/#building-and-installing-the-plugin","title":"Building and Installing the Plugin","text":"<pre><code># Build the gem\ngem build train-k8s-container.gemspec\n\n# Install the gem locally for testing\ngem install ./train-k8s-container-x.y.z.gem\n</code></pre>"},{"location":"configuration/plugins/implementation/#related-topics","title":"Related Topics","text":"<ul> <li>Distroless Container Support</li> <li>Testing Guide</li> <li>Kubernetes API Approach</li> </ul>"},{"location":"configuration/plugins/inventory/","title":"Plugin Customization Directory Inventory","text":"<p>This document provides a directory overview of the plugin customization resources and documentation.</p>"},{"location":"configuration/plugins/inventory/#directory-contents","title":"Directory Contents","text":"<p>The plugins directory contains documentation for customizing InSpec plugins:</p> <ul> <li>index.md: Main MkDocs documentation page for plugin customization</li> <li>inventory.md: This directory listing file</li> <li>distroless.md: Documentation for distroless container support modifications</li> <li>implementation.md: Implementation guide for plugin modifications</li> <li>testing.md: Testing guide for plugin modifications</li> </ul>"},{"location":"configuration/plugins/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Distroless Support: Modifications to support scanning distroless containers</li> <li>Implementation Guidance: Detailed implementation steps for plugin modifications</li> <li>Testing Framework: Methods to test and validate plugin modifications</li> </ul>"},{"location":"configuration/plugins/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Kubernetes API Approach</li> <li>Debug Container Approach</li> <li>Distroless Container Basics</li> </ul>"},{"location":"configuration/plugins/testing/","title":"Testing Plugin Modifications","text":"<p>This document provides guidelines for testing the modifications to the train-k8s-container plugin, particularly for distroless container support.</p>"},{"location":"configuration/plugins/testing/#testing-approach","title":"Testing Approach","text":"<p>Testing the plugin modifications requires a combination of unit tests, integration tests, and end-to-end tests. This ensures that the plugin works correctly across different scenarios and environments.</p>"},{"location":"configuration/plugins/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"configuration/plugins/testing/#setting-up-unit-tests","title":"Setting Up Unit Tests","text":"<p>Unit tests for the train-k8s-container plugin are written using RSpec. They can be found in the <code>spec</code> directory.</p> <pre><code># Install testing dependencies\nbundle install --with development\n\n# Run the unit tests\nbundle exec rake spec\n</code></pre>"},{"location":"configuration/plugins/testing/#key-unit-tests-to-implement","title":"Key Unit Tests to Implement","text":"<ol> <li>Distroless Detection Tests</li> </ol> <pre><code>describe '#distroless?' do\n  context 'when container has a shell' do\n    before do\n      allow(Train::Extras::CommandWrapper).to receive(:run).and_return(double(stdout: \"test\\n\", stderr: \"\", exit_status: 0))\n    end\n\n    it 'returns false' do\n      expect(subject.distroless?('default', 'test-pod', 'test-container')).to be false\n    end\n  end\n\n  context 'when container does not have a shell' do\n    before do\n      allow(Train::Extras::CommandWrapper).to receive(:run).and_raise(Train::Errors::CommandExecutionError.new('Error', '', '', 1))\n    end\n\n    it 'returns true' do\n      expect(subject.distroless?('default', 'test-pod', 'test-container')).to be true\n    end\n  end\nend\n</code></pre> <ol> <li>Ephemeral Container Tests</li> </ol> <pre><code>describe '#setup_ephemeral_container' do\n  before do\n    allow(Process).to receive(:spawn).and_return(12345)\n    allow(Process).to receive(:detach)\n    allow_any_instance_of(Object).to receive(:sleep)\n  end\n\n  it 'creates an ephemeral container and returns its details' do\n    result = subject.setup_ephemeral_container('default', 'test-pod', 'test-container')\n    expect(result).to include(:name, :pid)\n    expect(result[:pid]).to eq(12345)\n    expect(result[:name]).to match(/^inspec-debug-/)\n  end\nend\n</code></pre> <ol> <li>File Access Tests</li> </ol> <pre><code>describe '#file' do\n  context 'with standard container' do\n    before do\n      subject.instance_variable_set(:@using_ephemeral, false)\n    end\n\n    it 'returns a Remote file instance' do\n      expect(Train::File::Remote).to receive(:new).with(subject, '/etc/passwd')\n      subject.file('/etc/passwd')\n    end\n  end\n\n  context 'with distroless container' do\n    before do\n      subject.instance_variable_set(:@using_ephemeral, true)\n      subject.instance_variable_set(:@options, { container: 'test-container' })\n      allow(subject.instance_variable_get(:@k8s_client)).to receive(:run_command).and_return(double(stdout: \"123\\n\", stderr: \"\", exit_status: 0))\n    end\n\n    it 'returns a Local file instance with modified path' do\n      expect(Train::File::Local).to receive(:new).with(subject, '/proc/123/root/etc/passwd')\n      subject.file('/etc/passwd')\n    end\n  end\nend\n</code></pre>"},{"location":"configuration/plugins/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"configuration/plugins/testing/#setting-up-a-test-environment","title":"Setting Up a Test Environment","text":"<p>For integration testing, set up a Kubernetes cluster with both standard and distroless containers:</p> <pre><code># Start minikube with ephemeral container support\nminikube start --kubernetes-version=v1.23.0\n\n# Deploy a standard container\nkubectl create deployment nginx --image=nginx\n\n# Deploy a distroless container\nkubectl create deployment distroless --image=gcr.io/distroless/static-debian11\n</code></pre>"},{"location":"configuration/plugins/testing/#manual-integration-tests","title":"Manual Integration Tests","text":"<ol> <li>Test with standard container:</li> </ol> <pre><code># Run InSpec with modified plugin against standard container\nINSPEC_LOG_LEVEL=debug inspec exec profile -t k8s-container://default/$(kubectl get pods -l app=nginx -o name | cut -d/ -f2)/nginx\n</code></pre> <ol> <li>Test with distroless container:</li> </ol> <pre><code># Run InSpec with modified plugin against distroless container\nINSPEC_LOG_LEVEL=debug inspec exec profile -t k8s-container://default/$(kubectl get pods -l app=distroless -o name | cut -d/ -f2)/distroless\n</code></pre>"},{"location":"configuration/plugins/testing/#automated-integration-tests","title":"Automated Integration Tests","text":"<p>Create an integration test script:</p> <pre><code>#!/usr/bin/env ruby\nrequire 'json'\n\ndef run_test(name, namespace, pod, container)\n  puts \"Running test: #{name}\"\n  cmd = \"inspec exec ./test-profile -t k8s-container://#{namespace}/#{pod}/#{container} --reporter json\"\n  output = `#{cmd}`\n  begin\n    result = JSON.parse(output)\n    status = result['profiles'][0]['status'] == 'passed' ? \"PASSED\" : \"FAILED\"\n    puts \"Test #{name}: #{status}\"\n    puts \"Summary: #{result['profiles'][0]['controls'].size} controls, #{result['profiles'][0]['controls'].count { |c| c['status'] == 'passed' }} passed\"\n  rescue =&gt; e\n    puts \"Error parsing results: #{e.message}\"\n    puts output\n  end\nend\n\n# Get pods\nnginx_pod = `kubectl get pods -l app=nginx -o name | cut -d/ -f2`.strip\ndistroless_pod = `kubectl get pods -l app=distroless -o name | cut -d/ -f2`.strip\n\n# Run tests\nrun_test(\"Standard Container\", \"default\", nginx_pod, \"nginx\")\nrun_test(\"Distroless Container\", \"default\", distroless_pod, \"distroless\")\n</code></pre>"},{"location":"configuration/plugins/testing/#end-to-end-testing","title":"End-to-End Testing","text":""},{"location":"configuration/plugins/testing/#test-with-real-profiles","title":"Test with Real Profiles","text":"<p>Test the plugin with real compliance profiles to ensure it works in practical scenarios:</p> <pre><code># Test with DevSec Linux Baseline\ninspec exec https://github.com/dev-sec/linux-baseline -t k8s-container://default/nginx-pod/nginx\n\n# Test with DevSec Linux Baseline against distroless container\ninspec exec https://github.com/dev-sec/linux-baseline -t k8s-container://default/distroless-pod/distroless\n</code></pre>"},{"location":"configuration/plugins/testing/#test-in-cicd-environment","title":"Test in CI/CD Environment","text":"<p>Test the plugin in a CI/CD environment to ensure it works in automated pipelines:</p> <pre><code># GitHub Actions workflow for testing\nname: Test Plugin\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n\n      - name: Deploy test containers\n        run: |\n          kubectl create deployment nginx --image=nginx\n          kubectl create deployment distroless --image=gcr.io/distroless/static-debian11\n          kubectl wait --for=condition=available deployment/nginx deployment/distroless --timeout=60s\n\n      - name: Install plugin\n        run: |\n          gem build train-k8s-container.gemspec\n          gem install ./train-k8s-container-*.gem\n\n      - name: Run tests\n        run: ruby ./integration_test.rb\n</code></pre>"},{"location":"configuration/plugins/testing/#performance-testing","title":"Performance Testing","text":"<p>Measure the performance impact of the modifications:</p> <pre><code># Time standard container scan\ntime inspec exec profile -t k8s-container://default/nginx-pod/nginx\n\n# Time distroless container scan\ntime inspec exec profile -t k8s-container://default/distroless-pod/distroless\n</code></pre>"},{"location":"configuration/plugins/testing/#compatibility-testing","title":"Compatibility Testing","text":"<p>Test with different Kubernetes versions and configurations:</p> <pre><code># Test with different Kubernetes versions\nfor k8s_version in 1.19.0 1.20.0 1.21.0 1.22.0 1.23.0; do\n  echo \"Testing with Kubernetes ${k8s_version}\"\n  minikube delete\n  minikube start --kubernetes-version=${k8s_version}\n  # Deploy test containers and run tests\n  kubectl create deployment nginx --image=nginx\n  kubectl create deployment distroless --image=gcr.io/distroless/static-debian11\n  # Wait for pods to be ready\n  kubectl wait --for=condition=ready pod -l app=nginx --timeout=60s\n  kubectl wait --for=condition=ready pod -l app=distroless --timeout=60s\n  # Run tests\n  ruby ./integration_test.rb\ndone\n</code></pre>"},{"location":"configuration/plugins/testing/#test-various-distroless-images","title":"Test Various Distroless Images","text":"<p>Test with different distroless container images to ensure compatibility:</p> <pre><code># Test with various distroless images\ndistroless_images=(\n  \"gcr.io/distroless/static-debian11\"\n  \"gcr.io/distroless/base-debian11\"\n  \"gcr.io/distroless/java11-debian11\"\n  \"gcr.io/distroless/nodejs16-debian11\"\n  \"gcr.io/distroless/python3-debian11\"\n)\n\nfor image in \"${distroless_images[@]}\"; do\n  echo \"Testing with image: ${image}\"\n  kubectl create deployment test-distroless --image=${image}\n  kubectl wait --for=condition=ready pod -l app=test-distroless --timeout=60s\n  pod=$(kubectl get pods -l app=test-distroless -o name | cut -d/ -f2)\n  inspec exec profile -t k8s-container://default/${pod}/test-distroless\n  kubectl delete deployment test-distroless\ndone\n</code></pre>"},{"location":"configuration/plugins/testing/#debugging-tips","title":"Debugging Tips","text":""},{"location":"configuration/plugins/testing/#troubleshooting-test-failures","title":"Troubleshooting Test Failures","text":"<p>If tests fail, increase the log level for more detailed output:</p> <pre><code>INSPEC_LOG_LEVEL=debug inspec exec profile -t k8s-container://default/pod/container\n</code></pre> <p>Check for common issues:</p> <ul> <li>Kubernetes permissions - ensure your kubeconfig has proper permissions</li> <li>Ephemeral container support - verify your Kubernetes version supports it</li> <li>Image compatibility - ensure the debug image has the necessary tools</li> </ul>"},{"location":"configuration/plugins/testing/#debugging-ephemeral-containers","title":"Debugging Ephemeral Containers","text":"<p>To debug ephemeral containers directly:</p> <pre><code># Start an ephemeral container manually\nkubectl debug pod/distroless-pod -it --image=alpine -- sh\n\n# Check process tree inside the ephemeral container\nps -ef\n\n# Explore the filesystem of the target container\nls -la /proc/&lt;PID&gt;/root/\n\n# Test commands on the target container filesystem\ncat /proc/&lt;PID&gt;/root/etc/os-release\n</code></pre>"},{"location":"configuration/plugins/testing/#related-topics","title":"Related Topics","text":"<ul> <li>Distroless Container Support</li> <li>Implementation Guide</li> <li>Kubernetes API Approach</li> <li>Debug Container Approach</li> </ul>"},{"location":"configuration/security/","title":"Security Configuration","text":"<p>Directory Inventory</p> <p>See the Security Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides documentation for security-focused configurations of the CINC Auditor container scanning solution.</p>"},{"location":"configuration/security/#security-configuration-overview","title":"Security Configuration Overview","text":"<p>Security configurations ensure that the scanner operates in a secure manner and maintains appropriate access controls. Key security considerations include:</p> <ol> <li>Credential Management: Secure handling of kubeconfig files and tokens</li> <li>RBAC Hardening: Configuring least-privilege role-based access</li> <li>Network Security: Securing network communications between components</li> </ol>"},{"location":"configuration/security/#security-configuration-guides","title":"Security Configuration Guides","text":"<ul> <li>Hardening Configuration - Security hardening recommendations</li> <li>Credential Management - Secure management of authentication credentials</li> <li>RBAC Configuration - Role-based access control for scanners</li> </ul>"},{"location":"configuration/security/#common-use-cases","title":"Common Use Cases","text":"Use Case Guide Description Production Deployment Hardening Secure configuration for production environments Sensitive Environments Credentials Managing credentials in high-security environments Multi-tenant Clusters RBAC Isolating scanner access between tenants"},{"location":"configuration/security/#getting-started","title":"Getting Started","text":"<p>Most users should begin with the Hardening Configuration to understand the basic security recommendations, followed by the specific guides relevant to their deployment scenario.</p>"},{"location":"configuration/security/#related-topics","title":"Related Topics","text":"<ul> <li>Kubeconfig Configuration</li> <li>RBAC Configuration</li> <li>Security Considerations</li> <li>Threat Model</li> </ul>"},{"location":"configuration/security/credentials/","title":"Secure Credential Management","text":"<p>This document covers secure management of authentication credentials for the CINC Auditor container scanning solution.</p>"},{"location":"configuration/security/credentials/#types-of-credentials","title":"Types of Credentials","text":"<p>The scanning solution uses several types of credentials:</p> <ol> <li>Kubeconfig Files: For Kubernetes API authentication</li> <li>Service Account Tokens: For service account authentication</li> <li>TLS Certificates: For secure communication with the Kubernetes API</li> <li>CI/CD Secrets: For secure pipeline integration</li> </ol>"},{"location":"configuration/security/credentials/#kubeconfig-security","title":"Kubeconfig Security","text":""},{"location":"configuration/security/credentials/#file-storage","title":"File Storage","text":"<p>Store kubeconfig files securely:</p> <pre><code># Create secure directory\nmkdir -p ~/.kube/secure\nchmod 700 ~/.kube/secure\n\n# Store kubeconfig with restricted permissions\ncp kubeconfig.yaml ~/.kube/secure/\nchmod 600 ~/.kube/secure/kubeconfig.yaml\n</code></pre>"},{"location":"configuration/security/credentials/#environment-variables","title":"Environment Variables","text":"<p>Be cautious with environment variables:</p> <pre><code># Using environment variables (note security considerations)\nexport KUBECONFIG=~/.kube/secure/kubeconfig.yaml\n\n# Avoid print or export commands that might expose the variable in logs\nset +x  # Turn off command echo\n</code></pre>"},{"location":"configuration/security/credentials/#memory-only-storage","title":"Memory-Only Storage","text":"<p>For highest security, keep credentials in memory only:</p> <pre><code># Generate kubeconfig in a subshell\n$(kubectl config set-credentials scanner-user --token=$(kubectl create token scanner-sa -n scanner-namespace) --kubeconfig=/dev/shm/temp-config)\n$(kubectl config set-cluster scanner-cluster --server=... --kubeconfig=/dev/shm/temp-config)\n$(kubectl config set-context scanner-context --cluster=scanner-cluster --user=scanner-user --kubeconfig=/dev/shm/temp-config)\n\n# Use the in-memory kubeconfig\nKUBECONFIG=/dev/shm/temp-config cinc-auditor exec ...\n\n# Clean up\nrm /dev/shm/temp-config\n</code></pre>"},{"location":"configuration/security/credentials/#service-account-token-management","title":"Service Account Token Management","text":""},{"location":"configuration/security/credentials/#token-expiration","title":"Token Expiration","text":"<p>Set appropriate token expiration times:</p> <pre><code># Short-lived token for single scan (15 minutes)\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\n\n# Medium-lived token for CI/CD pipeline (1 hour)\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=1h)\n\n# Long-lived token should be avoided, but if necessary (24 hours max)\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=24h)\n</code></pre>"},{"location":"configuration/security/credentials/#token-rotation","title":"Token Rotation","text":"<p>Implement regular token rotation:</p> <pre><code>#!/bin/bash\n# rotate-tokens.sh\nNAMESPACE=\"scanner-namespace\"\nSA_NAME=\"scanner-sa\"\n\n# Generate new token\nNEW_TOKEN=$(kubectl create token $SA_NAME -n $NAMESPACE --duration=24h)\n\n# Update configuration that uses the token\n# This depends on how you're storing/using the token\n# Example: Update a Kubernetes secret\nkubectl create secret generic scanner-token -n $NAMESPACE \\\n  --from-literal=token=$NEW_TOKEN --dry-run=client -o yaml | \\\n  kubectl apply -f -\n\necho \"Token rotated for $SA_NAME in $NAMESPACE\"\n</code></pre>"},{"location":"configuration/security/credentials/#kubernetes-secrets","title":"Kubernetes Secrets","text":""},{"location":"configuration/security/credentials/#storing-kubeconfig-in-secrets","title":"Storing Kubeconfig in Secrets","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: scanner-kubeconfig\n  namespace: scanner-namespace\ntype: Opaque\ndata:\n  kubeconfig.yaml: &lt;BASE64_ENCODED_KUBECONFIG&gt;\n</code></pre>"},{"location":"configuration/security/credentials/#mounting-secrets-in-pods","title":"Mounting Secrets in Pods","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: scanner-pod\n  namespace: scanner-namespace\nspec:\n  containers:\n  - name: scanner\n    image: scanner-image:latest\n    volumeMounts:\n    - name: config\n      mountPath: \"/etc/scanner/config\"\n      readOnly: true\n    env:\n    - name: KUBECONFIG\n      value: \"/etc/scanner/config/kubeconfig.yaml\"\n  volumes:\n  - name: config\n    secret:\n      secretName: scanner-kubeconfig\n      defaultMode: 0400  # Read-only for owner only\n</code></pre>"},{"location":"configuration/security/credentials/#cicd-pipeline-credentials","title":"CI/CD Pipeline Credentials","text":""},{"location":"configuration/security/credentials/#github-actions","title":"GitHub Actions","text":"<p>Securely store credentials in GitHub Secrets:</p> <pre><code>name: Security Scan\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      # Set up credentials securely\n      - name: Configure Kubernetes\n        run: |\n          mkdir -p $HOME/.kube\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; $HOME/.kube/config\n          chmod 600 $HOME/.kube/config\n</code></pre>"},{"location":"configuration/security/credentials/#gitlab-ci","title":"GitLab CI","text":"<p>Securely store credentials in GitLab CI/CD Variables:</p> <pre><code>container-security-scan:\n  stage: scan\n  script:\n    - mkdir -p $HOME/.kube\n    - echo \"$KUBECONFIG\" &gt; $HOME/.kube/config\n    - chmod 600 $HOME/.kube/config\n    - cinc-auditor exec profile -t k8s-container://namespace/pod/container\n  variables:\n    # Mark as protected and masked\n    KUBECONFIG: ${{ secrets.KUBECONFIG }}\n</code></pre>"},{"location":"configuration/security/credentials/#external-credential-providers","title":"External Credential Providers","text":""},{"location":"configuration/security/credentials/#aws-secrets-manager","title":"AWS Secrets Manager","text":"<pre><code># Retrieve kubeconfig from AWS Secrets Manager\naws secretsmanager get-secret-value \\\n  --secret-id scanner/kubeconfig \\\n  --query SecretString \\\n  --output text &gt; $HOME/.kube/config\nchmod 600 $HOME/.kube/config\n</code></pre>"},{"location":"configuration/security/credentials/#hashicorp-vault","title":"HashiCorp Vault","text":"<pre><code># Retrieve kubeconfig from HashiCorp Vault\nVAULT_TOKEN=$(vault login -token-only -method=kubernetes role=scanner)\nvault kv get -field=kubeconfig secret/scanner/kubeconfig &gt; $HOME/.kube/config\nchmod 600 $HOME/.kube/config\n</code></pre>"},{"location":"configuration/security/credentials/#best-practices","title":"Best Practices","text":"<ol> <li>Never hardcode credentials in scripts or configuration files</li> <li>Use short-lived tokens whenever possible</li> <li>Implement regular rotation for all credentials</li> <li>Set restrictive permissions on credential files</li> <li>Use secure memory for temporary credential storage</li> <li>Audit credential usage regularly</li> <li>Use external vaults for enterprise deployments</li> <li>Isolate credentials by environment (dev, staging, prod)</li> </ol>"},{"location":"configuration/security/credentials/#credential-compromise-response","title":"Credential Compromise Response","text":"<p>If credentials are compromised:</p> <ol> <li>Revoke the compromised credentials immediately</li> </ol> <pre><code>kubectl delete serviceaccount scanner-sa -n scanner-namespace\nkubectl create serviceaccount scanner-sa -n scanner-namespace\n</code></pre> <ol> <li>Audit usage to determine potential impact</li> </ol> <pre><code># Check audit logs for suspicious activity\nkubectl logs -n kube-system -l component=kube-apiserver\n</code></pre> <ol> <li>Rotate all related credentials</li> </ol> <pre><code># Regenerate and distribute new credentials\n./rotate-credentials.sh\n</code></pre> <ol> <li>Update security controls to prevent future compromises</li> </ol>"},{"location":"configuration/security/credentials/#related-topics","title":"Related Topics","text":"<ul> <li>Hardening Configuration</li> <li>RBAC Configuration</li> <li>Kubeconfig Security</li> <li>Token Management</li> </ul>"},{"location":"configuration/security/hardening/","title":"Security Hardening Configuration","text":"<p>This guide provides recommendations for hardening the security configuration of your CINC Auditor container scanning solution.</p>"},{"location":"configuration/security/hardening/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>Follow the principle of least privilege when configuring scanner access:</p> <ol> <li>Create dedicated service accounts for scanning</li> <li>Limit service account permissions to only what's necessary</li> <li>Avoid using cluster-admin or other high-privilege accounts</li> <li>Use namespace-scoped roles when possible</li> </ol>"},{"location":"configuration/security/hardening/#service-account-configuration","title":"Service Account Configuration","text":"<pre><code># Example: Secure service account configuration\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-sa\n  namespace: scanner-namespace\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\"]\n  # Optionally limit to specific pods by name\n  resourceNames: [\"target-pod-1\", \"target-pod-2\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-rolebinding\n  namespace: target-namespace\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa\n  namespace: scanner-namespace\nroleRef:\n  kind: Role\n  name: scanner-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"configuration/security/hardening/#kubeconfig-hardening","title":"Kubeconfig Hardening","text":""},{"location":"configuration/security/hardening/#short-lived-tokens","title":"Short-lived Tokens","text":"<p>Use short-lived tokens for authentication:</p> <pre><code># Create token with 15-minute expiration\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\n\n# Use token in kubeconfig\n# ... kubeconfig generation ...\n</code></pre>"},{"location":"configuration/security/hardening/#restricted-file-permissions","title":"Restricted File Permissions","text":"<p>Set restrictive permissions on kubeconfig files:</p> <pre><code>chmod 600 secure-kubeconfig.yaml\n</code></pre>"},{"location":"configuration/security/hardening/#environment-specific-configurations","title":"Environment-specific Configurations","text":"<p>Use separate configurations for different environments:</p> <pre><code># Production - most restricted permissions\n./generate-kubeconfig.sh prod-namespace scanner-sa-prod ./kubeconfig-prod.yaml\n\n# Development - less restricted permissions\n./generate-kubeconfig.sh dev-namespace scanner-sa-dev ./kubeconfig-dev.yaml\n</code></pre>"},{"location":"configuration/security/hardening/#network-security","title":"Network Security","text":""},{"location":"configuration/security/hardening/#tls-configuration","title":"TLS Configuration","text":"<p>Ensure TLS is properly configured:</p> <pre><code># In kubeconfig\nclusters:\n- cluster:\n    certificate-authority-data: &lt;REDACTED&gt;\n    server: https://kubernetes.api.server:6443\n  name: secure-cluster\n</code></pre>"},{"location":"configuration/security/hardening/#network-policies","title":"Network Policies","text":"<p>Implement network policies to restrict scanner pod communications:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\n  namespace: scanner-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n    ports:\n    - protocol: TCP\n      port: 443\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: target-namespace\n</code></pre>"},{"location":"configuration/security/hardening/#secrets-management","title":"Secrets Management","text":""},{"location":"configuration/security/hardening/#using-kubernetes-secrets","title":"Using Kubernetes Secrets","text":"<p>Store sensitive configuration in Kubernetes secrets:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: scanner-secret\n  namespace: scanner-namespace\ntype: Opaque\ndata:\n  kubeconfig.yaml: &lt;BASE64_ENCODED_KUBECONFIG&gt;\n</code></pre> <p>Mount the secret in scanner pods:</p> <pre><code>volumes:\n- name: config-volume\n  secret:\n    secretName: scanner-secret\ncontainers:\n- name: scanner\n  volumeMounts:\n  - name: config-volume\n    mountPath: \"/etc/scanner/config\"\n    readOnly: true\n</code></pre>"},{"location":"configuration/security/hardening/#secret-rotation","title":"Secret Rotation","text":"<p>Implement regular secret rotation:</p> <pre><code>#!/bin/bash\n# rotate-secrets.sh\nNAMESPACE=\"scanner-namespace\"\nSA_NAME=\"scanner-sa\"\nSECRET_NAME=\"scanner-secret\"\n\n# Generate new kubeconfig\nTOKEN=$(kubectl create token $SA_NAME -n $NAMESPACE --duration=24h)\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create kubeconfig file\ncat &gt; kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: ${NAMESPACE}\n    user: ${SA_NAME}\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: ${SA_NAME}\n  user:\n    token: ${TOKEN}\nEOF\n\n# Update Kubernetes secret\nkubectl create secret generic $SECRET_NAME -n $NAMESPACE \\\n  --from-file=kubeconfig.yaml --dry-run=client -o yaml | \\\n  kubectl apply -f -\n\necho \"Secret rotated: $SECRET_NAME\"\n</code></pre>"},{"location":"configuration/security/hardening/#distroless-containers","title":"Distroless Containers","text":"<p>When scanning distroless containers, use secure ephemeral debug containers:</p> <pre><code># Secure debug container configuration\ndebugContainers:\n  image: \"gcr.io/distroless/static-debian11:debug\"\n  securityContext:\n    runAsNonRoot: true\n    readOnlyRootFilesystem: true\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop: [\"ALL\"]\n</code></pre>"},{"location":"configuration/security/hardening/#audit-logging","title":"Audit Logging","text":"<p>Enable audit logging for scanner operations:</p> <pre><code># Kubernetes API server audit policy\napiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n- level: RequestResponse\n  users: [\"system:serviceaccount:scanner-namespace:scanner-sa\"]\n  resources:\n  - group: \"\"\n    resources: [\"pods/exec\"]\n</code></pre>"},{"location":"configuration/security/hardening/#cicd-pipeline-security","title":"CI/CD Pipeline Security","text":"<p>Secure CI/CD pipeline configurations:</p>"},{"location":"configuration/security/hardening/#github-actions","title":"GitHub Actions","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Kubernetes\n        run: |\n          mkdir -p $HOME/.kube\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; $HOME/.kube/config\n          chmod 600 $HOME/.kube/config\n\n      # Use OIDC for authentication when possible\n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}\n          aws-region: us-west-2\n</code></pre>"},{"location":"configuration/security/hardening/#gitlab-ci","title":"GitLab CI","text":"<pre><code>container-security-scan:\n  stage: scan\n  image: ruby:3.1-alpine\n  before_script:\n    - mkdir -p $HOME/.kube\n    - echo \"$KUBECONFIG\" &gt; $HOME/.kube/config\n    - chmod 600 $HOME/.kube/config\n  script:\n    - cinc-auditor exec profile -t k8s-container://namespace/pod/container\n  variables:\n    # Mark as protected and masked\n    KUBECONFIG: ${{ secrets.KUBECONFIG }}\n</code></pre>"},{"location":"configuration/security/hardening/#related-topics","title":"Related Topics","text":"<ul> <li>Credential Management</li> <li>RBAC Configuration</li> <li>Kubeconfig Security</li> <li>Security Principles</li> <li>Threat Mitigations</li> <li>NSA/CISA Kubernetes Hardening Guide</li> </ul>"},{"location":"configuration/security/inventory/","title":"Security Configuration Directory Inventory","text":"<p>This document provides a directory overview of the security configuration resources and documentation.</p>"},{"location":"configuration/security/inventory/#directory-contents","title":"Directory Contents","text":"<p>The security directory contains documentation for security-focused configurations:</p> <ul> <li>index.md: Main MkDocs documentation page for security configuration</li> <li>inventory.md: This directory listing file</li> <li>hardening.md: Security hardening recommendations</li> <li>credentials.md: Secure credential management documentation</li> <li>rbac.md: RBAC configuration for scanners</li> </ul>"},{"location":"configuration/security/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Security Hardening: Recommendations for secure deployment</li> <li>Credential Management: Secure handling of authentication credentials</li> <li>RBAC Configuration: Role-based access control for scanner isolation</li> </ul>"},{"location":"configuration/security/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Kubeconfig Configuration</li> <li>RBAC Configuration</li> <li>Security Considerations</li> <li>Threat Model</li> </ul>"},{"location":"configuration/security/rbac/","title":"RBAC Configuration for Scanners","text":"<p>This document covers role-based access control (RBAC) configuration for the CINC Auditor container scanning solution.</p>"},{"location":"configuration/security/rbac/#rbac-principles","title":"RBAC Principles","text":"<p>Follow these core principles when configuring RBAC for scanners:</p> <ol> <li>Least Privilege: Grant only the permissions necessary to perform scanning</li> <li>Isolation: Use separate service accounts for different environments or teams</li> <li>Specificity: Target specific resources rather than broad categories</li> <li>Regular Review: Audit and update RBAC configurations regularly</li> </ol>"},{"location":"configuration/security/rbac/#basic-scanner-rbac","title":"Basic Scanner RBAC","text":""},{"location":"configuration/security/rbac/#service-account","title":"Service Account","text":"<p>Create a dedicated service account for scanning:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-sa\n  namespace: scanner-namespace\n</code></pre>"},{"location":"configuration/security/rbac/#role-definition","title":"Role Definition","text":"<p>Define a role with minimal required permissions:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n</code></pre>"},{"location":"configuration/security/rbac/#role-binding","title":"Role Binding","text":"<p>Bind the role to the service account:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-rolebinding\n  namespace: target-namespace\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa\n  namespace: scanner-namespace\nroleRef:\n  kind: Role\n  name: scanner-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"configuration/security/rbac/#advanced-rbac-configurations","title":"Advanced RBAC Configurations","text":""},{"location":"configuration/security/rbac/#pod-specific-access","title":"Pod-Specific Access","text":"<p>Limit access to specific pods by name:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-restricted-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  resourceNames: [\"target-pod-1\", \"target-pod-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"target-pod-1\", \"target-pod-2\"]\n</code></pre>"},{"location":"configuration/security/rbac/#label-based-access","title":"Label-Based Access","text":"<p>Use label selectors to control access:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-label-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  resourceNames: []\n</code></pre> <p>Then, configure the label selector in your scanner:</p> <pre><code># Scanner configuration\nscanConfig:\n  labelSelector: \"app=scannable,environment=dev\"\n</code></pre>"},{"location":"configuration/security/rbac/#multi-namespace-access","title":"Multi-Namespace Access","text":"<p>For access across multiple namespaces, use a ClusterRole:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: scanner-cluster-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n</code></pre> <p>Bind to specific namespaces:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-ns1-binding\n  namespace: namespace1\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa\n  namespace: scanner-namespace\nroleRef:\n  kind: ClusterRole\n  name: scanner-cluster-role\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-ns2-binding\n  namespace: namespace2\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa\n  namespace: scanner-namespace\nroleRef:\n  kind: ClusterRole\n  name: scanner-cluster-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"configuration/security/rbac/#environment-specific-rbac","title":"Environment-specific RBAC","text":""},{"location":"configuration/security/rbac/#development-environment","title":"Development Environment","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-dev-role\n  namespace: dev\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\", \"create\"]\n</code></pre>"},{"location":"configuration/security/rbac/#production-environment","title":"Production Environment","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-prod-role\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre>"},{"location":"configuration/security/rbac/#distroless-container-rbac","title":"Distroless Container RBAC","text":"<p>For scanning distroless containers using ephemeral debug containers:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-debug-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"update\"]\n</code></pre>"},{"location":"configuration/security/rbac/#custom-resource-definition-access","title":"Custom Resource Definition Access","text":"<p>If you need to scan custom resources:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-crd-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"custom.example.com\"]\n  resources: [\"myresources\"]\n  verbs: [\"get\", \"list\"]\n</code></pre>"},{"location":"configuration/security/rbac/#rbac-validation","title":"RBAC Validation","text":"<p>Validate your RBAC configuration:</p> <pre><code># Check if service account can get pods\nkubectl auth can-i get pods --as=system:serviceaccount:scanner-namespace:scanner-sa -n target-namespace\n\n# Check if service account can create pods/exec\nkubectl auth can-i create pods/exec --as=system:serviceaccount:scanner-namespace:scanner-sa -n target-namespace\n\n# Check if service account can access specific pod\nkubectl auth can-i get pods/target-pod-1 --as=system:serviceaccount:scanner-namespace:scanner-sa -n target-namespace\n</code></pre>"},{"location":"configuration/security/rbac/#rbac-troubleshooting","title":"RBAC Troubleshooting","text":""},{"location":"configuration/security/rbac/#common-issues","title":"Common Issues","text":"<ol> <li>Missing permissions: Check that all necessary verbs are included</li> <li>Namespace mismatch: Ensure RoleBinding is in the target namespace</li> <li>Resource name restrictions: Verify resourceNames list includes target pods</li> </ol>"},{"location":"configuration/security/rbac/#debugging-rbac","title":"Debugging RBAC","text":"<pre><code># Get detailed information about RBAC errors\nkubectl get events -n target-namespace\n\n# Check for authorization errors in API server logs\nkubectl logs -n kube-system -l component=kube-apiserver | grep \"authorization\"\n\n# Use impersonation to test permissions\nkubectl --as=system:serviceaccount:scanner-namespace:scanner-sa -n target-namespace get pods\n</code></pre>"},{"location":"configuration/security/rbac/#related-topics","title":"Related Topics","text":"<ul> <li>Hardening Configuration</li> <li>Credential Management</li> <li>Label-based RBAC</li> <li>RBAC Configuration</li> </ul>"},{"location":"configuration/thresholds/","title":"Threshold Configuration","text":"<p>Directory Inventory</p> <p>See the Thresholds Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides detailed information on using SAF-CLI thresholds for quality gates in security scanning.</p>"},{"location":"configuration/thresholds/#what-are-thresholds","title":"What are Thresholds?","text":"<p>In the context of security scanning, thresholds define the minimum acceptable compliance level for your containerized applications. They allow you to:</p> <ul> <li>Set minimum passing scores</li> <li>Define acceptable failure counts for different severity levels</li> <li>Control how many skipped or error controls are permitted</li> <li>Implement quality gates in CI/CD pipelines</li> </ul>"},{"location":"configuration/thresholds/#threshold-guides","title":"Threshold Guides","text":"<ul> <li>Basic Threshold Configuration - Simple threshold configurations</li> <li>Advanced Threshold Options - Complex threshold configurations</li> <li>Example Configurations - Example configurations for different environments</li> <li>CI/CD Integration - Using thresholds in CI/CD pipelines</li> </ul>"},{"location":"configuration/thresholds/#common-use-cases","title":"Common Use Cases","text":"Use Case Guide Description Simple Compliance Basic Set a minimum overall compliance score Production Enforcement Examples Strict thresholds for production environments Development Flow Examples Lenient thresholds for development Pipeline Quality Gates CI/CD Implementing thresholds in automated pipelines"},{"location":"configuration/thresholds/#getting-started","title":"Getting Started","text":"<p>A simple threshold configuration looks like this:</p> <pre><code># threshold.yml\ncompliance:\n  min: 80\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 2\n</code></pre> <p>This configuration requires:</p> <ul> <li>At least 80% overall compliance</li> <li>No critical failures</li> <li>No more than 2 high severity failures</li> </ul>"},{"location":"configuration/thresholds/#related-topics","title":"Related Topics","text":"<ul> <li>SAF CLI Integration</li> <li>CI/CD Integration</li> <li>Helm Chart Configuration</li> </ul>"},{"location":"configuration/thresholds/advanced/","title":"Advanced Threshold Configuration","text":"<p>This guide covers advanced threshold configurations for security compliance validation.</p>"},{"location":"configuration/thresholds/advanced/#comprehensive-threshold-structure","title":"Comprehensive Threshold Structure","text":"<p>A comprehensive threshold configuration can include multiple validation criteria:</p> <pre><code># Advanced threshold.yml\ncompliance:\n  min: 85  # Minimum overall compliance percentage\n\nfailed:\n  critical:\n    max: 0  # Maximum critical failures\n  high:\n    max: 1  # Maximum high failures\n  medium:\n    max: 3  # Maximum medium failures\n  low:\n    max: 5  # Maximum low failures\n\nskipped:\n  total:\n    max: 2  # Maximum skipped controls\n\nerror:\n  total:\n    max: 0  # Maximum error controls\n</code></pre>"},{"location":"configuration/thresholds/advanced/#skipped-controls","title":"Skipped Controls","text":"<p>The <code>skipped</code> section sets limits on skipped controls:</p> <pre><code>skipped:\n  total:\n    max: 5  # Up to 5 skipped controls allowed\n</code></pre> <p>This is useful to ensure that controls aren't being inappropriately skipped to artificially boost compliance scores.</p>"},{"location":"configuration/thresholds/advanced/#error-controls","title":"Error Controls","text":"<p>The <code>error</code> section defines how many error controls are acceptable:</p> <pre><code>error:\n  total:\n    max: 0  # No error controls allowed\n</code></pre> <p>Errors typically indicate a problem with the scanning process rather than a compliance issue. Setting this to 0 ensures that all controls are properly evaluated.</p>"},{"location":"configuration/thresholds/advanced/#combining-threshold-criteria","title":"Combining Threshold Criteria","text":"<p>Threshold validation passes only if ALL specified criteria are met. For example:</p> <pre><code>compliance:\n  min: 90\nfailed:\n  critical:\n    max: 0\nskipped:\n  total:\n    max: 0\n</code></pre> <p>The scan will fail if:</p> <ul> <li>Compliance score is below 90%, OR</li> <li>Any critical failures exist, OR</li> <li>Any controls are skipped</li> </ul>"},{"location":"configuration/thresholds/advanced/#custom-compliance-calculations","title":"Custom Compliance Calculations","text":"<p>By default, the compliance percentage is calculated as:</p> <pre><code>compliance_percentage = (passed_controls / total_controls) * 100\n</code></pre> <p>You can focus on specific impact levels by only setting thresholds for them:</p> <pre><code>failed:\n  critical:\n    max: 0\n  high:\n    max: 0\n</code></pre> <p>This configuration ensures no critical or high failures, regardless of overall compliance scores.</p>"},{"location":"configuration/thresholds/advanced/#advanced-saf-cli-usage","title":"Advanced SAF CLI Usage","text":"<p>You can provide custom options when using the SAF CLI for threshold validation:</p> <pre><code># Custom reporting format\nsaf threshold -i scan-results.json -t threshold.yml --format json\n\n# Output to file\nsaf threshold -i scan-results.json -t threshold.yml --output results.json\n\n# Detailed reporting\nsaf threshold -i scan-results.json -t threshold.yml --verbose\n</code></pre>"},{"location":"configuration/thresholds/advanced/#advanced-script-integration","title":"Advanced Script Integration","text":"<p>You can create sophisticated validation scripts:</p> <pre><code>#!/bin/bash\n# advanced-validation.sh\nRESULTS_FILE=$1\nTHRESHOLD_FILE=$2\nOUTPUT_DIR=${3:-\"./validation-results\"}\n\n# Create output directory\nmkdir -p $OUTPUT_DIR\n\n# Run validation\nsaf threshold -i $RESULTS_FILE -t $THRESHOLD_FILE --format json &gt; $OUTPUT_DIR/validation.json\nTHRESHOLD_RESULT=$?\n\n# Generate detailed report\nsaf summary --input $RESULTS_FILE --output-md $OUTPUT_DIR/summary.md\n\n# Exit with threshold result\nexit $THRESHOLD_RESULT\n</code></pre>"},{"location":"configuration/thresholds/advanced/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can use environment variables to dynamically select the appropriate threshold:</p> <pre><code>#!/bin/bash\n# select-threshold.sh\nENV=${1:-\"dev\"}  # Default to development\n\ncase $ENV in\n  \"prod\")\n    THRESHOLD_FILE=\"./thresholds/production.yml\"\n    ;;\n  \"staging\")\n    THRESHOLD_FILE=\"./thresholds/staging.yml\"\n    ;;\n  *)\n    THRESHOLD_FILE=\"./thresholds/development.yml\"\n    ;;\nesac\n\necho \"Using threshold file: $THRESHOLD_FILE\"\nsaf threshold -i scan-results.json -t $THRESHOLD_FILE\n</code></pre>"},{"location":"configuration/thresholds/advanced/#advanced-helm-chart-integration","title":"Advanced Helm Chart Integration","text":"<p>For more sophisticated Helm chart configurations:</p> <pre><code>safCli:\n  enabled: true\n  thresholdSelector:\n    environment: production\n  thresholdConfigs:\n    development:\n      compliance:\n        min: 70\n      failed:\n        critical:\n          max: 0\n    staging:\n      compliance:\n        min: 85\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 2\n    production:\n      compliance:\n        min: 95\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 0\n      skipped:\n        total:\n          max: 0\n</code></pre>"},{"location":"configuration/thresholds/advanced/#threshold-inheritance","title":"Threshold Inheritance","text":"<p>You can use YAML anchors and aliases to create threshold inheritance:</p> <pre><code># Base configuration\nbase: &amp;base\n  compliance:\n    min: 70\n  failed:\n    critical:\n      max: 0\n\n# Development extends base\ndevelopment:\n  &lt;&lt;: *base  # Inherit from base\n  # No changes\n\n# Staging extends base with stricter requirements\nstaging:\n  &lt;&lt;: *base  # Inherit from base\n  compliance:\n    min: 85  # Override base value\n\n# Production has even stricter requirements\nproduction:\n  &lt;&lt;: *base  # Inherit from base\n  compliance:\n    min: 95  # Override base value\n  failed:\n    high:\n      max: 0  # Add high impact restriction\n</code></pre> <p>This approach allows you to maintain a consistent baseline while customizing thresholds for different environments.</p>"},{"location":"configuration/thresholds/advanced/#related-topics","title":"Related Topics","text":"<ul> <li>Basic Threshold Configuration</li> <li>Example Configurations</li> <li>CI/CD Integration</li> <li>SAF CLI Integration</li> </ul>"},{"location":"configuration/thresholds/basic/","title":"Basic Threshold Configuration","text":"<p>This guide covers basic threshold configurations for security compliance validation.</p>"},{"location":"configuration/thresholds/basic/#threshold-configuration-structure","title":"Threshold Configuration Structure","text":"<p>Thresholds are defined in YAML or JSON files with a standardized structure. Here's a basic example:</p> <pre><code># Basic threshold.yml\ncompliance:\n  min: 80  # Minimum overall compliance percentage (0-100)\n\nfailed:\n  critical:\n    max: 0  # Maximum number of critical-impact failures allowed\n  high:\n    max: 2  # Maximum number of high-impact failures allowed\n</code></pre>"},{"location":"configuration/thresholds/basic/#compliance-score","title":"Compliance Score","text":"<p>The <code>compliance</code> section sets the minimum overall compliance percentage required:</p> <pre><code>compliance:\n  min: 85  # Minimum overall compliance percentage (0-100)\n</code></pre> <p>This ensures that at least 85% of controls must pass for the scan to be considered successful.</p>"},{"location":"configuration/thresholds/basic/#failed-controls-by-impact","title":"Failed Controls by Impact","text":"<p>The <code>failed</code> section lets you set maximum failure counts by impact level:</p> <pre><code>failed:\n  critical:\n    max: 0  # No critical failures allowed\n  high: \n    max: 2  # Up to 2 high-impact failures allowed\n  medium:\n    max: 5  # Up to 5 medium-impact failures allowed\n  low:\n    max: 10  # Up to 10 low-impact failures allowed\n</code></pre> <p>The impact levels (critical, high, medium, low) correspond to the severity levels in InSpec/CINC Auditor controls.</p>"},{"location":"configuration/thresholds/basic/#using-thresholds-with-saf-cli","title":"Using Thresholds with SAF CLI","text":"<p>To validate scan results against a threshold file:</p> <pre><code># Usage\nsaf threshold -i scan-results.json -t threshold.yml\n</code></pre> <p>The command returns:</p> <ul> <li>Exit code 0 if all thresholds are met</li> <li>Non-zero exit code if any threshold is not met</li> </ul>"},{"location":"configuration/thresholds/basic/#using-thresholds-in-scripts","title":"Using Thresholds in Scripts","text":"<p>Our <code>scan-container.sh</code> script supports threshold files:</p> <pre><code># Using default threshold (70% compliance)\n./scan-container.sh my-namespace my-pod my-container my-profile\n\n# Using custom threshold file\n./scan-container.sh my-namespace my-pod my-container my-profile ./path/to/threshold.yml\n</code></pre>"},{"location":"configuration/thresholds/basic/#using-thresholds-in-helm-charts","title":"Using Thresholds in Helm Charts","text":"<p>Our Helm chart supports thresholds via <code>values.yaml</code>:</p> <pre><code>safCli:\n  enabled: true\n  thresholdConfig:\n    compliance:\n      min: 70\n    failed:\n      critical:\n        max: 0\n    # ... other threshold settings\n</code></pre> <p>You can also use an external threshold file:</p> <pre><code>safCli:\n  enabled: true\n  thresholdFilePath: \"/path/to/threshold.yml\"\n</code></pre>"},{"location":"configuration/thresholds/basic/#common-basic-configurations","title":"Common Basic Configurations","text":""},{"location":"configuration/thresholds/basic/#compliance-only","title":"Compliance Only","text":"<p>The simplest configuration focuses only on the overall compliance score:</p> <pre><code>compliance:\n  min: 80  # At least 80% compliance required\n</code></pre>"},{"location":"configuration/thresholds/basic/#no-critical-failures","title":"No Critical Failures","text":"<p>Enforce that no critical vulnerabilities are allowed:</p> <pre><code>failed:\n  critical:\n    max: 0  # No critical failures allowed\n</code></pre>"},{"location":"configuration/thresholds/basic/#limited-high-failures","title":"Limited High Failures","text":"<p>Allow a small number of high-severity issues:</p> <pre><code>failed:\n  high:\n    max: 3  # Up to 3 high-impact failures allowed\n</code></pre>"},{"location":"configuration/thresholds/basic/#troubleshooting","title":"Troubleshooting","text":"<p>If you're experiencing issues with thresholds:</p> <ol> <li>Verify your threshold file is valid YAML or JSON</li> <li>Check that your scan results contain the expected impact levels</li> <li>Use the <code>--debug</code> flag with SAF CLI for more detailed output:</li> </ol> <pre><code>saf threshold -i scan-results.json -t threshold.yml --debug\n</code></pre>"},{"location":"configuration/thresholds/basic/#related-topics","title":"Related Topics","text":"<ul> <li>Advanced Threshold Options</li> <li>Example Configurations</li> <li>CI/CD Integration</li> <li>SAF CLI Integration</li> </ul>"},{"location":"configuration/thresholds/cicd/","title":"Using Thresholds in CI/CD Pipelines","text":"<p>This guide provides detailed information on integrating threshold validation into CI/CD pipelines as quality gates.</p>"},{"location":"configuration/thresholds/cicd/#basic-pipeline-integration","title":"Basic Pipeline Integration","text":"<p>The core pattern for using thresholds in CI/CD pipelines is:</p> <ol> <li>Run the security scan and output results to a JSON file</li> <li>Validate the results against a threshold file</li> <li>Fail the pipeline if thresholds aren't met</li> </ol>"},{"location":"configuration/thresholds/cicd/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>In GitHub workflows, use thresholds as quality gates:</p> <pre><code>name: Container Security Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Kubernetes\n        uses: azure/k8s-set-context@v3\n        with:\n          kubeconfig: ${{ secrets.KUBECONFIG }}\n\n      - name: Run security scan\n        run: |\n          # Run scan and get results in JSON\n          cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n            --reporter json:scan-results.json\n\n          # Check against thresholds\n          saf threshold -i scan-results.json -t threshold.yml\n          if [ $? -ne 0 ]; then\n            echo \"Security scan failed to meet threshold requirements\"\n            exit 1\n          fi\n</code></pre> <p>See the GitHub workflow examples for complete implementations.</p>"},{"location":"configuration/thresholds/cicd/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>In GitLab pipelines, implement thresholds as:</p> <pre><code>security-scan:\n  stage: scan\n  script:\n    # Run scan with CINC Auditor\n    - cinc-auditor exec ${PROFILE_PATH} \\\n        -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n        --reporter json:scan-results.json\n\n    # Check against thresholds\n    - saf threshold -i scan-results.json -t threshold.yml\n    - |\n      if [ $? -ne 0 ]; then\n        echo \"Security scan failed to meet threshold requirements\"\n        exit 1\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n    when: always\n</code></pre> <p>See the GitLab CI examples for complete implementations.</p>"},{"location":"configuration/thresholds/cicd/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can set different thresholds for different environments:</p> <pre><code># GitHub Actions example with environment selection\nname: Container Security Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: 'Environment to scan (dev/staging/prod)'\n        required: true\n        default: 'dev'\n\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      # Select threshold based on environment\n      - name: Select threshold file\n        run: |\n          if [ \"${{ github.event.inputs.environment }}\" == \"prod\" ]; then\n            cp ./thresholds/production.yml ./threshold.yml\n          elif [ \"${{ github.event.inputs.environment }}\" == \"staging\" ]; then\n            cp ./thresholds/staging.yml ./threshold.yml\n          else\n            cp ./thresholds/development.yml ./threshold.yml\n          fi\n\n      # Run scan and validate\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n            --reporter json:scan-results.json\n\n          saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/thresholds/cicd/#reporting-and-notifications","title":"Reporting and Notifications","text":"<p>Enhance CI/CD integration with detailed reporting:</p> <pre><code># GitHub Actions with reporting\nsecurity-scan:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v3\n\n    - name: Run security scan\n      run: |\n        cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n          --reporter json:scan-results.json\n\n        # Generate markdown summary\n        saf summary --input scan-results.json --output-md scan-summary.md\n\n        # Validate against thresholds\n        saf threshold -i scan-results.json -t threshold.yml\n        THRESHOLD_RESULT=$?\n\n        # Always upload results\n        echo \"THRESHOLD_RESULT=$THRESHOLD_RESULT\" &gt;&gt; $GITHUB_ENV\n\n    - name: Upload scan results\n      uses: actions/upload-artifact@v3\n      with:\n        name: security-scan-results\n        path: |\n          scan-results.json\n          scan-summary.md\n\n    - name: Check threshold result\n      run: |\n        if [ \"${{ env.THRESHOLD_RESULT }}\" != \"0\" ]; then\n          echo \"Security scan failed to meet threshold requirements\"\n          exit 1\n        fi\n</code></pre>"},{"location":"configuration/thresholds/cicd/#branch-specific-thresholds","title":"Branch-Specific Thresholds","text":"<p>You can apply different thresholds to different branches:</p> <pre><code># GitLab CI with branch-specific thresholds\nsecurity-scan:\n  stage: scan\n  script:\n    # Run the scan\n    - cinc-auditor exec ${PROFILE_PATH} -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} --reporter json:scan-results.json\n\n    # Select threshold based on branch\n    - |\n      if [[ \"$CI_COMMIT_BRANCH\" == \"main\" ]]; then\n        THRESHOLD_FILE=\"production.yml\"\n      elif [[ \"$CI_COMMIT_BRANCH\" =~ ^release/.* ]]; then\n        THRESHOLD_FILE=\"staging.yml\"\n      else\n        THRESHOLD_FILE=\"development.yml\"\n      fi\n\n    # Validate threshold\n    - saf threshold -i scan-results.json -t ./thresholds/$THRESHOLD_FILE\n</code></pre>"},{"location":"configuration/thresholds/cicd/#pull-request-comments","title":"Pull Request Comments","text":"<p>You can add scan results as pull request comments:</p> <pre><code># GitHub Actions with PR comments\nsecurity-scan:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v3\n\n    - name: Run security scan\n      run: |\n        cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n          --reporter json:scan-results.json\n\n        # Generate markdown summary\n        saf summary --input scan-results.json --output-md scan-summary.md\n\n        # Validate against thresholds\n        saf threshold -i scan-results.json -t threshold.yml\n        echo \"THRESHOLD_RESULT=$?\" &gt;&gt; $GITHUB_ENV\n\n    - name: Comment on PR\n      if: github.event_name == 'pull_request'\n      uses: actions/github-script@v6\n      with:\n        github-token: ${{ secrets.GITHUB_TOKEN }}\n        script: |\n          const fs = require('fs');\n          const summary = fs.readFileSync('scan-summary.md', 'utf8');\n          const result = process.env.THRESHOLD_RESULT === '0' ? '\u2705 Passed' : '\u274c Failed';\n\n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: `## Security Scan Results: ${result}\\n\\n${summary}`\n          });\n</code></pre>"},{"location":"configuration/thresholds/cicd/#scheduled-scans","title":"Scheduled Scans","text":"<p>Set up scheduled security scans:</p> <pre><code># GitHub Actions scheduled scan\nname: Scheduled Security Scan\n\non:\n  schedule:\n    - cron: '0 0 * * *'  # Daily at midnight\n\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Run security scan\n        run: |\n          cinc-auditor exec ./profile -t k8s-container://namespace/pod/container \\\n            --reporter json:scan-results.json\n\n          # Validate against thresholds\n          saf threshold -i scan-results.json -t threshold.yml\n\n      - name: Notify on failure\n        if: failure()\n        run: |\n          # Add notification logic (email, Slack, etc.)\n          echo \"Security scan failed to meet threshold requirements\"\n</code></pre>"},{"location":"configuration/thresholds/cicd/#related-topics","title":"Related Topics","text":"<ul> <li>Basic Threshold Configuration</li> <li>Advanced Threshold Options</li> <li>Example Configurations</li> <li>GitHub Workflows</li> <li>GitLab Pipelines</li> </ul>"},{"location":"configuration/thresholds/examples/","title":"Threshold Configuration Examples","text":"<p>This document provides example threshold configurations for different environments and use cases.</p>"},{"location":"configuration/thresholds/examples/#development-environment","title":"Development Environment","text":"<p>More lenient thresholds for development environments:</p> <pre><code># development-threshold.yml\ncompliance:\n  min: 70\nfailed:\n  critical:\n    max: 0  # Still enforce no critical failures\n  high:\n    max: 3  # Allow some high-impact failures\n  medium:\n    max: 5  # Allow several medium-impact failures\n</code></pre> <p>This configuration:</p> <ul> <li>Requires a modest 70% compliance score</li> <li>Enforces zero critical vulnerabilities</li> <li>Allows up to 3 high-impact findings</li> <li>Allows up to 5 medium-impact findings</li> <li>Places no limit on low-impact findings</li> </ul>"},{"location":"configuration/thresholds/examples/#staging-environment","title":"Staging Environment","text":"<p>Moderate thresholds for staging environments:</p> <pre><code># staging-threshold.yml\ncompliance:\n  min: 85\nfailed:\n  critical:\n    max: 0  # No critical failures\n  high:\n    max: 1  # Only 1 high-impact failure\n  medium:\n    max: 3  # Limited medium-impact failures\nskipped:\n  total:\n    max: 2  # Limited skipped controls\n</code></pre> <p>This configuration:</p> <ul> <li>Requires a higher 85% compliance score</li> <li>Enforces zero critical vulnerabilities</li> <li>Allows only 1 high-impact finding</li> <li>Allows up to 3 medium-impact findings</li> <li>Allows no more than 2 skipped controls</li> </ul>"},{"location":"configuration/thresholds/examples/#production-environment","title":"Production Environment","text":"<p>Strict thresholds for production environments:</p> <pre><code># production-threshold.yml\ncompliance:\n  min: 95\nfailed:\n  critical:\n    max: 0  # No critical failures\n  high:\n    max: 0  # No high-impact failures\n  medium:\n    max: 1  # Only 1 medium-impact failure\nskipped:\n  total:\n    max: 0  # No skipped controls\nerror:\n  total:\n    max: 0  # No error controls\n</code></pre> <p>This configuration:</p> <ul> <li>Requires a high 95% compliance score</li> <li>Enforces zero critical vulnerabilities</li> <li>Enforces zero high-impact findings</li> <li>Allows only 1 medium-impact finding</li> <li>Prohibits skipped controls</li> <li>Prohibits error controls</li> </ul>"},{"location":"configuration/thresholds/examples/#compliance-focused-example","title":"Compliance-Focused Example","text":"<p>Focuses only on overall compliance score:</p> <pre><code># compliance-threshold.yml\ncompliance:\n  min: 90\n</code></pre> <p>This simple configuration only checks that the overall compliance score is at least 90%.</p>"},{"location":"configuration/thresholds/examples/#critical-only-example","title":"Critical-Only Example","text":"<p>Focuses only on critical vulnerabilities:</p> <pre><code># critical-threshold.yml\nfailed:\n  critical:\n    max: 0\n</code></pre> <p>This configuration only checks that there are no critical vulnerabilities, regardless of overall compliance score.</p>"},{"location":"configuration/thresholds/examples/#container-baseline-example","title":"Container Baseline Example","text":"<p>Focused example for container baseline scanning:</p> <pre><code># container-baseline-threshold.yml\ncompliance:\n  min: 85\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0  # No high-impact container vulnerabilities\n</code></pre> <p>This configuration is suitable for basic container security, focusing on critical and high-impact issues.</p>"},{"location":"configuration/thresholds/examples/#progressive-example","title":"Progressive Example","text":"<p>An example showing progression from development to production:</p> <pre><code># Shared base configuration with YAML anchors\nbase: &amp;base\n  failed:\n    critical:\n      max: 0  # No critical failures in any environment\n\n# Development configuration\ndevelopment: &amp;dev\n  &lt;&lt;: *base\n  compliance:\n    min: 70\n  failed:\n    high:\n      max: 3\n\n# Staging extends development with stricter rules\nstaging: &amp;staging\n  &lt;&lt;: *dev\n  compliance:\n    min: 85\n  failed:\n    high:\n      max: 1\n\n# Production has the strictest requirements\nproduction:\n  &lt;&lt;: *staging\n  compliance:\n    min: 95\n  failed:\n    high:\n      max: 0\n  skipped:\n    total:\n      max: 0\n</code></pre> <p>This example uses YAML anchors and aliases to show a progression of increasingly strict configurations.</p>"},{"location":"configuration/thresholds/examples/#using-these-examples","title":"Using These Examples","text":"<p>To use these examples:</p> <ol> <li>Copy the appropriate example to a file (e.g., <code>threshold.yml</code>)</li> <li>Run your scan with the threshold file:</li> </ol> <pre><code>./scan-container.sh my-namespace my-pod my-container my-profile ./threshold.yml\n</code></pre> <ol> <li>Alternatively, use with SAF CLI directly:</li> </ol> <pre><code>saf threshold -i scan-results.json -t threshold.yml\n</code></pre>"},{"location":"configuration/thresholds/examples/#related-topics","title":"Related Topics","text":"<ul> <li>Basic Threshold Configuration</li> <li>Advanced Threshold Options</li> <li>CI/CD Integration</li> <li>SAF CLI Integration</li> </ul>"},{"location":"configuration/thresholds/inventory/","title":"Threshold Configuration Directory Inventory","text":"<p>This document provides a directory overview of the threshold configuration resources and documentation.</p>"},{"location":"configuration/thresholds/inventory/#directory-contents","title":"Directory Contents","text":"<p>The thresholds directory contains documentation for compliance threshold configuration:</p> <ul> <li>index.md: Main MkDocs documentation page for threshold configuration</li> <li>inventory.md: This directory listing file</li> <li>basic.md: Basic threshold configuration documentation</li> <li>advanced.md: Advanced threshold configuration documentation</li> <li>examples.md: Example threshold configurations for different environments</li> <li>cicd.md: Using thresholds in CI/CD pipelines</li> </ul>"},{"location":"configuration/thresholds/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Compliance Thresholds: Settings for minimum compliance scores</li> <li>Failure Limits: Configuration for maximum allowed failures by severity</li> <li>Environment-Specific Settings: Different threshold configurations for development, staging, and production</li> <li>CI/CD Integration: Using thresholds as quality gates in pipelines</li> </ul>"},{"location":"configuration/thresholds/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>SAF CLI Integration</li> <li>CI/CD Integration</li> <li>GitHub Workflows</li> <li>GitLab Pipelines</li> </ul>"},{"location":"contributing/","title":"Contributing to Documentation","text":"<p>This section provides guidelines and tools for contributing to the Kube CINC Secure Scanner documentation.</p>"},{"location":"contributing/#overview","title":"Overview","text":"<p>Our documentation is built with Material for MkDocs, which provides a modern and responsive documentation experience with features like:</p> <ul> <li>Advanced code highlighting and annotations</li> <li>Content tabs for organizing related information</li> <li>Interactive diagrams with Mermaid integration</li> <li>Dark and light theme support</li> <li>Search functionality</li> </ul>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>To contribute to the documentation:</p> <ol> <li>Set up your local development environment</li> <li>Make your changes to the markdown files</li> <li>Preview your changes locally</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#development-environment-setup","title":"Development Environment Setup","text":"<p>To set up your local development environment:</p> <pre><code># Clone the repository\ngit clone https://github.com/mitre/kube-secure-scanner\ncd kube-secure-scanner\n\n# Install dependencies\ncd docs\nnpm install\n</code></pre>"},{"location":"contributing/#local-preview","title":"Local Preview","text":"<p>To preview the documentation locally:</p> <pre><code>cd docs\nnpm run preview\n</code></pre> <p>This will start a local server at http://localhost:8000/ where you can preview your changes in real-time.</p>"},{"location":"contributing/#documentation-tools","title":"Documentation Tools","text":"<p>We provide several useful tools for documentation development:</p> <ul> <li>Diagram Support: Create diagrams using Mermaid syntax</li> <li>Code Snippets: Include code examples from actual project files</li> <li>Styling Guidelines: Maintain consistent styling across documents</li> <li>Linting and Formatting: Ensure markdown quality and consistency</li> </ul> <p>For more details, see the individual topics in this section.</p>"},{"location":"contributing/#documentation-standards","title":"Documentation Standards","text":"<p>When contributing to documentation, please follow these guidelines:</p> <ul> <li>Use clear, concise language</li> <li>Follow the established directory structure</li> <li>Maintain consistent markdown formatting</li> <li>Include examples where appropriate</li> <li>Test all links and references</li> <li>Include diagrams for complex concepts</li> </ul>"},{"location":"contributing/#related-resources","title":"Related Resources","text":"<ul> <li>Material for MkDocs Documentation</li> <li>Markdown Guide</li> <li>Mermaid Diagram Syntax</li> </ul>"},{"location":"contributing/code-snippets/","title":"Using Code Snippets","text":"<p>This guide explains how to use the Material for MkDocs code snippet inclusion feature to embed code examples in your documentation.</p>"},{"location":"contributing/code-snippets/#overview","title":"Overview","text":"<p>Our documentation uses Material for MkDocs with the PyMdown Extensions to provide advanced code block functionality, including:</p> <ul> <li>Code syntax highlighting</li> <li>Line numbers and line highlighting</li> <li>Code block annotations</li> <li>Code copying button</li> <li>Code file inclusion</li> </ul>"},{"location":"contributing/code-snippets/#including-code-files","title":"Including Code Files","text":"<p>To include code from existing files in the repository:</p> <pre><code>```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>This will render as:\n\n```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre>"},{"location":"contributing/code-snippets/#highlighting-specific-lines","title":"Highlighting Specific Lines","text":"<p>You can highlight specific lines in the code:</p> <pre><code>```yaml hl_lines=\"3-5 8\"\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>## Adding Line Numbers\n\nLine numbers are automatically added to code blocks, but you can disable them if needed:\n\n```markdown\n```yaml linenums=\"1\"\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <pre><code>## Adding Annotations\n\nYou can add annotations to specific lines in code blocks:\n\n```markdown\n```yaml\nname: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <ol> <li>This line defines the workflow name</li> <li>These are the events that trigger the workflow</li> </ol> <pre><code>## Using Tabs for Multiple Code Examples\n\nYou can group related code examples in tabs:\n\n```markdown\n=== \"GitHub Workflow\"\n    ```yaml\n    name: CI/CD Pipeline with CINC Auditor Scanning\n\n    on:\n      workflow_dispatch:\n        inputs:\n          image_tag:\n            description: 'Tag for the container image'\n            required: true\n            default: 'latest'\n          scan_namespace:\n            description: 'Kubernetes namespace for scanning'\n            required: true\n            default: 'app-scan'\n          threshold:\n            description: 'Minimum passing score (0-100)'\n            required: true\n            default: '70'\n\n    jobs:\n      build-deploy-scan:\n        name: Build, Deploy and Scan Container\n        runs-on: ubuntu-latest\n\n        steps:\n          - name: Checkout code\n            uses: actions/checkout@v4\n\n          - name: Set up Docker Buildx\n            uses: docker/setup-buildx-action@v3\n\n          - name: Define test application\n            run: |\n              # Create a simple application for testing\n              mkdir -p ./app\n\n              # Create a minimal Dockerfile\n              cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n              FROM alpine:latest\n\n              # Add some packages to test vulnerability scanning\n              RUN apk add --no-cache bash curl wget\n\n              # Add a sample script\n              COPY hello.sh /hello.sh\n              RUN chmod +x /hello.sh\n\n              # Set CMD\n              CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n              EOF\n\n              # Create a simple script file\n              cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n              #!/bin/bash\n              echo \"Hello from test container! The time is $(date)\"\n              echo \"Running as user: $(whoami)\"\n              echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n              EOF\n\n          - name: Set up Minikube\n            uses: medyagh/setup-minikube@master\n            with:\n              driver: docker\n              start-args: --nodes=2\n\n          - name: Build container image\n            run: |\n              # Configure to use minikube's Docker daemon\n              eval $(minikube docker-env)\n\n              # Build the image\n              docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n              # List images to confirm\n              docker images | grep test-app\n\n          - name: Create Kubernetes deployment\n            run: |\n              # Create namespace\n              kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n              # Create deployment\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: apps/v1\n              kind: Deployment\n              metadata:\n                name: test-app\n                namespace: ${{ github.event.inputs.scan_namespace }}\n                labels:\n                  app: test-app\n              spec:\n                replicas: 1\n                selector:\n                  matchLabels:\n                    app: test-app\n                template:\n                  metadata:\n                    labels:\n                      app: test-app\n                      security-scan: \"enabled\"\n                  spec:\n                    containers:\n                    - name: app\n                      image: test-app:${{ github.event.inputs.image_tag }}\n                      imagePullPolicy: Never\n              EOF\n\n              # Wait for deployment to be ready\n              kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n              # Get pod name\n              POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n              echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n              # Show pods\n              kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n          - name: Set up CINC Auditor\n            run: |\n              # Install CINC Auditor\n              curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n              # Install train-k8s-container plugin\n              cinc-auditor plugin install train-k8s-container\n\n              # Create a custom profile for application scanning\n              mkdir -p ./app-scan-profile\n\n              # Create profile files\n              cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n              name: app-scan-profile\n              title: Custom Application Container Scan\n              maintainer: Security Team\n              copyright: Security Team\n              license: Apache-2.0\n              summary: A custom profile for scanning containerized applications\n              version: 0.1.0\n              supports:\n                platform: os\n              EOF\n\n              mkdir -p ./app-scan-profile/controls\n\n              cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n              control 'container-1.1' do\n                impact 0.7\n                title 'Ensure container is not running as root'\n                desc 'Containers should not run as root when possible'\n\n                describe command('whoami') do\n                  its('stdout') { should_not cmp 'root' }\n                end\n              end\n\n              control 'container-1.2' do\n                impact 0.5\n                title 'Check container OS version'\n                desc 'Verify the container OS version'\n\n                describe file('/etc/os-release') do\n                  it { should exist }\n                  its('content') { should include 'Alpine' }\n                end\n              end\n\n              control 'container-1.3' do\n                impact 0.3\n                title 'Check for unnecessary packages'\n                desc 'Container should not have unnecessary packages'\n\n                describe package('curl') do\n                  it { should be_installed }\n                end\n\n                describe package('wget') do\n                  it { should be_installed }\n                end\n              end\n\n              control 'container-1.4' do\n                impact 0.7\n                title 'Check for sensitive files'\n                desc 'Container should not have sensitive files'\n\n                describe file('/etc/shadow') do\n                  it { should exist }\n                  it { should_not be_readable.by('others') }\n                end\n              end\n              EOF\n\n          - name: Setup secure scanning infrastructure\n            run: |\n              # Create a unique ID for this run\n              RUN_ID=$(date +%s)\n              echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n              # Create service account\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: v1\n              kind: ServiceAccount\n              metadata:\n                name: cinc-scanner-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              EOF\n\n              # Create role with label-based access\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: rbac.authorization.k8s.io/v1\n              kind: Role\n              metadata:\n                name: cinc-scanner-role-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              rules:\n              - apiGroups: [\"\"]\n                resources: [\"pods\"]\n                verbs: [\"get\", \"list\"]\n              - apiGroups: [\"\"]\n                resources: [\"pods/exec\"]\n                verbs: [\"create\"]\n                # No resourceNames restriction - use label selector in code\n              - apiGroups: [\"\"]\n                resources: [\"pods/log\"]\n                verbs: [\"get\"]\n                # No resourceNames restriction - use label selector in code\n              EOF\n\n              # Create rolebinding\n              cat &lt;&lt;EOF | kubectl apply -f -\n              apiVersion: rbac.authorization.k8s.io/v1\n              kind: RoleBinding\n              metadata:\n                name: cinc-scanner-binding-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              subjects:\n              - kind: ServiceAccount\n                name: cinc-scanner-${RUN_ID}\n                namespace: ${{ github.event.inputs.scan_namespace }}\n              roleRef:\n                kind: Role\n                name: cinc-scanner-role-${RUN_ID}\n                apiGroup: rbac.authorization.k8s.io\n              EOF\n\n          - name: Setup SAF-CLI\n            run: |\n              # Install Node.js (should already be installed on GitHub runners)\n              node --version || echo \"Node.js not installed\"\n\n              # Install SAF-CLI globally\n              npm install -g @mitre/saf\n\n              # Verify installation\n              saf --version\n\n          - name: Run security scan with CINC Auditor\n            run: |\n              # Generate token\n              TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n              SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n              CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n              # Create kubeconfig\n              cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n              apiVersion: v1\n              kind: Config\n              preferences: {}\n              clusters:\n              - cluster:\n                  server: ${SERVER}\n                  certificate-authority-data: ${CA_DATA}\n                name: scanner-cluster\n              contexts:\n              - context:\n                  cluster: scanner-cluster\n                  namespace: ${{ github.event.inputs.scan_namespace }}\n                  user: scanner-user\n                name: scanner-context\n              current-context: scanner-context\n              users:\n              - name: scanner-user\n                user:\n                  token: ${TOKEN}\n              EOF\n\n              chmod 600 scan-kubeconfig.yaml\n\n              # Verify we can access the pod with our labels\n              POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n              if [ -z \"$POD_NAME\" ]; then\n                echo \"Error: No pod found with security-scan=enabled label\"\n                exit 1\n              fi\n              echo \"Found pod to scan: ${POD_NAME}\"\n\n              # Run the CINC Auditor scan\n              KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n                -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n                --reporter cli json:scan-results.json\n\n              SCAN_EXIT_CODE=$?\n              echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n              # Also run a standard profile for comparison\n              echo \"Running standard DevSec Linux Baseline for comparison:\"\n              KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n                -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n                --reporter cli json:baseline-results.json || true\n\n          - name: Generate scan summary with SAF-CLI\n            run: |\n              # Create summary report with SAF-CLI\n              echo \"Generating scan summary with SAF-CLI:\"\n              saf summary --input scan-results.json --output-md scan-summary.md\n\n              # Display the summary in the logs\n              cat scan-summary.md\n\n              # Create a proper threshold file\n              cat &gt; threshold.yml &lt;&lt; EOF\n    compliance:\n      min: ${{ github.event.inputs.threshold }}\n    failed:\n      critical:\n        max: 0  # No critical failures allowed\n    EOF\n\n              # Apply threshold check\n              echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n              saf threshold -i scan-results.json -t threshold.yml\n              THRESHOLD_EXIT_CODE=$?\n\n              if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n                echo \"\u2705 Security scan passed threshold requirements\"\n              else\n                echo \"\u274c Security scan failed to meet threshold requirements\"\n                # Uncomment to enforce the threshold as a quality gate\n                # exit $THRESHOLD_EXIT_CODE\n              fi\n\n              # Generate summary for baseline results too\n              echo \"Generating baseline summary with SAF-CLI:\"\n              saf summary --input baseline-results.json --output-md baseline-summary.md\n\n              # Create a combined summary for GitHub step summary\n              echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n              cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n              echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n              cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          - name: Upload scan results\n            uses: actions/upload-artifact@v4\n            with:\n              name: security-scan-results\n              path: |\n                scan-results.json\n                baseline-results.json\n                scan-summary.md\n                baseline-summary.md\n\n          - name: Cleanup resources\n            if: always()\n            run: |\n              kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n    ```\n\n=== \"GitLab CI\"\n    ```yaml\n    stages:\n      - deploy\n      - scan\n      - report\n      - cleanup\n\n    variables:\n      SCANNER_NAMESPACE: \"inspec-test\"\n      TARGET_LABEL: \"app=target-app\"\n      THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n    deploy_container:\n      stage: deploy\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: scan-target-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n            labels:\n              app: target-app\n              pipeline: \"${CI_PIPELINE_ID}\"\n          spec:\n            containers:\n            - name: target\n              image: registry.example.com/my-image:latest\n              command: [\"sleep\", \"1h\"]\n          EOF\n        - |\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --timeout=120s\n        - |\n          # Save target info for later stages\n          echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n          echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n      artifacts:\n        reports:\n          dotenv: deploy.env\n\n    create_access:\n      stage: scan\n      needs: [deploy_container]\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          # Create the role for this specific pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${TARGET_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${TARGET_POD}\"]\n          EOF\n        - |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          EOF\n        - |\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${CI_PIPELINE_ID}\n            namespace: ${SCANNER_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${CI_PIPELINE_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n        - |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --duration=30m)\n          echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n          # Save cluster info\n          SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten \\\n            -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n          echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n          echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n      artifacts:\n        reports:\n          dotenv: scanner.env\n\n    run_scan:\n      stage: scan\n      needs: [deploy_container, create_access]\n      script:\n        - |\n          # Create a kubeconfig file\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${CLUSTER_SERVER}\n              certificate-authority-data: ${CLUSTER_CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCANNER_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${SCANNER_TOKEN}\n          EOF\n        - |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Run cinc-auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml \\\n            cinc-auditor exec ${CINC_PROFILE_PATH} \\\n            -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n            --reporter json:scan-results.json\n\n          # Generate scan summary using SAF CLI\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display summary in job output\n          cat scan-summary.md\n\n          # Check scan against threshold\n          saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n          THRESHOLD_RESULT=$?\n\n          # Save result for later stages\n          echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n          if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce threshold as a gate\n            # exit ${THRESHOLD_RESULT}\n          fi\n      artifacts:\n        paths:\n          - scan-results.json\n          - scan-summary.md\n        reports:\n          dotenv: scan.env\n\n    generate_report:\n      stage: report\n      needs: [run_scan]\n      script:\n        - |\n          # Install SAF CLI if needed in this stage\n          which saf || npm install -g @mitre/saf\n\n          # Generate a more comprehensive report\n          saf view -i scan-results.json --output scan-report.html\n\n          # Create a simple markdown report for the MR\n          cat &gt; scan-report.md &lt;&lt; EOF\n          # Security Scan Results\n\n          ## Summary\n\n          $(cat scan-summary.md)\n\n          ## Threshold Check\n\n          ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n          Threshold: ${THRESHOLD_VALUE}%\n\n          ## Details\n\n          For full results, see the artifacts.\n          EOF\n      artifacts:\n        paths:\n          - scan-report.html\n          - scan-report.md\n        when: always\n\n    cleanup:\n      stage: cleanup\n      needs: [run_scan]\n      when: always  # Run even if previous stages failed\n      script:\n        - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n        - export KUBECONFIG=kubeconfig.yaml\n        - |\n          # Delete all resources\n          kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n          kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n            -n ${SCANNER_NAMESPACE} --ignore-not-found\n    ```\n</code></pre>"},{"location":"contributing/code-snippets/#best-practices","title":"Best Practices","text":"<ol> <li>Use Existing Examples: Reference existing example files rather than duplicating code</li> <li>Relative Paths: Use relative paths from the docs directory</li> <li>Context: Always provide explanatory text around code snippets</li> <li>Highlighting: Use line highlighting to draw attention to important parts</li> <li>Annotations: Add annotations to explain complex code sections</li> </ol>"},{"location":"contributing/code-snippets/#available-example-files","title":"Available Example Files","text":""},{"location":"contributing/code-snippets/#github-workflow-examples","title":"GitHub Workflow Examples","text":"<ul> <li><code>github-workflow-examples/ci-cd-pipeline.yml</code></li> <li><code>github-workflow-examples/setup-and-scan.yml</code></li> <li><code>github-workflow-examples/dynamic-rbac-scanning.yml</code></li> <li><code>github-workflow-examples/existing-cluster-scanning.yml</code></li> <li><code>github-workflow-examples/sidecar-scanner.yml</code></li> </ul>"},{"location":"contributing/code-snippets/#gitlab-ci-examples","title":"GitLab CI Examples","text":"<ul> <li><code>gitlab-pipeline-examples/gitlab-ci.yml</code></li> <li><code>gitlab-pipeline-examples/dynamic-rbac-scanning.yml</code></li> <li><code>gitlab-pipeline-examples/existing-cluster-scanning.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-sidecar.yml</code></li> <li><code>gitlab-pipeline-examples/gitlab-ci-sidecar-with-services.yml</code></li> </ul>"},{"location":"contributing/code-snippets/#further-reading","title":"Further Reading","text":"<p>For more information, see:</p> <ul> <li>PyMdown Extensions Documentation</li> <li>Material for MkDocs Code Blocks</li> </ul>"},{"location":"contributing/diagram-color-guide/","title":"Diagram Color Guide","text":"<p>This guide provides standards for creating accessible, WCAG-compliant diagrams that work well in both light and dark modes.</p>"},{"location":"contributing/diagram-color-guide/#wcag-compliance-for-diagrams","title":"WCAG Compliance for Diagrams","text":"<p>All diagrams should follow the Web Content Accessibility Guidelines (WCAG) 2.1 Level AA standards:</p> <ol> <li>Text Contrast Ratio: Text should have a contrast ratio of at least 4.5:1 against its background</li> <li>Important Graphics: Graphical elements conveying information should have a contrast ratio of at least 3:1</li> <li>Color Independence: Information should not be conveyed by color alone; always use shapes, patterns, or labels alongside color</li> </ol>"},{"location":"contributing/diagram-color-guide/#recommended-color-palette","title":"Recommended Color Palette","text":"<p>The following color palette has been tested for WCAG compliance and works well in both light and dark modes:</p>"},{"location":"contributing/diagram-color-guide/#primary-colors","title":"Primary Colors","text":"Purpose Color Hex Code Light Mode BG Dark Mode BG Primary Blue #0066CC 5.9:1 6.3:1 with white text Secondary Purple #4C366B 7.8:1 8.3:1 with white text Success Green #217645 5.6:1 5.9:1 with white text Warning Orange #DD6100 5.4:1 5.8:1 with white text Danger Red #A30000 8.5:1 9.1:1 with white text Neutral Gray #505050 7.0:1 7.5:1 with white text"},{"location":"contributing/diagram-color-guide/#node-type-colors","title":"Node Type Colors","text":"<p>For consistency across all diagrams, use the following color assignments:</p> <ul> <li>Start/End Nodes: Blue (#0066CC)</li> <li>Process Nodes: Gray (#505050) or Green (#217645)</li> <li>Decision Nodes: Orange (#DD6100)</li> <li>Input/Output Nodes: Purple (#4C366B)</li> <li>Success States: Green (#217645)</li> <li>Failure States: Red (#A30000)</li> </ul>"},{"location":"contributing/diagram-color-guide/#mermaid-diagram-example","title":"Mermaid Diagram Example","text":"<p>Here's an example of a WCAG-compliant Mermaid diagram using the recommended palette:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B{Decision?}\n    B --&gt;|Yes| C[Process 1]\n    B --&gt;|No| D[Process 2]\n    C --&gt; E[Output]\n    D --&gt; E\n    E --&gt; F{Validation}\n    F --&gt;|Pass| G[Success]\n    F --&gt;|Fail| H[Failure]\n    G --&gt; I[End]\n    H --&gt; I\n\n    %% WCAG-compliant styling\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style C fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style H fill:#A30000,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style I fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold</code></pre>"},{"location":"contributing/diagram-color-guide/#implementation-in-mermaid","title":"Implementation in Mermaid","text":"<p>When creating Mermaid diagrams, use the following style properties:</p> <pre><code>style NodeID fill:#HexColor,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n</code></pre> <p>For light mode compatibility, white text (#FFFFFF) works well with all the recommended background colors.</p>"},{"location":"contributing/diagram-color-guide/#proper-subgraph-containment","title":"Proper Subgraph Containment","text":"<p>When using subgraphs in Mermaid diagrams, follow these guidelines to ensure proper containment and wrapping:</p> <ol> <li>Always add <code>direction TB</code> inside subgraphs: This ensures proper containment of elements within the subgraph</li> </ol> <pre><code>flowchart TD\n  subgraph MySubgraph[\"My Subgraph Title\"]\n    direction TB\n    A --&gt; B\n    B --&gt; C\n  end</code></pre> <ol> <li> <p>Avoid using <code>classDef space</code> and <code>class</code> definitions in your diagrams, as these can interfere with proper rendering and containment. Instead, rely on the default sizing and standard styling.</p> </li> <li> <p>Consistent styling for subgraphs:</p> </li> </ol> <pre><code>style subgraphID fill:none,stroke:#DD6100,stroke-width:4px\n</code></pre> <ol> <li>Remove explicit text color and font-weight from subgraph labels to allow for automatic theme handling:</li> <li>Do NOT use: <code>style subgraphID fill:none,stroke:#DD6100,stroke-width:4px,color:#FFFFFF,font-weight:bold</code></li> <li>Instead use: <code>style subgraphID fill:none,stroke:#DD6100,stroke-width:4px</code></li> </ol> <p>These guidelines help ensure that subgraphs display correctly in both light and dark modes, with proper containment and wrapping of their elements.</p>"},{"location":"contributing/diagram-color-guide/#dark-mode-considerations","title":"Dark Mode Considerations","text":"<p>Our CSS and JavaScript configuration ensures that diagrams display properly in dark mode by:</p> <ol> <li>Increasing border contrast in dark mode</li> <li>Adjusting line thickness for better visibility</li> <li>Increasing font weight in dark mode for better readability</li> <li>Maintaining sufficient contrast for all elements</li> </ol>"},{"location":"contributing/diagram-color-guide/#testing-accessibility","title":"Testing Accessibility","text":"<p>To verify your diagram meets accessibility standards:</p> <ol> <li>Check color contrast using the WebAIM Contrast Checker</li> <li>Test in both light and dark modes</li> <li>Verify readability for users with color vision deficiencies using a tool like Color Oracle</li> </ol>"},{"location":"contributing/diagram-color-guide/#diagram-creation-process","title":"Diagram Creation Process","text":"<ol> <li>Design your diagram structure first</li> <li>Apply the standard color scheme based on node types</li> <li>Add clear, concise labels</li> <li>Include appropriate styling for all nodes</li> <li>Test in both light and dark mode</li> <li>Validate contrast ratios</li> </ol>"},{"location":"contributing/diagram-color-guide/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Pastel Colors: Avoid pale colors that lack sufficient contrast</li> <li>Red/Green Combinations: Avoid using red and green adjacently, which can be problematic for colorblind users</li> <li>Too Many Colors: Limit diagrams to 5-6 distinct colors for clarity</li> <li>Small Text: Ensure text is large enough and has sufficient weight</li> <li>Thin Lines: Use stroke-width of at least 2px for visibility</li> </ul> <p>By following these guidelines, your diagrams will be accessible to all users and display correctly in both light and dark mode themes.</p>"},{"location":"contributing/documentation-tools/","title":"Documentation Tools","text":"<p>This project provides a comprehensive documentation toolchain to ensure consistent, high-quality documentation. We use MkDocs with the Material theme as our documentation system, along with various validation tools.</p>"},{"location":"contributing/documentation-tools/#the-docs-toolssh-script","title":"The docs-tools.sh Script","text":"<p>Our <code>docs-tools.sh</code> script serves as the unified entry point for all documentation tasks, ensuring all contributors use consistent tooling and validation processes.</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Secure CINC Auditor Kubernetes Container Scanning          \u2503\n\u2503 Documentation Tools                                        \u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n\nUsage: ./docs-tools.sh [command]\n\nDocumentation Preview:\n  preview      - Start MkDocs server for local preview\n  status       - Check status of running preview server\n  stop         - Stop running preview server\n  restart      - Restart preview server\n  serve-prod   - Serve the production build locally\n\nDocumentation Quality:\n  lint         - Check Markdown files for style issues\n  fix          - Automatically fix linting issues where possible\n  spell        - Check spelling in documentation files\n  links        - Check for broken links (requires build first)\n  check-all    - Run all validation checks (lint, spell, links)\n\nBuild and Setup:\n  build        - Build static documentation site\n  setup        - Install/update all dependencies\n  help         - Show this help message\n</code></pre>"},{"location":"contributing/documentation-tools/#getting-started","title":"Getting Started","text":"<p>To start working on documentation:</p> <ol> <li>Clone the repository</li> </ol> <pre><code>git clone https://github.com/mitre/kube-secure-scanner.git\n</code></pre> <ol> <li>Navigate to the project root directory</li> </ol> <pre><code>cd kube-secure-scanner\n</code></pre> <ol> <li>Run initial setup to install dependencies:</li> </ol> <pre><code>./docs-tools.sh setup\n</code></pre> <ol> <li>Start the preview server:</li> </ol> <pre><code>./docs-tools.sh preview\n</code></pre> <p>The documentation will be available at http://localhost:8000.</p>"},{"location":"contributing/documentation-tools/#documentation-workflow","title":"Documentation Workflow","text":"<p>When working on documentation, follow this recommended workflow:</p>"},{"location":"contributing/documentation-tools/#1-start-your-session","title":"1. Start Your Session","text":"<pre><code># Update dependencies and start preview server\n./docs-tools.sh setup\n./docs-tools.sh preview\n</code></pre>"},{"location":"contributing/documentation-tools/#2-make-your-changes","title":"2. Make Your Changes","text":"<p>Edit markdown files in the <code>docs/</code> directory. The preview server automatically refreshes to show your changes.</p>"},{"location":"contributing/documentation-tools/#3-validate-your-work","title":"3. Validate Your Work","text":"<p>Before committing, always run the validation tools:</p> <pre><code># Check for style, spelling, and link issues\n./docs-tools.sh check-all\n</code></pre>"},{"location":"contributing/documentation-tools/#4-address-any-issues","title":"4. Address Any Issues","text":"<p>For linting issues:</p> <pre><code># Automatically fix common style issues\n./docs-tools.sh fix\n</code></pre> <p>For spelling issues:</p> <pre><code># Run spell check and add valid terms to dictionary\n./docs-tools.sh spell\n</code></pre>"},{"location":"contributing/documentation-tools/#5-finish-your-session","title":"5. Finish Your Session","text":"<pre><code># Stop the preview server when done\n./docs-tools.sh stop\n</code></pre>"},{"location":"contributing/documentation-tools/#documentation-standards","title":"Documentation Standards","text":"<p>When contributing to documentation, adhere to these standards:</p> <ol> <li>Consistent Terminology:</li> <li>Use \"CINC Auditor\" (not InSpec) consistently</li> <li> <p>Use standardized approach names:</p> <ul> <li>Kubernetes API Approach (recommended for enterprise)</li> <li>Debug Container Approach (interim solution)</li> <li>Sidecar Container Approach (interim solution)</li> </ul> </li> <li> <p>Strategic Emphasis:</p> </li> <li>Emphasize the Kubernetes API Approach as the enterprise-recommended solution</li> <li> <p>Clearly communicate that enhancing the train-k8s-container plugin is the highest strategic priority</p> </li> <li> <p>Links and References:</p> </li> <li>Use relative paths for links (e.g., <code>../overview/workflows.md</code>)</li> <li> <p>Ensure all external links are valid</p> </li> <li> <p>Code Snippets and Examples:</p> </li> <li>Use the Material for MkDocs snippet inclusion feature for code examples</li> <li>Place reusable code snippets in the <code>includes/</code> directory</li> <li> <p>Reference existing example files rather than duplicating them</p> </li> <li> <p>Validation Requirements:</p> </li> <li>All documentation must pass linting checks</li> <li>All spelling must be correct (with project-specific terms added to the dictionary)</li> <li>All links must be valid</li> </ol>"},{"location":"contributing/documentation-tools/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/documentation-tools/#preview-server-issues","title":"Preview Server Issues","text":"<p>If the preview server is unresponsive:</p> <pre><code># Check server status\n./docs-tools.sh status\n\n# Restart if necessary\n./docs-tools.sh restart\n</code></pre>"},{"location":"contributing/documentation-tools/#dependency-issues","title":"Dependency Issues","text":"<p>If you encounter dependency problems:</p> <pre><code># Clean and reinstall dependencies\n./docs-tools.sh setup --force\n</code></pre>"},{"location":"contributing/documentation-tools/#cicd-integration","title":"CI/CD Integration","text":"<p>The documentation is automatically built and validated in CI/CD pipelines using the same tools provided by the <code>docs-tools.sh</code> script. Any pull request with documentation changes will be checked for:</p> <ul> <li>Markdown style compliance</li> <li>Spelling correctness</li> <li>Link validity</li> <li>Successful build</li> </ul>"},{"location":"contributing/documentation-tools/#finding-help","title":"Finding Help","text":"<p>If you need assistance with documentation:</p> <ol> <li>Check the output of <code>./docs-tools.sh help</code></li> <li>Review the comments in the <code>mkdocs.yml</code> file</li> <li>Consult the MkDocs documentation</li> <li>Review the Material for MkDocs documentation</li> </ol>"},{"location":"contributing/inventory/","title":"Contributing Directory Contents","text":"<p>This page provides an inventory of all files in the contributing section of the documentation.</p>"},{"location":"contributing/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of contributing to documentation code-snippets.md Guide for including code examples in documentation diagram-color-guide.md Color scheme guidelines for creating consistent diagrams documentation-tools.md Overview of documentation development tools stig-api-tools.md Tools and APIs for working with DISA STIGs and SRGs"},{"location":"contributing/inventory/#subdirectories","title":"Subdirectories","text":""},{"location":"contributing/inventory/#testing","title":"Testing","text":"File Description dark-light-mode-test.md Test page for verifying dark/light mode functionality"},{"location":"contributing/inventory/#related-links","title":"Related Links","text":"<ul> <li>Developer Guide</li> <li>Project Documentation</li> </ul>"},{"location":"contributing/stig-api-tools/","title":"STIG/SRG API Tools","text":"<p>This document describes useful online tools and APIs for accessing, validating, and working with DISA STIGs and SRGs in documentation and code.</p>"},{"location":"contributing/stig-api-tools/#cyber-trackr-live","title":"Cyber Trackr Live","text":"<p>Cyber Trackr Live is a valuable online resource that provides access to Security Technical Implementation Guides (STIGs) and Security Requirements Guides (SRGs) through both a web interface and API.</p>"},{"location":"contributing/stig-api-tools/#web-interface","title":"Web Interface","text":"<p>The web interface allows browsing and searching STIGs and SRGs by:</p> <ul> <li>Title</li> <li>Version</li> <li>Release date</li> <li>Content</li> </ul> <p>For example, to view the Kubernetes STIG v1r11:</p> <pre><code>https://cyber.trackr.live/stig/Kubernetes/1/11\n</code></pre>"},{"location":"contributing/stig-api-tools/#api-usage","title":"API Usage","text":"<p>Cyber Trackr Live offers a robust API for programmatic access to STIGs and SRGs, which can be extremely valuable for:</p> <ul> <li>Validation of STIG/SRG requirements in documentation</li> <li>Automated compliance checking</li> <li>Building tools that integrate with STIG content</li> <li>Keeping documentation aligned with the latest STIG releases</li> </ul>"},{"location":"contributing/stig-api-tools/#api-endpoints","title":"API Endpoints","text":"<p>The base API URL is <code>https://cyber.trackr.live/api/</code></p> Endpoint Description Example <code>/stig</code> List all available STIGs <code>https://cyber.trackr.live/api/stig</code> <code>/stig/{title}/{version}/{release}</code> Get specific STIG <code>https://cyber.trackr.live/api/stig/Kubernetes/2/2</code>"},{"location":"contributing/stig-api-tools/#getting-a-list-of-stigs","title":"Getting a List of STIGs","text":"<pre><code>curl -X GET https://cyber.trackr.live/api/stig\n</code></pre> <p>This returns a JSON object with available STIGs grouped by title, including all versions and releases.</p> <p>Example response format:</p> <pre><code>{\n  \"Kubernetes\": [\n    {\n      \"date\": \"2024-08-22\",\n      \"released\": \"24 Oct 2024\",\n      \"version\": \"2\",\n      \"release\": \"2\",\n      \"link\": \"/stig/Kubernetes/2/2\"\n    },\n    {\n      \"date\": \"2023-08-29\",\n      \"released\": \"25 Oct 2023\",\n      \"version\": \"1\",\n      \"release\": \"11\",\n      \"link\": \"/stig/Kubernetes/1/11\"\n    }\n    // Additional versions...\n  ]\n  // Other STIGs...\n}\n</code></pre>"},{"location":"contributing/stig-api-tools/#getting-a-specific-stig","title":"Getting a Specific STIG","text":"<p>To retrieve details for a specific STIG, including all requirements:</p> <pre><code>curl -X GET https://cyber.trackr.live/api/stig/Kubernetes/2/2\n</code></pre> <p>This returns detailed information including:</p> <ul> <li>STIG metadata (release date, version)</li> <li>Requirements with vulnerability IDs (V-######)</li> <li>Rule descriptions</li> <li>Check procedures</li> <li>Fix procedures</li> </ul>"},{"location":"contributing/stig-api-tools/#using-the-api-for-documentation-validation","title":"Using the API for Documentation Validation","text":"<p>The API can be used to validate documentation against official STIG/SRG content:</p> <ol> <li>Verify Accuracy of Requirement References:</li> </ol> <pre><code># Get specific requirement\ncurl -X GET https://cyber.trackr.live/api/stig/Kubernetes/2/2 | jq '.[] | select(.vulnId==\"V-242407\")'\n</code></pre> <ol> <li>Check for Updated Requirements:</li> </ol> <pre><code># Compare versions\ncurl -X GET https://cyber.trackr.live/api/stig/Kubernetes/1/11 &gt; v1r11.json\ncurl -X GET https://cyber.trackr.live/api/stig/Kubernetes/2/2 &gt; v2r2.json\ndiff &lt;(jq -r '.[].vulnId' v1r11.json | sort) &lt;(jq -r '.[].vulnId' v2r2.json | sort)\n</code></pre> <ol> <li>Extract Requirement Text:</li> </ol> <pre><code># Get requirement title and description\ncurl -X GET https://cyber.trackr.live/api/stig/Kubernetes/2/2 | jq '.[] | select(.vulnId==\"V-242407\") | {title: .title, description: .description}'\n</code></pre>"},{"location":"contributing/stig-api-tools/#integration-into-documentation-workflow","title":"Integration into Documentation Workflow","text":"<p>This API can be integrated into documentation workflows to:</p> <ol> <li>Generate Documentation Stubs:</li> <li>Create initial compliance documentation with correct IDs and descriptions</li> <li> <p>Generate skeleton files for STIG/SRG requirements</p> </li> <li> <p>Validate Documentation Accuracy:</p> </li> <li>Check that requirement IDs mentioned in documentation exist</li> <li>Verify descriptions match official sources</li> <li> <p>Flag outdated references when new STIG versions are released</p> </li> <li> <p>Create Custom Compliance Reports:</p> </li> <li>Generate reports showing alignment with specific STIGs</li> <li>Create matrices showing coverage across multiple STIGs</li> </ol>"},{"location":"contributing/stig-api-tools/#implementation-example-stig-id-validator-script","title":"Implementation Example: STIG ID Validator Script","text":"<p>Here's a simple example script that could validate STIG IDs in markdown documentation:</p> <pre><code>#!/bin/bash\n# validate-stig-ids.sh - Validate STIG IDs in markdown files\n# \n# Extracts V-IDs from markdown files and validates them against the Cyber Trackr API\n\n# Extract all V-IDs from markdown files\nFOUND_IDS=$(grep -o 'V-[0-9]\\{6\\}' docs/security/compliance/*.md | sort | uniq)\n\n# Get the official list from the API\nOFFICIAL_IDS=$(curl -s https://cyber.trackr.live/api/stig/Kubernetes/2/2 | jq -r '.[].vulnId' | sort)\n\n# Compare and report\necho \"Validating STIG IDs in documentation...\"\nfor id in $FOUND_IDS; do\n  if echo \"$OFFICIAL_IDS\" | grep -q \"$id\"; then\n    echo \"\u2705 $id - Valid\"\n  else\n    echo \"\u274c $id - Not found in official STIG\"\n  fi\ndone\n</code></pre>"},{"location":"contributing/stig-api-tools/#related-documentation","title":"Related Documentation","text":"<ul> <li>Documentation Tools - Other documentation tools</li> <li>Contributing Guidelines - General contribution guidelines</li> <li>DISA Container Platform SRG - Our SRG alignment</li> <li>Kubernetes STIG - Our STIG alignment</li> </ul>"},{"location":"contributing/testing/","title":"Documentation Testing","text":"<p>This section provides resources for testing documentation display features and ensuring accessibility across different viewing modes.</p>"},{"location":"contributing/testing/#overview","title":"Overview","text":"<p>Testing documentation is a critical part of ensuring a high-quality user experience. Our documentation needs to be accessible, readable, and visually consistent across different devices, browsers, and display preferences.</p>"},{"location":"contributing/testing/#testing-areas","title":"Testing Areas","text":"<p>We focus on the following key testing areas:</p> <ol> <li>Accessibility Testing - Ensuring documentation meets WCAG standards</li> <li>Dark/Light Mode Testing - Verifying proper rendering in both color modes</li> <li>Responsive Design Testing - Ensuring documentation looks good on all devices</li> <li>Interactive Elements Testing - Testing tabs, admonitions, and code blocks</li> </ol>"},{"location":"contributing/testing/#test-pages","title":"Test Pages","text":"<p>The following test pages are available to help verify documentation rendering:</p> <ul> <li>Dark/Light Mode Test - Test page for verifying visual elements in both dark and light color schemes</li> </ul>"},{"location":"contributing/testing/#best-practices-for-documentation-testing","title":"Best Practices for Documentation Testing","text":"<p>When testing documentation:</p> <ol> <li>Check both light and dark modes</li> <li>Test with screen readers and keyboard navigation</li> <li>Verify diagrams have proper contrast ratios</li> <li>Ensure code snippets are readable in both modes</li> <li>Test on multiple devices and screen sizes</li> </ol>"},{"location":"contributing/testing/#using-color-schemes-that-work-in-both-modes","title":"Using Color Schemes That Work in Both Modes","text":"<p>When creating diagrams or custom elements, follow these guidelines:</p> <ul> <li>Use WCAG-compliant color combinations</li> <li>Test contrast ratios for both dark and light backgrounds</li> <li>Avoid color as the only means of conveying information</li> <li>Use patterns or shapes to supplement color coding</li> </ul> <p>For specific color recommendations, see the Diagram Color Guide.</p>"},{"location":"contributing/testing/dark-light-mode-test/","title":"Dark/Light Mode Rendering Test","text":"<p>This document tests the rendering of various elements in both dark and light themes to ensure proper display.</p>"},{"location":"contributing/testing/dark-light-mode-test/#mermaid-diagram-test","title":"Mermaid Diagram Test","text":"<p>The following Mermaid diagram should display correctly in both light and dark modes:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Create Minimal RBAC]\n    B --&gt; C[Generate Short-lived Token]\n    C --&gt; D[Create Scanner Kubeconfig]\n    D --&gt; E[Run CINC Auditor Scan]\n    E --&gt; F[Generate Reports]\n    F --&gt; G[Validate Against Thresholds]\n    G --&gt; H[Cleanup Resources]\n    H --&gt; I[End]\n\n    %% High contrast WCAG-compliant colors\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#116644,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style I fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#yaml-code-block-test","title":"YAML Code Block Test","text":"<p>YAML code blocks should display with proper syntax highlighting:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: scanner-test-pod\n  labels:\n    app: security-scanner\nspec:\n  containers:\n  - name: scanner\n    image: cinc/auditor:latest\n    command: [\"sleep\", \"3600\"]\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000\n      capabilities:\n        drop: [\"ALL\"]\n  serviceAccountName: scanner-sa\n</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#bash-code-block-test","title":"Bash Code Block Test","text":"<p>Bash code should also display with proper syntax highlighting:</p> <pre><code>#!/bin/bash\n# Example script for scanning\n\n# Set up variables\nNAMESPACE=\"scanner-ns\"\nSERVICE_ACCOUNT=\"scanner-sa\"\nTARGET_POD=\"target-pod\"\n\n# Create scanner kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh \"$NAMESPACE\" \"$SERVICE_ACCOUNT\"\n\n# Run scanner\ncinc-auditor exec my-profile -t k8s-container://$TARGET_POD --namespace $NAMESPACE\n</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#admonition-test","title":"Admonition Test","text":"<p>Admonitions should display with proper styling in both themes:</p> <p>Note Box</p> <p>This is a note admonition that should display properly in both themes.</p> <p>Warning Box</p> <p>This is a warning admonition that should display properly in both themes.</p> <p>Danger Box</p> <p>This is a danger admonition that should display properly in both themes.</p> <p>Tip Box</p> <p>This is a tip admonition that should display properly in both themes.</p>"},{"location":"contributing/testing/dark-light-mode-test/#table-test","title":"Table Test","text":"<p>Tables should be readable in both themes:</p> Approach Pros Cons Enterprise Readiness Kubernetes API No extra containers Limited to standard containers High Debug Container Works with distroless Requires ephemeral containers Medium Sidecar Universal support Extra container overhead High"},{"location":"contributing/testing/dark-light-mode-test/#dark-mode-vs-light-mode-elements","title":"Dark Mode vs Light Mode Elements","text":"<p>When switching between dark and light modes:</p> <ol> <li>Code block backgrounds should adapt</li> <li>Table borders and backgrounds should adapt</li> <li>Mermaid diagrams should update colors for readability</li> <li>Admonition backgrounds should adapt</li> <li>Text should maintain high contrast</li> </ol>"},{"location":"contributing/testing/dark-light-mode-test/#wcag-compliant-complex-diagram","title":"WCAG-Compliant Complex Diagram","text":"<p>This diagram demonstrates WCAG-compliant colors with good contrast in both light and dark modes:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B{Container Type?}\n    B --&gt;|Standard| C[Run Standard Scan]\n    B --&gt;|Distroless| D{Debug Available?}\n    D --&gt;|Yes| E[Debug Container Scan]\n    D --&gt;|No| F[Sidecar Container Scan]\n    C --&gt; G[Generate Reports]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H{Thresholds Met?}\n    H --&gt;|Yes| I[Pass]\n    H --&gt;|No| J[Fail]\n    I --&gt; K[End]\n    J --&gt; K\n\n    %% WCAG-compliant high contrast color scheme\n    style A fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style B fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style C fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style D fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style E fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style F fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style G fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style H fill:#DD6100,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style I fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style J fill:#A30000,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style K fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold</code></pre>"},{"location":"contributing/testing/dark-light-mode-test/#color-scheme-explanation","title":"Color Scheme Explanation","text":"<p>The above diagram follows WCAG 2.1 color contrast guidelines:</p> Element Type Color Hex Code Purpose Contrast Ratio Start/End Blue #0066CC Primary flow 6.3:1 with white text Decision Orange #DD6100 Decision points 5.8:1 with white text Process Green #217645 Standard processes 5.9:1 with white text Special Purple #4C366B Special processes 8.3:1 with white text Success Green #217645 Success states 5.9:1 with white text Failure Red #A30000 Failure states 9.1:1 with white text"},{"location":"contributing/testing/inventory/","title":"Testing Directory Contents","text":"<p>This page provides an inventory of all testing-related documentation files.</p>"},{"location":"contributing/testing/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of documentation testing approaches dark-light-mode-test.md Test page for verifying dark/light mode functionality"},{"location":"contributing/testing/inventory/#related-links","title":"Related Links","text":"<ul> <li>Contributing Overview</li> <li>Diagram Color Guide</li> <li>Developer Testing</li> </ul>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>This guide provides comprehensive information for developers working with the Kube CINC Secure Scanner platform.</p>"},{"location":"developer-guide/#overview","title":"Overview","text":"<p>The developer guide is designed to help you understand, test, deploy, and contribute to the Kube CINC Secure Scanner project. Whether you're setting up a development environment, implementing tests, or preparing for production deployment, this guide provides the necessary information.</p>"},{"location":"developer-guide/#key-areas","title":"Key Areas","text":"<p>The developer guide covers several critical areas:</p>"},{"location":"developer-guide/#testing","title":"Testing","text":"<p>The Testing Guide provides information on:</p> <ul> <li>Setting up test environments</li> <li>Running automated tests</li> <li>Creating new test cases</li> <li>Testing with different Kubernetes configurations</li> </ul>"},{"location":"developer-guide/#deployment","title":"Deployment","text":"<p>The Deployment Guide covers:</p> <ul> <li>Preparing for production deployment</li> <li>Sizing considerations</li> <li>High availability configurations</li> <li>Performance tuning</li> <li>Production security considerations</li> </ul>"},{"location":"developer-guide/#development-workflow","title":"Development Workflow","text":"<p>The typical development workflow for this project includes:</p> <ol> <li>Environment Setup</li> <li>Clone the repository</li> <li>Install dependencies</li> <li> <p>Set up test environment (typically using Minikube)</p> </li> <li> <p>Development</p> </li> <li>Make code changes</li> <li>Implement tests</li> <li> <p>Document your changes</p> </li> <li> <p>Testing</p> </li> <li>Run unit tests</li> <li>Run integration tests</li> <li> <p>Perform security validation</p> </li> <li> <p>Deployment</p> </li> <li>Package for deployment</li> <li>Deploy to target environment</li> <li>Monitor for issues</li> </ol>"},{"location":"developer-guide/#contributing","title":"Contributing","text":"<p>For details on how to contribute to the project, please see the Contributing Guide.</p>"},{"location":"developer-guide/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Documentation</li> <li>Kubernetes Setup Guide</li> <li>Security Considerations</li> </ul>"},{"location":"developer-guide/inventory/","title":"Developer Guide Directory Contents","text":"<p>This page provides an inventory of all files in the developer guide section of the documentation.</p>"},{"location":"developer-guide/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of the developer guide"},{"location":"developer-guide/inventory/#subdirectories","title":"Subdirectories","text":""},{"location":"developer-guide/inventory/#deployment","title":"Deployment","text":"<p>Documentation related to deploying the Kube CINC Secure Scanner in various environments.</p> File Description index.md Overview of deployment strategies and considerations inventory.md Directory listing of all deployment-related documentation"},{"location":"developer-guide/inventory/#testing","title":"Testing","text":"<p>Documentation related to testing methodologies and procedures.</p> File Description index.md Overview of testing approaches and methodologies inventory.md Directory listing of all testing-related documentation"},{"location":"developer-guide/inventory/#related-links","title":"Related Links","text":"<ul> <li>Contributing Guide</li> <li>Helm Charts Documentation</li> <li>Kubernetes Setup Guide</li> </ul>"},{"location":"developer-guide/deployment/","title":"Deployment Overview","text":"<p>Directory Inventory</p> <p>See the Deployment Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This document provides an overview of deploying the Secure CINC Auditor Kubernetes Container Scanning solution in various environments.</p>"},{"location":"developer-guide/deployment/#deployment-methods","title":"Deployment Methods","text":"<p>The container scanning solution can be deployed in several ways:</p> <ol> <li>Script-based Deployment: Using helper scripts for direct deployment</li> <li>Helm Charts Deployment: Using modular Helm charts for production deployment</li> <li>CI/CD Pipeline Integration: Integrating scanning into existing CI/CD workflows</li> </ol> <p>Each deployment method has its own advantages and is suitable for different scenarios.</p>"},{"location":"developer-guide/deployment/#deployment-scenarios","title":"Deployment Scenarios","text":"<p>We provide guidance for several common deployment scenarios:</p> <ul> <li>Enterprise Production Environment: Secure, scalable deployment for enterprise environments</li> <li>Development Environment: Rapid deployment for development and testing</li> <li>CI/CD Pipeline Environment: Integration with automated pipelines</li> <li>Multi-Tenant Kubernetes Environment: Secure deployment in shared clusters</li> </ul>"},{"location":"developer-guide/deployment/#advanced-deployment-topics","title":"Advanced Deployment Topics","text":"<p>For specialized environments and requirements:</p> <ul> <li>Scaling Considerations: Handling large-scale deployments</li> <li>Security Considerations: Enhanced security measures</li> <li>Monitoring and Maintenance: Long-term operations</li> <li>Air-Gapped Environments: Deployment without internet access</li> <li>High-Security Environments: Additional security controls</li> </ul>"},{"location":"developer-guide/deployment/#deployment-prerequisites","title":"Deployment Prerequisites","text":"<p>Before deploying, ensure you have:</p> <ol> <li>Kubernetes Cluster Requirements:</li> <li>Kubernetes 1.16+ (for all features including ephemeral containers)</li> <li>RBAC enabled</li> <li> <p>Service account support</p> </li> <li> <p>Tool Requirements:</p> </li> <li>kubectl with cluster access</li> <li>Helm 3+ (for Helm-based deployment)</li> <li>CINC Auditor/InSpec</li> <li> <p>SAF CLI (for threshold validation)</p> </li> <li> <p>Access Requirements:</p> </li> <li>Permissions to create namespaces, service accounts, and roles</li> <li>Permissions to create and manage pods</li> </ol>"},{"location":"developer-guide/deployment/#getting-started","title":"Getting Started","text":"<p>To get started with deployment, follow these steps:</p> <ol> <li>Review the deployment prerequisites</li> <li>Choose the appropriate deployment method for your environment</li> <li>Follow the detailed instructions for your chosen method</li> <li>Verify your deployment using the verification procedures</li> </ol>"},{"location":"developer-guide/deployment/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Charts Documentation</li> <li>RBAC Configuration</li> <li>Service Account Setup</li> <li>Threshold Configuration</li> <li>Integration Options</li> <li>Testing Guide</li> </ul>"},{"location":"developer-guide/deployment/cicd-deployment/","title":"CI/CD Pipeline Integration","text":"<p>This guide explains how to integrate the Secure CINC Auditor Kubernetes Container Scanning solution into CI/CD pipelines.</p>"},{"location":"developer-guide/deployment/cicd-deployment/#overview","title":"Overview","text":"<p>CI/CD integration is ideal for:</p> <ul> <li>Automated security scanning in deployment pipelines</li> <li>DevSecOps workflows</li> <li>Container validation before deployment</li> <li>Continuous compliance monitoring</li> </ul> <p>Integrating container scanning into CI/CD pipelines helps catch security issues early in the development lifecycle.</p>"},{"location":"developer-guide/deployment/cicd-deployment/#integration-approaches","title":"Integration Approaches","text":"<p>There are several approaches to CI/CD integration:</p> <ol> <li>Direct Script Integration: Execute scanning scripts directly in pipelines</li> <li>Container-based Integration: Run scanners as containers in pipeline stages</li> <li>Helm-based Integration: Deploy and execute scanners using Helm in pipelines</li> <li>API-based Integration: Trigger scans via API calls from pipelines</li> </ol>"},{"location":"developer-guide/deployment/cicd-deployment/#github-actions-integration","title":"GitHub Actions Integration","text":""},{"location":"developer-guide/deployment/cicd-deployment/#basic-github-actions-integration","title":"Basic GitHub Actions Integration","text":"<ol> <li>Add the GitHub Actions workflow to your repository:</li> </ol> <pre><code># .github/workflows/container-scan.yml\nname: Container Security Scan\non: [push, pull_request]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n\n      - name: Deploy scanner\n        run: ./kubernetes-scripts/setup-minikube.sh\n\n      - name: Run scan\n        run: ./kubernetes-scripts/scan-container.sh default app-pod app-container profiles/container-baseline\n</code></pre> <ol> <li>Configure repository secrets for any credentials needed.</li> </ol>"},{"location":"developer-guide/deployment/cicd-deployment/#advanced-github-actions-integration","title":"Advanced GitHub Actions Integration","text":"<p>For more advanced use cases, create a comprehensive workflow:</p> <pre><code># .github/workflows/advanced-container-scan.yml\nname: Advanced Container Security Scan\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n  schedule:\n    - cron: '0 0 * * *'  # Daily scan\n\njobs:\n  prepare:\n    runs-on: ubuntu-latest\n    outputs:\n      matrix: ${{ steps.set-matrix.outputs.matrix }}\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set scan matrix\n        id: set-matrix\n        run: |\n          echo \"::set-output name=matrix::{\\\"container\\\":[\\\"app\\\",\\\"api\\\",\\\"worker\\\"],\\\"profile\\\":[\\\"container-baseline\\\",\\\"cis-kubernetes\\\"]}\"\n\n  scan:\n    needs: prepare\n    runs-on: ubuntu-latest\n    strategy:\n      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n\n      - name: Build and deploy test containers\n        run: |\n          docker build -t ${{ matrix.container }}-image ./containers/${{ matrix.container }}\n          kind load docker-image ${{ matrix.container }}-image\n          kubectl apply -f ./kubernetes/deploy-${{ matrix.container }}.yaml\n\n      - name: Deploy scanner\n        run: ./kubernetes-scripts/setup-minikube.sh\n\n      - name: Run scan\n        run: ./kubernetes-scripts/scan-container.sh default ${{ matrix.container }}-pod ${{ matrix.container }} profiles/${{ matrix.profile }}\n\n      - name: Process results\n        run: |\n          saf report -i results.json -o report.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v2\n        with:\n          name: scan-results-${{ matrix.container }}-${{ matrix.profile }}\n          path: report.html\n</code></pre> <p>For more examples, see the GitHub Workflow Examples.</p>"},{"location":"developer-guide/deployment/cicd-deployment/#gitlab-ci-integration","title":"GitLab CI Integration","text":""},{"location":"developer-guide/deployment/cicd-deployment/#basic-gitlab-ci-integration","title":"Basic GitLab CI Integration","text":"<ol> <li>Add the GitLab CI pipeline to your repository:</li> </ol> <pre><code># .gitlab-ci.yml\nstages:\n  - deploy\n  - scan\n  - report\n\ndeploy_scanner:\n  stage: deploy\n  script:\n    - ./kubernetes-scripts/setup-minikube.sh\n\nrun_scan:\n  stage: scan\n  script:\n    - ./kubernetes-scripts/scan-container.sh default app-pod app-container profiles/container-baseline\n\ngenerate_report:\n  stage: report\n  script:\n    - saf report -i results.json -o report.html\n  artifacts:\n    paths:\n      - report.html\n</code></pre> <ol> <li>Configure CI/CD variables for any credentials needed.</li> </ol>"},{"location":"developer-guide/deployment/cicd-deployment/#advanced-gitlab-ci-integration","title":"Advanced GitLab CI Integration","text":"<p>For more robust GitLab CI integration:</p> <pre><code># .gitlab-ci.yml\nvariables:\n  KUBERNETES_VERSION: 1.23.5\n  SCANNER_IMAGE: cinc/auditor:latest\n  SAF_CLI_VERSION: 2.0.0\n\nstages:\n  - build\n  - deploy\n  - scan\n  - report\n  - cleanup\n\n.kubernetes_template: &amp;kubernetes_setup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y curl\n    - curl -LO \"https://dl.k8s.io/release/v${KUBERNETES_VERSION}/bin/linux/amd64/kubectl\"\n    - chmod +x kubectl &amp;&amp; mv kubectl /usr/local/bin/\n    - curl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64\n    - chmod +x ./kind &amp;&amp; mv ./kind /usr/local/bin/kind\n    - kind create cluster --name scanner-cluster\n    - kubectl cluster-info\n    - kubectl get nodes\n\nbuild_containers:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker build -t app-image ./containers/app\n    - docker build -t api-image ./containers/api\n    - docker save app-image &gt; app-image.tar\n    - docker save api-image &gt; api-image.tar\n  artifacts:\n    paths:\n      - app-image.tar\n      - api-image.tar\n\ndeploy_containers:\n  stage: deploy\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - kind load image-archive app-image.tar\n    - kind load image-archive api-image.tar\n    - kubectl apply -f ./kubernetes/deployments/\n\ndeploy_scanner:\n  stage: deploy\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - ./kubernetes-scripts/setup-minikube.sh\n    - kubectl get pods -A\n\nscan_job:\n  stage: scan\n  parallel:\n    matrix:\n      - CONTAINER: [\"app\", \"api\"]\n        PROFILE: [\"container-baseline\", \"cis-kubernetes\"]\n  script:\n    - ./kubernetes-scripts/scan-container.sh default ${CONTAINER}-pod ${CONTAINER} profiles/${PROFILE}\n    - mkdir -p ./results/${CONTAINER}/${PROFILE}\n    - cp results.json ./results/${CONTAINER}/${PROFILE}/\n  artifacts:\n    paths:\n      - ./results/\n\ngenerate_reports:\n  stage: report\n  image: ruby:latest\n  script:\n    - gem install saf-cli -v ${SAF_CLI_VERSION}\n    - mkdir -p ./reports\n    - |\n      for dir in ./results/*; do\n        CONTAINER=$(basename $dir)\n        for profile_dir in $dir/*; do\n          PROFILE=$(basename $profile_dir)\n          saf report -i $profile_dir/results.json -o ./reports/${CONTAINER}-${PROFILE}.html\n        done\n      done\n  artifacts:\n    paths:\n      - ./reports/\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - kind delete cluster --name scanner-cluster\n  when: always\n</code></pre> <p>For more examples, see the GitLab Pipeline Examples.</p>"},{"location":"developer-guide/deployment/cicd-deployment/#jenkins-integration","title":"Jenkins Integration","text":"<p>Add a Jenkinsfile to your repository:</p> <pre><code>pipeline {\n    agent {\n        kubernetes {\n            yaml \"\"\"\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: kubernetes\n    image: bitnami/kubectl:latest\n    command:\n    - cat\n    tty: true\n  - name: scanner\n    image: cinc/auditor:latest\n    command:\n    - cat\n    tty: true\n\"\"\"\n        }\n    }\n\n    stages {\n        stage('Deploy Scanner') {\n            steps {\n                container('kubernetes') {\n                    sh './kubernetes-scripts/setup-minikube.sh'\n                }\n            }\n        }\n\n        stage('Run Scan') {\n            steps {\n                container('scanner') {\n                    sh './kubernetes-scripts/scan-container.sh default app-pod app-container profiles/container-baseline'\n                }\n            }\n        }\n\n        stage('Process Results') {\n            steps {\n                container('scanner') {\n                    sh 'saf report -i results.json -o report.html'\n                    archiveArtifacts artifacts: 'report.html', fingerprint: true\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"developer-guide/deployment/cicd-deployment/#cicd-integration-best-practices","title":"CI/CD Integration Best Practices","text":"<ol> <li>Automate Everything:</li> <li>Avoid manual steps in your scanning workflow</li> <li> <p>Parameterize configurations for flexibility</p> </li> <li> <p>Scan Early and Often:</p> </li> <li>Integrate scanning in multiple pipeline stages</li> <li> <p>Scan both development and production images</p> </li> <li> <p>Manage Thresholds Appropriately:</p> </li> <li>Use stricter thresholds for production-bound containers</li> <li> <p>Consider progressive thresholds for different environments</p> </li> <li> <p>Handle Results Properly:</p> </li> <li>Archive scan results as pipeline artifacts</li> <li> <p>Integrate with security dashboards and notification systems</p> </li> <li> <p>Fail Builds Appropriately:</p> </li> <li>Decide whether scans should be blocking or informational</li> <li>Consider using warning thresholds vs. failure thresholds</li> </ol>"},{"location":"developer-guide/deployment/cicd-deployment/#integration-with-kubernetes-controllers","title":"Integration with Kubernetes Controllers","text":"<p>For ongoing scanning in Kubernetes environments:</p> <pre><code># scan-cronjob.yaml\napiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  name: container-security-scan\nspec:\n  schedule: \"0 */6 * * *\"  # Every 6 hours\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          serviceAccountName: scanner-sa\n          containers:\n          - name: scanner\n            image: cinc/auditor:latest\n            command:\n            - /bin/sh\n            - -c\n            - ./kubernetes-scripts/scan-container.sh default app-pod app-container profiles/container-baseline\n          restartPolicy: OnFailure\n</code></pre>"},{"location":"developer-guide/deployment/cicd-deployment/#related-topics","title":"Related Topics","text":"<ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>Deployment Scenarios</li> <li>Threshold Configuration</li> </ul>"},{"location":"developer-guide/deployment/helm-deployment/","title":"Helm Charts Deployment","text":"<p>This guide provides detailed instructions for deploying the Secure CINC Auditor Kubernetes Container Scanning solution using Helm charts.</p>"},{"location":"developer-guide/deployment/helm-deployment/#overview","title":"Overview","text":"<p>Helm-based deployment is ideal for:</p> <ul> <li>Production environments</li> <li>Automated deployments</li> <li>Integration with existing Kubernetes workflows</li> <li>Customized scanning configurations</li> </ul> <p>Helm charts provide a standardized, repeatable way to deploy the scanner with various configurations.</p>"},{"location":"developer-guide/deployment/helm-deployment/#available-helm-charts","title":"Available Helm Charts","text":"<p>The project includes several modular Helm charts:</p> <ul> <li>scanner-infrastructure: Base infrastructure including namespaces, service accounts, and RBAC</li> <li>common-scanner: Common components and configurations shared by all scanner types</li> <li>standard-scanner: Scanner for standard containers using the Kubernetes API approach</li> <li>distroless-scanner: Scanner for distroless containers using the debug container approach</li> <li>sidecar-scanner: Scanner using the sidecar container approach</li> </ul>"},{"location":"developer-guide/deployment/helm-deployment/#basic-helm-deployment","title":"Basic Helm Deployment","text":"<p>For a simple deployment with default settings:</p> <pre><code># Add Helm repository (if hosted externally)\nhelm repo add secure-scanner https://example.com/helm-charts/\nhelm repo update\n\n# Install scanner infrastructure\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure\n\n# Install the appropriate scanner based on your container types\nhelm install standard-scanner ./helm-charts/standard-scanner\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#customized-helm-deployment","title":"Customized Helm Deployment","text":"<p>For customized deployments, create a values file:</p> <pre><code># Create custom values file\ncat &gt; custom-values.yaml &lt;&lt; EOF\nglobal:\n  namespace: security-scanning\n  serviceAccount:\n    create: true\n    name: restricted-scanner\n  rbac:\n    timeoutSeconds: 900\n    podSelector:\n      matchLabels:\n        scan: enabled\nEOF\n\n# Install with custom values\nhelm install -f custom-values.yaml scanner-infrastructure ./helm-charts/scanner-infrastructure\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#common-customization-options","title":"Common Customization Options","text":"<p>The following customization options are available for all charts:</p> <ul> <li>Namespace Configuration: Customize the namespace for scanner deployment</li> <li>RBAC Settings: Configure role-based access control rules</li> <li>Service Account: Configure service account settings</li> <li>Resource Limits: Set CPU and memory limits for scanner components</li> <li>Scanning Parameters: Configure scan frequency, timeouts, and targets</li> </ul>"},{"location":"developer-guide/deployment/helm-deployment/#chart-specific-configurations","title":"Chart-Specific Configurations","text":""},{"location":"developer-guide/deployment/helm-deployment/#scanner-infrastructure-chart","title":"Scanner Infrastructure Chart","text":"<pre><code># scanner-infrastructure values.yaml\nglobal:\n  namespace: scanner-system\n  createNamespace: true\n\nrbac:\n  strategy: label-based  # or \"namespace-based\"\n  timeoutSeconds: 600\n  labelSelector:\n    scan: enabled\n\nserviceAccount:\n  create: true\n  name: scanner-sa\n  annotations:\n    custom.annotation: value\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#standard-scanner-chart","title":"Standard Scanner Chart","text":"<pre><code># standard-scanner values.yaml\nglobal:\n  namespace: scanner-system\n\nscanner:\n  image:\n    repository: cinc/auditor\n    tag: latest\n  resources:\n    requests:\n      cpu: 100m\n      memory: 256Mi\n    limits:\n      cpu: 500m\n      memory: 512Mi\n\nprofiles:\n  - name: container-baseline\n    path: profiles/container-baseline\n  - name: kube-baseline\n    path: profiles/kube-baseline\n\nschedule: \"0 0 * * *\"  # Daily at midnight (cron format)\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#distroless-scanner-chart","title":"Distroless Scanner Chart","text":"<pre><code># distroless-scanner values.yaml\nglobal:\n  namespace: scanner-system\n\ndebugContainer:\n  image:\n    repository: busybox\n    tag: latest\n  command: [\"/bin/sh\"]\n\nscanner:\n  image:\n    repository: cinc/auditor\n    tag: latest\n  resources:\n    requests:\n      cpu: 200m\n      memory: 256Mi\n    limits:\n      cpu: 1000m\n      memory: 1Gi\n\nprofiles:\n  - name: container-baseline\n    path: profiles/container-baseline\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#production-deployment-recommendations","title":"Production Deployment Recommendations","text":"<p>For production deployments, consider the following recommendations:</p> <ol> <li>Use Version Pinning:</li> </ol> <pre><code>scanner:\n  image:\n    repository: cinc/auditor\n    tag: 5.18.14  # Pin to specific version\n</code></pre> <ol> <li>Configure Resource Limits:</li> </ol> <pre><code>resources:\n  requests:\n    cpu: 500m\n    memory: 512Mi\n  limits:\n    cpu: 2000m\n    memory: 1Gi\n</code></pre> <ol> <li>Enable Security Features:</li> </ol> <pre><code>securityContext:\n  runAsUser: 1000\n  runAsGroup: 1000\n  fsGroup: 1000\n  runAsNonRoot: true\n  readOnlyRootFilesystem: true\n</code></pre> <ol> <li>Configure Persistent Storage:</li> </ol> <pre><code>persistence:\n  enabled: true\n  storageClass: standard\n  size: 10Gi\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#helm-deployment-workflow","title":"Helm Deployment Workflow","text":"<p>The Helm-based deployment follows this general workflow:</p> <ol> <li>Planning: Determine which charts and configurations you need</li> <li>Configuration: Create custom values files for your environment</li> <li>Installation: Install the charts using Helm</li> <li>Verification: Verify the deployment is working correctly</li> <li>Maintenance: Update values and upgrade charts as needed</li> </ol>"},{"location":"developer-guide/deployment/helm-deployment/#upgrading-helm-deployments","title":"Upgrading Helm Deployments","text":"<p>To update an existing deployment:</p> <pre><code># Update custom values file with new settings\nnano custom-values.yaml\n\n# Upgrade the deployment\nhelm upgrade -f custom-values.yaml scanner-infrastructure ./helm-charts/scanner-infrastructure\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#uninstalling-helm-deployments","title":"Uninstalling Helm Deployments","text":"<p>To remove a deployment:</p> <pre><code># Uninstall charts\nhelm uninstall standard-scanner\nhelm uninstall scanner-infrastructure\n\n# Clean up persistent resources if needed\nkubectl delete namespace scanner-system\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#advanced-helm-features","title":"Advanced Helm Features","text":""},{"location":"developer-guide/deployment/helm-deployment/#using-helm-dependencies","title":"Using Helm Dependencies","text":"<p>For complex deployments, you can use Helm dependencies:</p> <pre><code># Chart.yaml\ndependencies:\n  - name: scanner-infrastructure\n    version: 1.0.0\n    repository: https://example.com/helm-charts/\n    condition: scanner-infrastructure.enabled\n  - name: standard-scanner\n    version: 1.0.0\n    repository: https://example.com/helm-charts/\n    condition: standard-scanner.enabled\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#using-helm-post-render","title":"Using Helm Post-Render","text":"<p>For advanced customization, consider using post-render hooks:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --post-renderer ./scripts/customize-yamls.sh\n</code></pre>"},{"location":"developer-guide/deployment/helm-deployment/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Charts Documentation</li> <li>Deployment Scenarios</li> <li>Advanced Deployment Topics</li> <li>RBAC Configuration</li> </ul>"},{"location":"developer-guide/deployment/inventory/","title":"Deployment Directory Inventory","text":"<p>This document provides a directory overview of the deployment resources and documentation.</p>"},{"location":"developer-guide/deployment/inventory/#directory-contents","title":"Directory Contents","text":"<p>The deployment directory contains comprehensive documentation for deploying the container scanning solution:</p> File Description index.md Overview of deployment options and prerequisites script-deployment.md Guide for script-based deployment helm-deployment.md Guide for Helm-based deployment cicd-deployment.md Guide for CI/CD pipeline integration scenarios.md Redirect to detailed deployment scenarios scenarios/index.md Overview of deployment scenarios scenarios/enterprise.md Enterprise production environment deployment scenarios/development.md Development environment deployment scenarios/cicd.md CI/CD pipeline environment deployment scenarios/multi-tenant.md Multi-tenant Kubernetes environment deployment scenarios/air-gapped.md Air-gapped environment deployment advanced-topics.md Redirect to detailed advanced topics advanced-topics/index.md Overview of advanced deployment topics advanced-topics/scaling.md Scaling and performance optimization advanced-topics/security.md Advanced security configurations advanced-topics/monitoring.md Monitoring and maintenance advanced-topics/specialized-environments.md Specialized environment deployments advanced-topics/verification.md Deployment verification and testing advanced-topics/custom-development.md Custom script and extension development advanced-topics/inventory.md Advanced topics directory listing inventory.md This directory listing"},{"location":"developer-guide/deployment/inventory/#deployment-methods","title":"Deployment Methods","text":"<p>This directory covers multiple deployment approaches for different environments:</p> <ul> <li>Script-based Deployment: Using helper scripts for direct deployment in development environments</li> <li>Helm Charts Deployment: Using modular Helm charts for robust production deployment</li> <li>CI/CD Pipeline Integration: Integrating scanning into existing CI/CD workflows</li> </ul>"},{"location":"developer-guide/deployment/inventory/#deployment-scenarios","title":"Deployment Scenarios","text":"<p>The documentation covers various deployment scenarios including:</p> <ol> <li>Enterprise Production Environment</li> <li>Development Environment</li> <li>CI/CD Pipeline Environment</li> <li>Multi-Tenant Kubernetes Environment</li> <li>Air-Gapped Environments</li> <li>High-Security Environments</li> </ol>"},{"location":"developer-guide/deployment/inventory/#advanced-topics","title":"Advanced Topics","text":"<p>The advanced topics section covers:</p> <ul> <li>Scaling considerations for large environments</li> <li>Security enhancements for production</li> <li>Monitoring and maintenance best practices</li> <li>Specialized deployment scenarios</li> </ul>"},{"location":"developer-guide/deployment/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Testing Guide</li> <li>Helm Charts Documentation</li> <li>RBAC Configuration</li> <li>CI/CD Integration</li> <li>Threshold Configuration</li> </ul>"},{"location":"developer-guide/deployment/script-deployment/","title":"Script-based Deployment","text":"<p>This guide focuses on deploying the Secure CINC Auditor Kubernetes Container Scanning solution using shell scripts.</p>"},{"location":"developer-guide/deployment/script-deployment/#overview","title":"Overview","text":"<p>Script-based deployment is ideal for:</p> <ul> <li>Development environments</li> <li>Testing and evaluation</li> <li>One-off scanning operations</li> <li>Quick deployment without Helm</li> </ul> <p>The project provides several helper scripts that simplify the deployment and operation of the scanner.</p>"},{"location":"developer-guide/deployment/script-deployment/#key-scripts","title":"Key Scripts","text":"<p>The following scripts are available in the <code>/scripts</code> directory:</p> <ul> <li><code>setup-minikube.sh</code>: Sets up a Minikube environment for testing</li> <li><code>scan-container.sh</code>: Scans a standard container using the Kubernetes API approach</li> <li><code>scan-distroless-container.sh</code>: Scans a distroless container using debug containers</li> <li><code>scan-with-sidecar.sh</code>: Scans a container using the sidecar approach</li> <li><code>generate-kubeconfig.sh</code>: Generates a restricted kubeconfig for scanning</li> </ul>"},{"location":"developer-guide/deployment/script-deployment/#local-development-environment","title":"Local Development Environment","text":"<p>For development and testing, you can use Minikube:</p> <pre><code># Set up minikube for development\n./kubernetes-scripts/setup-minikube.sh\n\n# Run a scan against a specific container\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name path/to/profile\n</code></pre>"},{"location":"developer-guide/deployment/script-deployment/#optional-parameters","title":"Optional Parameters","text":"<p>The scan scripts support various optional parameters:</p> <pre><code># Scan with a custom threshold file\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name path/to/profile path/to/threshold.yml\n\n# Scan distroless containers\n./kubernetes-scripts/scan-distroless-container.sh namespace-name pod-name container-name path/to/profile\n\n# Scan using sidecar approach\n./kubernetes-scripts/scan-with-sidecar.sh namespace-name pod-name path/to/profile\n</code></pre>"},{"location":"developer-guide/deployment/script-deployment/#production-environment","title":"Production Environment","text":"<p>For production environments, additional setup is required:</p> <pre><code># Configure access to production cluster\nexport KUBECONFIG=/path/to/production/kubeconfig\n\n# Create restricted service account and role\nkubectl apply -f kubernetes/templates/namespace.yaml\nkubectl apply -f kubernetes/templates/service-account.yaml\nkubectl apply -f kubernetes/templates/rbac.yaml\n\n# Generate a restricted kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh scanner-namespace scanner-service-account\n\n# Run scan with production settings\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name path/to/profile --production-mode\n</code></pre>"},{"location":"developer-guide/deployment/script-deployment/#customizing-scripts","title":"Customizing Scripts","text":"<p>The scripts can be customized for specific environments:</p> <ol> <li>Create copies of the scripts with your modifications</li> <li>Adjust parameters like timeouts, namespace names, and resource configurations</li> <li>Add custom pre/post processing steps as needed</li> </ol> <pre><code># Example of a customized script\n#!/bin/bash\nset -e\n\n# Custom environment setup\nNAMESPACE=\"security-scanner\"\nSERVICE_ACCOUNT=\"restricted-scanner\"\nTIMEOUT=600\n\n# Create custom namespace and RBAC\nkubectl apply -f /path/to/custom/namespace.yaml\nkubectl apply -f /path/to/custom/rbac.yaml\n\n# Run the scan with custom parameters\n./kubernetes-scripts/scan-container.sh $NAMESPACE app-pod app-container /path/to/custom/profile.yml\n</code></pre>"},{"location":"developer-guide/deployment/script-deployment/#script-workflow","title":"Script Workflow","text":"<p>The script-based deployment follows this general workflow:</p> <ol> <li>Setup: Create necessary resources (namespaces, service accounts, roles)</li> <li>Configuration: Generate or provide restricted kubeconfig</li> <li>Execution: Run the appropriate scan script for your container type</li> <li>Reporting: Process scan results and generate reports</li> <li>Cleanup: Remove temporary resources and credentials</li> </ol>"},{"location":"developer-guide/deployment/script-deployment/#environment-variables","title":"Environment Variables","text":"<p>The scripts respect several environment variables that can be used to customize behavior:</p> <ul> <li><code>KUBECONFIG</code>: Path to the Kubernetes configuration file</li> <li><code>INSPEC_PROFILE_PATH</code>: Default path for InSpec profiles</li> <li><code>SCANNER_NAMESPACE</code>: Default namespace for scanner resources</li> <li><code>THRESHOLD_FILE</code>: Path to a threshold file for validation</li> </ul> <p>Example usage:</p> <pre><code>export KUBECONFIG=/path/to/custom/kubeconfig\nexport SCANNER_NAMESPACE=security-scanning\nexport THRESHOLD_FILE=/path/to/strict-thresholds.yml\n\n./kubernetes-scripts/scan-container.sh target-namespace app-pod app-container\n</code></pre>"},{"location":"developer-guide/deployment/script-deployment/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues with script-based deployment:</p> <ol> <li>Permission Errors:</li> <li>Ensure your current user has sufficient Kubernetes permissions</li> <li> <p>Check that service accounts have been properly created and bound to roles</p> </li> <li> <p>Connectivity Issues:</p> </li> <li>Verify that your KUBECONFIG points to the correct cluster</li> <li> <p>Check network connectivity between your machine and the Kubernetes API</p> </li> <li> <p>Script Failures:</p> </li> <li>Ensure scripts are executable (<code>chmod +x scripts/*.sh</code>)</li> <li>Check for bash version compatibility (Bash 4+ recommended)</li> <li>Verify that all required tools are installed and in your PATH</li> </ol>"},{"location":"developer-guide/deployment/script-deployment/#related-topics","title":"Related Topics","text":"<ul> <li>Deployment Scenarios</li> <li>Advanced Deployment Topics</li> <li>Helm Deployment</li> <li>Testing Guide</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/","title":"Advanced Deployment Topics","text":"<p>This guide provides an overview of advanced deployment topics for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/#overview","title":"Overview","text":"<p>Advanced deployment topics cover specialized aspects of deploying and operating the scanner solution, focusing on performance, security, monitoring, and specialized environments.</p>"},{"location":"developer-guide/deployment/advanced-topics/#key-advanced-topics","title":"Key Advanced Topics","text":"<p>We provide detailed guidance on several advanced deployment topics:</p> <ul> <li>Scaling and Performance: Optimize scanner performance for large environments</li> <li>Security Enhancements: Implement additional security measures</li> <li>Monitoring and Maintenance: Set up comprehensive monitoring and operational procedures</li> <li>Specialized Environments: Deploy in air-gapped and high-security environments</li> <li>Deployment Verification: Validate and test deployments</li> <li>Custom Development: Create custom scripts and extensions</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/#when-to-use-advanced-topics","title":"When to Use Advanced Topics","text":"<p>Consider these advanced deployment topics when:</p> <ol> <li>Deploying at Scale: If you're scanning hundreds or thousands of containers</li> <li>High-Security Requirements: If you're in regulated or security-sensitive environments</li> <li>Operational Integration: When integrating with existing monitoring and maintenance systems</li> <li>Custom Requirements: When standard deployment approaches need customization</li> </ol>"},{"location":"developer-guide/deployment/advanced-topics/#getting-started-with-advanced-topics","title":"Getting Started with Advanced Topics","text":"<p>Before diving into advanced topics, ensure you:</p> <ol> <li>Understand the basic deployment approaches</li> <li>Have a working deployment using one of the standard methods</li> <li>Identify specific areas where advanced configuration is needed</li> </ol>"},{"location":"developer-guide/deployment/advanced-topics/#related-topics","title":"Related Topics","text":"<ul> <li>Deployment Overview</li> <li>Script Deployment</li> <li>Helm Deployment</li> <li>CI/CD Integration</li> <li>Deployment Scenarios</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/","title":"Custom Development","text":"<p>This guide covers custom development and extension of the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#overview","title":"Overview","text":"<p>The scanner solution can be extended and customized to meet specific requirements. This guide covers custom script development, plugin creation, and integration with other systems.</p>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#custom-script-development","title":"Custom Script Development","text":"<p>For advanced users who need to develop custom deployment scripts:</p> <pre><code>#!/bin/bash\n# custom-deployment.sh\n\n# Configuration variables\nNAMESPACE=\"security-scanner\"\nSCANNER_IMAGE=\"cinc/auditor:latest\"\nPROFILE_PATH=\"/path/to/profiles\"\nTHRESHOLD_FILE=\"/path/to/thresholds.yml\"\nTOKEN_DURATION=\"1h\"\n\n# Create namespace\nkubectl create namespace $NAMESPACE\n\n# Create RBAC\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-sa\n  namespace: $NAMESPACE\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: scanner-role\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: scanner-rolebinding\nsubjects:\n  - kind: ServiceAccount\n    name: scanner-sa\n    namespace: $NAMESPACE\nroleRef:\n  kind: ClusterRole\n  name: scanner-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n\n# Create scanner job\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: scanner-job\n  namespace: $NAMESPACE\nspec:\n  template:\n    spec:\n      serviceAccountName: scanner-sa\n      containers:\n      - name: scanner\n        image: $SCANNER_IMAGE\n        command:\n        - /bin/sh\n        - -c\n        - |\n          cinc-auditor exec $PROFILE_PATH -t k8s-container://target-container --namespace default\n      restartPolicy: Never\n  backoffLimit: 1\nEOF\n\n# Wait for job completion\nkubectl wait --for=condition=complete job/scanner-job -n $NAMESPACE --timeout=300s\n\n# Get results\npod=$(kubectl get pods -n $NAMESPACE -l job-name=scanner-job -o jsonpath='{.items[0].metadata.name}')\nkubectl logs $pod -n $NAMESPACE &gt; results.json\n\n# Validate results\necho \"Validating results against thresholds...\"\nsaf validate -i results.json -f $THRESHOLD_FILE\n\n# Cleanup\nkubectl delete job scanner-job -n $NAMESPACE\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#best-practices-for-custom-scripts","title":"Best Practices for Custom Scripts","text":"<p>Follow these best practices when developing custom scripts:</p> <ol> <li>Error Handling: Implement robust error handling and logging</li> <li>Idempotency: Make scripts idempotent to allow retries</li> <li>Parameterization: Make scripts configurable through parameters</li> <li>Documentation: Document script purpose, parameters, and usage</li> <li>Testing: Test scripts in isolated environments before production use</li> </ol> <pre><code>#!/bin/bash\n# Example of a well-structured custom script\n\nset -e  # Exit on error\nset -o pipefail  # Exit on pipe failure\n\n# Script information\n# Name: enhanced-scanner.sh\n# Description: Enhanced scanner deployment with custom configurations\n# Usage: ./enhanced-scanner.sh [options]\n# Options:\n#   -n, --namespace NAMESPACE    Namespace to deploy scanner (default: scanner-system)\n#   -i, --image IMAGE            Scanner image to use (default: cinc/auditor:latest)\n#   -p, --profile PROFILE        Profile path (default: profiles/baseline)\n#   -t, --timeout SECONDS        Scan timeout in seconds (default: 300)\n#   -h, --help                   Show this help message\n\n# Default values\nNAMESPACE=\"scanner-system\"\nIMAGE=\"cinc/auditor:latest\"\nPROFILE=\"profiles/baseline\"\nTIMEOUT=300\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n  key=\"$1\"\n  case $key in\n    -n|--namespace)\n      NAMESPACE=\"$2\"\n      shift 2\n      ;;\n    -i|--image)\n      IMAGE=\"$2\"\n      shift 2\n      ;;\n    -p|--profile)\n      PROFILE=\"$2\"\n      shift 2\n      ;;\n    -t|--timeout)\n      TIMEOUT=\"$2\"\n      shift 2\n      ;;\n    -h|--help)\n      echo \"Usage: ./enhanced-scanner.sh [options]\"\n      echo \"Options:\"\n      echo \"  -n, --namespace NAMESPACE    Namespace to deploy scanner (default: scanner-system)\"\n      echo \"  -i, --image IMAGE            Scanner image to use (default: cinc/auditor:latest)\"\n      echo \"  -p, --profile PROFILE        Profile path (default: profiles/baseline)\"\n      echo \"  -t, --timeout SECONDS        Scan timeout in seconds (default: 300)\"\n      echo \"  -h, --help                   Show this help message\"\n      exit 0\n      ;;\n    *)\n      echo \"Unknown option: $1\"\n      exit 1\n      ;;\n  esac\ndone\n\n# Logging function\nlog() {\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $1\"\n}\n\n# Error handling function\nhandle_error() {\n  log \"ERROR: $1\"\n  exit 1\n}\n\n# Verify kubectl is installed\nif ! command -v kubectl &amp;&gt; /dev/null; then\n  handle_error \"kubectl not found, please install kubectl\"\nfi\n\n# Main functionality\nlog \"Starting scanner deployment in namespace $NAMESPACE\"\n\n# Create namespace if it doesn't exist\nkubectl get namespace $NAMESPACE &amp;&gt; /dev/null || kubectl create namespace $NAMESPACE\n\n# Rest of the script...\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#custom-profile-development","title":"Custom Profile Development","text":"<p>Develop custom security profiles for specific requirements:</p> <pre><code># Example custom profile: kubernetes-custom.rb\ncontrol 'K8S-CUSTOM-1' do\n  impact 1.0\n  title 'Ensure containers do not run with privileged flag'\n  desc 'Running containers with the privileged flag gives them full access to the host system.'\n\n  containers = json('/api/v1/pods').pod.each_with_object([]) do |pod, arr|\n    pod.spec.containers.each do |container|\n      arr &lt;&lt; {\n        'pod' =&gt; pod.metadata.name,\n        'container' =&gt; container.name,\n        'privileged' =&gt; container.securityContext.privileged\n      }\n    end\n  end\n\n  containers.each do |container|\n    describe \"Container #{container['pod']}/#{container['container']}\" do\n      it 'should not have privileged flag set to true' do\n        expect(container['privileged']).not_to eq true\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#custom-integration-development","title":"Custom Integration Development","text":"<p>Develop custom integrations with other systems:</p> <pre><code># Example custom integration: slack-notifier.rb\nrequire 'uri'\nrequire 'net/http'\nrequire 'json'\n\nclass SlackNotifier\n  def initialize(webhook_url)\n    @webhook_url = webhook_url\n  end\n\n  def notify(message, severity = :info)\n    color = case severity\n            when :info then \"#36a64f\"\n            when :warning then \"#ffcc00\"\n            when :critical then \"#ff0000\"\n            else \"#eeeeee\"\n            end\n\n    payload = {\n      text: \"Scanner Notification\",\n      attachments: [\n        {\n          color: color,\n          text: message,\n          ts: Time.now.to_i\n        }\n      ]\n    }\n\n    send_notification(payload)\n  end\n\n  def notify_scan_results(results)\n    stats = calculate_statistics(results)\n\n    color = if stats[:critical] &gt; 0\n              \"#ff0000\"\n            elsif stats[:high] &gt; 0\n              \"#ff9900\"\n            elsif stats[:medium] &gt; 0\n              \"#ffcc00\"\n            else\n              \"#36a64f\"\n            end\n\n    payload = {\n      text: \"Scan Completed\",\n      attachments: [\n        {\n          color: color,\n          title: \"Scan Results Summary\",\n          fields: [\n            {\n              title: \"Critical Findings\",\n              value: stats[:critical],\n              short: true\n            },\n            {\n              title: \"High Findings\",\n              value: stats[:high],\n              short: true\n            },\n            {\n              title: \"Medium Findings\",\n              value: stats[:medium],\n              short: true\n            },\n            {\n              title: \"Low Findings\",\n              value: stats[:low],\n              short: true\n            }\n          ],\n          ts: Time.now.to_i\n        }\n      ]\n    }\n\n    send_notification(payload)\n  end\n\n  private\n\n  def send_notification(payload)\n    uri = URI.parse(@webhook_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    request = Net::HTTP::Post.new(uri.request_uri)\n    request.content_type = 'application/json'\n    request.body = payload.to_json\n\n    response = http.request(request)\n\n    unless response.code.to_i == 200\n      puts \"Error sending notification: #{response.code} - #{response.body}\"\n    end\n  end\n\n  def calculate_statistics(results)\n    stats = { critical: 0, high: 0, medium: 0, low: 0 }\n\n    results['profiles'].each do |profile|\n      profile['controls'].each do |control|\n        control['results'].each do |result|\n          if result['status'] == 'failed'\n            case control['impact']\n            when 0.9..1.0\n              stats[:critical] += 1\n            when 0.7...0.9\n              stats[:high] += 1\n            when 0.4...0.7\n              stats[:medium] += 1\n            else\n              stats[:low] += 1\n            end\n          end\n        end\n      end\n    end\n\n    stats\n  end\nend\n\n# Usage\nnotifier = SlackNotifier.new('https://hooks.slack.com/services/YOUR/WEBHOOK/URL')\nnotifier.notify('Scanner started', :info)\n\n# After scan completes\nresults = JSON.parse(File.read('results.json'))\nnotifier.notify_scan_results(results)\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#custom-helm-chart-development","title":"Custom Helm Chart Development","text":"<p>Develop custom Helm charts for specialized deployments:</p> <pre><code># Example custom-scanner/Chart.yaml\napiVersion: v2\nname: custom-scanner\ndescription: A custom scanner for specialized environments\ntype: application\nversion: 0.1.0\nappVersion: 1.0.0\ndependencies:\n  - name: scanner-infrastructure\n    version: \"&gt;=1.0.0\"\n    repository: \"file://../scanner-infrastructure\"\n</code></pre> <pre><code># Example custom-scanner/values.yaml\nglobal:\n  environment: production\n  namespace: custom-scanner\n\nscanner:\n  image:\n    repository: custom/scanner\n    tag: latest\n\n  customization:\n    enabled: true\n    features:\n      - name: specialized-scans\n        enabled: true\n      - name: custom-reporting\n        enabled: true\n\n    configuration:\n      specializedMode: true\n      reportFormat: \"custom-format\"\n</code></pre> <pre><code># Example custom-scanner/templates/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"custom-scanner.fullname\" . }}\n  labels:\n    {{- include \"custom-scanner.labels\" . | nindent 4 }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      {{- include \"custom-scanner.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      labels:\n        {{- include \"custom-scanner.selectorLabels\" . | nindent 8 }}\n    spec:\n      serviceAccountName: {{ include \"custom-scanner.serviceAccountName\" . }}\n      containers:\n        - name: {{ .Chart.Name }}\n          image: \"{{ .Values.scanner.image.repository }}:{{ .Values.scanner.image.tag }}\"\n          imagePullPolicy: {{ .Values.scanner.image.pullPolicy }}\n          env:\n            - name: CUSTOM_MODE\n              value: \"{{ .Values.scanner.customization.configuration.specializedMode }}\"\n            - name: REPORT_FORMAT\n              value: \"{{ .Values.scanner.customization.configuration.reportFormat }}\"\n          volumeMounts:\n            - name: config-volume\n              mountPath: /config\n            - name: custom-profiles\n              mountPath: /profiles\n      volumes:\n        - name: config-volume\n          configMap:\n            name: {{ include \"custom-scanner.fullname\" . }}-config\n        - name: custom-profiles\n          configMap:\n            name: {{ include \"custom-scanner.fullname\" . }}-profiles\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/custom-development/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Deployment</li> <li>Script Deployment</li> <li>Deployment Verification</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/inventory/","title":"Advanced Deployment Topics Directory Inventory","text":"<p>This document provides a directory overview of the advanced deployment topics.</p>"},{"location":"developer-guide/deployment/advanced-topics/inventory/#directory-contents","title":"Directory Contents","text":"<p>The advanced topics directory contains detailed documentation for specialized aspects of deployment:</p> File Description index.md Overview of advanced deployment topics scaling.md Scaling and performance optimization security.md Advanced security configurations monitoring.md Monitoring and maintenance specialized-environments.md Deployment in air-gapped and high-security environments verification.md Deployment verification and testing custom-development.md Custom script and extension development inventory.md This directory listing"},{"location":"developer-guide/deployment/advanced-topics/inventory/#advanced-topics-summary","title":"Advanced Topics Summary","text":"<p>This documentation section covers:</p> <ul> <li>Scaling and Performance: Optimizing scanner performance for large environments</li> <li>Security Enhancements: Implementing additional security measures</li> <li>Monitoring and Maintenance: Setting up comprehensive monitoring and operational procedures</li> <li>Specialized Environments: Deploying in air-gapped and high-security environments</li> <li>Deployment Verification: Validating and testing deployments</li> <li>Custom Development: Creating custom scripts and extensions</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Deployment Overview</li> <li>Script Deployment</li> <li>Helm Deployment</li> <li>CI/CD Integration</li> <li>Deployment Scenarios</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/","title":"Monitoring and Maintenance","text":"<p>This guide provides detailed information on monitoring and maintaining the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#overview","title":"Overview","text":"<p>Proper monitoring and maintenance are essential for ensuring the reliability and effectiveness of your container scanning solution. This guide covers health monitoring, version management, backup strategies, and other operational aspects.</p>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#health-monitoring","title":"Health Monitoring","text":"<p>Configure comprehensive monitoring to track the health and performance of scanner components:</p> <pre><code># monitoring-values.yaml\nmonitoring:\n  enabled: true\n  serviceMonitor:\n    enabled: true\n    additionalLabels:\n      release: prometheus\n  healthCheck:\n    liveness:\n      enabled: true\n      initialDelaySeconds: 30\n      periodSeconds: 10\n    readiness:\n      enabled: true\n      initialDelaySeconds: 5\n      periodSeconds: 10\n  dashboard:\n    enabled: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#prometheus-integration","title":"Prometheus Integration","text":"<p>Configure Prometheus metrics for detailed monitoring:</p> <pre><code># prometheus-values.yaml\nprometheus:\n  metrics:\n    enabled: true\n    port: 9090\n    path: /metrics\n\n  rules:\n    - name: scanner-alerts\n      groups:\n        - name: scanner\n          rules:\n            - alert: ScannerDown\n              expr: up{job=\"scanner\"} == 0\n              for: 5m\n              labels:\n                severity: critical\n              annotations:\n                summary: \"Scanner is down\"\n                description: \"Scanner has been down for more than 5 minutes\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>Deploy pre-configured Grafana dashboards for visualization:</p> <pre><code># grafana-values.yaml\ngrafana:\n  dashboards:\n    - name: scanner-overview\n      json: |\n        {\n          \"title\": \"Scanner Overview\",\n          \"panels\": [\n            {\n              \"title\": \"Active Scans\",\n              \"type\": \"graph\",\n              \"datasource\": \"Prometheus\"\n            },\n            {\n              \"title\": \"Scan Duration\",\n              \"type\": \"graph\",\n              \"datasource\": \"Prometheus\"\n            }\n          ]\n        }\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#version-updates","title":"Version Updates","text":"<p>Manage scanner component versions and updates:</p> <pre><code># version-management-values.yaml\nversionManagement:\n  updateStrategy: RollingUpdate\n  maxUnavailable: 1\n  maxSurge: 1\n  imageUpdateAutomation:\n    enabled: true\n    schedule: \"0 0 * * 0\"  # Weekly on Sundays\n    testBeforePromotion: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#automated-updates","title":"Automated Updates","text":"<p>Configure automated update workflows:</p> <pre><code># automated-updates-values.yaml\nupdates:\n  automated:\n    enabled: true\n    schedule: \"0 0 * * 0\"  # Weekly on Sundays\n    timeWindow:\n      start: \"01:00\"\n      end: \"05:00\"\n    notifyOn:\n      - success\n      - failure\n\n  versioning:\n    policy: semver\n    allowMajorUpgrades: false\n    pinMinorVersion: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#canary-deployments","title":"Canary Deployments","text":"<p>Implement canary deployments for safer updates:</p> <pre><code># canary-values.yaml\ndeployment:\n  strategy:\n    type: Canary\n    canary:\n      steps:\n        - setWeight: 20\n        - pause: {duration: 10m}\n        - setWeight: 40\n        - pause: {duration: 10m}\n        - setWeight: 60\n        - pause: {duration: 10m}\n        - setWeight: 80\n        - pause: {duration: 10m}\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#backup-and-recovery","title":"Backup and Recovery","text":"<p>Configure backup strategies for critical configurations and data:</p> <pre><code># backup-values.yaml\nbackup:\n  enabled: true\n  schedule: \"0 0 * * *\"  # Daily at midnight\n  retention:\n    count: 7\n  include:\n    - configs\n    - results\n    - profiles\n  storage:\n    type: s3\n    bucket: scanner-backups\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#disaster-recovery","title":"Disaster Recovery","text":"<p>Implement disaster recovery procedures:</p> <pre><code># disaster-recovery-values.yaml\ndisasterRecovery:\n  enabled: true\n  backupLocation: s3://scanner-backups\n\n  restore:\n    fromBackup: true\n    backupId: latest  # or specific backup ID\n    restoreOptions:\n      includeConfigs: true\n      includeResults: true\n      includeProfiles: true\n\n  testing:\n    schedule: \"0 0 * * 0\"  # Weekly on Sundays\n    environment: dr-test\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#log-management","title":"Log Management","text":"<p>Configure comprehensive logging:</p> <pre><code># logging-values.yaml\nlogging:\n  level: info  # debug, info, warn, error\n  format: json  # or text\n\n  storage:\n    retention:\n      days: 30\n    rotation:\n      maxSize: 100MB\n      maxFiles: 10\n\n  exporters:\n    - type: elasticsearch\n      enabled: true\n      host: elasticsearch.example.com\n      index: scanner-logs\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#resource-cleanup","title":"Resource Cleanup","text":"<p>Implement regular resource cleanup to prevent clutter:</p> <pre><code># cleanup-values.yaml\ncleanup:\n  enabled: true\n  schedule: \"0 0 * * *\"  # Daily at midnight\n\n  resources:\n    - type: pods\n      selector: app=scanner,status=completed\n      olderThan: 7d\n\n    - type: scans\n      olderThan: 30d\n      includeSuccessful: true\n      includeFailed: false\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#alerting-and-notifications","title":"Alerting and Notifications","text":"<p>Configure alerting for critical events:</p> <pre><code># alerting-values.yaml\nalerting:\n  enabled: true\n  providers:\n    - name: slack\n      enabled: true\n      channel: \"#security-alerts\"\n      severities:\n        - critical\n        - error\n\n    - name: email\n      enabled: true\n      recipients:\n        - security-team@example.com\n      severities:\n        - critical\n        - error\n        - warning\n\n  alerts:\n    - name: ScanFailure\n      description: \"Scan failed to complete\"\n      severity: error\n\n    - name: CriticalVulnerability\n      description: \"Critical vulnerability detected\"\n      severity: critical\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor scanner performance metrics:</p> <pre><code># performance-monitoring-values.yaml\nperformanceMonitoring:\n  enabled: true\n  metrics:\n    - name: scanDuration\n      description: \"Time taken to complete a scan\"\n\n    - name: scanQueueLength\n      description: \"Number of scans waiting in queue\"\n\n    - name: scannerCPUUsage\n      description: \"CPU usage of scanner pods\"\n\n  thresholds:\n    - metric: scanDuration\n      warning: 300  # seconds\n      critical: 600  # seconds\n\n    - metric: scanQueueLength\n      warning: 10\n      critical: 20\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#cluster-wide-monitoring","title":"Cluster-Wide Monitoring","text":"<p>Implement cluster-wide monitoring for scanner infrastructure:</p> <pre><code># cluster-monitoring-values.yaml\nclusterMonitoring:\n  enabled: true\n\n  components:\n    - name: scanner-infrastructure\n      selector: app=scanner-infrastructure\n\n    - name: standard-scanner\n      selector: app=standard-scanner\n\n    - name: distroless-scanner\n      selector: app=distroless-scanner\n\n  resourceUsage:\n    pods:\n      enabled: true\n\n    nodes:\n      enabled: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/monitoring/#related-topics","title":"Related Topics","text":"<ul> <li>Scaling and Performance</li> <li>Deployment Verification</li> <li>Helm Deployment</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/scaling/","title":"Scaling and Performance","text":"<p>This guide provides detailed guidance on scaling and optimizing performance for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#overview","title":"Overview","text":"<p>As the number of containers to scan increases, proper scaling and resource allocation become critical for maintaining performance and reliability. This guide covers strategies for scaling the scanner to handle large Kubernetes environments.</p>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#parallel-scanning","title":"Parallel Scanning","text":"<p>Distribute scanning load across multiple scanner instances to increase throughput:</p> <pre><code># parallel-scanning-values.yaml\nscanner:\n  parallelism:\n    enabled: true\n    maxConcurrent: 5\n    queueSize: 100\n  resources:\n    requests:\n      cpu: 250m\n      memory: 256Mi\n    limits:\n      cpu: 1000m\n      memory: 1Gi\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#key-parallelism-parameters","title":"Key Parallelism Parameters","text":"<ul> <li>maxConcurrent: Maximum number of concurrent scans</li> <li>queueSize: Size of the scan request queue</li> <li>processingStrategy: Choose between <code>parallel</code> or <code>sequential</code> processing</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#parallelism-considerations","title":"Parallelism Considerations","text":"<ul> <li>Increase maxConcurrent for faster processing but watch resource usage</li> <li>Use larger queueSize for bursty workloads</li> <li>Consider worker pods for distributing scanning workloads</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#resource-allocation","title":"Resource Allocation","text":"<p>Properly allocate CPU and memory resources based on your environment size:</p> Environment Size Containers CPU Request Memory Request CPU Limit Memory Limit Small &lt;50 250m 256Mi 500m 512Mi Medium 50-200 500m 512Mi 1000m 1Gi Large 200-1000 1000m 1Gi 2000m 2Gi Enterprise &gt;1000 2000m 2Gi 4000m 4Gi"},{"location":"developer-guide/deployment/advanced-topics/scaling/#tuning-resource-allocations","title":"Tuning Resource Allocations","text":"<p>For optimal resource utilization:</p> <pre><code># optimized-resources-values.yaml\nscanner:\n  resources:\n    requests:\n      cpu: \"1\"\n      memory: 1Gi\n    limits:\n      cpu: \"2\"\n      memory: 2Gi\n\n  tuning:\n    memoryBufferPercent: 20\n    cpuThrottling: false\n    optimizeFor: throughput  # or latency\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#result-storage","title":"Result Storage","text":"<p>Implement centralized storage for scan results to handle large volumes of data:</p> <pre><code># storage-values.yaml\npersistence:\n  enabled: true\n  storageClass: managed-premium\n  accessMode: ReadWriteMany\n  size: 20Gi\n  retention:\n    days: 90\n    maxSize: 50Gi\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#storage-considerations","title":"Storage Considerations","text":"<ul> <li>Use ReadWriteMany access mode for multi-scanner deployments</li> <li>Implement appropriate retention policies</li> <li>Consider cloud-based storage for enterprise deployments</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#storage-provider-options","title":"Storage Provider Options","text":"<pre><code># storage-providers-values.yaml\npersistence:\n  provider: aws  # or azure, gcp, local\n  aws:\n    bucketName: scanner-results\n    region: us-west-2\n\n  compression:\n    enabled: true\n    format: gzip\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#horizontal-pod-autoscaling","title":"Horizontal Pod Autoscaling","text":"<p>Configure Horizontal Pod Autoscaling (HPA) for dynamic scaling based on workload:</p> <pre><code># hpa-values.yaml\nautoscaling:\n  enabled: true\n  minReplicas: 2\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 70\n  targetMemoryUtilizationPercentage: 80\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#advanced-hpa-configuration","title":"Advanced HPA Configuration","text":"<p>For more precise control over scaling behavior:</p> <pre><code># advanced-hpa-values.yaml\nautoscaling:\n  enabled: true\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        targetAverageUtilization: 70\n    - type: Resource\n      resource:\n        name: memory\n        targetAverageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n        - type: Percent\n          value: 10\n          periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n        - type: Percent\n          value: 100\n          periodSeconds: 15\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#distribution-and-scheduling","title":"Distribution and Scheduling","text":"<p>Optimize pod distribution across nodes:</p> <pre><code># distribution-values.yaml\naffinity:\n  podAntiAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        podAffinityTerm:\n          labelSelector:\n            matchExpressions:\n              - key: app\n                operator: In\n                values:\n                  - scanner\n          topologyKey: kubernetes.io/hostname\n\n  nodeAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        preference:\n          matchExpressions:\n            - key: node-role.kubernetes.io/worker\n              operator: Exists\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#performance-tuning","title":"Performance Tuning","text":"<p>Fine-tune scanner performance for specific environments:</p> <pre><code># performance-tuning-values.yaml\nscanner:\n  performance:\n    concurrency: 4\n    memoryOptimization: true\n    scanTimeout: 600\n    batchSize: 20\n    workerPoolSize: 5\n\n  profiles:\n    optimized: true\n    excludeControls:\n      - resource-intensive-control-1\n      - resource-intensive-control-2\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#scanner-performance-parameters","title":"Scanner Performance Parameters","text":"<ul> <li>concurrency: Number of concurrent scans per scanner pod</li> <li>memoryOptimization: Enable memory usage optimizations</li> <li>scanTimeout: Maximum time for a scan to complete</li> <li>batchSize: Number of containers processed in a single batch</li> <li>workerPoolSize: Size of the worker pool for processing</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#scaling-across-multiple-clusters","title":"Scaling Across Multiple Clusters","text":"<p>For large enterprises with multiple Kubernetes clusters:</p> <pre><code># multi-cluster-values.yaml\nmultiCluster:\n  enabled: true\n  strategy: federation  # or aggregation\n  centralized:\n    reporting: true\n    storage: true\n\n  clusters:\n    - name: cluster-1\n      kubeconfig: /path/to/kubeconfig-1\n    - name: cluster-2\n      kubeconfig: /path/to/kubeconfig-2\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/scaling/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Use these benchmarks as a reference for sizing your deployment:</p> Environment Scanner Pods Concurrent Scans Containers Scanned Time to Complete Small 1 5 50 ~10 minutes Medium 2 10 200 ~25 minutes Large 5 20 1000 ~60 minutes Enterprise 10+ 50+ 5000+ ~3 hours"},{"location":"developer-guide/deployment/advanced-topics/scaling/#related-topics","title":"Related Topics","text":"<ul> <li>Monitoring and Maintenance</li> <li>Helm Deployment</li> <li>Advanced Security</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/security/","title":"Security Enhancements","text":"<p>This guide provides detailed security enhancements for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/security/#overview","title":"Overview","text":"<p>Security is a critical aspect of deploying container scanning solutions, especially in production environments. This guide covers advanced security configurations to protect your scanning infrastructure and the data it processes.</p>"},{"location":"developer-guide/deployment/advanced-topics/security/#rbac-restrictions","title":"RBAC Restrictions","text":"<p>Implement fine-grained role-based access control (RBAC) to limit scanner permissions:</p> <pre><code># restricted-rbac-values.yaml\nrbac:\n  create: true\n  restrictive: true\n  timebound: true\n  tokenExpiration: 300  # 5 minutes\n  podSelector:\n    matchLabels:\n      scan: enabled\n  namespaceSelector:\n    matchLabels:\n      scan: enabled\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>Follow these guidelines for RBAC restrictions:</p> <ol> <li>Limit scanner to specific namespaces</li> <li>Use time-bound tokens for ephemeral access</li> <li>Implement label-based targeting to restrict scope</li> <li>Use restrictive verbs (get, list) instead of broad permissions</li> </ol>"},{"location":"developer-guide/deployment/advanced-topics/security/#advanced-rbac-configuration","title":"Advanced RBAC Configuration","text":"<p>For more complex security scenarios:</p> <pre><code># advanced-rbac-values.yaml\nrbac:\n  clusterRoles:\n    enabled: false  # Use namespaced roles when possible\n\n  roles:\n    - name: scanner-reader\n      rules:\n        - apiGroups: [\"\"]\n          resources: [\"pods\"]\n          verbs: [\"get\", \"list\"]\n          resourceNames: []  # Optional list of specific resources\n\n    - name: scanner-reporter\n      rules:\n        - apiGroups: [\"\"]\n          resources: [\"configmaps\"]\n          verbs: [\"get\", \"create\", \"update\"]\n\n  serviceAccounts:\n    - name: scanner-sa\n      namespace: scanner-ns\n      annotations:\n        eks.amazonaws.com/role-arn: \"arn:aws:iam::123456789012:role/scanner-role\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#scanner-isolation","title":"Scanner Isolation","text":"<p>Isolate scanner components to prevent privilege escalation and limit the impact of potential breaches:</p> <pre><code># isolation-values.yaml\npodSecurityContext:\n  runAsUser: 1000\n  runAsGroup: 1000\n  fsGroup: 1000\n  runAsNonRoot: true\n\nsecurityContext:\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n  capabilities:\n    drop: [\"ALL\"]\n\nnetworkPolicy:\n  enabled: true\n  restrictEgress: true\n  allowedEgressDomains:\n    - kubernetes.default.svc.cluster.local\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#pod-security-standards","title":"Pod Security Standards","text":"<p>Implement Kubernetes Pod Security Standards:</p> <pre><code># pod-security-values.yaml\npodSecurity:\n  standard: restricted\n  enforce: true\n  audit: true\n  warn: true\n\n  seccompProfile:\n    type: RuntimeDefault\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#network-policies","title":"Network Policies","text":"<p>Restrict scanner network communications:</p> <pre><code># network-policy-values.yaml\nnetworkPolicies:\n  - name: scanner-network-policy\n    spec:\n      podSelector:\n        matchLabels:\n          app: scanner\n      policyTypes:\n        - Ingress\n        - Egress\n      ingress:\n        - from:\n            - namespaceSelector:\n                matchLabels:\n                  name: security-tools\n      egress:\n        - to:\n            - namespaceSelector:\n                matchLabels:\n                  kubernetes.io/metadata.name: default\n            - podSelector:\n                matchLabels:\n                  k8s-app: kube-dns\n          ports:\n            - protocol: UDP\n              port: 53\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>Implement secure handling of scan results and sensitive information:</p> <pre><code># data-security-values.yaml\nresults:\n  encryption:\n    enabled: true\n    provider: kubernetes-secrets\n  redaction:\n    enabled: true\n    patterns:\n      - PASSWORD\n      - SECRET\n      - TOKEN\n  rbac:\n    viewResults:\n      create: true\n      subjects:\n        - kind: Group\n          name: security-team\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#data-classification","title":"Data Classification","text":"<p>Classify and protect data according to sensitivity:</p> <pre><code># data-classification-values.yaml\ndataClassification:\n  enabled: true\n  levels:\n    - name: public\n      protection: none\n    - name: internal\n      protection: encryption\n    - name: confidential\n      protection: encryption-and-access-control\n\n  classifications:\n    scanResults: confidential\n    scanConfigurations: internal\n    scanLogs: internal\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#secret-management","title":"Secret Management","text":"<p>Integrate with external secret managers:</p> <pre><code># secret-management-values.yaml\nsecretManagement:\n  provider: vault  # or aws-secrets-manager, azure-key-vault\n\n  vault:\n    address: https://vault.example.com\n    role: scanner\n    secretPath: secret/scanner\n\n  integratedSecrets:\n    - name: scanner-credentials\n      keys:\n        - apiKey\n        - token\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>Implement strong authentication and authorization:</p> <pre><code># auth-values.yaml\nauthentication:\n  serviceAccounts:\n    annotations:\n      eks.amazonaws.com/role-arn: \"arn:aws:iam::123456789012:role/scanner-role\"\n\n  oidc:\n    enabled: true\n    issuerUrl: https://auth.example.com\n    clientId: scanner-client\n    requestedScopes:\n      - openid\n      - profile\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#mutual-tls-configuration","title":"Mutual TLS Configuration","text":"<p>Implement mutual TLS for secure communication:</p> <pre><code># mtls-values.yaml\ntls:\n  enabled: true\n  mutual: true\n  certificateAuthority:\n    create: true\n  certificates:\n    server:\n      create: true\n    client:\n      create: true\n  verifyDepth: 2\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#tls-rotation-and-management","title":"TLS Rotation and Management","text":"<p>Implement certificate rotation and management:</p> <pre><code># certificate-management-values.yaml\ncertificateManagement:\n  provider: cert-manager\n  autoRenew: true\n  notifyBeforeExpiry: 30  # days\n  certDuration: 365  # days\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#audit-logging","title":"Audit Logging","text":"<p>Enable comprehensive audit logging for security monitoring:</p> <pre><code># audit-values.yaml\naudit:\n  enabled: true\n  level: RequestResponse\n  maxAge: 30\n  maxBackups: 10\n  maxSize: 100\n  path: /var/log/scanner-audit.log\n  policy:\n    create: true\n    rules:\n      - level: RequestResponse\n        resources:\n          - group: \"\"\n            resources: [\"pods\"]\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#log-forwarding-and-integration","title":"Log Forwarding and Integration","text":"<p>Forward logs to security information and event management (SIEM) systems:</p> <pre><code># log-integration-values.yaml\nlogging:\n  forwarding:\n    enabled: true\n    destination: splunk  # or elasticsearch, datadog, etc.\n    splunk:\n      hec:\n        url: https://splunk-hec.example.com\n        token: ${SPLUNK_TOKEN}\n      index: kubernetes-security\n\n  format: json\n  includeMetadata: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#container-image-security","title":"Container Image Security","text":"<p>Enhance container image security:</p> <pre><code># image-security-values.yaml\nimageSecurity:\n  policy:\n    allowedRegistries:\n      - docker.io/cinc\n      - registry.example.com\n    scanBeforePull: true\n    enforceSignature: true\n\n  scanner:\n    image:\n      pullPolicy: Always\n      pullSecrets:\n        - name: registry-credentials\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/security/#related-topics","title":"Related Topics","text":"<ul> <li>Specialized Environments</li> <li>Monitoring and Maintenance</li> <li>RBAC Configuration</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/","title":"Specialized Environments","text":"<p>This guide covers deployment configurations for specialized environments, including air-gapped and high-security Kubernetes deployments.</p>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#overview","title":"Overview","text":"<p>Some environments have specific requirements that necessitate specialized deployment approaches. This guide covers deployment in air-gapped environments (without internet access) and high-security environments with strict security controls.</p>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#air-gapped-environments","title":"Air-Gapped Environments","text":"<p>Air-gapped environments have no internet connectivity, requiring all resources to be pre-downloaded and available locally.</p>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#image-bundling","title":"Image Bundling","text":"<p>Create a bundle of all required container images for air-gapped deployment:</p> <pre><code>#!/bin/bash\n# create-image-bundle.sh\n\nREGISTRY=\"docker.io\"\nIMAGES=(\n  \"cinc/auditor:latest\"\n  \"bitnami/kubectl:latest\"\n  \"busybox:latest\"\n)\n\nmkdir -p ./airgap-bundle/images\nfor image in \"${IMAGES[@]}\"; do\n  echo \"Pulling $image...\"\n  docker pull $image\n  filename=$(echo $image | tr '/:' '_')\n  echo \"Saving $image to ./airgap-bundle/images/$filename.tar\"\n  docker save $image &gt; ./airgap-bundle/images/$filename.tar\ndone\n\n# Bundle profiles and configurations\ncp -r ./profiles ./airgap-bundle/\ncp -r ./helm-charts ./airgap-bundle/\ncp -r ./kubernetes ./airgap-bundle/\ncp -r ./scripts ./airgap-bundle/\n\ntar -czf scanner-airgap-bundle.tar.gz ./airgap-bundle\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#local-registry-setup","title":"Local Registry Setup","text":"<p>Set up and configure a local container registry:</p> <pre><code># local-registry-values.yaml\nregistry:\n  internal:\n    enabled: true\n    persistence:\n      enabled: true\n      size: 50Gi\n  imageOverrides:\n    repository: registry.local:5000/cinc/auditor\n    tag: latest\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#air-gapped-deployment-configuration","title":"Air-Gapped Deployment Configuration","text":"<p>Configure the scanner to use local resources:</p> <pre><code># airgapped-values.yaml\nglobal:\n  imageRegistry: registry.local:5000\n  airgapped: true\n\nscanner:\n  image:\n    repository: registry.local:5000/cinc/auditor\n    tag: latest\n\n  profiles:\n    source: configmap\n    configMap:\n      name: airgapped-profiles\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#air-gapped-updates","title":"Air-Gapped Updates","text":"<p>Manage updates in air-gapped environments:</p> <pre><code># airgapped-updates-values.yaml\nupdates:\n  source: local\n  bundle:\n    path: /path/to/updates\n\n  verification:\n    enabled: true\n    checksum: true\n    signature: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#high-security-environments","title":"High-Security Environments","text":"<p>High-security environments require additional security controls beyond standard deployments.</p>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#enhanced-security-controls","title":"Enhanced Security Controls","text":"<p>Implement enhanced security controls:</p> <pre><code># high-security-values.yaml\nsecurity:\n  enhanced:\n    enabled: true\n    seccompProfile:\n      type: RuntimeDefault\n    seLinux:\n      enabled: true\n    apparmor:\n      enabled: true\n    psp:\n      enabled: true\n    admission:\n      enabled: true\n      validateImages: true\n      validateSecrets: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#mutual-tls-configuration","title":"Mutual TLS Configuration","text":"<p>Implement mutual TLS for secure communications:</p> <pre><code># mtls-values.yaml\ntls:\n  enabled: true\n  mutual: true\n  certificateAuthority:\n    create: true\n  certificates:\n    server:\n      create: true\n    client:\n      create: true\n  verifyDepth: 2\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#audit-logging","title":"Audit Logging","text":"<p>Enable comprehensive audit logging:</p> <pre><code># audit-values.yaml\naudit:\n  enabled: true\n  level: RequestResponse\n  maxAge: 30\n  maxBackups: 10\n  maxSize: 100\n  path: /var/log/scanner-audit.log\n  policy:\n    create: true\n    rules:\n      - level: RequestResponse\n        resources:\n          - group: \"\"\n            resources: [\"pods\"]\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#defense-in-depth-measures","title":"Defense in Depth Measures","text":"<p>Implement multiple layers of security:</p> <pre><code># defense-in-depth-values.yaml\ndefensiveControls:\n  network:\n    denyByDefault: true\n    allowedRoutes:\n      - source: scanner\n        destination: kubernetes-api\n      - source: scanner\n        destination: containers\n\n  application:\n    securityFilters:\n      - type: input-validation\n        enabled: true\n      - type: output-encoding\n        enabled: true\n\n  runtime:\n    secureDefaults: true\n    failClosed: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#fedrampfisma-compliance","title":"FedRAMP/FISMA Compliance","text":"<p>Configure for FedRAMP or FISMA compliance:</p> <pre><code># compliance-values.yaml\ncompliance:\n  fedramp:\n    enabled: true\n    level: high  # moderate or high\n\n  controls:\n    - id: AC-2\n      implementation: automatic\n    - id: AC-3\n      implementation: automatic\n    - id: AU-2\n      implementation: automatic\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#disconnected-edge-environments","title":"Disconnected Edge Environments","text":"<p>Configure for disconnected edge deployments:</p> <pre><code># edge-values.yaml\nedge:\n  enabled: true\n  autonomousOperation: true\n\n  resilience:\n    offlineMode: true\n    dataRetention:\n      local:\n        enabled: true\n        size: 10Gi\n\n  synchronization:\n    mode: manual\n    schedule: \"0 0 * * *\"  # When connected\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#sensitive-data-environments","title":"Sensitive Data Environments","text":"<p>Configure for environments with sensitive data:</p> <pre><code># sensitive-data-values.yaml\ndataProtection:\n  encryption:\n    enabled: true\n    provider: vault\n    vault:\n      address: https://vault.example.com\n      path: secret/scanner\n\n  masking:\n    enabled: true\n    patterns:\n      - type: regex\n        pattern: \"([0-9]{3}-[0-9]{2}-[0-9]{4})\"\n        replacement: \"XXX-XX-XXXX\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#regulated-environments","title":"Regulated Environments","text":"<p>Configure for regulated industries:</p> <pre><code># regulated-values.yaml\nregulated:\n  enabled: true\n  industry: healthcare  # healthcare, finance, government\n\n  compliance:\n    hipaa:\n      enabled: true\n    pci:\n      enabled: false\n    gdpr:\n      enabled: false\n\n  documentation:\n    generateReports: true\n    auditEvidence: true\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#cross-regional-deployments","title":"Cross-Regional Deployments","text":"<p>Configure for multi-region deployments:</p> <pre><code># multi-region-values.yaml\nregions:\n  enabled: true\n  primary: us-east\n\n  secondaries:\n    - name: eu-central\n      replication:\n        enabled: true\n        mode: async\n\n    - name: ap-southeast\n      replication:\n        enabled: true\n        mode: async\n\n  failover:\n    enabled: true\n    automatic: false\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/specialized-environments/#related-topics","title":"Related Topics","text":"<ul> <li>Security Enhancements</li> <li>Monitoring and Maintenance</li> <li>Deployment Scenarios</li> </ul>"},{"location":"developer-guide/deployment/advanced-topics/verification/","title":"Deployment Verification","text":"<p>This guide covers comprehensive verification and testing procedures for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/advanced-topics/verification/#overview","title":"Overview","text":"<p>Verifying a deployment is critical to ensure the scanner is functioning correctly and securely. This guide covers functionality testing, security verification, and integration testing procedures.</p>"},{"location":"developer-guide/deployment/advanced-topics/verification/#functionality-check","title":"Functionality Check","text":"<p>After deploying the scanner, verify its basic functionality:</p> <pre><code># Run a test scan\n./kubernetes-scripts/scan-container.sh default test-pod test-container profiles/container-baseline\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#scan-verification-checklist","title":"Scan Verification Checklist","text":"<p>Use this checklist to verify scanner functionality:</p> <ol> <li>Scanner pods are running:</li> </ol> <pre><code>kubectl get pods -n scanner-namespace\n</code></pre> <ol> <li>Scanner can access target containers:</li> </ol> <pre><code>kubectl logs scanner-pod -n scanner-namespace\n# Check for access/permission errors\n</code></pre> <ol> <li>Scan completes successfully:</li> </ol> <pre><code>kubectl get pods -n scanner-namespace -l app=scanner --field-selector status.phase=Succeeded\n</code></pre> <ol> <li>Results are generated:</li> </ol> <pre><code># Check if results file exists\nls -la results.json\n\n# Verify results format\njq . results.json\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#security-verification","title":"Security Verification","text":"<p>Verify security controls and restrictions:</p> <pre><code># Verify RBAC restrictions\nkubectl auth can-i get pods --as=system:serviceaccount:scanner-ns:scanner-sa -n target-ns\n\n# Verify token timeout\nTOKEN=$(kubectl -n scanner-ns create token scanner-sa --duration=300s)\necho $TOKEN\n# Wait 6 minutes\ncurl -k -H \"Authorization: Bearer $TOKEN\" https://kubernetes.default.svc/api/v1/namespaces/default/pods\n# Should return an authentication error\n\n# Check proper cleanup\nkubectl get pods -n scanner-ns -l app=scanner-job --field-selector status.phase=Succeeded\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#security-control-validation-matrix","title":"Security Control Validation Matrix","text":"Security Control Validation Method Expected Result RBAC Permissions Test API access Access only to authorized resources Token Timeout Check token validity after timeout Token expires as configured Pod Security Try privileged operations Operations fail with security error Network Policy Test unauthorized connections Connections blocked by policy Resource Limits Exceed configured limits Pod throttling without crashes"},{"location":"developer-guide/deployment/advanced-topics/verification/#integration-testing","title":"Integration Testing","text":"<p>Test integration with other systems:</p> <pre><code># Test alerting\n./scripts/test-alert.sh critical \"Test critical alert\"\n\n# Test report generation\n./scripts/generate-report.sh results.json --format html\n\n# Test threshold validation\n./scripts/validate-threshold.sh results.json thresholds/strict.yml\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#integration-test-cases","title":"Integration Test Cases","text":"<p>Document test cases for each integration point:</p> <pre><code># integration-tests.yaml\ntests:\n  - name: AlertingIntegration\n    description: Verify alerts are sent to configured channels\n    steps:\n      - \"Generate a test alert using the test-alert.sh script\"\n      - \"Verify alert appears in the configured Slack channel\"\n      - \"Verify alert contains the expected information\"\n    expectedResult: \"Alert received in Slack with correct information\"\n\n  - name: ReportGeneration\n    description: Verify report generation functionality\n    steps:\n      - \"Run a scan to generate results\"\n      - \"Generate reports in multiple formats (HTML, JSON, PDF)\"\n      - \"Verify report content accuracy\"\n    expectedResult: \"Reports generated in each format with accurate information\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#load-testing","title":"Load Testing","text":"<p>Verify scanner performance under load:</p> <pre><code># Deploy test targets\nkubectl apply -f test/load-test-targets.yaml\n\n# Run load test script\n./scripts/load-test.sh --concurrency=10 --duration=10m\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#performance-test-parameters","title":"Performance Test Parameters","text":"<p>Configure load testing parameters:</p> <pre><code># load-test-values.yaml\nloadTest:\n  targets:\n    count: 50\n    namespaces:\n      - default\n      - test-ns-1\n      - test-ns-2\n\n  scanners:\n    count: 5\n    concurrency: 10\n\n  duration: 30m\n\n  metrics:\n    collect: true\n    output: load-test-metrics.json\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Run comprehensive end-to-end tests:</p> <pre><code># Run E2E test suite\n./scripts/e2e-test.sh\n\n# Verify test results\ncat e2e-test-results.txt\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#e2e-test-scenarios","title":"E2E Test Scenarios","text":"<p>Document end-to-end test scenarios:</p> <pre><code># e2e-test-scenarios.yaml\nscenarios:\n  - name: StandardContainerScan\n    description: Test scanning a standard container\n    steps:\n      - \"Deploy a standard container\"\n      - \"Run a scan using the standard scanner\"\n      - \"Verify scan completes successfully\"\n      - \"Validate results against expected controls\"\n\n  - name: DistrolessContainerScan\n    description: Test scanning a distroless container\n    steps:\n      - \"Deploy a distroless container\"\n      - \"Run a scan using the distroless scanner\"\n      - \"Verify scan completes successfully\"\n      - \"Validate results against expected controls\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#compliance-verification","title":"Compliance Verification","text":"<p>Verify compliance with security standards:</p> <pre><code># Run compliance verification\n./scripts/verify-compliance.sh --standard=nist-800-53\n\n# Generate compliance report\n./scripts/compliance-report.sh --output=compliance-report.pdf\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#compliance-matrix","title":"Compliance Matrix","text":"<p>Document compliance verification:</p> <pre><code># compliance-matrix.yaml\nstandards:\n  - name: NIST 800-53\n    controls:\n      - id: AC-2\n        description: \"Account Management\"\n        verification: \"Verify scanner uses dedicated service accounts\"\n\n      - id: CM-6\n        description: \"Configuration Settings\"\n        verification: \"Verify scanner uses secure configuration defaults\"\n\n  - name: CIS Kubernetes\n    controls:\n      - id: 1.1.1\n        description: \"API Server Pod File Permissions\"\n        verification: \"Verify scanner deployment file permissions\"\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#verification-automation","title":"Verification Automation","text":"<p>Automate verification procedures:</p> <pre><code># verification-automation-values.yaml\nverification:\n  automated:\n    enabled: true\n    schedule: \"0 0 * * *\"  # Daily at midnight\n\n  tests:\n    - name: functionality\n      enabled: true\n    - name: security\n      enabled: true\n    - name: integration\n      enabled: true\n    - name: performance\n      enabled: true\n      schedule: \"0 0 * * 0\"  # Weekly on Sundays\n\n  reporting:\n    enabled: true\n    format: [\"html\", \"json\"]\n    retention: 30  # days\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#post-deployment-monitoring","title":"Post-Deployment Monitoring","text":"<p>Implement post-deployment monitoring:</p> <pre><code># post-deployment-values.yaml\npostDeployment:\n  monitoring:\n    duration: 24h\n    metrics:\n      - name: scanSuccess\n        threshold: 99.9  # percentage\n      - name: scanDuration\n        threshold: 120  # seconds\n\n  alerts:\n    enabled: true\n    channels:\n      - slack\n      - email\n</code></pre>"},{"location":"developer-guide/deployment/advanced-topics/verification/#related-topics","title":"Related Topics","text":"<ul> <li>Monitoring and Maintenance</li> <li>Security Enhancements</li> <li>Custom Development</li> </ul>"},{"location":"developer-guide/deployment/scenarios/","title":"Deployment Scenarios Overview","text":"<p>This guide provides an overview of different deployment scenarios for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"developer-guide/deployment/scenarios/#introduction","title":"Introduction","text":"<p>Different environments and organizational requirements call for different deployment approaches. These scenario guides provide detailed, real-world examples to help you implement the scanner in various environments.</p>"},{"location":"developer-guide/deployment/scenarios/#available-scenarios","title":"Available Scenarios","text":"<p>We provide detailed guidance for several common deployment scenarios:</p> <ul> <li>Enterprise Production Environment: Secure, scalable deployment for large organizations with multiple Kubernetes clusters</li> <li>Development Environment: Quick setup for development teams working on applications</li> <li>CI/CD Pipeline Environment: Integration with automated CI/CD pipelines for continuous security validation</li> <li>Multi-Tenant Kubernetes Environment: Deployment in shared clusters with multiple teams</li> <li>Air-Gapped Environment: Deployment in secure environments without internet access</li> </ul>"},{"location":"developer-guide/deployment/scenarios/#choosing-the-right-scenario","title":"Choosing the Right Scenario","text":"<p>When selecting a deployment scenario, consider the following factors:</p> <ol> <li>Environment Type: Production, development, testing, or specialized environment</li> <li>Scale: Single cluster vs. multiple clusters, number of containers to scan</li> <li>Security Requirements: Security posture, compliance needs, data sensitivity</li> <li>Team Structure: Single team or multiple teams sharing resources</li> <li>Integration Needs: CI/CD pipelines, security monitoring, compliance reporting</li> </ol>"},{"location":"developer-guide/deployment/scenarios/#customizing-scenarios","title":"Customizing Scenarios","text":"<p>Each scenario can be customized to meet your specific requirements:</p> <ul> <li>Adjust resource allocations based on your environment scale</li> <li>Modify security controls to match your security policies</li> <li>Customize scanning profiles for your application types</li> <li>Adapt deployment scripts or Helm values for your infrastructure</li> </ul>"},{"location":"developer-guide/deployment/scenarios/#related-topics","title":"Related Topics","text":"<ul> <li>Deployment Overview</li> <li>Script Deployment</li> <li>Helm Deployment</li> <li>CI/CD Integration</li> <li>Advanced Deployment Topics</li> </ul>"},{"location":"developer-guide/deployment/scenarios/air-gapped/","title":"Air-Gapped Environment","text":"<p>This guide provides a detailed approach for deploying the Secure CINC Auditor Kubernetes Container Scanning solution in an air-gapped environment.</p>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#use-case","title":"Use Case","text":"<p>Secure environment without internet access requiring container scanning capabilities.</p>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#recommended-approach","title":"Recommended Approach","text":"<p>Helm Charts with Pre-Downloaded Images is the recommended approach for air-gapped environments.</p>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#key-requirements","title":"Key Requirements","text":"<ul> <li>No internet connectivity</li> <li>Pre-downloaded images and charts</li> <li>Local image registry</li> <li>Self-contained operation</li> </ul>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#deployment-steps","title":"Deployment Steps","text":""},{"location":"developer-guide/deployment/scenarios/air-gapped/#1-prepare-the-environment","title":"1. Prepare the Environment","text":"<p>First, create a bundle containing all required images and configurations:</p> <pre><code># Create an image bundle for air-gapped environments\n./scripts/create-airgap-bundle.sh\n\n# Extract the bundle on the air-gapped environment\ntar -xzf scanner-airgap-bundle.tar.gz\n</code></pre> <p>The <code>create-airgap-bundle.sh</code> script should:</p> <ul> <li>Download all required container images</li> <li>Copy Helm charts and their dependencies</li> <li>Include necessary profiles and configurations</li> <li>Bundle everything into a portable archive</li> </ul>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#2-set-up-local-registry","title":"2. Set Up Local Registry","text":"<p>Load the images into a local registry in the air-gapped environment:</p> <pre><code># Load images to local registry\n./airgap/load-images.sh registry.local:5000\n</code></pre> <p>The <code>load-images.sh</code> script should:</p> <ul> <li>Load the saved Docker images from the bundle</li> <li>Tag them appropriately for the local registry</li> <li>Push them to the local registry</li> </ul>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#3-configure-helm-charts-for-local-resources","title":"3. Configure Helm Charts for Local Resources","text":"<p>Update the Helm chart values to use local resources:</p> <pre><code># airgap-values.yaml\nglobal:\n  imageRegistry: registry.local:5000\n  airgapped: true\n\nscanner:\n  image:\n    repository: registry.local:5000/cinc/auditor\n    tag: latest\n  resources: {}\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#4-deploy-using-local-resources","title":"4. Deploy Using Local Resources","text":"<p>Deploy the scanner using the local charts and registry:</p> <pre><code># Deploy using local charts and registry\nhelm install scanner-infrastructure ./airgap/charts/scanner-infrastructure -f airgap-values.yaml\nhelm install standard-scanner ./airgap/charts/standard-scanner -f airgap-values.yaml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#air-gapped-specific-considerations","title":"Air-Gapped-Specific Considerations","text":""},{"location":"developer-guide/deployment/scenarios/air-gapped/#creating-comprehensive-bundles","title":"Creating Comprehensive Bundles","text":"<p>Ensure your air-gapped bundle includes all necessary components:</p> <pre><code>#!/bin/bash\n# create-comprehensive-bundle.sh\n\n# Set variables\nREGISTRY=\"docker.io\"\nOUTPUT_DIR=\"./airgap-bundle\"\nCHARTS_DIR=\"./helm-charts\"\nPROFILES_DIR=\"./profiles\"\nSCRIPTS_DIR=\"./scripts\"\n\n# Create output directories\nmkdir -p ${OUTPUT_DIR}/{images,charts,profiles,scripts,kubernetes}\n\n# Download and save container images\nIMAGES=(\n  \"cinc/auditor:latest\"\n  \"bitnami/kubectl:latest\"\n  \"busybox:latest\"\n  \"ruby:3.1-alpine\"\n)\n\nfor image in \"${IMAGES[@]}\"; do\n  echo \"Pulling $image...\"\n  docker pull $image\n  filename=$(echo $image | tr '/:' '_')\n  echo \"Saving $image to ${OUTPUT_DIR}/images/$filename.tar\"\n  docker save $image &gt; ${OUTPUT_DIR}/images/$filename.tar\ndone\n\n# Copy Helm charts\ncp -r ${CHARTS_DIR}/* ${OUTPUT_DIR}/charts/\n\n# Copy profiles\ncp -r ${PROFILES_DIR}/* ${OUTPUT_DIR}/profiles/\n\n# Copy scripts\ncp -r ${SCRIPTS_DIR}/* ${OUTPUT_DIR}/scripts/\n\n# Copy Kubernetes manifests\ncp -r ./kubernetes/* ${OUTPUT_DIR}/kubernetes/\n\n# Create load script\ncat &gt; ${OUTPUT_DIR}/load-images.sh &lt;&lt; 'EOF'\n#!/bin/bash\n# Load images to local registry\n\nREGISTRY=${1:-\"registry.local:5000\"}\n\nfor image_file in ./images/*.tar; do\n  echo \"Loading $image_file...\"\n  docker load &lt; $image_file\ndone\n\n# Get loaded images and tag for local registry\nfor image in $(docker images --format \"{{.Repository}}:{{.Tag}}\" | grep -v \"&lt;none&gt;\"); do\n  if [[ $image != $REGISTRY/* ]]; then\n    new_name=$REGISTRY/$(echo $image | cut -d/ -f2-)\n    echo \"Tagging $image as $new_name\"\n    docker tag $image $new_name\n    echo \"Pushing $new_name to local registry\"\n    docker push $new_name\n  fi\ndone\nEOF\n\nchmod +x ${OUTPUT_DIR}/load-images.sh\n\n# Create README\ncat &gt; ${OUTPUT_DIR}/README.md &lt;&lt; EOF\n# Air-Gapped Scanner Bundle\n\nThis bundle contains all necessary components to deploy the Secure CINC Auditor Kubernetes Container Scanning solution in an air-gapped environment.\n\n## Contents\n\n- /images - Container images in TAR format\n- /charts - Helm charts for deployment\n- /profiles - Scanner profiles\n- /scripts - Helper scripts\n- /kubernetes - Kubernetes manifests\n\n## Deployment Instructions\n\n1. Ensure you have Docker and a local registry running\n2. Run ./load-images.sh &lt;registry-url&gt; to load images to your local registry\n3. Deploy using Helm:\n   \\`\\`\\`\n   helm install scanner-infrastructure ./charts/scanner-infrastructure -f airgap-values.yaml\n   helm install standard-scanner ./charts/standard-scanner -f airgap-values.yaml\n   \\`\\`\\`\n\n## Requirements\n\n- Kubernetes 1.16+\n- Helm 3+\n- Docker\n- Local container registry\nEOF\n\n# Create values file for air-gapped deployment\ncat &gt; ${OUTPUT_DIR}/airgap-values.yaml &lt;&lt; EOF\nglobal:\n  imageRegistry: registry.local:5000\n  airgapped: true\n\nscanner:\n  image:\n    repository: registry.local:5000/cinc/auditor\n    tag: latest\n\nkubernetes:\n  image:\n    repository: registry.local:5000/bitnami/kubectl\n    tag: latest\n\ndebug:\n  image:\n    repository: registry.local:5000/busybox\n    tag: latest\nEOF\n\n# Create final bundle\ntar -czf scanner-airgap-bundle.tar.gz -C ${OUTPUT_DIR} .\n\necho \"Air-gapped bundle created: scanner-airgap-bundle.tar.gz\"\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#local-profile-and-configuration-management","title":"Local Profile and Configuration Management","text":"<p>Set up local profile management for air-gapped environments:</p> <pre><code># local-profiles-values.yaml\nprofiles:\n  source: local\n  path: /path/to/airgap-bundle/profiles\n  configMap:\n    create: true\n    name: airgapped-profiles\n\nconfigurations:\n  source: local\n  path: /path/to/airgap-bundle/configs\n  configMap:\n    create: true\n    name: airgapped-configs\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#offline-updates","title":"Offline Updates","text":"<p>Implement a process for offline updates:</p> <pre><code>#!/bin/bash\n# offline-update.sh\n\n# Set variables\nUPDATE_BUNDLE=\"scanner-update-bundle.tar.gz\"\nEXTRACT_DIR=\"./update-bundle\"\n\n# Extract update bundle\nmkdir -p ${EXTRACT_DIR}\ntar -xzf ${UPDATE_BUNDLE} -C ${EXTRACT_DIR}\n\n# Load updated images\n./load-images.sh registry.local:5000 ${EXTRACT_DIR}/images\n\n# Update Helm charts\ncp -r ${EXTRACT_DIR}/charts/* ./charts/\n\n# Update profiles\ncp -r ${EXTRACT_DIR}/profiles/* ./profiles/\n\n# Apply updates\nhelm upgrade scanner-infrastructure ./charts/scanner-infrastructure -f airgap-values.yaml\nhelm upgrade standard-scanner ./charts/standard-scanner -f airgap-values.yaml\n\n# Update ConfigMaps if needed\nkubectl create configmap airgapped-profiles --from-file=./profiles/ -o yaml --dry-run=client | kubectl apply -f -\n\necho \"Update completed\"\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#validation-and-testing","title":"Validation and Testing","text":"<p>After deployment, validate your air-gapped setup:</p> <ol> <li>Verify all images are available locally:</li> </ol> <pre><code># List images in local registry\ncurl -X GET http://registry.local:5000/v2/_catalog\n</code></pre> <ol> <li>Test scanning functionality:</li> </ol> <pre><code># Run a test scan\n./kubernetes-scripts/scan-container.sh default test-pod test-container profiles/container-baseline\n</code></pre> <ol> <li>Verify no external calls are made:</li> </ol> <pre><code># Monitor network connections (should show no external connections)\ntcpdump -n not port 22\n</code></pre> <ol> <li>Test profile application:</li> </ol> <pre><code># Create a test pod\nkubectl apply -f kubernetes/test-pod.yaml\n\n# Run scan with local profile\n./kubernetes-scripts/scan-container.sh default test-pod test-container /path/to/airgap-bundle/profiles/container-baseline\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#air-gapped-documentation","title":"Air-Gapped Documentation","text":"<p>Include offline documentation in your deployment:</p> <pre><code># documentation-values.yaml\ndocumentation:\n  offline:\n    enabled: true\n    format: html\n    configMap:\n      create: true\n      name: airgapped-docs\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/air-gapped/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Deployment</li> <li>Advanced Deployment Topics</li> <li>High-Security Environments</li> <li>Enterprise Environment</li> </ul>"},{"location":"developer-guide/deployment/scenarios/cicd/","title":"CI/CD Pipeline Environment","text":"<p>This guide provides a detailed approach for integrating the Secure CINC Auditor Kubernetes Container Scanning solution into CI/CD pipelines.</p>"},{"location":"developer-guide/deployment/scenarios/cicd/#use-case","title":"Use Case","text":"<p>Automated container scanning as part of CI/CD pipelines to enforce security policies before deployment.</p>"},{"location":"developer-guide/deployment/scenarios/cicd/#recommended-approach","title":"Recommended Approach","text":"<p>CI/CD Pipeline Integration is the recommended approach for automated security scanning in deployment pipelines.</p>"},{"location":"developer-guide/deployment/scenarios/cicd/#key-requirements","title":"Key Requirements","text":"<ul> <li>Automated execution</li> <li>Pass/fail criteria</li> <li>Artifact generation</li> <li>Integration with CI/CD tools</li> </ul>"},{"location":"developer-guide/deployment/scenarios/cicd/#github-actions-integration","title":"GitHub Actions Integration","text":""},{"location":"developer-guide/deployment/scenarios/cicd/#basic-github-actions-workflow","title":"Basic GitHub Actions Workflow","text":"<p>Create a GitHub Actions workflow file to scan containers:</p> <pre><code># .github/workflows/container-scan.yml\nname: Container Security Scan\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n\n      - name: Deploy scanner\n        run: ./kubernetes-scripts/setup-minikube.sh\n\n      - name: Build container\n        run: |\n          docker build -t test-app:${{ github.sha }} .\n          kind load docker-image test-app:${{ github.sha }}\n          kubectl apply -f kubernetes/deploy-test-app.yaml\n\n      - name: Run scan\n        run: |\n          ./kubernetes-scripts/scan-container.sh default test-app test-container profiles/ci-baseline\n\n      - name: Validate against thresholds\n        run: |\n          saf validate -i results.json -f thresholds/ci-thresholds.yml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#advanced-github-actions-workflow","title":"Advanced GitHub Actions Workflow","text":"<p>For more complex scenarios, use matrix builds to scan multiple containers:</p> <pre><code># .github/workflows/advanced-scan.yml\nname: Advanced Container Security Scan\non:\n  push:\n    branches: [main]\n  schedule:\n    - cron: '0 0 * * *'  # Daily scan\n\njobs:\n  prepare:\n    runs-on: ubuntu-latest\n    outputs:\n      matrix: ${{ steps.set-matrix.outputs.matrix }}\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set scan matrix\n        id: set-matrix\n        run: |\n          echo \"::set-output name=matrix::{\\\"container\\\":[\\\"app\\\",\\\"api\\\",\\\"worker\\\"],\\\"profile\\\":[\\\"container-baseline\\\",\\\"cis-kubernetes\\\"]}\"\n\n  scan:\n    needs: prepare\n    runs-on: ubuntu-latest\n    strategy:\n      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Kubernetes\n        uses: engineerd/setup-kind@v0.5.0\n\n      - name: Build and deploy test containers\n        run: |\n          docker build -t ${{ matrix.container }}-image ./containers/${{ matrix.container }}\n          kind load docker-image ${{ matrix.container }}-image\n          kubectl apply -f ./kubernetes/deploy-${{ matrix.container }}.yaml\n\n      - name: Run scan\n        run: ./kubernetes-scripts/scan-container.sh default ${{ matrix.container }}-pod ${{ matrix.container }} profiles/${{ matrix.profile }}\n\n      - name: Process results\n        run: |\n          saf report -i results.json -o report-${{ matrix.container }}-${{ matrix.profile }}.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v2\n        with:\n          name: scan-results-${{ matrix.container }}-${{ matrix.profile }}\n          path: report-${{ matrix.container }}-${{ matrix.profile }}.html\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#gitlab-ci-integration","title":"GitLab CI Integration","text":""},{"location":"developer-guide/deployment/scenarios/cicd/#basic-gitlab-ci-pipeline","title":"Basic GitLab CI Pipeline","text":"<p>Create a GitLab CI pipeline file for container scanning:</p> <pre><code># .gitlab-ci.yml\nstages:\n  - build\n  - deploy\n  - scan\n  - validate\n\nbuild_container:\n  stage: build\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA\n\ndeploy_to_test:\n  stage: deploy\n  script:\n    - kubectl apply -f &lt;(sed \"s/IMAGE_TAG/$CI_COMMIT_SHORT_SHA/g\" kubernetes/deploy-test-app.yaml)\n\nscan_container:\n  stage: scan\n  script:\n    - ./kubernetes-scripts/scan-container.sh default test-app test-container profiles/ci-baseline\n\nvalidate_results:\n  stage: validate\n  script:\n    - saf validate -i results.json -f thresholds/ci-thresholds.yml\n  artifacts:\n    paths:\n      - results.json\n    when: always\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#advanced-gitlab-ci-pipeline","title":"Advanced GitLab CI Pipeline","text":"<p>For more comprehensive scanning in GitLab:</p> <pre><code># .gitlab-ci.yml\nvariables:\n  KUBERNETES_VERSION: 1.23.5\n  SCANNER_IMAGE: cinc/auditor:latest\n  SAF_CLI_VERSION: 2.0.0\n\nstages:\n  - build\n  - deploy\n  - scan\n  - report\n  - cleanup\n\n.kubernetes_template: &amp;kubernetes_setup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y curl\n    - curl -LO \"https://dl.k8s.io/release/v${KUBERNETES_VERSION}/bin/linux/amd64/kubectl\"\n    - chmod +x kubectl &amp;&amp; mv kubectl /usr/local/bin/\n    - curl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64\n    - chmod +x ./kind &amp;&amp; mv ./kind /usr/local/bin/kind\n    - kind create cluster --name scanner-cluster\n    - kubectl cluster-info\n    - kubectl get nodes\n\nbuild_containers:\n  stage: build\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker build -t app-image ./containers/app\n    - docker build -t api-image ./containers/api\n    - docker save app-image &gt; app-image.tar\n    - docker save api-image &gt; api-image.tar\n  artifacts:\n    paths:\n      - app-image.tar\n      - api-image.tar\n\ndeploy_containers:\n  stage: deploy\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - kind load image-archive app-image.tar\n    - kind load image-archive api-image.tar\n    - kubectl apply -f ./kubernetes/deployments/\n\ndeploy_scanner:\n  stage: deploy\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - ./kubernetes-scripts/setup-minikube.sh\n    - kubectl get pods -A\n\nscan_job:\n  stage: scan\n  parallel:\n    matrix:\n      - CONTAINER: [\"app\", \"api\"]\n        PROFILE: [\"container-baseline\", \"cis-kubernetes\"]\n  script:\n    - ./kubernetes-scripts/scan-container.sh default ${CONTAINER}-pod ${CONTAINER} profiles/${PROFILE}\n    - mkdir -p ./results/${CONTAINER}/${PROFILE}\n    - cp results.json ./results/${CONTAINER}/${PROFILE}/\n  artifacts:\n    paths:\n      - ./results/\n\ngenerate_reports:\n  stage: report\n  image: ruby:latest\n  script:\n    - gem install saf-cli -v ${SAF_CLI_VERSION}\n    - mkdir -p ./reports\n    - |\n      for dir in ./results/*; do\n        CONTAINER=$(basename $dir)\n        for profile_dir in $dir/*; do\n          PROFILE=$(basename $profile_dir)\n          saf report -i $profile_dir/results.json -o ./reports/${CONTAINER}-${PROFILE}.html\n        done\n      done\n  artifacts:\n    paths:\n      - ./reports/\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  &lt;&lt;: *kubernetes_setup\n  script:\n    - kind delete cluster --name scanner-cluster\n  when: always\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#cicd-specific-considerations","title":"CI/CD-Specific Considerations","text":""},{"location":"developer-guide/deployment/scenarios/cicd/#thresholds-for-automated-pipelines","title":"Thresholds for Automated Pipelines","text":"<p>Create threshold files for pass/fail criteria:</p> <pre><code># thresholds/ci-thresholds.yml\nfailure:\n  critical: 1   # Fail on any critical findings\n  high: 5       # Allow up to 5 high findings\nwarning:\n  critical: 0   # Warn on any critical findings\n  high: 1       # Warn on any high findings\n  medium: 10    # Warn if more than 10 medium findings\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#integration-with-security-gates","title":"Integration with Security Gates","text":"<p>Configure security gates in your CI/CD pipeline:</p> <pre><code># Example security gate configuration\nsecurity_gate:\n  stage: verify\n  script:\n    - |\n      if [ -f security-gate-failed ]; then\n        echo \"Security gate failed - critical vulnerabilities found\"\n        cat security-findings.txt\n        exit 1\n      fi\n  allow_failure:\n    exit_codes: 1\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#notifications-for-security-issues","title":"Notifications for Security Issues","text":"<p>Set up notifications for security findings:</p> <pre><code># Example notification configuration\nnotify_security_team:\n  stage: notify\n  script:\n    - |\n      if [ -f security-findings.txt ]; then\n        curl -X POST -H \"Content-Type: application/json\" \\\n          -d \"{\\\"text\\\":\\\"Security issues found in build $CI_PIPELINE_ID\\\"}\" \\\n          ${SLACK_WEBHOOK_URL}\n      fi\n  when: always\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/cicd/#best-practices-for-cicd-integration","title":"Best Practices for CI/CD Integration","text":"<ol> <li>Define clear thresholds:</li> <li>Establish appropriate thresholds based on your security policies</li> <li> <p>Consider different thresholds for different environments (dev/staging/prod)</p> </li> <li> <p>Store scan artifacts:</p> </li> <li>Preserve scan results for future reference</li> <li> <p>Link results to specific build artifacts</p> </li> <li> <p>Implement graduated enforcement:</p> </li> <li>Start with warnings-only mode to avoid blocking pipelines</li> <li> <p>Gradually increase enforcement as teams address findings</p> </li> <li> <p>Ensure good reporting:</p> </li> <li>Generate comprehensive reports with actionable items</li> <li> <p>Make reports easily accessible to development teams</p> </li> <li> <p>Optimize for performance:</p> </li> <li>Use caching where possible</li> <li>Parallelize scanning for multiple containers</li> <li>Consider scanning only changed components</li> </ol>"},{"location":"developer-guide/deployment/scenarios/cicd/#related-topics","title":"Related Topics","text":"<ul> <li>CI/CD Integration Guide</li> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>Threshold Configuration</li> </ul>"},{"location":"developer-guide/deployment/scenarios/development/","title":"Development Environment","text":"<p>This guide provides a detailed approach for deploying the Secure CINC Auditor Kubernetes Container Scanning solution in a development environment.</p>"},{"location":"developer-guide/deployment/scenarios/development/#use-case","title":"Use Case","text":"<p>Development teams needing quick setup for testing and developing applications with security scanning.</p>"},{"location":"developer-guide/deployment/scenarios/development/#recommended-approach","title":"Recommended Approach","text":"<p>Script-based Deployment is the recommended approach for development environments due to its simplicity and flexibility.</p>"},{"location":"developer-guide/deployment/scenarios/development/#key-requirements","title":"Key Requirements","text":"<ul> <li>Quick setup</li> <li>Minimal configuration</li> <li>Local development focus</li> <li>Rapid iteration</li> </ul>"},{"location":"developer-guide/deployment/scenarios/development/#deployment-steps","title":"Deployment Steps","text":""},{"location":"developer-guide/deployment/scenarios/development/#1-set-up-local-environment","title":"1. Set Up Local Environment","text":"<p>First, use the setup script to configure a local development environment:</p> <pre><code># Set up development environment with minikube\n./kubernetes-scripts/setup-minikube.sh --dev-mode\n</code></pre> <p>This script:</p> <ul> <li>Creates a Minikube cluster if one doesn't exist</li> <li>Configures necessary RBAC permissions</li> <li>Sets up the scanner service account</li> <li>Configures the environment for scanning</li> </ul>"},{"location":"developer-guide/deployment/scenarios/development/#2-run-on-demand-scans","title":"2. Run On-Demand Scans","text":"<p>During development, run scans on demand to validate container security:</p> <pre><code># Scan containers during development\n./kubernetes-scripts/scan-container.sh default app-pod app-container profiles/dev-baseline\n\n# Scan with custom profile path\n./kubernetes-scripts/scan-container.sh default app-pod app-container ~/my-custom-profiles/baseline\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#3-create-team-wrapper-scripts","title":"3. Create Team Wrapper Scripts","text":"<p>To simplify usage for development teams, create custom wrapper scripts:</p> <pre><code># Create a team-specific wrapper script\ncat &gt; scan-dev.sh &lt;&lt; EOF\n#!/bin/bash\n# Team Development Scanner\nNAMESPACE=\\${1:-default}\nPOD=\\${2:-app-pod}\nCONTAINER=\\${3:-app-container}\nPROFILE=\\${4:-profiles/dev-baseline}\n\n./kubernetes-scripts/scan-container.sh \\$NAMESPACE \\$POD \\$CONTAINER \\$PROFILE\nEOF\n\nchmod +x scan-dev.sh\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#development-specific-considerations","title":"Development-Specific Considerations","text":""},{"location":"developer-guide/deployment/scenarios/development/#local-profile-development","title":"Local Profile Development","text":"<p>For developing and testing custom security profiles:</p> <pre><code># Create a new profile directory\nmkdir -p my-profiles/custom-baseline\n\n# Initialize a new profile\ncinc-auditor init profile --platform k8s-container my-profiles/custom-baseline\n\n# Edit the profile\ncode my-profiles/custom-baseline\n\n# Test the profile\n./kubernetes-scripts/scan-container.sh default app-pod app-container my-profiles/custom-baseline\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#quick-feedback-loop","title":"Quick Feedback Loop","text":"<p>Set up aliases for faster development workflow:</p> <pre><code># Add to your .bashrc or .zshrc\nalias k-scan='./kubernetes-scripts/scan-container.sh'\nalias k-scan-distroless='./kubernetes-scripts/scan-distroless-container.sh'\nalias k-scan-sidecar='./kubernetes-scripts/scan-with-sidecar.sh'\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#development-team-setup","title":"Development Team Setup","text":"<p>For multiple developers working on the same project:</p> <pre><code># Create a development config script\ncat &gt; dev-config.sh &lt;&lt; EOF\n#!/bin/bash\n# Development Environment Setup\nexport KUBECONFIG=\\$(pwd)/.kube/config\nexport SCANNER_NAMESPACE=dev-scanner\nexport INSPEC_PROFILE_PATH=\\$(pwd)/profiles\nexport DEFAULT_THRESHOLD=\\$(pwd)/thresholds/dev-thresholds.yml\n\n# Create local scanner namespace\nkubectl create namespace \\$SCANNER_NAMESPACE 2&gt;/dev/null || true\n\n# Set up local profiles\nmkdir -p \\$INSPEC_PROFILE_PATH\n\necho \"Development environment configured\"\nEOF\n\nchmod +x dev-config.sh\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#validation-and-testing","title":"Validation and Testing","text":"<p>Verify your development setup with these tests:</p> <ol> <li>Verify Minikube is running:</li> </ol> <pre><code>minikube status\n</code></pre> <ol> <li>Test a basic scan:</li> </ol> <pre><code>./kubernetes-scripts/scan-container.sh default nginx nginx profiles/container-baseline\n</code></pre> <ol> <li>Check scan results:</li> </ol> <pre><code># View the latest results\ncat results.json | jq\n\n# Generate a report\nsaf report -i results.json -o dev-report.html\n</code></pre> <ol> <li>Test profile modifications:</li> </ol> <pre><code># Edit a profile control\nnano profiles/container-baseline/controls/01_file_checks.rb\n\n# Run scan with modified profile\n./kubernetes-scripts/scan-container.sh default nginx nginx profiles/container-baseline\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#troubleshooting-development-setups","title":"Troubleshooting Development Setups","text":"<p>Common issues in development environments:</p> <ol> <li>Minikube Issues:</li> </ol> <pre><code># Restart Minikube if needed\nminikube stop\nminikube start\n\n# Check Minikube logs\nminikube logs\n</code></pre> <ol> <li>Scanner Access Issues:</li> </ol> <pre><code># Verify RBAC permissions\nkubectl auth can-i get pods --as system:serviceaccount:default:scanner-sa\n</code></pre> <ol> <li>Profile Errors:</li> </ol> <pre><code># Validate profile syntax\ncinc-auditor check profiles/container-baseline\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/development/#related-topics","title":"Related Topics","text":"<ul> <li>Script Deployment</li> <li>Custom Profile Development</li> <li>Local Testing</li> <li>CI/CD Environment</li> </ul>"},{"location":"developer-guide/deployment/scenarios/enterprise/","title":"Enterprise Production Environment","text":"<p>This guide provides a detailed approach for deploying the Secure CINC Auditor Kubernetes Container Scanning solution in an enterprise production environment.</p>"},{"location":"developer-guide/deployment/scenarios/enterprise/#use-case","title":"Use Case","text":"<p>Large organizations with multiple Kubernetes clusters requiring robust security scanning of all containers.</p>"},{"location":"developer-guide/deployment/scenarios/enterprise/#recommended-approach","title":"Recommended Approach","text":"<p>Helm Charts Deployment is the recommended approach for enterprise environments due to its flexibility, scalability, and integration capabilities.</p>"},{"location":"developer-guide/deployment/scenarios/enterprise/#key-requirements","title":"Key Requirements","text":"<ul> <li>High availability</li> <li>Centralized reporting</li> <li>Integration with security monitoring systems</li> <li>Comprehensive scan coverage</li> <li>Role-based access control</li> </ul>"},{"location":"developer-guide/deployment/scenarios/enterprise/#deployment-steps","title":"Deployment Steps","text":""},{"location":"developer-guide/deployment/scenarios/enterprise/#1-deploy-scanner-infrastructure","title":"1. Deploy Scanner Infrastructure","text":"<p>First, deploy the base scanner infrastructure across all required namespaces:</p> <pre><code># Deploy base infrastructure\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set global.enterprise=true \\\n  --set global.monitoring.enabled=true\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#2-configure-rbac","title":"2. Configure RBAC","text":"<p>Configure RBAC with appropriate restrictions for your enterprise environment:</p> <pre><code># custom-rbac-values.yaml\nrbac:\n  strategy: label-based\n  timeoutSeconds: 900\n  labelSelector:\n    scan: enabled\n  clusterRoles:\n    create: true\n    restrictive: true\n</code></pre> <p>Apply the RBAC configuration:</p> <pre><code>helm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  -f custom-rbac-values.yaml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#3-deploy-scanners","title":"3. Deploy Scanners","text":"<p>Deploy the appropriate scanner types based on your container types:</p> <pre><code># Deploy standard scanner for regular containers\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set scanSchedule=\"0 0 * * *\" \\\n  --set notifications.slack.enabled=true\n\n# Set up distroless scanner if needed\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set kubernetes.version=1.16+\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#4-configure-monitoring-and-alerting","title":"4. Configure Monitoring and Alerting","text":"<p>Set up monitoring and alerting for your scanning infrastructure:</p> <pre><code># monitoring-values.yaml\nmonitoring:\n  enabled: true\n  prometheus:\n    scrape: true\n  grafana:\n    dashboards: true\n  alerts:\n    critical:\n      threshold: 75\n      channels: [\"security-team\", \"ops-team\"]\n    warning:\n      threshold: 50\n      channels: [\"security-team\"]\n</code></pre> <p>Apply the monitoring configuration:</p> <pre><code>helm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  -f monitoring-values.yaml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#enterprise-specific-considerations","title":"Enterprise-Specific Considerations","text":""},{"location":"developer-guide/deployment/scenarios/enterprise/#high-availability","title":"High Availability","text":"<p>For high availability in enterprise environments:</p> <pre><code># ha-values.yaml\nreplicaCount: 3\npodDisruptionBudget:\n  enabled: true\n  minAvailable: 2\nantiAffinity:\n  enabled: true\n  type: hard  # Or soft for flexible scheduling\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#data-retention","title":"Data Retention","text":"<p>Configure appropriate data retention policies:</p> <pre><code># retention-values.yaml\ndataRetention:\n  enabled: true\n  scanResults:\n    retentionDays: 90\n  reports:\n    retentionDays: 365\n  archiving:\n    enabled: true\n    destination: \"s3://security-archive/container-scans\"\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#enterprise-integration","title":"Enterprise Integration","text":"<p>Configure integration with enterprise security systems:</p> <pre><code># integration-values.yaml\nintegration:\n  siem:\n    enabled: true\n    type: splunk  # or elasticsearch, etc.\n    endpoint: \"https://splunk.example.com:8088\"\n    token: \"${SPLUNK_TOKEN}\"\n  ticketing:\n    enabled: true\n    type: jira\n    endpoint: \"https://jira.example.com/api\"\n    credentials:\n      secretName: jira-credentials\n  compliance:\n    enabled: true\n    reports:\n      schedule: \"0 0 * * 0\"  # Weekly on Sundays\n      formats: [\"html\", \"pdf\", \"csv\"]\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#validation-and-testing","title":"Validation and Testing","text":"<p>After deployment, validate your enterprise setup:</p> <ol> <li>Verify scanner deployment across all namespaces:</li> </ol> <pre><code>kubectl get pods -n scanner-system\nkubectl get pods -A -l app=scanner\n</code></pre> <ol> <li>Test scanning functionality:</li> </ol> <pre><code># Run a test scan\n./kubernetes-scripts/scan-container.sh default test-pod test-container profiles/enterprise-baseline\n</code></pre> <ol> <li>Verify monitoring integration:</li> </ol> <pre><code># Check Prometheus targets\nkubectl port-forward svc/prometheus-server 9090:9090 -n monitoring\n# Open http://localhost:9090/targets in your browser\n</code></pre> <ol> <li>Test alerting:</li> </ol> <pre><code># Trigger a test alert\nkubectl annotate pod test-pod security.scan/test-alert=true\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/enterprise/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Deployment</li> <li>Advanced Deployment Topics</li> <li>Multi-Tenant Environment</li> <li>Security Considerations</li> </ul>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/","title":"Multi-Tenant Kubernetes Environment","text":"<p>This guide provides a detailed approach for deploying the Secure CINC Auditor Kubernetes Container Scanning solution in a multi-tenant Kubernetes environment.</p>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#use-case","title":"Use Case","text":"<p>Shared Kubernetes cluster with multiple teams or applications requiring secure container scanning with strong isolation between tenants.</p>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#recommended-approach","title":"Recommended Approach","text":"<p>Helm Charts with Label-based RBAC is the recommended approach for multi-tenant environments.</p>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#key-requirements","title":"Key Requirements","text":"<ul> <li>Strong isolation between tenants</li> <li>Granular access controls</li> <li>Tenant-specific configurations</li> <li>Centralized management</li> </ul>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#deployment-steps","title":"Deployment Steps","text":""},{"location":"developer-guide/deployment/scenarios/multi-tenant/#1-deploy-infrastructure-with-label-based-rbac","title":"1. Deploy Infrastructure with Label-based RBAC","text":"<p>First, deploy the scanner infrastructure with label-based RBAC:</p> <pre><code># Deploy with label-based RBAC\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set rbac.strategy=label-based \\\n  --set rbac.labelSelector=scan=enabled\n</code></pre> <p>The label-based approach ensures:</p> <ul> <li>Only containers with specific labels are scanned</li> <li>Access permissions are strictly limited to labeled resources</li> <li>Different teams can manage their own scanned resources</li> </ul>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#2-configure-namespaced-service-accounts","title":"2. Configure Namespaced Service Accounts","text":"<p>Configure separate service accounts for each tenant namespace:</p> <pre><code># tenant-values.yaml\nserviceAccounts:\n  perNamespace: true\n  namespaces:\n    - name: team-a\n      labels:\n        team: a\n        scan: enabled\n    - name: team-b\n      labels:\n        team: b\n        scan: enabled\n</code></pre> <p>Apply the configuration:</p> <pre><code>helm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  -f tenant-values.yaml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#3-implement-strict-security-controls","title":"3. Implement Strict Security Controls","text":"<p>Add time-bound token validation and additional security measures:</p> <pre><code># security-values.yaml\nsecurity:\n  tokenTimeout: 300  # 5 minutes\n  requireAnnotations: true\n  auditEvents: true\n</code></pre> <p>Apply the security controls:</p> <pre><code>helm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  -f security-values.yaml\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#4-configure-tenant-specific-scanners","title":"4. Configure Tenant-Specific Scanners","text":"<p>Deploy separate scanner instances for each tenant:</p> <pre><code># Deploy tenant-specific scanners\nfor team in team-a team-b team-c; do\n  helm install $team-scanner ./helm-charts/standard-scanner \\\n    --set global.namespace=$team \\\n    --set scanner.serviceAccount=$team-scanner-sa \\\n    --set profiles.configMap=$team-profiles\ndone\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#multi-tenant-specific-considerations","title":"Multi-Tenant-Specific Considerations","text":""},{"location":"developer-guide/deployment/scenarios/multi-tenant/#tenant-isolation","title":"Tenant Isolation","text":"<p>Enhance tenant isolation with network policies:</p> <pre><code># network-policy-values.yaml\nnetworkPolicies:\n  enabled: true\n  defaultDeny: true\n  allowedNamespaces:\n    - team-a\n    - team-b\n    - team-c\n  rules:\n    - from:\n        namespaceSelector:\n          matchLabels:\n            name: team-a\n      to:\n        namespaceSelector:\n          matchLabels:\n            name: team-a\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#resource-quotas","title":"Resource Quotas","text":"<p>Implement resource quotas to prevent resource contention:</p> <pre><code># resource-quota-values.yaml\nresourceQuotas:\n  enabled: true\n  quotas:\n    - namespace: team-a\n      limits:\n        cpu: \"4\"\n        memory: 8Gi\n    - namespace: team-b\n      limits:\n        cpu: \"4\"\n        memory: 8Gi\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#tenant-specific-profiles-and-thresholds","title":"Tenant-Specific Profiles and Thresholds","text":"<p>Configure tenant-specific security profiles and thresholds:</p> <pre><code># tenant-profiles-values.yaml\nprofiles:\n  tenantSpecific: true\n  configMaps:\n    - name: team-a-profiles\n      namespace: team-a\n      data:\n        baseline: |\n          name: team-a-baseline\n          controls:\n            - id: TA-001\n              desc: Team A specific control\n    - name: team-b-profiles\n      namespace: team-b\n      data:\n        baseline: |\n          name: team-b-baseline\n          controls:\n            - id: TB-001\n              desc: Team B specific control\n\nthresholds:\n  tenantSpecific: true\n  configMaps:\n    - name: team-a-thresholds\n      namespace: team-a\n      data:\n        thresholds.yml: |\n          failure:\n            critical: 0\n            high: 3\n    - name: team-b-thresholds\n      namespace: team-b\n      data:\n        thresholds.yml: |\n          failure:\n            critical: 1\n            high: 5\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#role-based-access-for-different-teams","title":"Role-Based Access for Different Teams","text":"<p>Implement role-based access for different tenant teams:</p> <pre><code># rbac-values.yaml\ntenantRBAC:\n  enabled: true\n  roles:\n    - name: scanner-admin\n      rules:\n        - apiGroups: [\"\"]\n          resources: [\"pods\", \"configmaps\"]\n          verbs: [\"get\", \"list\"]\n    - name: scanner-viewer\n      rules:\n        - apiGroups: [\"\"]\n          resources: [\"pods\"]\n          verbs: [\"get\", \"list\"]\n\n  roleBindings:\n    - name: team-a-admin\n      namespace: team-a\n      role: scanner-admin\n      subjects:\n        - kind: Group\n          name: team-a-admins\n    - name: team-b-viewer\n      namespace: team-b\n      role: scanner-viewer\n      subjects:\n        - kind: Group\n          name: team-b-users\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#centralized-reporting-with-tenant-filtering","title":"Centralized Reporting with Tenant Filtering","text":"<p>Configure centralized reporting with tenant filtering:</p> <pre><code># reporting-values.yaml\nreporting:\n  centralized:\n    enabled: true\n    storage:\n      type: s3\n      bucket: scanner-reports\n    tenantFiltering:\n      enabled: true\n      attributeField: namespace\n    access:\n      rbac:\n        globalAdmins: true\n        tenantScopedAccess: true\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#validation-and-testing","title":"Validation and Testing","text":"<p>After deployment, validate your multi-tenant setup:</p> <ol> <li>Verify tenant isolation:</li> </ol> <pre><code># Attempt to scan across namespace boundaries\n./kubernetes-scripts/scan-container.sh team-b app-pod app-container profiles/baseline --service-account team-a-scanner-sa\n# Should fail due to RBAC restrictions\n</code></pre> <ol> <li>Test tenant-specific scanning:</li> </ol> <pre><code># Scan a team-a container\n./kubernetes-scripts/scan-container.sh team-a app-pod app-container profiles/baseline --service-account team-a-scanner-sa\n# Should succeed\n</code></pre> <ol> <li>Verify label-based targeting:</li> </ol> <pre><code># Add scan label to pod\nkubectl label pod app-pod -n team-a scan=enabled\n\n# Run the scanner\nhelm test team-a-scanner\n</code></pre>"},{"location":"developer-guide/deployment/scenarios/multi-tenant/#related-topics","title":"Related Topics","text":"<ul> <li>Helm Deployment</li> <li>RBAC Configuration</li> <li>Label-based RBAC</li> <li>Advanced Deployment Topics</li> <li>Enterprise Environment</li> </ul>"},{"location":"developer-guide/testing/","title":"Testing Guide","text":"<p>Directory Inventory</p> <p>See the Testing Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This document provides a comprehensive guide to testing the Secure CINC Auditor Kubernetes Container Scanning solution, covering test methodology, test environments, and recommended testing practices.</p>"},{"location":"developer-guide/testing/#testing-overview","title":"Testing Overview","text":"<p>The testing strategy for this container scanning solution covers several key aspects:</p> <ol> <li>Functional Testing: Validating that the scanning tools correctly identify security issues</li> <li>Integration Testing: Ensuring the scanning tools work with various Kubernetes environments</li> <li>Security Testing: Verifying that the scanning implementation itself doesn't introduce security risks</li> <li>Performance Testing: Measuring scan times and resource utilization</li> <li>Compliance Testing: Validating that scanning results meet compliance requirements</li> </ol>"},{"location":"developer-guide/testing/#testing-environments","title":"Testing Environments","text":"<p>We recommend testing in the following environments:</p> <ul> <li>Local Minikube: For initial functional testing and development</li> <li>GitLab CI/GitHub Actions: For CI/CD pipeline integration testing</li> <li>Production-like Kubernetes: For final validation before production deployment</li> </ul>"},{"location":"developer-guide/testing/#testing-prerequisites","title":"Testing Prerequisites","text":"<p>Before running tests, ensure you have:</p> <ol> <li>A Kubernetes Cluster:</li> <li>For local testing: minikube with at least 2 nodes</li> <li> <p>For production testing: A Kubernetes cluster with appropriate access</p> </li> <li> <p>Required Tools:</p> </li> <li>kubectl</li> <li>CINC Auditor/InSpec</li> <li>SAF CLI for results processing</li> <li> <p>Appropriate container images for testing (standard and distroless)</p> </li> <li> <p>Access Credentials:</p> </li> <li>RBAC permissions to create service accounts, roles, and pods</li> <li>Ability to create tokens for testing</li> </ol>"},{"location":"developer-guide/testing/#test-categories","title":"Test Categories","text":""},{"location":"developer-guide/testing/#1-functional-testing","title":"1. Functional Testing","text":"<p>Tests that validate the core scanning functionality works correctly.</p> <pre><code># Basic functional test example\n./kubernetes-scripts/setup-minikube.sh --with-distroless\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name\n</code></pre> <p>Verify that:</p> <ul> <li>Scan executes without errors</li> <li>Results are properly formatted</li> <li>Issues are correctly identified</li> </ul>"},{"location":"developer-guide/testing/#2-integration-testing","title":"2. Integration Testing","text":"<p>Tests that validate integration with various Kubernetes environments and CI/CD systems.</p>"},{"location":"developer-guide/testing/#cicd-integration-tests","title":"CI/CD Integration Tests","text":"<p>For each CI/CD system (GitHub Actions, GitLab CI):</p> <ul> <li>Verify automated scanning works in pipelines</li> <li>Validate pipeline success/failure based on scan results</li> <li>Check threshold validation works correctly</li> </ul>"},{"location":"developer-guide/testing/#environment-integration-tests","title":"Environment Integration Tests","text":"<p>For different Kubernetes distributions:</p> <ul> <li>Standard Kubernetes (various versions)</li> <li>AKS, EKS, GKE</li> <li>OpenShift</li> </ul>"},{"location":"developer-guide/testing/#3-security-testing","title":"3. Security Testing","text":"<p>Tests that validate the security of the scanning implementation.</p>"},{"location":"developer-guide/testing/#rbac-testing","title":"RBAC Testing","text":"<pre><code># Test with restricted permissions\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name --restricted-rbac\n</code></pre> <p>Verify:</p> <ul> <li>Scanner operates with minimal permissions</li> <li>Timeouts work correctly for tokens</li> <li>Resources are properly cleaned up after scan</li> </ul>"},{"location":"developer-guide/testing/#container-security-testing","title":"Container Security Testing","text":"<p>For each scanning approach:</p> <ul> <li>Validate that scanning doesn't introduce vulnerabilities</li> <li>Verify isolation between scanner and target containers</li> <li>Test scanner with various security contexts</li> </ul>"},{"location":"developer-guide/testing/#4-performance-testing","title":"4. Performance Testing","text":"<p>Tests that measure scanning performance.</p> <pre><code># Performance test with timing\ntime ./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name\n</code></pre> <p>Measurements:</p> <ul> <li>Scan initialization time</li> <li>Scan execution time</li> <li>Resource utilization (CPU, memory)</li> <li>Scaling tests (scanning multiple containers)</li> </ul>"},{"location":"developer-guide/testing/#5-compliance-testing","title":"5. Compliance Testing","text":"<p>Tests that validate compliance requirements are met.</p> <pre><code># Compliance validation with thresholds\n./kubernetes-scripts/scan-container.sh namespace-name pod-name container-name --threshold-file threshold.yml\n</code></pre> <p>Verify:</p> <ul> <li>Compliance checks match required standards</li> <li>Threshold validation works correctly</li> <li>Reports include necessary compliance data</li> </ul>"},{"location":"developer-guide/testing/#test-matrix-for-container-types","title":"Test Matrix for Container Types","text":"Container Type Standard Scanning Distroless Scanning Sidecar Scanning Base Images Required Required Required Java Applications Required Required Required Node.js Applications Required Required Required Python Applications Required Required Required Go Applications Required Required Required Multi-stage Builds Required Required Required Custom Distroless Required Required Required"},{"location":"developer-guide/testing/#automated-test-suite","title":"Automated Test Suite","text":"<p>We provide automated tests to validate core functionality:</p> <pre><code># Run automated test suite\n./scripts/run-tests.sh\n</code></pre> <p>The automated test suite includes:</p> <ul> <li>Unit tests for helper scripts</li> <li>Integration tests for scanning functionality</li> <li>Regression tests for known issues</li> </ul>"},{"location":"developer-guide/testing/#test-environments-setup","title":"Test Environments Setup","text":""},{"location":"developer-guide/testing/#local-minikube-setup-for-testing","title":"Local Minikube Setup for Testing","text":"<pre><code># Set up minikube for testing\n./kubernetes-scripts/setup-minikube.sh --with-distroless\n\n# Verify minikube setup\nkubectl get nodes\nkubectl get pods -A\n</code></pre>"},{"location":"developer-guide/testing/#cicd-environment-setup","title":"CI/CD Environment Setup","text":"<p>For GitHub Actions:</p> <ul> <li>Use the provided GitHub Actions workflows in <code>github-workflow-examples/</code></li> <li>Configure with appropriate secrets and environment variables</li> </ul> <p>For GitLab CI:</p> <ul> <li>Use the provided GitLab CI pipelines in <code>gitlab-pipeline-examples/</code></li> <li>Configure with appropriate variables and runners</li> </ul>"},{"location":"developer-guide/testing/#troubleshooting-tests","title":"Troubleshooting Tests","text":"<p>Common issues and resolutions:</p> <ol> <li>Scanner can't access containers:</li> <li>Verify RBAC permissions are correct</li> <li>Check service account configuration</li> <li> <p>Ensure token is valid and not expired</p> </li> <li> <p>Distroless scanning fails:</p> </li> <li>Verify Kubernetes version supports ephemeral containers</li> <li>Check debug container configuration</li> <li> <p>Confirm sidecar container has shared process namespace</p> </li> <li> <p>Threshold validation fails:</p> </li> <li>Check threshold file syntax</li> <li>Verify SAF CLI is correctly configured</li> <li>Review scan results for unexpected failures</li> </ol>"},{"location":"developer-guide/testing/#reference-test-cases","title":"Reference Test Cases","text":""},{"location":"developer-guide/testing/#standard-container-test-case","title":"Standard Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: standard-test-pod\n  labels:\n    app: test-app\nspec:\n  containers:\n  - name: standard-container\n    image: nginx:latest\n    ports:\n    - containerPort: 80\n</code></pre>"},{"location":"developer-guide/testing/#distroless-container-test-case","title":"Distroless Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: distroless-test-pod\n  labels:\n    app: test-app\nspec:\n  containers:\n  - name: distroless-container\n    image: gcr.io/distroless/java:11\n    command: [\"java\", \"-version\"]\n</code></pre>"},{"location":"developer-guide/testing/#sidecar-container-test-case","title":"Sidecar Container Test Case","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: sidecar-test-pod\n  labels:\n    app: test-app\nspec:\n  shareProcessNamespace: true\n  containers:\n  - name: target-container\n    image: gcr.io/distroless/java:11\n    command: [\"java\", \"-version\"]\n  - name: scanner-sidecar\n    image: cinc/auditor:latest\n    securityContext:\n      privileged: false\n    volumeMounts:\n    - name: results-volume\n      mountPath: /results\n  volumes:\n  - name: results-volume\n    emptyDir: {}\n</code></pre>"},{"location":"developer-guide/testing/#next-steps","title":"Next Steps","text":"<p>After completing testing, refer to:</p> <ul> <li>Deployment Scenarios for production deployment</li> <li>Threshold Configuration for compliance settings</li> <li>CI/CD Integration for pipeline setup</li> </ul>"},{"location":"developer-guide/testing/inventory/","title":"Testing Directory Inventory","text":"<p>This document provides a directory overview of the testing resources and documentation.</p>"},{"location":"developer-guide/testing/inventory/#directory-contents","title":"Directory Contents","text":"<p>The testing directory contains comprehensive documentation for testing the container scanning solution:</p> <ul> <li>README.md: Original documentation (being migrated to this structure)</li> <li>index.md: Main MkDocs documentation page for testing guidance</li> </ul>"},{"location":"developer-guide/testing/inventory/#testing-categories","title":"Testing Categories","text":"<p>This directory covers multiple testing approaches:</p> <ul> <li>Functional Testing: Validating core scanning functionality</li> <li>Integration Testing: Testing with various Kubernetes environments</li> <li>Security Testing: Verifying RBAC and security controls</li> <li>Performance Testing: Measuring scan times and resource utilization</li> <li>Compliance Testing: Validating compliance requirements</li> </ul>"},{"location":"developer-guide/testing/inventory/#testing-resources","title":"Testing Resources","text":"<p>The documentation includes:</p> <ul> <li>Test methodologies and best practices</li> <li>Environment setup instructions</li> <li>Test matrices for different container types</li> <li>Example test cases for all scanning approaches</li> <li>Troubleshooting guidance</li> </ul>"},{"location":"developer-guide/testing/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Deployment Guide</li> <li>Scanning Approaches</li> <li>CI/CD Integration</li> <li>Threshold Configuration</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section contains examples and demonstrations for using the Kube CINC Secure Scanner platform.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>Examples provide practical demonstrations of how to use various features of the platform. These examples range from code snippets to complete workflows, helping you understand how to implement and work with the platform in real-world scenarios.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>The examples directory includes:</p> <ul> <li>Code Display Demo - Demonstrations of how to display code in documentation</li> </ul>"},{"location":"examples/#using-examples","title":"Using Examples","text":"<p>These examples are designed to be starting points that you can adapt to your specific needs. Each example includes:</p> <ul> <li>Explanation of what the example demonstrates</li> <li>Complete code or configuration files</li> <li>Instructions for implementation</li> <li>Notes on customization</li> </ul>"},{"location":"examples/#related-resources","title":"Related Resources","text":"<p>For more examples of specific implementations, see also:</p> <ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>Helm Chart Examples</li> </ul>"},{"location":"examples/code-display-demo/","title":"Code Display Demo","text":"<p>This page demonstrates the enhanced code display capabilities in our documentation.</p>"},{"location":"examples/code-display-demo/#github-actions-integration-examples","title":"GitHub Actions Integration Examples","text":"<p>Below is an example of a GitHub Actions workflow for setting up and scanning containers:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#highlighting-important-sections","title":"Highlighting Important Sections","text":"<p>Let's highlight the key parts of the configuration:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#adding-annotations","title":"Adding Annotations","text":"<p>Here's the same code with annotations explaining key components:</p> <pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <ol> <li>This is the workflow name that appears in the GitHub Actions tab</li> <li>This workflow runs when code is pushed to the main branch</li> <li>This section defines the environment variables used throughout the workflow</li> <li>This job sets up the Kubernetes environment for scanning</li> <li>This step uses the official GitHub Action for Kubernetes</li> <li>The scanning job runs after the setup job completes successfully</li> </ol>"},{"location":"examples/code-display-demo/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>Let's compare with a GitLab CI configuration:</p> GitLab CI BasicGitLab CI with Services <pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"examples/code-display-demo/#sidecar-scanner-configuration","title":"Sidecar Scanner Configuration","text":"<p>This is a configuration for the sidecar container approach:</p> <pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"examples/code-display-demo/#key-configuration-elements","title":"Key Configuration Elements","text":"<p>Let's break down the important configuration elements:</p> <ol> <li>Service Account: The scanner requires appropriate RBAC permissions</li> <li>Container Configuration: The scanner is deployed alongside the application container</li> <li>Volume Mounts: Configuration is provided through ConfigMaps</li> <li>Environment Variables: Control the scanner's behavior</li> </ol>"},{"location":"examples/code-display-demo/#comparing-different-approaches","title":"Comparing Different Approaches","text":"<p>Here's a comparison of different scanning approaches:</p> Sidecar ApproachRBAC ScanningExisting Cluster <pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre> <pre><code>name: Existing Cluster Container Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_namespace:\n        description: 'Namespace where target pods are deployed'\n        required: true\n        default: 'default'\n      target_label:\n        description: 'Label selector for target pods (app=myapp)'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan-existing-cluster:\n    name: Scan Containers in Existing Cluster\n    runs-on: ubuntu-latest\n\n    env:\n      SCAN_NAMESPACE: ${{ github.event.inputs.target_namespace }}\n      LABEL_SELECTOR: ${{ github.event.inputs.target_label }}\n      CINC_PROFILE: ${{ github.event.inputs.cinc_profile }}\n      THRESHOLD_VALUE: ${{ github.event.inputs.threshold }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v3\n\n      - name: Configure Kubernetes cluster\n        run: |\n          # Set up kubeconfig using supplied cluster credentials\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          chmod 600 kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Verify connection and target namespace\n          kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n          # Find pods matching the label selector\n          TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n          if [ -z \"$TARGET_PODS\" ]; then\n            echo \"No pods found matching label: ${LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n            exit 1\n          fi\n\n          # Count and list found pods\n          POD_COUNT=$(echo $TARGET_PODS | wc -w)\n          echo \"Found ${POD_COUNT} pods to scan:\"\n          kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} --show-labels\n\n          # Save the first pod as our primary target\n          PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n          echo \"Primary target pod: ${PRIMARY_POD}\"\n          echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Get container name for the primary pod\n          PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n          echo \"Primary container: ${PRIMARY_CONTAINER}\"\n          echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; $GITHUB_ENV\n\n          # Check if pod has profile annotation\n          PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n          if [ -n \"$PROFILE_ANNOTATION\" ]; then\n            echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n            echo \"CINC_PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; $GITHUB_ENV\n          fi\n\n      - name: Create dynamic RBAC for scanning\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create a unique ID for this run\n          RUN_ID=\"gh-${{ github.run_id }}-${{ github.run_attempt }}\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account for scanning\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          EOF\n\n          # Create role with least privilege\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Create token for service account (15 minute duration)\n          TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create restricted kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCAN_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Set up CINC Auditor and SAF-CLI\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installations\n          cinc-auditor --version\n          saf --version\n\n      - name: Run security scan with restricted access\n        run: |\n          # Verify access with restricted token\n          echo \"Verifying restricted access:\"\n          KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR}\n\n          # Verify we can access the target pod\n          ACCESSIBLE_POD=$(KUBECONFIG=scanner-kubeconfig.yaml kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.name}' 2&gt;/dev/null || echo \"\")\n          if [ -z \"$ACCESSIBLE_POD\" ]; then\n            echo \"Error: Cannot access pod ${PRIMARY_POD} with restricted token\"\n            exit 1\n          fi\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${CINC_PROFILE} \\\n            -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${THRESHOLD_VALUE}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate HTML report\n          saf view -i scan-results.json --output scan-report.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n\n      - name: Cleanup RBAC resources\n        if: always()\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Delete role binding\n          kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete role\n          kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete service account\n          kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"examples/code-display-demo/#conclusion","title":"Conclusion","text":"<p>The code display capabilities demonstrated on this page help make our documentation more:</p> <ul> <li>Clear: Code is syntax highlighted and properly formatted</li> <li>Interactive: Copy buttons and line highlighting improve usability</li> <li>Annotated: Comments help explain complex configurations</li> <li>Consistent: Using the same example files throughout documentation</li> </ul>"},{"location":"examples/inventory/","title":"Examples Directory Contents","text":"<p>This page provides an inventory of all example files in this directory.</p>"},{"location":"examples/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of examples and demonstrations code-display-demo.md Guide for displaying code in documentation"},{"location":"examples/inventory/#related-links","title":"Related Links","text":"<ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>Contributing Guide</li> </ul>"},{"location":"github-workflow-examples/","title":"GitHub Workflow Examples","text":"<p>This directory contains example GitHub Action workflow files that demonstrate various container scanning approaches.</p>"},{"location":"github-workflow-examples/#available-examples","title":"Available Examples","text":"<ul> <li>CI/CD Pipeline: Complete CI/CD pipeline with build, deploy, and scan steps</li> <li>Dynamic RBAC Scanning: Dynamic RBAC implementation with least-privilege model</li> <li>Existing Cluster Scanning: Scanning pods in existing clusters with externally provided credentials</li> <li>Setup and Scan: Setup of minikube and scanning with distroless container support</li> <li>Sidecar Scanner: Sidecar container approach with shared process namespace</li> </ul>"},{"location":"github-workflow-examples/#cicd-pipeline-example","title":"CI/CD Pipeline Example","text":"<pre><code>name: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre>"},{"location":"github-workflow-examples/#dynamic-rbac-scanning-example","title":"Dynamic RBAC Scanning Example","text":"<pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre>"},{"location":"github-workflow-examples/#existing-cluster-scanning-example","title":"Existing Cluster Scanning Example","text":"<pre><code>name: Existing Cluster Container Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_namespace:\n        description: 'Namespace where target pods are deployed'\n        required: true\n        default: 'default'\n      target_label:\n        description: 'Label selector for target pods (app=myapp)'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan-existing-cluster:\n    name: Scan Containers in Existing Cluster\n    runs-on: ubuntu-latest\n\n    env:\n      SCAN_NAMESPACE: ${{ github.event.inputs.target_namespace }}\n      LABEL_SELECTOR: ${{ github.event.inputs.target_label }}\n      CINC_PROFILE: ${{ github.event.inputs.cinc_profile }}\n      THRESHOLD_VALUE: ${{ github.event.inputs.threshold }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v3\n\n      - name: Configure Kubernetes cluster\n        run: |\n          # Set up kubeconfig using supplied cluster credentials\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          chmod 600 kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Verify connection and target namespace\n          kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n          # Find pods matching the label selector\n          TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n          if [ -z \"$TARGET_PODS\" ]; then\n            echo \"No pods found matching label: ${LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n            exit 1\n          fi\n\n          # Count and list found pods\n          POD_COUNT=$(echo $TARGET_PODS | wc -w)\n          echo \"Found ${POD_COUNT} pods to scan:\"\n          kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR} --show-labels\n\n          # Save the first pod as our primary target\n          PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n          echo \"Primary target pod: ${PRIMARY_POD}\"\n          echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Get container name for the primary pod\n          PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n          echo \"Primary container: ${PRIMARY_CONTAINER}\"\n          echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; $GITHUB_ENV\n\n          # Check if pod has profile annotation\n          PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n          if [ -n \"$PROFILE_ANNOTATION\" ]; then\n            echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n            echo \"CINC_PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; $GITHUB_ENV\n          fi\n\n      - name: Create dynamic RBAC for scanning\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create a unique ID for this run\n          RUN_ID=\"gh-${{ github.run_id }}-${{ github.run_attempt }}\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account for scanning\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          EOF\n\n          # Create role with least privilege\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${PRIMARY_POD}\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n            labels:\n              app: security-scanner\n              run-id: \"${RUN_ID}\"\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-${RUN_ID}\n            namespace: ${SCAN_NAMESPACE}\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Create token for service account (15 minute duration)\n          TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create restricted kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${SCAN_NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Set up CINC Auditor and SAF-CLI\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installations\n          cinc-auditor --version\n          saf --version\n\n      - name: Run security scan with restricted access\n        run: |\n          # Verify access with restricted token\n          echo \"Verifying restricted access:\"\n          KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} -l ${LABEL_SELECTOR}\n\n          # Verify we can access the target pod\n          ACCESSIBLE_POD=$(KUBECONFIG=scanner-kubeconfig.yaml kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.name}' 2&gt;/dev/null || echo \"\")\n          if [ -z \"$ACCESSIBLE_POD\" ]; then\n            echo \"Error: Cannot access pod ${PRIMARY_POD} with restricted token\"\n            exit 1\n          fi\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${CINC_PROFILE} \\\n            -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${THRESHOLD_VALUE}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate HTML report\n          saf view -i scan-results.json --output scan-report.html\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n\n      - name: Cleanup RBAC resources\n        if: always()\n        run: |\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Delete role binding\n          kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete role\n          kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          # Delete service account\n          kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n          echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"github-workflow-examples/#setup-and-scan-example","title":"Setup and Scan Example","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"github-workflow-examples/#sidecar-scanner-example","title":"Sidecar Scanner Example","text":"<pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre>"},{"location":"github-workflow-examples/#usage","title":"Usage","text":"<p>These workflow examples are designed to be adapted to your specific environment. Each example includes detailed comments explaining the purpose of each step and how to customize it for your needs.</p> <p>For detailed information on which scanning approach to use in different scenarios, see:</p> <ul> <li>Approach Comparison</li> <li>Approach Decision Matrix</li> </ul> <p>For detailed GitHub Actions integration instructions, see the GitHub Actions Integration Guide.</p>"},{"location":"github-workflow-examples/inventory/","title":"GitHub Workflow Examples Directory Contents","text":"<p>This page provides an inventory of all GitHub Actions workflow example files in this directory.</p>"},{"location":"github-workflow-examples/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of GitHub Actions workflow examples ci-cd-pipeline.yml Complete CI/CD pipeline workflow example setup-and-scan.yml Basic setup and container scanning workflow dynamic-rbac-scanning.yml Workflow with dynamic RBAC generation for scanning existing-cluster-scanning.yml Workflow for scanning containers in existing clusters sidecar-scanner.yml Workflow for sidecar container scanning approach"},{"location":"github-workflow-examples/inventory/#related-links","title":"Related Links","text":"<ul> <li>GitHub Actions Integration Guide</li> <li>CI/CD Integration Overview</li> <li>Approach Mapping</li> </ul>"},{"location":"gitlab-components-examples/","title":"GitLab Components Example","text":"<p>This directory gives resources you can use to add jobs to a GitLab CI/CD pipeline for deploying a container to a kubernetes cluster, scan it with InSpec, and tear it back down. This method permits you to run container configuration management scans (i.e. check against security benchmarks) without having to modify the image (i.e. by punching a new port through the network layer).</p>"},{"location":"gitlab-components-examples/#basic-pattern","title":"Basic Pattern","text":"<p>We are going to create a namespace of the Kubernetes cluster specifically for pipeline activities and pass GitLab only enough permissions to run scans against a pod in that isolated namespace.</p>"},{"location":"gitlab-components-examples/#assumptions","title":"Assumptions","text":"<ul> <li>You have a Kubernetes cluster (or even just a minikube)</li> <li>You have permissions to add the resources defined below</li> <li>You have a GitLab repo </li> <li>You have permissions to add pipeline secrets to that repo (or to the overall GitLab instance)</li> <li>You have the kubectl, jq and base64 utilities available</li> <li>You have created a custom image with InSpec and Kubectl present, as well as the InSpec plugin for Kubernetes (more on this below)</li> </ul>"},{"location":"gitlab-components-examples/#resources-on-kubernetes","title":"Resources on Kubernetes","text":"<p>Deploy the <code>inspec-rbac.yaml</code> manifest to your cluster. This will create - a namespace (<code>pipeline</code>) - a service account (<code>pipeline</code>) - a role (<code>pipeline-role</code>) - a role binding to attach the role to the service account we just made (<code>pipeline-rolebinding</code>) - a service account secret token that we can use as a credential in the GitLab CI pipeline (<code>pipeline-secret</code>)</p> <p>If we look at <code>pipeline-role</code> resource specifically, we see that we are defining a very limited set of permissions to our pipeline service account. We can only interact with a single pod named <code>inspec-target</code>. Note the permission to <code>create</code> a <code>pods/exec</code> as well -- that gives us the permission to execute another command against a running pod (also only <code>inspec-target</code> pod). That <code>pods/exec</code> permission is why we can connect to the pod's containers with InSpec later. The same permission allows you to manually run <code>kubectl exec -it pod-name</code>, for example.</p> <pre><code>---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: pipeline-role\nnamespace: pipeline\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\", \"create\", \"delete\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"inspec-target\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"inspec-target\"]\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\"]\n</code></pre> <p>Apply the <code>inspec-rbac.yaml</code> manifest: <pre><code>kubectl apply -f inspec-rbac.yaml -n pipeline\n</code></pre></p> <p>Once you apply this manifest, you can read the service account token by looking at the <code>pipeline-secret</code>, which is stored encoded in base64:</p> <pre><code>kubectl get secret -n pipeline pipeline-secret -o json | jq -r  .data.token | base64 -d\n</code></pre> <p>The output will be the raw token. We want to take this value and create a kubeconfig file out of it. We've created a simple script for this.</p>"},{"location":"gitlab-components-examples/#generating-kubeconfig","title":"Generating Kubeconfig","text":"<p>Run <code>generate-kubeconfig.sh</code>:</p> <pre><code>./generate-kubeconfig.sh pipeline pipeline\n</code></pre> <p>(The script wants a namespace and a service account name as inputs, both of which happen to be \"pipeline\".)</p> <p>The script will fetch your secret token and a certificate and enter it into a kubeconfig file structure. It will save the file and also print it to stdout in base64-encoded form, for convenience, because our next step will be to make this file a GitLab secret.</p> <p>We now have a kubeconfig file that can serve as a credential that will allow the pipeline to authenticate to Kubernetes but only take a limited number of actions in a segregated namespace for safety.</p>"},{"location":"gitlab-components-examples/#gitlab","title":"GitLab","text":""},{"location":"gitlab-components-examples/#create-a-secret","title":"Create a Secret","text":"<p>Log into your GitLab instance and create a new secret (either at the repository scope if you just want to run this one pipeline or at the entire instance scope if multiple repos will need to do this). The secret should be named PIPELINE_KUBECONFIG and it should be populated with the base64-encoded value of the pipeline kubeconfig we just generated (GitLab can't make a variable out of the entire file; it needs to be encoded).</p>"},{"location":"gitlab-components-examples/#construct-a-pipeline","title":"Construct a pipeline","text":"<p>Now you can write a GitLab CI file to stand up your test container on Kubernetes, scan it, and tear it back down. We'll create an example pipeline to demonstrate this. A real container image pipeline will need many more jobs -- for one thing, we'll need a job to build the container image in the first place for testing -- but we're focusing on InSpec CCE (Common Configuration Enumeration, synonymous in this context with \"configuration management\") scanning for now. Our hello-world container image for testing will be off-the-shelf UBI9.</p>"},{"location":"gitlab-components-examples/#the-runner-image","title":"The runner image","text":"<p>All three of the jobs in this example use a sample image called <code>cinc-kubestation</code> as the job runner. We built a custom image using the Dockerfile for <code>cinc-workstation</code>, the community build of Chef's open source <code>chef-workstation</code> tool, and added in the kubectl utility and the plugin for InSpec that enables it to borrow kubectl for talking to the Kubernetes API. See the Dockerfile we used for this at https://github.com/mitre/chef-workstation/tree/cinc-kubestation. That image needs optimization and some cleanup but is functional.</p> <p>(Technically only the scan job actually needs this image; the other two just need an image with kubectl present, but for simplicity's sake we are using the same image for all three jobs.)</p>"},{"location":"gitlab-components-examples/#the-repos","title":"The  Repos","text":"<p>This example was created using two repos -- one serves as the pipeline component repository (\"pipeline templates\") and the other is the source code for the containerized application we want to build and test (\"app\"). We used a pipeline templates repo because it makes it easier to run multiple pipelines for separate applications, all of which reference the same job components stored elsewhere. See GitLab's CI/CD Components documentation for details.</p>"},{"location":"gitlab-components-examples/#pipeline-templates","title":"pipeline-templates","text":"<p>In your pipeline templates repo, create the following file tree:</p> <pre><code>tree\n.\n\u251c\u2500\u2500 templates\n    \u251c\u2500\u2500 delete_test_pod.yml\n    \u251c\u2500\u2500 deploy_test_pod.yml\n    \u2514\u2500\u2500 scan.yml\n</code></pre> <p>This is the required structure for GitLab CI to be able to parse your components. Copy the files for <code>delete_test_pod.yml</code>, <code>deploy_test_pod.yml</code>, and <code>scan.yml</code> to a <code>templates</code> folder in your pipeline templates repo. Save and commit the changes, then push them to GitLab.</p>"},{"location":"gitlab-components-examples/#app-repo","title":"app repo","text":"<p>In your app repo, create a <code>.gitlab-ci.yml</code> file that invokes the job components you saved in the template repo.</p> <pre><code>include: # pull in templates from a separate repository 'pipeline-templates' at branch 'dev'\n  - component: $CI_SERVER_FQDN/pipeline-templates/deploy_test_pod@dev\n  - component: $CI_SERVER_FQDN/pipeline-templates/scan@dev\n  - component: $CI_SERVER_FQDN/pipeline-templates/delete_test_pod@dev\n\nstages:\n  - deploy\n  - scan\n  - delete\n</code></pre> <p>You'll also want to create a file at the root of the app repo called <code>inputs.yml</code>, since the InSpec run is expecting you to pass it some parameters -- for now, we can populate the file to simply turn off the longer-running STIG scan requirements.</p> <p><code>inputs.yml</code>: <pre><code>disable_slow_controls: true\n</code></pre></p> <p>The <code>gitlab-ci.yml</code> file will now invoke your job templates when the pipeline is triggered. Again, real pipelines will have many more jobs and will be running scans against a container built from this repo's source code.</p>"},{"location":"gitlab-components-examples/#the-components","title":"The Components","text":"<p>Let's briefly look at what the job components do.</p>"},{"location":"gitlab-components-examples/#deploying-the-test-pod","title":"Deploying the test pod","text":"<p>The deploy component will read the GitLab secret for your pipeline-kubeconfig, decode it back into a file, and then use it to launch a pod containing solely the container we are trying to scan.</p> <pre><code>deploy_test_pod:\n  stage: $[[ inputs.stage ]]\n  image: $REGISTRY/cincproject/cinc-kubestation:0.0.1\n  tags:\n  - k8s\n  script: |\n\n    base64 -d &lt;&lt;&lt; $PIPELINE_KUBECONFIG &gt; pipeline-config.yml\n\n    echo \"&gt;&gt;&gt; Starting test container &lt;&lt;&lt; \"\n    cat &lt;&lt;EOF &gt; inspec-target.yml\n    apiVersion: v1\n    kind: Pod\n    metadata:\n    name: inspec-target\n    spec:\n      containers:\n      - name: inspec-target\n        image: $[[ inputs.image ]]\n        command: ['sh', '-c', 'sleep 10000']\n    EOF\n\n    kubectl --kubeconfig=pipeline-config.yml apply -f inspec-target.yml --validate=false\n</code></pre> <p>We create the manifest for a pod wrapping the image we want to create on-the-spot. We then use kubectl to apply the manifest using our pipeline-kubeconfig, which authenticates us as the <code>pipeline</code> service account, which has very limited permissions but those permissions do include the ability to create a pod in the <code>pipeline</code> namespace.</p> <p>We also save the manifest we created as an artifact, so that we can reference it later.</p> <pre><code>artifacts:\n  name: \"$CI_JOB_NAME\"\n  paths:\n  - inspec-target.yml\n</code></pre>"},{"location":"gitlab-components-examples/#scanning-the-test-pod","title":"Scanning the test pod","text":"<p>Next we scan the pod in the <code>scan</code> job. This one has some similarities to the deploy step. First, we assemble our kubeconfig and run our scan with it in the <code>script</code> tag:</p> <pre><code>base64 -d &lt;&lt;&lt; $PIPELINE_KUBECONFIG &gt; pipeline-kubeconfig.yml\n\nexport KUBECONFIG=pipeline-kubeconfig.yml\n\necho \"&gt;&gt;&gt; Vendoring InSpec profile $[[ inputs.profile ]] &lt;&lt;&lt; \"\ncinc-auditor vendor $[[ inputs.profile ]]\n\necho \"&gt;&gt;&gt; Running InSpec &lt;&lt;&lt; \"\n\ncinc-auditor exec $[[ inputs.profile ]] \\\n  -t k8s-container://pipeline/inspec-target/inspec-target \\\n  --input-file=$[[ inputs.inputs_file ]] \\\n  --enhanced-outcomes \\\n  --reporter cli json:$CI_PROJECT_DIR/reports/raw/inspec.json || true\n</code></pre> <p>Note that cinc-auditor uses the <code>-t</code>, or \"target\" flag, to indicate that we are attempting to scan a remote system. We use the <code>k8s-container</code> plugin to connect to a running container on the Kubernetes cluster. We must pass InSpec a string to tell it which container we want to scan -- a namespace, pod, and container. In this case, we are scanning in the <code>pipeline</code> namespace, and both our pod and our container are called <code>inspec-test</code>.</p> <p>When this job executes, we will prove that we can run InSpec against a remote pod. The next part of the job serves to confirm that we cannot do anything else. We should not, for example, be capable of listing pods in any namespace other than the <code>pipeline</code> one. We should also not be capable of listing any resources other than pods in our namespace.</p> <pre><code>echo \"&gt;&gt;&gt; Demonstrating that pipeline-kubeconfig is restricted in scope &lt;&lt;&lt;\"\nkubectl get pods -n kube-system || true\nkubectl get all -n pipeline || true\nkubectl get pods -n pipeline || true\n</code></pre>"},{"location":"gitlab-components-examples/#deleting-the-test-pod","title":"Deleting the test pod","text":"<p>The <code>delete_test_pod</code> job is simple. It runs <code>kubectl delete</code> on the exact same manifest we applied earlier, since we helpfully saved the manifest as an artifact to make it available to later jobs.</p> <pre><code>delete_test_pod:\n  stage: $[[ inputs.stage ]]\n  image: $REGISTRY/cincproject/cinc-kubestation:0.0.1\n  tags:\n  - k8s\n  script: |\n    base64 -d &lt;&lt;&lt; $PIPELINE_KUBECONFIG &gt; pipeline-config.yml\n    kubectl --kubeconfig=pipeline-config.yml delete -f inspec-target.yml\n</code></pre> <p>Simple enough.</p>"},{"location":"gitlab-components-examples/#running-the-pipeline","title":"Running the pipeline","text":"<p>Commit and push the changes to both the template and the app repos discussed above. Then use GitLab's UI to manually trigger the pipeline for the app repo. The output of the <code>scan</code> job will show the results of your scan (also saved as a JSON artifact) and also a number of error messages as our pipeline user attempts to call the API for information on resources it is not permitted to see (as well as some data about the pods that it is in fact allowed to access).</p>"},{"location":"gitlab-pipeline-examples/","title":"GitLab Pipeline Examples","text":"<p>This directory contains example GitLab CI pipeline configuration files that demonstrate various container scanning approaches.</p>"},{"location":"gitlab-pipeline-examples/#available-examples","title":"Available Examples","text":"<ul> <li>Standard Kubernetes API: Four-stage pipeline for container scanning using the Kubernetes API</li> <li>Dynamic RBAC Scanning: Label-based pod targeting with restricted RBAC permissions</li> <li>Existing Cluster Scanning: Configuration for scanning distroless containers</li> <li>GitLab CI with Services: Pipeline using GitLab services for a pre-configured scanning environment</li> <li>Sidecar Container: Pipeline implementing pod deployment with shared process namespace</li> <li>Sidecar with Services: Pipeline using GitLab services for sidecar scanner deployment</li> </ul>"},{"location":"gitlab-pipeline-examples/#standard-gitlab-ci-pipeline","title":"Standard GitLab CI Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#dynamic-rbac-scanning-pipeline","title":"Dynamic RBAC Scanning Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  KUBERNETES_NAMESPACE: \"dynamic-scan-$CI_PIPELINE_ID\"\n  TARGET_IMAGE: \"busybox:latest\"\n  SCAN_LABEL_KEY: \"scan-target\"\n  SCAN_LABEL_VALUE: \"true\"\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\" # Token duration in minutes\n\n# Allow overriding variables through pipeline triggers or UI\n.dynamic_variables: &amp;dynamic_variables\n  TARGET_IMAGE: ${TARGET_IMAGE}\n  SCAN_LABEL_KEY: ${SCAN_LABEL_KEY}\n  SCAN_LABEL_VALUE: ${SCAN_LABEL_VALUE}\n  CINC_PROFILE: ${CINC_PROFILE}\n  THRESHOLD_VALUE: ${THRESHOLD_VALUE}\n  ADDITIONAL_PROFILE_ANNOTATION: \"${ADDITIONAL_PROFILE_ANNOTATION}\"  # Optional annotation for specifying additional profiles\n\nsetup_test_environment:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create test namespace\n    - kubectl create namespace ${KUBERNETES_NAMESPACE}\n\n    # Create multiple test pods with different images and labels\n    - |\n      # Create 3 pods, but only mark the first one for scanning\n      for i in {1..3}; do\n        cat &lt;&lt;EOF | kubectl apply -f -\n        apiVersion: v1\n        kind: Pod\n        metadata:\n          name: pod-${i}\n          namespace: ${KUBERNETES_NAMESPACE}\n          labels:\n            app: test-pod-${i}\n            ${SCAN_LABEL_KEY}: \"$([ $i -eq 1 ] &amp;&amp; echo \"${SCAN_LABEL_VALUE}\" || echo \"false\")\"\n          annotations:\n            scan-profile: \"${CINC_PROFILE}\"\n            $([ -n \"${ADDITIONAL_PROFILE_ANNOTATION}\" ] &amp;&amp; echo \"${ADDITIONAL_PROFILE_ANNOTATION}\" || echo \"\")\n        spec:\n          containers:\n          - name: container\n            image: ${TARGET_IMAGE}\n            command: [\"sleep\", \"infinity\"]\n        EOF\n      done\n\n    # Wait for pods to be ready\n    - kubectl wait --for=condition=ready pod -l app=test-pod-1 -n ${KUBERNETES_NAMESPACE} --timeout=120s\n\n    # Get the name of the pod with our scan label\n    - |\n      TARGET_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$TARGET_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n        exit 1\n      fi\n      echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; deploy.env\n\n    # Save scan profile from annotations if available\n    - |\n      SCAN_PROFILE=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}')\n      if [ -n \"$SCAN_PROFILE\" ]; then\n        echo \"Found scan profile annotation: ${SCAN_PROFILE}\"\n        echo \"SCAN_PROFILE=${SCAN_PROFILE}\" &gt;&gt; deploy.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"SCAN_PROFILE=${CINC_PROFILE}\" &gt;&gt; deploy.env\n      fi\n\n    # Show all pods in the namespace\n    - kubectl get pods -n ${KUBERNETES_NAMESPACE} --show-labels\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_dynamic_rbac:\n  stage: scan\n  needs: [setup_test_environment]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      EOF\n\n    # Create role with label-based access\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role\n        namespace: ${KUBERNETES_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding\n        namespace: ${KUBERNETES_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token\n    - |\n      TOKEN=$(kubectl create token scanner-sa -n ${KUBERNETES_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_security_scan:\n  stage: scan\n  needs: [setup_test_environment, create_dynamic_rbac]\n  script:\n    # Create kubeconfig with restricted token\n    - |\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scan-kubeconfig.yaml\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n    # Install train-k8s-container plugin\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - npm install -g @mitre/saf\n\n    # Verify the tools\n    - cinc-auditor --version\n    - saf --version\n\n    # Find the target pod by label using the restricted token\n    - |\n      echo \"Looking for pods with label: ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n      SCANNED_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$SCANNED_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} using restricted access\"\n        exit 1\n      fi\n      echo \"Found target pod: ${SCANNED_POD}\"\n\n      # Verify it matches what we expected\n      if [ \"$SCANNED_POD\" != \"$TARGET_POD\" ]; then\n        echo \"Warning: Scanned pod ($SCANNED_POD) doesn't match expected target pod ($TARGET_POD)\"\n      fi\n\n    # Get container name\n    - CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n\n    # Run CINC Auditor scan\n    - |\n      echo \"Running CINC Auditor scan on ${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME}\"\n      KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${SCAN_PROFILE} \\\n        -t k8s-container://${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate comprehensive HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\nverify_rbac_restrictions:\n  stage: verify\n  needs: [setup_test_environment, create_dynamic_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a second kubeconfig with restricted token\n    - |\n      cat &gt; verify-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 verify-kubeconfig.yaml\n\n    # Get a non-target pod name\n    - OTHER_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${KUBERNETES_NAMESPACE} --resource-name=${TARGET_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n      echo \"Cannot create pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i delete pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n    # Create a security report for MR\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Results\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Details\n\n      - Target Pod: \\`${TARGET_POD}\\`\n      - Container: \\`${CONTAINER_NAME}\\`\n      - Image: \\`${TARGET_IMAGE}\\`\n      - Profile: \\`${SCAN_PROFILE}\\`\n\n      For full results, see the scan artifacts.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\ncleanup:\n  stage: cleanup\n  needs: [setup_test_environment]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete namespace ${KUBERNETES_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#existing-cluster-scanning-pipeline","title":"Existing Cluster Scanning Pipeline","text":"<pre><code>stages:\n  - prepare\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  # Default values - override in UI or with pipeline parameters\n  SCAN_NAMESPACE: \"default\"  # Existing namespace where pods are deployed\n  TARGET_LABEL_SELECTOR: \"scan-target=true\"  # Label to identify target pods\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\"  # Token duration in minutes\n\n# Define workflow\nworkflow:\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"web\"  # Manual trigger from UI\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"  # Scheduled pipeline\n    - if: $CI_PIPELINE_SOURCE == \"trigger\"  # API trigger with token\n\n# Find pods to scan in existing cluster\nprepare_scan:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  script:\n    # Configure kubectl with cluster credentials\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a unique run ID for this pipeline\n    - RUN_ID=\"gl-$CI_PIPELINE_ID-$CI_JOB_ID\"\n    - echo \"RUN_ID=${RUN_ID}\" &gt;&gt; prepare.env\n\n    # Verify the namespace exists\n    - kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n    # Find target pods with specified label\n    - |\n      TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n      if [ -z \"$TARGET_PODS\" ]; then\n        echo \"No pods found matching label: ${TARGET_LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n        exit 1\n      fi\n\n      # Count and list found pods\n      POD_COUNT=$(echo $TARGET_PODS | wc -w)\n      echo \"Found ${POD_COUNT} pods to scan:\"\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} --show-labels\n\n      # Get the first pod as primary target\n      PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n      echo \"Primary target pod: ${PRIMARY_POD}\"\n      echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; prepare.env\n\n      # Get container name for the primary pod\n      PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n      echo \"Primary container: ${PRIMARY_CONTAINER}\"\n      echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; prepare.env\n\n      # Check for custom profile annotation\n      PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$PROFILE_ANNOTATION\" ]; then\n        echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n        echo \"PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; prepare.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"PROFILE=${CINC_PROFILE}\" &gt;&gt; prepare.env\n      fi\n  artifacts:\n    reports:\n      dotenv: prepare.env\n\n# Create temporary RBAC for scanning\ncreate_rbac:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account for scanning\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      EOF\n\n    # Create role with least privilege\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${RUN_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token for service account\n    - |\n      TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; rbac.env\n  artifacts:\n    reports:\n      dotenv: rbac.env\n\n# Run the security scan with restricted access\nrun_security_scan:\n  stage: scan\n  image: registry.gitlab.com/gitlab-org/security-products/analyzers/container-scanning:5\n  needs: [prepare_scan, create_rbac]\n  script:\n    # Create restricted kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Install CINC Auditor and plugins\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - apt-get update &amp;&amp; apt-get install -y npm\n    - npm install -g @mitre/saf\n\n    # Test restricted access\n    - |\n      echo \"Testing restricted access:\"\n      export KUBECONFIG=scanner-kubeconfig.yaml\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR}\n\n      echo \"Verifying target pod access:\"\n      kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o name || { echo \"Cannot access target pod with restricted token\"; exit 1; }\n\n    # Run the scan\n    - |\n      echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n      KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n        -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n      - threshold.yml\n    reports:\n      dotenv: scan.env\n\n# Verify RBAC permissions are properly restricted\nverify_rbac:\n  stage: verify\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan, create_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create restricted kubeconfig for testing\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${PRIMARY_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n\n      echo \"Cannot create pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i delete pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n      # Find non-target pod for testing\n      OTHER_POD=$(kubectl get pods -n ${SCAN_NAMESPACE} -l app!=scan-target -o jsonpath='{.items[0].metadata.name}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$OTHER_POD\" ] &amp;&amp; [ \"$OTHER_POD\" != \"$PRIMARY_POD\" ]; then\n        echo \"Cannot exec into non-target pod:\"\n        KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${OTHER_POD} &amp;&amp; \n          echo \"\u274c Security issue: Can exec into non-target pod\" || \n          echo \"\u2705 Cannot exec into non-target pod (expected)\"\n      fi\n\n    # Create security report\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Details\n\n      - **Pipeline:** ${CI_PIPELINE_ID}\n      - **Target Namespace:** ${SCAN_NAMESPACE}\n      - **Target Pod:** ${PRIMARY_POD}\n      - **Target Container:** ${PRIMARY_CONTAINER}\n      - **CINC Profile:** ${PROFILE}\n      - **Compliance Threshold:** ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot exec into non-target pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Results\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      See scan artifacts for detailed compliance results.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\n# Always clean up RBAC resources\ncleanup_rbac:\n  stage: cleanup\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Delete role binding\n    - kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete role\n    - kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete service account\n    - kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    - echo \"RBAC resources cleaned up\"\n</code></pre>"},{"location":"gitlab-pipeline-examples/#gitlab-ci-with-services-pipeline","title":"GitLab CI with Services Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#sidecar-container-pipeline","title":"Sidecar Container Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for CINC profile\n      cat &gt; container-baseline.rb &lt;&lt; EOF\n      # Example CINC Auditor profile for container scanning\n\n      title \"Container Baseline\"\n\n      control \"container-1.1\" do\n        impact 0.7\n        title \"Container files should have proper permissions\"\n        desc \"Critical files in the container should have proper permissions.\"\n\n        describe file('/etc/passwd') do\n          it { should exist }\n          its('mode') { should cmp '0644' }\n        end\n      end\n\n      control \"container-1.2\" do\n        impact 0.5\n        title \"Container should not have unnecessary packages\"\n        desc \"Container should be minimal and not contain unnecessary packages.\"\n\n        describe directory('/var/lib/apt') do\n          it { should_not exist }\n        end\n      end\n      EOF\n\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=container-baseline.rb \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: ruby:3.0-slim\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Install dependencies\n            apt-get update\n            apt-get install -y curl gnupg procps nodejs npm\n\n            # Install CINC Auditor\n            curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n            # Install SAF CLI\n            npm install -g @mitre/saf\n\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=\\$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print \\$2}')\n\n            if [ -z \"\\$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID \\$TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/\\$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=\\$?\n\n            echo \"Scan completed with exit code: \\$SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=\\$?\n                echo \"Threshold validation result: \\$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json ./scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md ./scan-summary.md -c scanner\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#sidecar-with-services-pipeline","title":"Sidecar with Services Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\n# Define a custom service image for CINC Auditor sidecar deployment\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Copy profile from within the service container\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n      docker exec cinc-scanner ls -la /tmp/profile\n\n      # Create ConfigMap for CINC profile from the service container\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=$(docker exec cinc-scanner find /tmp/profile -name \"*.rb\" | head -1) \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print $2}')\n\n            if [ -z \"$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID $TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=$?\n\n            echo \"Scan completed with exit code: $SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=$?\n                echo \"$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results using the service container\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json /tmp/scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md /tmp/scan-summary.md -c scanner\n\n      # Copy results to service container for processing\n      docker cp /tmp/scan-results.json cinc-scanner:/tmp/\n      docker cp /tmp/scan-summary.md cinc-scanner:/tmp/\n\n      # Process results in the service container\n      docker exec cinc-scanner bash -c \"\n        # Generate normalized report\n        saf normalize -i /tmp/scan-results.json -o /tmp/normalized-results.json\n\n        # Additional report processing\n        saf view -i /tmp/scan-results.json --output /tmp/scan-report.html\n      \"\n\n      # Copy processed results back\n      docker cp cinc-scanner:/tmp/normalized-results.json ./normalized-results.json\n      docker cp cinc-scanner:/tmp/scan-report.html ./scan-report.html\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - normalized-results.json\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\n# This example shows how to utilize the service container \n# to generate specialized reports from the scan results\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Use the service container to generate comprehensive reports\n      docker cp scan-results.json cinc-scanner:/tmp/\n\n      # Generate multiple report formats in the service container\n      docker exec cinc-scanner bash -c \"\n        cd /tmp\n\n        # Generate HTML report\n        saf view -i scan-results.json --output enhanced-report.html\n\n        # Generate CSV report\n        saf generate -i scan-results.json -o csv &gt; results.csv\n\n        # Generate Excel report\n        saf generate -i scan-results.json -o xlsx &gt; results.xlsx\n\n        # Generate JUnit report for CI integration\n        saf generate -i scan-results.json -o junit &gt; junit.xml\n      \"\n\n      # Copy all reports back\n      docker cp cinc-scanner:/tmp/enhanced-report.html ./enhanced-report.html\n      docker cp cinc-scanner:/tmp/results.csv ./results.csv\n      docker cp cinc-scanner:/tmp/results.xlsx ./results.xlsx\n      docker cp cinc-scanner:/tmp/junit.xml ./junit.xml\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([ \"${THRESHOLD_PASSED}\" -eq 0 ] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the enhanced report artifacts.\n\n      * HTML Report: enhanced-report.html\n      * CSV Report: results.csv\n      * Excel Report: results.xlsx\n      * JUnit Report: junit.xml\n      EOF\n  artifacts:\n    paths:\n      - enhanced-report.html\n      - results.csv\n      - results.xlsx\n      - junit.xml\n      - scan-report.md\n    reports:\n      junit: junit.xml\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"gitlab-pipeline-examples/#usage","title":"Usage","text":"<p>These pipeline examples are designed to be adapted to your specific environment. Each example includes detailed comments explaining the purpose of each step and how to customize it for your needs.</p> <p>Strategic Priority</p> <p>We strongly recommend the Kubernetes API Approach (standard GitLab CI example) for enterprise-grade container scanning. Our highest priority is enhancing the train-k8s-container plugin to support distroless containers. The other examples provide interim solutions until this enhancement is complete.</p> <p>For detailed information on which scanning approach to use in different scenarios, see:</p> <ul> <li>Approach Comparison</li> <li>Approach Decision Matrix</li> </ul> <p>For detailed GitLab integration instructions, see the GitLab Integration Guide.</p>"},{"location":"gitlab-pipeline-examples/inventory/","title":"GitLab Pipeline Examples Directory Contents","text":"<p>This page provides an inventory of all GitLab CI pipeline example files in this directory.</p>"},{"location":"gitlab-pipeline-examples/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of GitLab CI pipeline examples gitlab-ci.yml Basic GitLab CI pipeline example gitlab-ci-with-services.yml Example using GitLab CI services for container scanning gitlab-ci-sidecar.yml Example using sidecar container approach gitlab-ci-sidecar-with-services.yml Combined sidecar and services approach dynamic-rbac-scanning.yml Pipeline with dynamic RBAC generation for scanning existing-cluster-scanning.yml Pipeline for scanning containers in existing clusters"},{"location":"gitlab-pipeline-examples/inventory/#related-links","title":"Related Links","text":"<ul> <li>GitLab CI Integration Guide</li> <li>GitLab Services Integration</li> <li>GitLab Services Analysis</li> <li>CI/CD Integration Overview</li> </ul>"},{"location":"gitlab-services-examples/","title":"GitLab Services Examples","text":"<p>This section provides examples for using the GitLab Services integration with Kube CINC Secure Scanner.</p>"},{"location":"gitlab-services-examples/#overview","title":"Overview","text":"<p>GitLab Services provide a way to run additional containers alongside your CI/CD jobs. This can be particularly useful for implementing container scanning without modifying your existing pipelines.</p>"},{"location":"gitlab-services-examples/#examples","title":"Examples","text":"<p>This directory will contain examples for GitLab Services configurations for various scanning scenarios.</p> <p>Note</p> <p>This section is currently under development. More examples will be added in future releases.</p>"},{"location":"gitlab-services-examples/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>When implementing GitLab Services for container scanning:</p> <ol> <li>Use the appropriate service definition based on your scanning approach</li> <li>Configure the necessary environment variables</li> <li>Set up volume mounts for sharing data between the service and your job</li> <li>Implement proper error handling</li> </ol>"},{"location":"gitlab-services-examples/#related-resources","title":"Related Resources","text":"<ul> <li>GitLab Services Integration Guide</li> <li>GitLab Services Analysis</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"gitlab-services-examples/inventory/","title":"GitLab Services Examples Directory Contents","text":"<p>This page provides an inventory of all GitLab Services example files in this directory.</p>"},{"location":"gitlab-services-examples/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of GitLab Services examples <p>Note</p> <p>This directory is currently under development. More example files will be added in future releases.</p>"},{"location":"gitlab-services-examples/inventory/#related-links","title":"Related Links","text":"<ul> <li>GitLab Services Integration Guide</li> <li>GitLab Services Analysis</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"helm-charts/","title":"Helm Charts Documentation","text":"<p>Documentation Reorganization</p> <p>This section has been reorganized into a more structured format. Please see the links below for specific topics.</p> <p>Directory Inventory</p> <p>See the Helm Charts Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section contains documentation for the Helm charts used to deploy the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"helm-charts/#documentation-structure","title":"Documentation Structure","text":"<p>The Helm charts documentation is now organized into the following sections:</p>"},{"location":"helm-charts/#overview","title":"Overview","text":"<ul> <li>Architecture</li> </ul>"},{"location":"helm-charts/#scanner-types","title":"Scanner Types","text":"<ul> <li>Common Scanner</li> <li>Kubernetes API Scanner</li> <li>Debug Container Scanner</li> <li>Sidecar Container Scanner</li> </ul>"},{"location":"helm-charts/#infrastructure","title":"Infrastructure","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Namespaces</li> </ul>"},{"location":"helm-charts/#usage-customization","title":"Usage &amp; Customization","text":"<ul> <li>Customization Guide</li> <li>Configuration Reference</li> <li>Values Files</li> </ul>"},{"location":"helm-charts/#security","title":"Security","text":"<ul> <li>Best Practices</li> <li>RBAC Hardening</li> <li>Risk Assessment</li> </ul>"},{"location":"helm-charts/#operations","title":"Operations","text":"<ul> <li>Troubleshooting</li> <li>Performance Optimization</li> <li>Maintenance Procedures</li> </ul>"},{"location":"helm-charts/#getting-started","title":"Getting Started","text":"<p>To get started with our Helm charts, visit the Overview section for an introduction to the charts and their architecture. Then explore the Scanner Types section to learn about the different scanning approaches available.</p>"},{"location":"helm-charts/inventory/","title":"Helm Charts Directory Inventory","text":"<p>This document provides a directory overview of all Helm chart resources in the project.</p>"},{"location":"helm-charts/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts directory contains all of the Helm charts documentation for the Kubernetes container scanning solution. The documentation is organized into the following subdirectories:</p>"},{"location":"helm-charts/inventory/#overview","title":"Overview","text":"<ul> <li>overview/index.md: Introduction to the Helm charts</li> <li>overview/inventory.md: Directory listing</li> <li>overview/architecture.md: Detailed architecture documentation</li> </ul>"},{"location":"helm-charts/inventory/#scanner-types","title":"Scanner Types","text":"<ul> <li>scanner-types/index.md: Introduction to scanner types</li> <li>scanner-types/inventory.md: Directory listing</li> <li>scanner-types/common-scanner.md: Common scanner documentation</li> <li>scanner-types/standard-scanner.md: Kubernetes API scanner documentation</li> <li>scanner-types/distroless-scanner.md: Debug container scanner documentation</li> <li>scanner-types/sidecar-scanner.md: Sidecar container scanner documentation</li> </ul>"},{"location":"helm-charts/inventory/#infrastructure","title":"Infrastructure","text":"<ul> <li>infrastructure/index.md: Infrastructure overview</li> <li>infrastructure/inventory.md: Directory listing</li> <li>infrastructure/rbac.md: RBAC configuration documentation</li> <li>infrastructure/service-accounts.md: Service account documentation</li> <li>infrastructure/namespaces.md: Namespace management documentation</li> </ul>"},{"location":"helm-charts/inventory/#usage-customization","title":"Usage &amp; Customization","text":"<ul> <li>usage/index.md: Usage and customization overview</li> <li>usage/inventory.md: Directory listing</li> <li>usage/customization.md: Customization guide</li> <li>usage/configuration.md: Configuration reference</li> <li>usage/values.md: Values file documentation</li> </ul>"},{"location":"helm-charts/inventory/#security","title":"Security","text":"<ul> <li>security/index.md: Security overview</li> <li>security/inventory.md: Directory listing</li> <li>security/best-practices.md: Security best practices</li> <li>security/rbac-hardening.md: RBAC hardening guide</li> <li>security/risk-assessment.md: Security risk assessment</li> </ul>"},{"location":"helm-charts/inventory/#operations","title":"Operations","text":"<ul> <li>operations/index.md: Operations overview</li> <li>operations/inventory.md: Directory listing</li> <li>operations/troubleshooting.md: Troubleshooting guide</li> <li>operations/performance.md: Performance optimization guide</li> <li>operations/maintenance.md: Maintenance procedures</li> </ul>"},{"location":"helm-charts/inventory/#original-files-legacy","title":"Original Files (Legacy)","text":"<ul> <li>index.md: Main documentation page (with redirects to new structure)</li> <li>inventory.md: This directory listing</li> </ul>"},{"location":"helm-charts/inventory/#chart-relationships","title":"Chart Relationships","text":"<p>The Helm charts follow a hierarchical relationship:</p> <ol> <li>Scanner Infrastructure (base layer)</li> <li>Common Scanner (depends on Scanner Infrastructure)</li> <li>Implementation Charts (depend on Common Scanner):</li> <li>Standard Scanner</li> <li>Distroless Scanner</li> <li>Sidecar Scanner</li> </ol>"},{"location":"helm-charts/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Main Project Documentation</li> <li>GitHub Helm Chart Source</li> <li>Scanning Approaches</li> </ul>"},{"location":"helm-charts/infrastructure/","title":"Helm Charts Infrastructure","text":"<p>Directory Inventory</p> <p>See the Infrastructure Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/infrastructure/#overview","title":"Overview","text":"<p>The infrastructure components provide the core foundation for all container scanning operations in Kubernetes. The <code>scanner-infrastructure</code> chart creates the necessary Kubernetes resources to enable secure, least-privilege scanning access.</p>"},{"location":"helm-charts/infrastructure/#key-components","title":"Key Components","text":""},{"location":"helm-charts/infrastructure/#namespace-management","title":"Namespace Management","text":"<p>The infrastructure chart manages namespaces for scanning operations:</p> <ul> <li>Creates dedicated namespaces for scanning</li> <li>Isolates scanning operations from other workloads</li> <li>Enables namespace-specific security controls</li> <li>Supports multi-tenant deployments</li> </ul>"},{"location":"helm-charts/infrastructure/#service-accounts-and-authentication","title":"Service Accounts and Authentication","text":"<p>The infrastructure chart creates service accounts for authentication:</p> <ul> <li>Dedicated service account per scanning context</li> <li>Time-limited token generation</li> <li>Support for integration with external identity providers</li> <li>Proper token cleanup and rotation</li> </ul>"},{"location":"helm-charts/infrastructure/#rbac-configuration","title":"RBAC Configuration","text":"<p>The infrastructure chart implements RBAC controls for authorization:</p> <ul> <li>Least-privilege access model</li> <li>Support for resource name restrictions</li> <li>Label selector-based access control</li> <li>Custom role definitions for different scanning approaches</li> </ul>"},{"location":"helm-charts/infrastructure/#security-first-design","title":"Security-First Design","text":"<p>The infrastructure components are designed with security as a primary consideration:</p> <ul> <li>Time-limited tokens ensure credentials can't be misused long-term</li> <li>Least-privilege access model restricts scanning to specific pods</li> <li>Namespace isolation prevents cross-namespace access</li> <li>No privileged access required for container scanning</li> </ul>"},{"location":"helm-charts/infrastructure/#usage-with-scanner-types","title":"Usage with Scanner Types","text":"<p>The infrastructure components serve as the foundation for all scanner types:</p> <ul> <li>Common Scanner: Builds on infrastructure with shared utilities</li> <li>Kubernetes API Scanner: Uses infrastructure for direct API access</li> <li>Debug Container Scanner: Extends infrastructure for ephemeral containers</li> <li>Sidecar Scanner: Relies on infrastructure for secure deployment</li> </ul>"},{"location":"helm-charts/infrastructure/#getting-started","title":"Getting Started","text":"<p>To get started with the infrastructure components:</p> <ol> <li>Review the detailed documentation for each component</li> <li>Consider your security requirements and scanning scope</li> <li>Plan your namespace strategy for scanning operations</li> <li>Configure RBAC controls based on your security model</li> <li>Set up service accounts with appropriate permissions</li> </ol>"},{"location":"helm-charts/infrastructure/inventory/","title":"Infrastructure Directory Inventory","text":"<p>This document provides a directory overview of all infrastructure-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/infrastructure/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/infrastructure directory contains documentation for the infrastructure components:</p> <ul> <li>index.md: Overview of the infrastructure components</li> <li>inventory.md: This directory listing</li> <li>rbac.md: Documentation for RBAC configuration</li> <li>service-accounts.md: Documentation for service account setup</li> <li>namespaces.md: Documentation for namespace management</li> </ul>"},{"location":"helm-charts/infrastructure/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The infrastructure section provides:</p> <ul> <li>Introduction to the core infrastructure components</li> <li>Details on RBAC implementation and security model</li> <li>Service account configuration and token management</li> <li>Namespace organization and isolation strategies</li> <li>Security considerations for infrastructure components</li> </ul>"},{"location":"helm-charts/infrastructure/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Overview</li> <li>Scanner Types Documentation</li> <li>Security Considerations</li> <li>Operations &amp; Troubleshooting</li> </ul>"},{"location":"helm-charts/infrastructure/namespaces/","title":"Infrastructure Namespace Management","text":"<p>Directory Context</p> <p>This document is part of the Infrastructure Directory. See the Infrastructure Directory Inventory for related resources.</p>"},{"location":"helm-charts/infrastructure/namespaces/#overview","title":"Overview","text":"<p>The <code>scanner-infrastructure</code> chart manages Kubernetes namespaces for container scanning operations. Proper namespace management is important for security isolation, resource management, and multi-team deployments.</p>"},{"location":"helm-charts/infrastructure/namespaces/#namespace-implementation","title":"Namespace Implementation","text":""},{"location":"helm-charts/infrastructure/namespaces/#namespace-creation","title":"Namespace Creation","text":"<p>The chart can optionally create a dedicated namespace:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: scanning-namespace\n  labels:\n    app.kubernetes.io/name: scanner-infrastructure\n    app.kubernetes.io/instance: scanner\n</code></pre> <p>This namespace:</p> <ul> <li>Isolates scanning operations from other workloads</li> <li>Groups scanning resources together</li> <li>Enables namespace-level security controls</li> </ul>"},{"location":"helm-charts/infrastructure/namespaces/#using-existing-namespaces","title":"Using Existing Namespaces","text":"<p>For existing namespaces, disable namespace creation:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set createNamespace=false \\\n  --set targetNamespace=existing-namespace\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#namespace-organizational-patterns","title":"Namespace Organizational Patterns","text":""},{"location":"helm-charts/infrastructure/namespaces/#dedicated-scanning-namespace","title":"Dedicated Scanning Namespace","text":"<p>For centralized scanning operations:</p> <pre><code># Create a dedicated scanning namespace\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=security-scanning\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#environment-specific-namespaces","title":"Environment-Specific Namespaces","text":"<p>For environment-specific scanning:</p> <pre><code># Development environment\nhelm install dev-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=dev-scanning\n\n# Production environment\nhelm install prod-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=prod-scanning\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#team-specific-namespaces","title":"Team-Specific Namespaces","text":"<p>For multi-team deployments:</p> <pre><code># Team A scanner infrastructure\nhelm install team-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-a-scanning\n\n# Team B scanner infrastructure\nhelm install team-b-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-b-scanning\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#namespace-security-controls","title":"Namespace Security Controls","text":""},{"location":"helm-charts/infrastructure/namespaces/#network-policies","title":"Network Policies","text":"<p>Add network policies to restrict scanner communication:</p> <pre><code># network-policy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-policy\n  namespace: scanning-namespace\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: scanning-namespace\n    - podSelector:\n        matchLabels:\n          scan-target: \"true\"\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - protocol: TCP\n      port: 443  # Kubernetes API\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#resource-quotas","title":"Resource Quotas","text":"<p>Apply resource quotas to scanning namespaces:</p> <pre><code># resource-quota.yaml\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: scanner-quota\n  namespace: scanning-namespace\nspec:\n  hard:\n    pods: \"10\"\n    requests.cpu: \"2\"\n    requests.memory: 4Gi\n    limits.cpu: \"4\"\n    limits.memory: 8Gi\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#cross-namespace-scanning","title":"Cross-Namespace Scanning","text":"<p>For scanning pods in other namespaces:</p> <pre><code># Install infrastructure in scanning namespace\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.clusterWide=true  # Creates ClusterRole instead of Role\n</code></pre>"},{"location":"helm-charts/infrastructure/namespaces/#configuration-reference","title":"Configuration Reference","text":"Parameter Description Default Required <code>createNamespace</code> Create the namespace <code>true</code> No <code>targetNamespace</code> Target namespace for installation <code>inspec-test</code> Yes <code>namespace.labels</code> Labels for the namespace <code>{}</code> No <code>namespace.annotations</code> Annotations for the namespace <code>{}</code> No <code>rbac.clusterWide</code> Enable cluster-wide permissions <code>false</code> No"},{"location":"helm-charts/infrastructure/namespaces/#best-practices","title":"Best Practices","text":"<ol> <li>Use Dedicated Namespaces: Isolate scanning operations from other workloads</li> <li>Apply Namespace Labels: Label namespaces for identifying scanning resources</li> <li>Implement Network Policies: Restrict scanner communication to necessary endpoints</li> <li>Define Resource Quotas: Limit resource consumption by scanning operations</li> <li>Consider Namespace Hierarchy: Organize namespaces by environment, team, or application</li> <li>Avoid Cluster-Wide Permissions: Use namespace-specific permissions when possible</li> </ol>"},{"location":"helm-charts/infrastructure/namespaces/#related-documentation","title":"Related Documentation","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Security Considerations</li> <li>Scanner Types Documentation</li> </ul>"},{"location":"helm-charts/infrastructure/rbac/","title":"Infrastructure RBAC Configuration","text":"<p>Directory Context</p> <p>This document is part of the Infrastructure Directory. See the Infrastructure Directory Inventory for related resources.</p>"},{"location":"helm-charts/infrastructure/rbac/#overview","title":"Overview","text":"<p>The <code>scanner-infrastructure</code> chart implements a robust Role-Based Access Control (RBAC) model for securing container scanning operations. This document details the RBAC configuration options and best practices for different deployment scenarios.</p>"},{"location":"helm-charts/infrastructure/rbac/#rbac-implementation","title":"RBAC Implementation","text":""},{"location":"helm-charts/infrastructure/rbac/#core-permissions","title":"Core Permissions","text":"<p>The scanner requires these core permissions:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\", \"create\"]\n</code></pre> <p>These permissions enable:</p> <ul> <li>Listing pods in the target namespace</li> <li>Executing commands in pods (for Kubernetes API scanning)</li> <li>Getting pod details (for all scanning approaches)</li> </ul>"},{"location":"helm-charts/infrastructure/rbac/#ephemeral-container-support","title":"Ephemeral Container Support","text":"<p>For distroless container scanning, additional permissions are needed:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"update\", \"patch\"]\n</code></pre> <p>These permissions enable:</p> <ul> <li>Creating ephemeral debug containers</li> <li>Attaching to target containers</li> </ul>"},{"location":"helm-charts/infrastructure/rbac/#security-controls","title":"Security Controls","text":""},{"location":"helm-charts/infrastructure/rbac/#resource-name-restrictions","title":"Resource Name Restrictions","text":"<p>For enhanced security, you can restrict access to specific pods:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.resourceNames[0]=app-pod-1 \\\n  --set rbac.resourceNames[1]=app-pod-2\n</code></pre> <p>This restricts the scanner to only access the specifically named pods.</p>"},{"location":"helm-charts/infrastructure/rbac/#label-selector-restrictions","title":"Label Selector Restrictions","text":"<p>Alternatively, you can use label selectors for dynamic access control:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app \\\n  --set rbac.podSelectorLabels.scannable=true\n</code></pre> <p>This restricts the scanner to only access pods with the specified labels.</p>"},{"location":"helm-charts/infrastructure/rbac/#multi-team-rbac","title":"Multi-Team RBAC","text":"<p>For multi-team environments, create separate roles and bindings:</p> <pre><code># Team A scanner infrastructure\nhelm install team-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-a-namespace \\\n  --set rbac.roleName=team-a-scanner-role \\\n  --set rbac.roleBindingName=team-a-scanner-rolebinding \\\n  --set serviceAccount.name=team-a-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.team=team-a\n\n# Team B scanner infrastructure\nhelm install team-b-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-b-namespace \\\n  --set rbac.roleName=team-b-scanner-role \\\n  --set rbac.roleBindingName=team-b-scanner-rolebinding \\\n  --set serviceAccount.name=team-b-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.team=team-b\n</code></pre>"},{"location":"helm-charts/infrastructure/rbac/#custom-rbac-rules","title":"Custom RBAC Rules","text":"<p>Add additional permissions as needed:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.extraRules[0].apiGroups[0]=\"\" \\\n  --set rbac.extraRules[0].resources[0]=pods/log \\\n  --set rbac.extraRules[0].verbs[0]=get \\\n  --set rbac.extraRules[1].apiGroups[0]=apps \\\n  --set rbac.extraRules[1].resources[0]=deployments \\\n  --set rbac.extraRules[1].verbs[0]=get \\\n  --set rbac.extraRules[1].verbs[1]=list\n</code></pre>"},{"location":"helm-charts/infrastructure/rbac/#configuration-reference","title":"Configuration Reference","text":"Parameter Description Default Required <code>rbac.create</code> Create RBAC resources <code>true</code> No <code>rbac.roleName</code> Name of the role <code>scanner-role</code> No <code>rbac.roleBindingName</code> Name of the role binding <code>scanner-rolebinding</code> No <code>rbac.useResourceNames</code> Restrict to specific pod names <code>false</code> No <code>rbac.resourceNames</code> List of allowed pod names <code>[]</code> No <code>rbac.useLabelSelector</code> Use label selector restrictions <code>false</code> No <code>rbac.podSelectorLabels</code> Labels for pod selection <code>{}</code> No <code>rbac.rules.core.enabled</code> Enable core RBAC rules <code>true</code> No <code>rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container rules <code>false</code> No <code>rbac.extraRules</code> Additional RBAC rules <code>[]</code> No"},{"location":"helm-charts/infrastructure/rbac/#best-practices","title":"Best Practices","text":"<ol> <li>Follow Least Privilege: Always use the minimum permissions required</li> <li>Prefer Label Selectors: Use labels for dynamic access control</li> <li>Limit Namespace Scope: Use separate roles for different namespaces</li> <li>Audit RBAC Regularly: Review and update RBAC configuration regularly</li> <li>Disable Unused Rules: Disable ephemeral container permissions if not needed</li> </ol>"},{"location":"helm-charts/infrastructure/rbac/#related-documentation","title":"Related Documentation","text":"<ul> <li>Service Accounts</li> <li>Namespaces</li> <li>Security Considerations</li> <li>Kubernetes API Scanner</li> <li>Debug Container Scanner</li> </ul>"},{"location":"helm-charts/infrastructure/service-accounts/","title":"Infrastructure Service Accounts","text":"<p>Directory Context</p> <p>This document is part of the Infrastructure Directory. See the Infrastructure Directory Inventory for related resources.</p>"},{"location":"helm-charts/infrastructure/service-accounts/#overview","title":"Overview","text":"<p>The <code>scanner-infrastructure</code> chart creates and manages service accounts for container scanning operations. These service accounts are the identity used for authentication to the Kubernetes API and are bound to specific roles through RBAC.</p>"},{"location":"helm-charts/infrastructure/service-accounts/#service-account-implementation","title":"Service Account Implementation","text":""},{"location":"helm-charts/infrastructure/service-accounts/#core-service-account","title":"Core Service Account","text":"<p>The chart creates a dedicated service account for scanning operations:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: inspec-scanner\n  namespace: scanning-namespace\n</code></pre> <p>This service account:</p> <ul> <li>Acts as the identity for all scanning operations</li> <li>Is bound to a role with specific permissions</li> <li>Exists in the target namespace for scanning</li> </ul>"},{"location":"helm-charts/infrastructure/service-accounts/#token-management","title":"Token Management","text":"<p>The chart supports token generation for service account authentication:</p> <pre><code># Generate kubeconfig with time-limited token\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n</code></pre> <p>This process:</p> <ul> <li>Creates a short-lived token (typically 1 hour)</li> <li>Configures kubeconfig with the token</li> <li>Provides temporary access for scanning</li> </ul>"},{"location":"helm-charts/infrastructure/service-accounts/#cloud-provider-integration","title":"Cloud Provider Integration","text":""},{"location":"helm-charts/infrastructure/service-accounts/#aws-eks-integration","title":"AWS EKS Integration","text":"<p>For EKS clusters with IAM roles for service accounts:</p> <pre><code># Create IAM role with proper permissions first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/scanner-role\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#google-gke-integration","title":"Google GKE Integration","text":"<p>For GKE clusters with Workload Identity:</p> <pre><code># Create GCP service account and bind IAM policy first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"iam.gke.io/gcp-service-account\"=scanner-sa@project-id.iam.gserviceaccount.com\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#azure-aks-integration","title":"Azure AKS Integration","text":"<p>For AKS clusters with Pod Identity or Workload Identity:</p> <pre><code># Create Azure identity first, then:\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"azure.workload.identity/client-id\"=00000000-0000-0000-0000-000000000000\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#multi-team-service-account-setup","title":"Multi-Team Service Account Setup","text":"<p>For multi-team environments, create separate service accounts:</p> <pre><code># Team A service account\nhelm install team-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-a-namespace \\\n  --set serviceAccount.name=team-a-scanner\n\n# Team B service account\nhelm install team-b-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=team-b-namespace \\\n  --set serviceAccount.name=team-b-scanner\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#configuration-reference","title":"Configuration Reference","text":"Parameter Description Default Required <code>serviceAccount.create</code> Create service account <code>true</code> No <code>serviceAccount.name</code> Service account name <code>inspec-scanner</code> No <code>serviceAccount.annotations</code> Service account annotations <code>{}</code> No <code>serviceAccount.labels</code> Service account labels <code>{}</code> No <code>serviceAccount.automountToken</code> Automount API token <code>true</code> No <code>serviceAccount.imagePullSecrets</code> Image pull secrets <code>[]</code> No"},{"location":"helm-charts/infrastructure/service-accounts/#token-management-options","title":"Token Management Options","text":""},{"location":"helm-charts/infrastructure/service-accounts/#setting-token-ttl","title":"Setting Token TTL","text":"<p>Configure token time-to-live for enhanced security:</p> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.tokenTTL=900  # 15 minutes in seconds\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#automating-token-rotation","title":"Automating Token Rotation","text":"<p>For automated scanning in CI/CD pipelines:</p> <pre><code># Ensure fresh token for each CI job\nbefore_script:\n  - ./kubernetes-scripts/generate-kubeconfig.sh ${NAMESPACE} ${SERVICE_ACCOUNT} ./kubeconfig.yaml\n  - export KUBECONFIG=./kubeconfig.yaml\n\n# Run scan\nscript:\n  - ./kubernetes-scripts/scan-container.sh ${NAMESPACE} ${POD_NAME} ${CONTAINER_NAME} ./profiles/container-baseline\n\n# Clean up token\nafter_script:\n  - rm ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/infrastructure/service-accounts/#best-practices","title":"Best Practices","text":"<ol> <li>Use Dedicated Service Accounts: Create separate accounts for different teams or purposes</li> <li>Limit Token Lifetime: Use short-lived tokens (15-60 minutes)</li> <li>Avoid Persistent Credentials: Generate tokens only when needed</li> <li>Clean Up Tokens: Remove token files after use</li> <li>Leverage Cloud IAM: Use cloud provider IAM integration when available</li> <li>Set Appropriate Annotations: Configure annotations for cloud provider integration</li> </ol>"},{"location":"helm-charts/infrastructure/service-accounts/#related-documentation","title":"Related Documentation","text":"<ul> <li>RBAC Configuration</li> <li>Namespaces</li> <li>Security Considerations</li> <li>Scanner Types Documentation</li> </ul>"},{"location":"helm-charts/operations/","title":"Helm Chart Operations","text":"<p>Directory Inventory</p> <p>See the Operations Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/operations/#overview","title":"Overview","text":"<p>This section provides guidance on operational aspects of the Secure Kubernetes Container Scanning Helm charts, including troubleshooting, performance optimization, and maintenance procedures.</p>"},{"location":"helm-charts/operations/#operational-documentation","title":"Operational Documentation","text":"<p>The operations documentation is organized into the following sections:</p> <ul> <li>Troubleshooting: Solutions for common issues encountered with the Helm charts</li> <li>Performance: Guidance for optimizing performance of container scanning operations</li> <li>Maintenance: Procedures for maintaining and updating the scanning infrastructure</li> </ul>"},{"location":"helm-charts/operations/#operational-considerations","title":"Operational Considerations","text":""},{"location":"helm-charts/operations/#installation-verification","title":"Installation Verification","text":"<p>After installing the Helm charts, verify successful deployment:</p> <pre><code># Check infrastructure components\nkubectl get all -n scanning-namespace -l app.kubernetes.io/instance=scanner-infrastructure\n\n# Verify RBAC configuration\nkubectl get serviceaccount,role,rolebinding -n scanning-namespace -l app.kubernetes.io/instance=scanner-infrastructure\n\n# Test accessibility to target pods\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\nKUBECONFIG=./kubeconfig.yaml kubectl get pods -n scanning-namespace\n</code></pre>"},{"location":"helm-charts/operations/#monitoring-scanning-operations","title":"Monitoring Scanning Operations","text":"<p>Monitor scanning operations for issues:</p> <pre><code># Check scanner logs\nkubectl logs -n scanning-namespace scanner-pod -c scanner\n\n# Monitor scan results\nkubectl exec -n scanning-namespace scanner-pod -c scanner -- ls -la /results\n\n# Check for error conditions\nkubectl exec -n scanning-namespace scanner-pod -c scanner -- grep -i error /results/scan-results.json\n</code></pre>"},{"location":"helm-charts/operations/#regular-maintenance-tasks","title":"Regular Maintenance Tasks","text":"<p>Regular maintenance tasks include:</p> <ol> <li>Token Rotation: Regularly rotate service account tokens</li> <li>RBAC Updates: Update RBAC permissions as needed for new pods</li> <li>Chart Updates: Upgrade Helm charts to latest versions</li> <li>Profile Updates: Keep compliance profiles up to date</li> <li>Security Patches: Apply security patches to scanner images</li> </ol>"},{"location":"helm-charts/operations/#getting-started-with-operations","title":"Getting Started with Operations","text":"<p>To effectively manage your scanning infrastructure:</p> <ol> <li>Review the Troubleshooting guide for common issues and solutions</li> <li>Explore the Performance guide for optimization strategies</li> <li>Follow the Maintenance procedures for keeping your environment up to date</li> </ol>"},{"location":"helm-charts/operations/inventory/","title":"Operations Directory Inventory","text":"<p>This document provides a directory overview of all operations-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/operations/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/operations directory contains documentation for operational aspects of the Helm charts:</p> <ul> <li>index.md: Overview of operational considerations</li> <li>inventory.md: This directory listing</li> <li>troubleshooting.md: Guide for troubleshooting common issues</li> <li>performance.md: Guide for optimizing performance</li> <li>maintenance.md: Procedures for maintenance and updates</li> </ul>"},{"location":"helm-charts/operations/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The operations section provides:</p> <ul> <li>Introduction to operational aspects of the Helm charts</li> <li>Troubleshooting procedures for common issues</li> <li>Performance optimization strategies</li> <li>Maintenance procedures for ongoing operations</li> <li>Monitoring and logging guidance</li> </ul>"},{"location":"helm-charts/operations/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Overview</li> <li>Scanner Types Documentation</li> <li>Infrastructure Documentation</li> <li>Usage &amp; Customization</li> <li>Security Considerations</li> </ul>"},{"location":"helm-charts/operations/maintenance/","title":"Maintenance Procedures","text":"<p>Directory Context</p> <p>This document is part of the Operations Directory. See the Operations Directory Inventory for related resources.</p>"},{"location":"helm-charts/operations/maintenance/#overview","title":"Overview","text":"<p>This document outlines maintenance procedures for the Secure Kubernetes Container Scanning Helm charts. Regular maintenance is essential for keeping your scanning infrastructure secure, up-to-date, and running efficiently.</p>"},{"location":"helm-charts/operations/maintenance/#routine-maintenance-tasks","title":"Routine Maintenance Tasks","text":""},{"location":"helm-charts/operations/maintenance/#1-helm-chart-updates","title":"1. Helm Chart Updates","text":"<p>Regularly update Helm charts to get the latest features and security fixes:</p> <pre><code># Update Helm repository\nhelm repo update\n\n# Check for chart updates\nhelm list -A\n\n# Update specific chart\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --reuse-values\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#2-scanner-image-updates","title":"2. Scanner Image Updates","text":"<p>Keep scanner container images up to date:</p> <pre><code># Update to latest CINC Auditor image\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=chef/inspec:latest \\\n  --reuse-values\n</code></pre> <p>For debug containers:</p> <pre><code># Update debug container image\nhelm upgrade distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.image=alpine:latest \\\n  --reuse-values\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#3-compliance-profile-updates","title":"3. Compliance Profile Updates","text":"<p>Keep compliance profiles up to date:</p> <pre><code># Update profiles in ConfigMap\nkubectl create configmap inspec-profiles -n scanning-namespace \\\n  --from-file=./updated-profiles \\\n  --dry-run=client -o yaml | kubectl apply -f -\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#4-rbac-maintenance","title":"4. RBAC Maintenance","text":"<p>Regularly review and update RBAC permissions:</p> <pre><code># Check current RBAC configuration\nkubectl get role scanner-role -n scanning-namespace -o yaml\n\n# Update RBAC for new pod patterns\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app \\\n  --set rbac.podSelectorLabels.scannable=true \\\n  --reuse-values\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#5-token-rotation","title":"5. Token Rotation","text":"<p>Regularly rotate service account tokens:</p> <pre><code># Delete existing token secrets to force rotation\nkubectl delete secrets -n scanning-namespace -l kubernetes.io/service-account.name=inspec-scanner\n\n# Regenerate kubeconfig with fresh token\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#scheduled-maintenance-procedures","title":"Scheduled Maintenance Procedures","text":""},{"location":"helm-charts/operations/maintenance/#monthly-maintenance-checklist","title":"Monthly Maintenance Checklist","text":"<p>Implement a monthly maintenance schedule:</p> <pre><code>#!/bin/bash\n# monthly-maintenance.sh\nNAMESPACE=\"scanning-namespace\"\n\necho \"Monthly Scanner Maintenance\"\necho \"==========================\"\n\n# 1. Update Helm charts\nhelm dependency update ./helm-charts/standard-scanner\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=$NAMESPACE \\\n  --reuse-values\n\n# 2. Update scanner images\nkubectl set image deployment/scanner-deployment scanner=chef/inspec:latest -n $NAMESPACE\n\n# 3. Update profiles\nkubectl create configmap inspec-profiles -n $NAMESPACE \\\n  --from-file=./updated-profiles \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# 4. Review and update RBAC\nkubectl get role scanner-role -n $NAMESPACE -o yaml\n\n# 5. Rotate tokens\nkubectl delete secrets -n $NAMESPACE -l kubernetes.io/service-account.name=inspec-scanner\n./kubernetes-scripts/generate-kubeconfig.sh $NAMESPACE inspec-scanner ./kubeconfig.yaml\n\n# 6. Verify scanner functionality\n./kubernetes-scripts/scan-container.sh $NAMESPACE test-pod container-name ./profiles/container-baseline\n\necho \"Maintenance complete!\"\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#quarterly-security-review","title":"Quarterly Security Review","text":"<p>Conduct quarterly security reviews:</p> <pre><code>#!/bin/bash\n# quarterly-security-review.sh\nNAMESPACE=\"scanning-namespace\"\n\necho \"Quarterly Security Review\"\necho \"=========================\"\n\n# 1. Review RBAC permissions\nkubectl get rolebinding -n $NAMESPACE -o json | jq '.items[] | select(.roleRef.name==\"scanner-role\")'\n\n# 2. Check for unused permissions\nkubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:inspec-scanner -n $NAMESPACE\n\n# 3. Review network policies\nkubectl get networkpolicy -n $NAMESPACE -o yaml\n\n# 4. Audit scanner usage\nkubectl logs -n $NAMESPACE deployment/scanner-deployment --since=90d | grep \"Scan completed\" | wc -l\n\n# 5. Check for security updates\nhelm dependency update ./helm-charts/standard-scanner\nhelm diff upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=$NAMESPACE \\\n  --reuse-values\n\necho \"Security review complete!\"\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#version-upgrades","title":"Version Upgrades","text":""},{"location":"helm-charts/operations/maintenance/#minor-version-upgrades","title":"Minor Version Upgrades","text":"<p>For minor version upgrades, a simple update is usually sufficient:</p> <pre><code># Minor version upgrade\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --reuse-values\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#major-version-upgrades","title":"Major Version Upgrades","text":"<p>For major version upgrades, follow a more careful process:</p> <pre><code># 1. Review release notes and changes\n\n# 2. Backup existing configuration\nhelm get values standard-scanner &gt; standard-scanner-values-backup.yaml\n\n# 3. Test upgrade in a non-production environment\nhelm upgrade standard-scanner-test ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=test-namespace \\\n  -f standard-scanner-values-backup.yaml\n\n# 4. Verify functionality in test environment\n./kubernetes-scripts/scan-container.sh test-namespace test-pod container-name ./profiles/container-baseline\n\n# 5. Schedule production upgrade during maintenance window\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  -f standard-scanner-values-backup.yaml\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"helm-charts/operations/maintenance/#configure-monitoring","title":"Configure Monitoring","text":"<p>Set up monitoring for scanner components:</p> <pre><code># prometheus-servicemonitor.yaml\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: scanner-monitor\n  namespace: monitoring\nspec:\n  selector:\n    matchLabels:\n      app: scanner\n  namespaceSelector:\n    matchNames:\n      - scanning-namespace\n  endpoints:\n  - port: metrics\n    interval: 30s\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#log-collection","title":"Log Collection","text":"<p>Configure log collection for scanner components:</p> <pre><code># fluentd-configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\n  namespace: logging\ndata:\n  fluent.conf: |\n    &lt;match kubernetes.var.log.containers.scanner-**&gt;\n      @type elasticsearch\n      host elasticsearch.logging\n      port 9200\n      logstash_format true\n      logstash_prefix scanner\n      &lt;buffer&gt;\n        @type file\n        path /var/log/fluentd-buffers/scanner\n        flush_mode interval\n        retry_type exponential_backoff\n        flush_thread_count 2\n        flush_interval 5s\n      &lt;/buffer&gt;\n    &lt;/match&gt;\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"helm-charts/operations/maintenance/#backup-configurations","title":"Backup Configurations","text":"<p>Regularly backup Helm chart configurations:</p> <pre><code># Backup all Helm release configurations\nmkdir -p helm-backups/$(date +%Y-%m-%d)\nhelm list -A -o json | jq -r '.[] | .name + \" \" + .namespace' | while read -r release namespace; do\n  helm get values $release -n $namespace &gt; helm-backups/$(date +%Y-%m-%d)/$release-$namespace.yaml\ndone\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#recovery-procedures","title":"Recovery Procedures","text":"<p>If you need to recover from a failure:</p> <pre><code># Restore from backup\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  -f helm-backups/2025-03-24/standard-scanner-scanning-namespace.yaml\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#cleanup-procedures","title":"Cleanup Procedures","text":""},{"location":"helm-charts/operations/maintenance/#resource-cleanup","title":"Resource Cleanup","text":"<p>Regularly clean up old scan results and temporary resources:</p> <pre><code># Clean up old scan results\nkubectl exec -n scanning-namespace scanner-pod -- find /results -type f -mtime +30 -delete\n\n# Remove old kubeconfig files\nfind /path/to/kubeconfig-files -name \"kubeconfig-*.yaml\" -mtime +7 -delete\n\n# Delete completed jobs\nkubectl delete jobs -n scanning-namespace --field-selector status.successful=1\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#namespace-cleanup","title":"Namespace Cleanup","text":"<p>Periodically review and clean up scanning namespaces:</p> <pre><code># List all scanner namespaces\nkubectl get ns -l purpose=scanning\n\n# Clean up resources in a namespace\nkubectl delete all -n old-scanning-namespace -l app.kubernetes.io/instance=scanner\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#retirement-and-decommissioning","title":"Retirement and Decommissioning","text":"<p>When retiring a scanner deployment:</p> <pre><code># 1. Revoke tokens\nkubectl delete secrets -n scanning-namespace -l kubernetes.io/service-account.name=inspec-scanner\n\n# 2. Remove Helm releases\nhelm uninstall standard-scanner -n scanning-namespace\nhelm uninstall scanner-infrastructure -n scanning-namespace\n\n# 3. Clean up any remaining resources\nkubectl delete configmap -n scanning-namespace -l app.kubernetes.io/part-of=scanner\nkubectl delete secret -n scanning-namespace -l app.kubernetes.io/part-of=scanner\n\n# 4. Remove namespace if no longer needed\nkubectl delete namespace scanning-namespace\n</code></pre>"},{"location":"helm-charts/operations/maintenance/#related-documentation","title":"Related Documentation","text":"<ul> <li>Troubleshooting</li> <li>Performance Optimization</li> <li>Usage &amp; Customization</li> <li>Security Considerations</li> </ul>"},{"location":"helm-charts/operations/performance/","title":"Performance Optimization Guide","text":"<p>Directory Context</p> <p>This document is part of the Operations Directory. See the Operations Directory Inventory for related resources.</p>"},{"location":"helm-charts/operations/performance/#overview","title":"Overview","text":"<p>This guide provides strategies for optimizing the performance of the Secure Kubernetes Container Scanning Helm charts. Proper performance tuning is essential for running efficient scanning operations, particularly in environments with many containers or limited resources.</p>"},{"location":"helm-charts/operations/performance/#performance-factors","title":"Performance Factors","text":"<p>Several factors affect container scanning performance:</p> <ol> <li>Profile Complexity: The number of controls and their complexity</li> <li>Container Size: The size of the target container's filesystem</li> <li>Network Latency: The latency between scanner and target</li> <li>Resource Allocation: CPU and memory allocated to scanner components</li> <li>Concurrency: The number of concurrent scans</li> <li>Scanning Approach: Different approaches have different performance characteristics</li> </ol>"},{"location":"helm-charts/operations/performance/#performance-optimization-strategies","title":"Performance Optimization Strategies","text":""},{"location":"helm-charts/operations/performance/#1-profile-optimization","title":"1. Profile Optimization","text":"<p>Optimize your CINC Auditor profiles for better performance:</p> <pre><code># Efficient file checking using wildcards\ndescribe file('/etc/passwd') do\n  it { should exist }\nend\n\n# Instead of checking every file in a directory individually,\n# use a single check with wildcard for better performance\ndescribe command('find /etc -name \"*.conf\" -type f -perm -o+w | wc -l') do\n  its('stdout.strip') { should eq '0' }\nend\n</code></pre> <p>Create focused, purpose-specific profiles:</p> <pre><code># Create a lightweight profile for basic checks\ncat &gt; basic-profile/inspec.yml &lt;&lt; EOF\nname: basic-profile\nversion: 1.0.0\ndepends:\n  - name: container-baseline\n    path: ../container-baseline\n    skip_controls:\n      - filesystem_checks\n      - process_checks\nEOF\n\n# Use the lightweight profile for faster scans\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./basic-profile\n</code></pre>"},{"location":"helm-charts/operations/performance/#2-resource-allocation","title":"2. Resource Allocation","text":"<p>Adjust resource limits and requests for scanner containers:</p> <pre><code># Optimize sidecar scanner resources\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.resources.requests.cpu=200m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre> <p>For debug containers:</p> <pre><code># Optimize debug container resources\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.resources.requests.cpu=100m \\\n  --set debugContainer.resources.requests.memory=128Mi \\\n  --set debugContainer.resources.limits.cpu=200m \\\n  --set debugContainer.resources.limits.memory=256Mi\n</code></pre>"},{"location":"helm-charts/operations/performance/#3-scan-timing-and-scheduling","title":"3. Scan Timing and Scheduling","text":"<p>Schedule scans during off-peak hours:</p> <pre><code># Example cron job for off-peak scanning\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: nightly-scan\n  namespace: scanning-namespace\nspec:\n  schedule: \"0 2 * * *\"  # Run at 2 AM daily\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: scanner\n            image: scanner-image:latest\n            command: [\"/bin/sh\", \"-c\"]\n            args:\n            - |\n              ./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n          restartPolicy: OnFailure\n</code></pre>"},{"location":"helm-charts/operations/performance/#4-parallel-scanning","title":"4. Parallel Scanning","text":"<p>Implement parallel scanning for multiple containers:</p> <pre><code>#!/bin/bash\n# parallel-scan.sh\nNAMESPACE=\"scanning-namespace\"\nPODS=$(kubectl get pods -n $NAMESPACE -l app=target-app -o jsonpath='{.items[*].metadata.name}')\n\n# Scan pods in parallel\nfor POD in $PODS; do\n  ./kubernetes-scripts/scan-container.sh $NAMESPACE $POD container-name ./profiles/container-baseline --output-file=results-$POD.json &amp;\ndone\n\n# Wait for all background processes to complete\nwait\n\n# Process results\nfor POD in $PODS; do\n  echo \"Results for $POD:\"\n  saf summary --input results-$POD.json --output-md summary-$POD.md\ndone\n</code></pre>"},{"location":"helm-charts/operations/performance/#5-approach-specific-optimizations","title":"5. Approach-Specific Optimizations","text":""},{"location":"helm-charts/operations/performance/#kubernetes-api-scanner-standard","title":"Kubernetes API Scanner (Standard)","text":"<pre><code># Optimize standard scanner\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.scripts.includeScanScript=true \\\n  --set common-scanner.scripts.includeDistrolessScanScript=false \\\n  --set common-scanner.scripts.includeSidecarScanScript=false\n</code></pre> <p>Use direct transport invocation for faster scanning:</p> <pre><code># Direct transport for better performance\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./profiles/container-baseline \\\n  -t k8s-container://scanning-namespace/target-pod/container --sudo=false\n</code></pre>"},{"location":"helm-charts/operations/performance/#debug-container-scanner-distroless","title":"Debug Container Scanner (Distroless)","text":"<pre><code># Optimize debug container approach\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.image=alpine:3.15  # Smaller image\n</code></pre> <p>Use minimal debug container image:</p> <pre><code># Minimal debug container for faster startup\ndebugContainer:\n  image: busybox:musl  # Smaller than alpine\n  command: null\n  args: null\n  timeout: 300  # Shorter timeout\n</code></pre>"},{"location":"helm-charts/operations/performance/#sidecar-scanner","title":"Sidecar Scanner","text":"<pre><code># Optimize sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=chef/inspec:slim  # Use smaller image if available\n</code></pre>"},{"location":"helm-charts/operations/performance/#6-cinc-auditor-performance-tuning","title":"6. CINC Auditor Performance Tuning","text":"<p>Enable CINC Auditor caching:</p> <pre><code># Use caching for repeated scans\nINSPEC_CACHE_ENABLED=true \\\nINSPEC_CACHE_LOCATION=/tmp/inspec-cache \\\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n</code></pre> <p>Disable unnecessary reporters:</p> <pre><code># Use only required reporters\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name \\\n  ./profiles/container-baseline --reporter json:/results/scan-results.json\n</code></pre>"},{"location":"helm-charts/operations/performance/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"helm-charts/operations/performance/#scanning-approach-comparison","title":"Scanning Approach Comparison","text":"Approach Small Container Medium Container Large Container Kubernetes API 5-10 seconds 10-30 seconds 30-120 seconds Debug Container 15-30 seconds 30-60 seconds 60-180 seconds Sidecar Container 5-15 seconds 15-45 seconds 45-150 seconds <p>Note: Actual times will vary based on profile complexity, container content, and system resources.</p>"},{"location":"helm-charts/operations/performance/#profile-performance-impact","title":"Profile Performance Impact","text":"Profile Type Controls Scan Time Impact Basic Security 10-20 Minimal CIS Benchmark 50-100 Moderate Full Compliance 100+ Significant"},{"location":"helm-charts/operations/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"helm-charts/operations/performance/#resource-usage-monitoring","title":"Resource Usage Monitoring","text":"<p>Monitor resource usage during scans:</p> <pre><code># Monitor scanner pod resource usage\nkubectl top pod -n scanning-namespace scanner-pod --containers\n\n# Monitor debug container usage\nkubectl top pod -n scanning-namespace target-pod\n</code></pre>"},{"location":"helm-charts/operations/performance/#scan-timing-metrics","title":"Scan Timing Metrics","text":"<p>Collect scan timing metrics:</p> <pre><code># Add timing to scan script\ntime ./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n\n# Output detailed timing in profiles\ncontrol 'container-1.1' do\n  impact 0.7\n  title 'Ensure container has proper permissions'\n\n  describe.one do\n    start_time = Time.now\n    describe file('/etc/passwd') do\n      it { should exist }\n      it { should be_owned_by 'root' }\n    end\n    puts \"Executed control container-1.1 in #{Time.now - start_time} seconds\"\n  end\nend\n</code></pre>"},{"location":"helm-charts/operations/performance/#optimizing-for-different-environments","title":"Optimizing for Different Environments","text":""},{"location":"helm-charts/operations/performance/#cicd-pipeline-optimization","title":"CI/CD Pipeline Optimization","text":"<p>For CI/CD environments, focus on speed:</p> <pre><code># CI/CD optimized scan\n./kubernetes-scripts/scan-container.sh ci-namespace target-pod container-name ./profiles/ci-profile \\\n  --reporter json-min:/results/scan-results.json\n</code></pre> <p>Use a streamlined CI profile:</p> <pre><code># ci-profile/inspec.yml\nname: ci-profile\nversion: 1.0.0\ndepends:\n  - name: container-baseline\n    path: ../container-baseline\n    controls:\n      - critical_controls  # Only run critical controls for faster CI\n</code></pre>"},{"location":"helm-charts/operations/performance/#production-environment-optimization","title":"Production Environment Optimization","text":"<p>For production environments, balance thoroughness with performance:</p> <pre><code># Production scan with optimal balance\n./kubernetes-scripts/scan-container.sh prod-namespace target-pod container-name ./profiles/prod-profile \\\n  --reporter json:/results/scan-results.json \\\n  --ignore-warning-controls  # Skip warning-level controls\n</code></pre>"},{"location":"helm-charts/operations/performance/#large-scale-environment-optimization","title":"Large-Scale Environment Optimization","text":"<p>For environments with many containers:</p> <pre><code># Distributed scanning with multiple scanners\nfor NAMESPACE in namespace1 namespace2 namespace3; do\n  kubectl create job --from=cronjob/scanner-job scanner-$NAMESPACE -n scanning-namespace\ndone\n</code></pre>"},{"location":"helm-charts/operations/performance/#conclusion","title":"Conclusion","text":"<p>Optimizing container scanning performance requires a multi-faceted approach. By fine-tuning profiles, resource allocation, and scanning strategies, you can significantly improve scanning efficiency while maintaining security effectiveness.</p>"},{"location":"helm-charts/operations/performance/#related-documentation","title":"Related Documentation","text":"<ul> <li>Troubleshooting</li> <li>Maintenance Procedures</li> <li>Scanner Types</li> <li>Usage &amp; Customization</li> </ul>"},{"location":"helm-charts/operations/troubleshooting/","title":"Helm Chart Troubleshooting Guide","text":"<p>Directory Context</p> <p>This document is part of the Operations Directory. See the Operations Directory Inventory for related resources.</p>"},{"location":"helm-charts/operations/troubleshooting/#overview","title":"Overview","text":"<p>This guide provides solutions for common issues encountered when using the Secure Kubernetes Container Scanning Helm charts. It covers installation problems, scanning errors, RBAC issues, and performance troubleshooting.</p>"},{"location":"helm-charts/operations/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#chart-dependency-resolution-failures","title":"Chart Dependency Resolution Failures","text":"<p>Problem: Dependencies not resolved during installation.</p> <pre><code>Error: found in Chart.yaml, but missing in charts/ directory: common-scanner, scanner-infrastructure\n</code></pre> <p>Solution:</p> <pre><code># Update dependencies before installing\nhelm dependency update ./helm-charts/standard-scanner\n\n# Alternative: build dependencies explicitly\ncd ./helm-charts\nhelm dependency build standard-scanner\nhelm install standard-scanner ./standard-scanner\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#namespace-conflicts","title":"Namespace Conflicts","text":"<p>Problem: Chart tries to create a namespace that already exists.</p> <pre><code>Error: rendered manifests contain a resource that already exists. Unable to continue with install: namespace \"inspec-test\" exists\n</code></pre> <p>Solution:</p> <pre><code># Disable namespace creation\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.createNamespace=false \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#chart-version-incompatibility","title":"Chart Version Incompatibility","text":"<p>Problem: Helm version doesn't support the chart schema version.</p> <p>Solution:</p> <pre><code># Check Helm version\nhelm version\n\n# Upgrade Helm if needed\ncurl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#rbac-and-authentication-issues","title":"RBAC and Authentication Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#permission-denied-errors","title":"Permission Denied Errors","text":"<p>Problem: Scanner can't access target containers.</p> <pre><code>Error: PERMISSION_DENIED: pods \"target-pod\" is forbidden: User \"system:serviceaccount:inspec-test:inspec-scanner\" cannot exec into pods in the namespace \"inspec-test\"\n</code></pre> <p>Solution:</p> <ol> <li>Verify RBAC configuration:</li> </ol> <pre><code># Check service account\nkubectl get serviceaccount inspec-scanner -n inspec-test\n\n# Check role and permissions\nkubectl get role inspec-container-role -n inspec-test -o yaml\n\n# Check role binding\nkubectl get rolebinding inspec-container-rolebinding -n inspec-test -o yaml\n</code></pre> <ol> <li>Ensure proper role configuration:</li> </ol> <pre><code># Update chart with explicit permissions\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.rules.core.enabled=true \\\n  --set rbac.rules.ephemeralContainers.enabled=true  # If needed\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#resource-name-restriction-issues","title":"Resource Name Restriction Issues","text":"<p>Problem: When using resource name restrictions, scanner can't access pods.</p> <p>Solution:</p> <pre><code># Disable resource name restrictions temporarily for debugging\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.useResourceNames=false\n\n# Or set the correct pod names in restrictions\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.resourceNames[0]=target-pod-1 \\\n  --set rbac.resourceNames[1]=target-pod-2\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#token-generation-issues","title":"Token Generation Issues","text":"<p>Problem: Can't generate valid tokens for scanner.</p> <p>Solution:</p> <pre><code># Check service account secrets\nkubectl get serviceaccount inspec-scanner -n inspec-test -o yaml\n\n# Recreate service account if needed\nkubectl delete serviceaccount inspec-scanner -n inspec-test\nhelm upgrade scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=inspec-test\n\n# Manual token generation\nSERVICE_ACCOUNT=inspec-scanner\nNAMESPACE=inspec-test\nSECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT} -n ${NAMESPACE} -o jsonpath='{.secrets[0].name}')\nTOKEN=$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.token}' | base64 --decode)\necho $TOKEN\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#scanning-issues","title":"Scanning Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#standard-scanner-kubernetes-api-approach-issues","title":"Standard Scanner (Kubernetes API Approach) Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#transport-plugin-errors","title":"Transport Plugin Errors","text":"<p>Problem: CINC Auditor can't connect to target container.</p> <pre><code>Error connecting to 'k8s-container://inspec-test/target-pod/container': unable to execute command on pod...\n</code></pre> <p>Solution:</p> <pre><code># Check if container has shell\nkubectl exec -n inspec-test target-pod -c container -- /bin/sh -c \"echo test\"\n\n# Verify CINC Auditor plugin installation\ncinc-auditor plugin list\n\n# Install plugin if missing\ncinc-auditor plugin install inspec-k8s-container\n\n# Update transport plugin version\ncinc-auditor plugin update inspec-k8s-container\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#shell-command-failures","title":"Shell Command Failures","text":"<p>Problem: CINC Auditor can't execute commands in target container.</p> <p>Solution:</p> <pre><code># Check container shell\nkubectl exec -n inspec-test target-pod -c container -- ls -la /bin/sh\n\n# If using Alpine, ensure sh is available\nkubectl exec -n inspec-test target-pod -c container -- apk add --no-cache bash\n\n# Update profile to use available commands\n# Edit profile to use `/bin/sh` instead of `/bin/bash`\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#distroless-scanner-debug-container-approach-issues","title":"Distroless Scanner (Debug Container Approach) Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#ephemeral-container-creation-failures","title":"Ephemeral Container Creation Failures","text":"<p>Problem: Debug container can't be created.</p> <pre><code>Error: ephemeral containers are disabled for this cluster\n</code></pre> <p>Solution:</p> <pre><code># Check Kubernetes version\nkubectl version\n\n# Enable ephemeral containers in API server (requires admin access)\n# For k8s &lt; 1.23, update kube-apiserver with feature gate:\n--feature-gates=EphemeralContainers=true\n\n# For newer versions, ephemeral containers should be enabled by default\n# Verify API version support\nkubectl api-resources | grep ephemeralcontainers\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#debug-container-access-issues","title":"Debug Container Access Issues","text":"<p>Problem: Debug container can't access target container filesystem.</p> <p>Solution:</p> <pre><code># Manually test ephemeral container access\nkubectl debug -it -n inspec-test target-pod --image=alpine:latest --target=container -- sh\n\n# Inside debug container, check process list and filesystem access\nps aux\nls -la /proc/1/root/\n\n# If access issues persist, check security policies\nkubectl get psp  # PodSecurityPolicies in older clusters\nkubectl get podsecuritypolicy  # In newer clusters\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#sidecar-scanner-issues","title":"Sidecar Scanner Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#process-namespace-sharing-failures","title":"Process Namespace Sharing Failures","text":"<p>Problem: Sidecar can't access target container processes.</p> <p>Solution:</p> <pre><code># Verify pod has shareProcessNamespace enabled\nkubectl get pod sidecar-target -n inspec-test -o yaml | grep shareProcessNamespace\n\n# Recreate pod with proper configuration\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.shareProcessNamespace=true\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#sidecar-container-failures","title":"Sidecar Container Failures","text":"<p>Problem: Scanner container crashes or can't run profiles.</p> <p>Solution:</p> <pre><code># Check scanner container logs\nkubectl logs -n inspec-test sidecar-target -c scanner\n\n# Shell into scanner container for debugging\nkubectl exec -it -n inspec-test sidecar-target -c scanner -- sh\n\n# Try manual profile execution\ninspec exec /profiles/container-baseline -t proc://1/root --logger debug\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#saf-cli-integration-issues","title":"SAF CLI Integration Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#threshold-validation-failures","title":"Threshold Validation Failures","text":"<p>Problem: SAF CLI can't validate against threshold file.</p> <pre><code>Error: Failed to validate results against threshold: Invalid threshold file format\n</code></pre> <p>Solution:</p> <pre><code># Check threshold file format\ncat threshold.yml\n\n# Ensure threshold file has correct structure:\ncompliance:\n  min: 70\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 2\n\n# Validate threshold file with SAF CLI\nsaf validate-threshold --threshold threshold.yml\n\n# Update chart with correct threshold configuration\nhelm upgrade common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test \\\n  --set safCli.thresholdConfig.compliance.min=70 \\\n  --set safCli.thresholdConfig.failed.critical.max=0 \\\n  --set safCli.thresholdConfig.failed.high.max=2\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#saf-cli-missing-or-incompatible","title":"SAF CLI Missing or Incompatible","text":"<p>Problem: SAF CLI not available or incompatible version.</p> <p>Solution:</p> <pre><code># Check if SAF CLI is installed\nsaf --version\n\n# Install SAF CLI if missing\npip install saf-cli\n\n# Update to compatible version\npip install saf-cli==1.2.3\n\n# Alternatively, disable SAF CLI integration temporarily\nhelm upgrade common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=inspec-test \\\n  --set safCli.enabled=false\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#scan-taking-too-long","title":"Scan Taking Too Long","text":"<p>Problem: Container scans taking too long to complete.</p> <p>Solution:</p> <pre><code># Profile optimization\n# Use smaller, focused profiles instead of large ones\n\n# For standard scanner, add timeout\ncinc-auditor exec ./profiles/container-baseline -t k8s-container://inspec-test/target-pod/container --timeout 300\n\n# For distroless scanner, adjust debug container timeout\nhelm upgrade distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set debugContainer.timeout=300\n\n# For sidecar scanner, adjust resource limits\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#resource-constraints","title":"Resource Constraints","text":"<p>Problem: Scanner or target pods experiencing resource issues.</p> <p>Solution:</p> <pre><code># Check resource usage\nkubectl top pods -n inspec-test\n\n# Adjust resource limits and requests\nhelm upgrade sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#helm-chart-specific-issues","title":"Helm Chart Specific Issues","text":""},{"location":"helm-charts/operations/troubleshooting/#chart-value-inheritance-issues","title":"Chart Value Inheritance Issues","text":"<p>Problem: Values not being passed correctly through chart dependencies.</p> <p>Solution:</p> <pre><code># Check how values are passed through dependencies\nhelm template standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --debug\n\n# Use explicit values file instead\ncat &gt; values.yaml &lt;&lt; EOF\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: inspec-test\n    rbac:\n      useResourceNames: true\nEOF\n\nhelm install standard-scanner ./helm-charts/standard-scanner -f values.yaml\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#chart-update-issues","title":"Chart Update Issues","text":"<p>Problem: Helm upgrade not applying changes as expected.</p> <p>Solution:</p> <pre><code># Verify changes before upgrade\nhelm diff upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n\n# Force resource updates if needed\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --force\n\n# Worst case, uninstall and reinstall\nhelm uninstall standard-scanner\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#diagnostic-scripts","title":"Diagnostic Scripts","text":""},{"location":"helm-charts/operations/troubleshooting/#scanner-setup-diagnostics","title":"Scanner Setup Diagnostics","text":"<p>Use this script to diagnose scanner setup issues:</p> <pre><code>#!/bin/bash\n# scanner-diagnostics.sh\nNAMESPACE=\"inspec-test\"\nSERVICE_ACCOUNT=\"inspec-scanner\"\n\necho \"Scanner Diagnostics\"\necho \"===================\"\n\n# Check namespace\necho \"\\nChecking namespace...\"\nkubectl get ns $NAMESPACE || echo \"Namespace $NAMESPACE does not exist!\"\n\n# Check service account\necho \"\\nChecking service account...\"\nkubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o yaml || echo \"Service account $SERVICE_ACCOUNT does not exist!\"\n\n# Check role and role binding\necho \"\\nChecking RBAC configuration...\"\nROLE_NAME=$(kubectl get rolebinding -n $NAMESPACE -o json | jq -r '.items[] | select(.subjects[] | select(.kind==\"ServiceAccount\" and .name==\"'$SERVICE_ACCOUNT'\")) | .roleRef.name')\necho \"Role name: $ROLE_NAME\"\nkubectl get role $ROLE_NAME -n $NAMESPACE -o yaml || echo \"Role $ROLE_NAME does not exist!\"\n\n# Check token secrets\necho \"\\nChecking token secrets...\"\nSECRETS=$(kubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o json | jq -r '.secrets[].name')\nfor SECRET in $SECRETS; do\n  echo \"Secret: $SECRET\"\n  kubectl get secret $SECRET -n $NAMESPACE -o yaml | grep -v \"token:\" || echo \"Secret $SECRET does not exist!\"\ndone\n\necho \"\\nDiagnostics complete!\"\n</code></pre>"},{"location":"helm-charts/operations/troubleshooting/#related-documentation","title":"Related Documentation","text":"<ul> <li>Performance Optimization</li> <li>Maintenance Procedures</li> <li>Scanner Types</li> <li>Security Considerations</li> </ul>"},{"location":"helm-charts/overview/","title":"Helm Charts Overview","text":"<p>Directory Inventory</p> <p>See the Overview Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/overview/#introduction","title":"Introduction","text":"<p>The Secure Kubernetes Container Scanning solution provides a comprehensive set of Helm charts for deploying container scanning infrastructure in Kubernetes environments. These charts are designed with security, modularity, and enterprise usability in mind.</p> <p>Our Helm charts implement a layered architecture to support all three container scanning approaches:</p> <ol> <li>Kubernetes API Approach (standard-scanner): For scanning regular containers via Kubernetes API</li> <li>Debug Container Approach (distroless-scanner): For scanning distroless containers using ephemeral debug containers</li> <li>Sidecar Container Approach (sidecar-scanner): For universal container scanning using process namespace sharing</li> </ol> <p>The charts are structured to maximize reusability and minimize duplication, with common components extracted into shared charts.</p>"},{"location":"helm-charts/overview/#chart-organization","title":"Chart Organization","text":"<p>The charts are organized in a hierarchical structure:</p> <pre><code>helm-charts/\n\u251c\u2500\u2500 scanner-infrastructure/  # Core RBAC, service accounts, tokens\n\u251c\u2500\u2500 common-scanner/          # Common scanning components and utilities\n\u251c\u2500\u2500 standard-scanner/        # Kubernetes API Approach (regular containers)\n\u251c\u2500\u2500 distroless-scanner/      # Debug Container Approach (distroless containers)\n\u2514\u2500\u2500 sidecar-scanner/         # Sidecar Container Approach (shared process namespace)\n</code></pre>"},{"location":"helm-charts/overview/#key-features","title":"Key Features","text":""},{"location":"helm-charts/overview/#security-first-design","title":"Security-First Design","text":"<p>All charts implement security best practices:</p> <ul> <li>Least-privilege RBAC model</li> <li>Short-lived access tokens</li> <li>Non-privileged containers</li> <li>Resource limitations</li> <li>Namespace isolation</li> </ul>"},{"location":"helm-charts/overview/#modularity","title":"Modularity","text":"<p>The charts are designed for maximum flexibility:</p> <ul> <li>Use only the components you need</li> <li>Mix and match scanning approaches</li> <li>Customize individual chart values</li> <li>Extend with your own configurations</li> </ul>"},{"location":"helm-charts/overview/#enterprise-integration","title":"Enterprise Integration","text":"<p>Built-in support for enterprise environments:</p> <ul> <li>CI/CD pipeline integration</li> <li>Compliance reporting with SAF CLI</li> <li>Threshold-based validation</li> <li>Multi-team and multi-cluster support</li> </ul>"},{"location":"helm-charts/overview/#getting-started","title":"Getting Started","text":"<p>To learn more about our Helm Charts:</p> <ol> <li>See the Architecture page for an overview of chart components and relationships</li> <li>Visit the Scanner Types section to learn about different scanning approaches</li> <li>Review the Infrastructure section for core RBAC and service account setup</li> <li>Follow the Usage &amp; Customization guides for tailoring charts to your environment</li> <li>Learn about Security Considerations for important security guidance</li> <li>Check the Operations section for troubleshooting and maintenance</li> </ol>"},{"location":"helm-charts/overview/architecture/","title":"Helm Chart Architecture","text":"<p>Directory Context</p> <p>This document is part of the Overview Directory. See the Overview Directory Inventory for related resources.</p>"},{"location":"helm-charts/overview/architecture/#chart-relationship-diagram","title":"Chart Relationship Diagram","text":"<pre><code>graph TD\n    subgraph \"Core Infrastructure\"\n        A[scanner-infrastructure] --&gt; A1[RBAC]\n        A --&gt; A2[Service Accounts]\n        A --&gt; A3[Token Management]\n        A --&gt; A4[Namespace]\n    end\n\n    subgraph \"Common Components\"\n        B[common-scanner] --&gt; B1[Scanning Scripts]\n        B --&gt; B2[SAF CLI Integration]\n        B --&gt; B3[Threshold Configuration]\n    end\n\n    subgraph \"Scanning Approaches\"\n        C[standard-scanner] --&gt; C1[Kubernetes API Scanning]\n        D[distroless-scanner] --&gt; D1[Debug Container Scanning]\n        E[sidecar-scanner] --&gt; E1[Sidecar Container Scanning]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n\n    classDef core fill:#f9f,stroke:#333,stroke-width:2px\n    classDef common fill:#bbf,stroke:#333,stroke-width:2px\n    classDef scanning fill:#bfb,stroke:#333,stroke-width:2px\n\n    class A,A1,A2,A3,A4 core\n    class B,B1,B2,B3 common\n    class C,C1,D,D1,E,E1 scanning</code></pre>"},{"location":"helm-charts/overview/architecture/#layered-architecture","title":"Layered Architecture","text":"<p>Our Helm charts follow a layered architecture pattern with three distinct layers:</p> <ol> <li>Core Infrastructure Layer (scanner-infrastructure)</li> <li>Foundation for all scanning operations</li> <li>RBAC and security model implementation</li> <li>Service account and access control</li> <li> <p>Namespace management</p> </li> <li> <p>Common Components Layer (common-scanner)</p> </li> <li>Reusable scanning utilities and scripts</li> <li>SAF CLI integration for compliance validation</li> <li>Threshold configuration for pass/fail criteria</li> <li> <p>Results processing and reporting</p> </li> <li> <p>Scanning Approaches Layer (approach-specific charts)</p> </li> <li>Specialized components for each scanning approach</li> <li>Test pods for demonstration and validation</li> <li>Approach-specific configurations</li> <li>Usage examples</li> </ol>"},{"location":"helm-charts/overview/architecture/#value-flow","title":"Value Flow","text":"<p>Values flow through the chart hierarchy, allowing configuration at multiple levels:</p> <pre><code>graph TD\n    A[User Values] --&gt; B[standard-scanner Values]\n    B --&gt; C[common-scanner Values]\n    C --&gt; D[scanner-infrastructure Values]\n    D --&gt; E[Final Configuration]</code></pre> <p>This allows:</p> <ul> <li>Global values set at top level</li> <li>Approach-specific overrides</li> <li>Component-specific settings</li> <li>Local environment customization</li> </ul>"},{"location":"helm-charts/overview/architecture/#deployment-flow","title":"Deployment Flow","text":"<p>The typical deployment flow involves these steps:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Helm\n    participant K8s as Kubernetes\n    participant Scanner\n\n    User-&gt;&gt;Helm: Install Chart\n    Helm-&gt;&gt;K8s: Create Resources\n    User-&gt;&gt;K8s: Generate Tokens\n    User-&gt;&gt;Scanner: Run Scan\n    Scanner-&gt;&gt;K8s: Access Container\n    Scanner-&gt;&gt;User: Return Results</code></pre> <ol> <li>User installs Helm chart</li> <li>Helm creates Kubernetes resources</li> <li>User generates short-lived tokens</li> <li>User runs scanning operation</li> <li>Scanner accesses container via K8s API</li> <li>Results returned to user</li> </ol>"},{"location":"helm-charts/overview/architecture/#integration-points","title":"Integration Points","text":"<p>Our charts provide integration points with external systems:</p> <pre><code>graph TD\n    subgraph \"Integration Points\"\n        Charts[Helm Charts] --&gt; CI[CI/CD Systems]\n        Charts --&gt; SM[Secret Management]\n        Charts --&gt; LO[Logging/Monitoring]\n        Charts --&gt; CMDB[CMDB/Inventory]\n    end</code></pre> <p>Key integration points:</p> <ul> <li>CI/CD Systems: Pipeline integration</li> <li>Secret Management: External secrets for tokens</li> <li>Logging/Monitoring: Result tracking and alerting</li> <li>CMDB/Inventory: Asset tracking and management</li> </ul>"},{"location":"helm-charts/overview/architecture/#chart-dependencies","title":"Chart Dependencies","text":"<p>Formal Helm chart dependencies are defined in Chart.yaml files:</p> Chart Dependencies scanner-infrastructure None common-scanner scanner-infrastructure standard-scanner common-scanner distroless-scanner common-scanner sidecar-scanner common-scanner <p>These dependencies ensure proper installation order and value inheritance.</p>"},{"location":"helm-charts/overview/inventory/","title":"Helm Charts Overview Directory Inventory","text":"<p>This document provides a directory overview of all overview-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/overview/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/overview directory contains high-level documentation about the Helm chart architecture and design:</p> <ul> <li>index.md: Main overview and introduction to Helm charts</li> <li>inventory.md: This directory listing</li> <li>architecture.md: Detailed architecture documentation including component relationships and design patterns</li> </ul>"},{"location":"helm-charts/overview/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The overview section provides:</p> <ul> <li>High-level introduction to all Helm charts</li> <li>Explanation of the layered architecture approach</li> <li>Description of chart relationships and dependencies</li> <li>Key features and benefits of the Helm chart implementation</li> <li>Getting started guidance for users</li> </ul>"},{"location":"helm-charts/overview/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Main Helm Charts Documentation</li> <li>Scanner Types Documentation</li> <li>Infrastructure Documentation</li> <li>Usage &amp; Customization Guides</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/","title":"Scanner Infrastructure Helm Chart","text":"<p>Directory Inventory</p> <p>See the Scanner Infrastructure Chart Inventory for a complete listing of files and resources in this directory.</p> <p>This chart provides the core infrastructure components for secure container scanning, including:</p> <ul> <li>RBAC configuration</li> <li>Service accounts</li> <li>Namespaces</li> <li>Supporting scripts and configurations</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#overview","title":"Overview","text":"<p>The Scanner Infrastructure Helm chart is the foundation for all container scanning approaches in this project. It creates the necessary Kubernetes resources to enable secure, least-privilege scanning access.</p>"},{"location":"helm-charts/scanner-infrastructure/#key-components","title":"Key Components","text":"<ul> <li>Namespace: Creates a dedicated namespace for scanning operations</li> <li>Service Account: Creates a service account with time-limited tokens</li> <li>RBAC: Sets up appropriate roles and role bindings with least-privilege access</li> <li>ConfigMap: Stores scripts and configuration for scanning operations</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#values","title":"Values","text":"Parameter Description Default <code>targetNamespace</code> Namespace where the scanning infrastructure will be deployed <code>inspec-test</code> <code>serviceAccount.name</code> Name of the service account for scanning <code>inspec-scanner</code> <code>serviceAccount.ttl</code> Time-to-live for service account tokens <code>1h</code> <code>rbac.roleName</code> Name of the RBAC role <code>scanner-role</code> <code>rbac.clusterWide</code> Whether to create cluster-wide permissions <code>false</code>"},{"location":"helm-charts/scanner-infrastructure/#usage","title":"Usage","text":"<p>See the main Helm Charts documentation for details on how to use this chart as part of the overall container scanning solution.</p>"},{"location":"helm-charts/scanner-infrastructure/#security-considerations","title":"Security Considerations","text":"<p>This chart is designed with security in mind:</p> <ul> <li>Time-limited tokens ensure credentials can't be misused long-term</li> <li>Least-privilege access model restricts scanning to specific pods</li> <li>Namespace isolation prevents cross-namespace access</li> <li>No privileged access required for container scanning</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/#related-charts","title":"Related Charts","text":"<ul> <li>Common Scanner - Common components used by all scanner types</li> <li>Standard Scanner - For standard containers</li> <li>Distroless Scanner - For distroless containers</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/inventory/","title":"Scanner Infrastructure Helm Chart Inventory","text":"<p>This document provides a directory overview of the Scanner Infrastructure Helm chart resources.</p>"},{"location":"helm-charts/scanner-infrastructure/inventory/#directory-contents","title":"Directory Contents","text":"<p>The Scanner Infrastructure Helm chart provides the core infrastructure components for secure container scanning:</p> <ul> <li>README.md: Original documentation (being migrated to this structure)</li> <li>index.md: Main MkDocs documentation page</li> <li>templates/: Kubernetes templates for infrastructure resources<ul> <li><code>configmap-scripts.yaml</code>: Configuration maps for scanning scripts</li> <li><code>namespace.yaml</code>: Namespace creation template</li> <li><code>rbac.yaml</code>: RBAC configuration with proper permissions</li> <li><code>serviceaccount.yaml</code>: Service account with token configuration</li> </ul> </li> <li>values.yaml: Default values for the Helm chart</li> <li>examples/: Example configurations<ul> <li><code>values-production.yaml</code>: Production-grade configuration</li> </ul> </li> </ul>"},{"location":"helm-charts/scanner-infrastructure/inventory/#primary-features","title":"Primary Features","text":"<ul> <li>Namespace isolation: Creates dedicated namespace for scanning operations</li> <li>Service Account: Creates service account with time-limited tokens</li> <li>RBAC: Sets up appropriate roles and role bindings with least-privilege access</li> <li>ConfigMap: Stores scripts and configuration for scanning operations</li> </ul>"},{"location":"helm-charts/scanner-infrastructure/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Main Helm Charts Overview</li> <li>Common Scanner Chart</li> <li>Standard Scanner Chart</li> <li>Distroless Scanner Chart</li> <li>Sidecar Scanner Chart</li> </ul>"},{"location":"helm-charts/scanner-types/","title":"Scanner Types","text":"<p>Directory Inventory</p> <p>See the Scanner Types Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/scanner-types/#introduction-to-scanner-types","title":"Introduction to Scanner Types","text":"<p>The Secure Kubernetes Container Scanning solution provides multiple specialized Helm charts for different container scanning approaches. Each scanner type is optimized for specific use cases and container types, allowing you to choose the most appropriate approach for your environment.</p>"},{"location":"helm-charts/scanner-types/#available-scanner-types","title":"Available Scanner Types","text":""},{"location":"helm-charts/scanner-types/#common-scanner","title":"Common Scanner","text":"<p>The Common Scanner provides shared components used by all scanner types:</p> <ul> <li>Common scripts and utilities</li> <li>SAF CLI integration</li> <li>Threshold configuration</li> <li>Results processing</li> </ul>"},{"location":"helm-charts/scanner-types/#kubernetes-api-scanner-standard","title":"Kubernetes API Scanner (Standard)","text":"<p>The Kubernetes API Scanner is our recommended approach for scanning standard containers:</p> <ul> <li>Uses the train-k8s-container transport</li> <li>Direct access via Kubernetes API</li> <li>Minimal attack surface</li> <li>Ideal for containers with shell access</li> </ul>"},{"location":"helm-charts/scanner-types/#debug-container-scanner-distroless","title":"Debug Container Scanner (Distroless)","text":"<p>The Debug Container Scanner specializes in scanning distroless containers:</p> <ul> <li>Uses ephemeral debug containers</li> <li>Compatible with containers lacking shell access</li> <li>Filesystem-based scanning approach</li> <li>Requires Kubernetes 1.16+ with ephemeral containers feature</li> </ul>"},{"location":"helm-charts/scanner-types/#sidecar-container-scanner","title":"Sidecar Container Scanner","text":"<p>The Sidecar Container Scanner offers a universal approach:</p> <ul> <li>Uses shared process namespace</li> <li>Works with both standard and distroless containers</li> <li>Deployed alongside target containers</li> <li>Immediate scanning capability</li> </ul>"},{"location":"helm-charts/scanner-types/#selecting-a-scanner-type","title":"Selecting a Scanner Type","text":"<p>When choosing a scanner type, consider:</p> <ol> <li>Container Types: Do you have standard containers, distroless containers, or both?</li> <li>Kubernetes Version: Does your cluster support debug containers?</li> <li>Security Requirements: Which security model best fits your needs?</li> <li>Operational Model: Will scans be triggered on-demand or during deployment?</li> </ol> <p>For most environments, we recommend:</p> <ul> <li>Standard Containers: Use the Kubernetes API Scanner</li> <li>Distroless Containers: Use the Debug Container Scanner</li> <li>Mixed Environment: Use approach-specific scanners for each container type</li> </ul>"},{"location":"helm-charts/scanner-types/#getting-started","title":"Getting Started","text":"<p>To get started with a specific scanner type:</p> <ol> <li>Review the overview page for your chosen scanner</li> <li>Check the configuration options and requirements</li> <li>Follow the installation and usage examples</li> <li>Explore customization options for your environment</li> </ol>"},{"location":"helm-charts/scanner-types/common-scanner/","title":"Common Scanner Chart","text":"<p>Directory Context</p> <p>This document is part of the Scanner Types Directory. See the Scanner Types Directory Inventory for related resources.</p>"},{"location":"helm-charts/scanner-types/common-scanner/#overview","title":"Overview","text":"<p>The <code>common-scanner</code> chart provides shared utilities and components for container scanning in Kubernetes. It builds on top of the <code>scanner-infrastructure</code> chart and delivers the core scanning functionality used by all scanning approach-specific charts.</p> <p>This chart implements scanning scripts, SAF CLI integration for compliance validation, and threshold configuration for pass/fail determination.</p>"},{"location":"helm-charts/scanner-types/common-scanner/#components","title":"Components","text":""},{"location":"helm-charts/scanner-types/common-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>ConfigMap: Scanning Scripts</li> <li>Shell scripts for executing CINC Auditor scans</li> <li>Helper utilities for results processing</li> <li> <p>Support for both standard and distroless scanning</p> </li> <li> <p>ConfigMap: Thresholds</p> </li> <li>Compliance threshold configuration</li> <li>Rules for pass/fail determination</li> <li>Customizable by severity level</li> </ol>"},{"location":"helm-charts/scanner-types/common-scanner/#features","title":"Features","text":""},{"location":"helm-charts/scanner-types/common-scanner/#saf-cli-integration","title":"SAF CLI Integration","text":"<p>The chart integrates with the MITRE SAF CLI for compliance reporting and validation:</p> <ul> <li>Threshold-Based Validation: Define pass/fail criteria</li> <li>Compliance Scoring: Calculate overall compliance percentage</li> <li>Results Formatting: Format scan results for reporting</li> <li>Failure Handling: Process scan failures with configurable behavior</li> </ul>"},{"location":"helm-charts/scanner-types/common-scanner/#scanning-scripts","title":"Scanning Scripts","text":"<p>Includes specialized scripts for different scanning scenarios:</p> <ol> <li>scan-container.sh: Standard container scanning</li> <li>scan-distroless-container.sh: Distroless container scanning with debug containers</li> <li>scan-with-sidecar.sh: Scanning with sidecar container approach</li> </ol>"},{"location":"helm-charts/scanner-types/common-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/scanner-types/common-scanner/#basic-installation","title":"Basic Installation","text":"<pre><code># Install common scanner components with default settings\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/scanner-types/common-scanner/#custom-threshold-configuration","title":"Custom Threshold Configuration","text":"<pre><code># Install with custom threshold settings\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set safCli.thresholdConfig.compliance.min=90 \\\n  --set safCli.thresholdConfig.failed.critical.max=0 \\\n  --set safCli.thresholdConfig.failed.high.max=0 \\\n  --set safCli.thresholdConfig.failed.medium.max=5 \\\n  --set safCli.thresholdConfig.failed.low.max=10\n</code></pre>"},{"location":"helm-charts/scanner-types/common-scanner/#external-threshold-file","title":"External Threshold File","text":"<pre><code># Install with reference to external threshold file\nhelm install common-scanner ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set safCli.thresholdFilePath=/path/to/threshold.yml\n</code></pre>"},{"location":"helm-charts/scanner-types/common-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/scanner-types/common-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/scanner-types/common-scanner/#script-configuration","title":"Script Configuration","text":"Parameter Description Default Required <code>scripts.generate</code> Generate helper scripts <code>true</code> No <code>scripts.directory</code> Directory for scripts <code>/tmp/inspec-scanner</code> No <code>scripts.includeScanScript</code> Include scan-container.sh <code>true</code> No <code>scripts.includeDistrolessScanScript</code> Include distroless scanning script <code>true</code> No <code>scripts.includeSidecarScanScript</code> Include sidecar scanning script <code>true</code> No"},{"location":"helm-charts/scanner-types/common-scanner/#saf-cli-configuration","title":"SAF CLI Configuration","text":"Parameter Description Default Required <code>safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/scanner-types/common-scanner/#threshold-configuration","title":"Threshold Configuration","text":"Parameter Description Default Required <code>safCli.thresholdConfig.compliance.min</code> Minimum compliance score <code>70</code> No <code>safCli.thresholdConfig.failed.critical.max</code> Maximum critical failures <code>0</code> No <code>safCli.thresholdConfig.failed.high.max</code> Maximum high failures <code>2</code> No <code>safCli.thresholdConfig.failed.medium.max</code> Maximum medium failures <code>5</code> No <code>safCli.thresholdConfig.failed.low.max</code> Maximum low failures <code>10</code> No <code>safCli.thresholdConfig.skipped.total.max</code> Maximum skipped controls <code>5</code> No"},{"location":"helm-charts/scanner-types/common-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/scanner-types/common-scanner/#basic-scanning","title":"Basic Scanning","text":"<p>After installing the chart, you can use the scanning scripts:</p> <pre><code># Generate kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n\n# Run standard container scan\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/scanner-types/common-scanner/#threshold-configuration-examples","title":"Threshold Configuration Examples","text":"<p>Create a custom threshold file for compliance requirements:</p> <pre><code># threshold.yml\ncompliance:\n  min: 90\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\n  medium:\n    max: 2\n  low:\n    max: 5\nskipped:\n  total:\n    max: 3\n</code></pre> <p>Then use it in scanning:</p> <pre><code># Run scan with custom threshold\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/scanner-types/common-scanner/#related-documentation","title":"Related Documentation","text":"<ul> <li>Kubernetes API Scanner</li> <li>Debug Container Scanner</li> <li>Sidecar Container Scanner</li> <li>Infrastructure Documentation</li> <li>Customization Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/scanner-types/distroless-scanner/","title":"Debug Container Scanner (Distroless)","text":"<p>Directory Context</p> <p>This document is part of the Scanner Types Directory. See the Scanner Types Directory Inventory for related resources.</p>"},{"location":"helm-charts/scanner-types/distroless-scanner/#overview","title":"Overview","text":"<p>The <code>distroless-scanner</code> chart implements the Debug Container Approach for scanning distroless containers in Kubernetes. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specialized components for scanning containers without shell access.</p> <p>The Debug Container Approach uses Kubernetes ephemeral debug containers to temporarily attach to target pods and access the filesystem of distroless containers, enabling compliance scanning without modifying the original containers.</p>"},{"location":"helm-charts/scanner-types/distroless-scanner/#components","title":"Components","text":""},{"location":"helm-charts/scanner-types/distroless-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo distroless container for testing</li> <li>Typically based on Google's distroless images</li> <li> <p>Demonstrates distroless scanning capabilities</p> </li> <li> <p>RBAC for Ephemeral Containers</p> </li> <li>Additional permissions for ephemeral container creation</li> <li>Limited to specific pods when resource names are used</li> </ol> <p>This chart primarily relies on components from its dependencies:</p> <ul> <li><code>common-scanner</code>: Scanning scripts and SAF CLI integration</li> <li><code>scanner-infrastructure</code>: Core RBAC, service accounts, and security model</li> </ul>"},{"location":"helm-charts/scanner-types/distroless-scanner/#features","title":"Features","text":""},{"location":"helm-charts/scanner-types/distroless-scanner/#ephemeral-container-scanning","title":"Ephemeral Container Scanning","text":"<p>The Debug Container Approach provides these capabilities:</p> <ul> <li>Distroless Container Support: Scan containers without shell access</li> <li>Non-Intrusive: Temporary debug containers that are removed after scanning</li> <li>Filesystem Analysis: Read access to target container filesystem</li> <li>Specialized Profiles: Support for profiles focused on filesystem analysis</li> <li>Kubernetes 1.16+ Required: Uses ephemeral container feature</li> </ul>"},{"location":"helm-charts/scanner-types/distroless-scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Temporary Attack Surface: Debug container is only active during scanning</li> <li>Minimal Permissions: Limited access to specific target containers</li> <li>Non-Persistent: Debug containers are automatically removed when scanning completes</li> <li>Read-Only Analysis: Filesystem access is typically read-only</li> </ul>"},{"location":"helm-charts/scanner-types/distroless-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/scanner-types/distroless-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true \\\n  --set common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled=true\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app \\\n  --set common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled=true\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#installation-with-custom-debug-container","title":"Installation with Custom Debug Container","text":"<pre><code># Install with custom debug container settings\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.image=alpine:3.15 \\\n  --set debugContainer.command=\"/bin/sh\" \\\n  --set debugContainer.args=\"-c,sleep 3600\"\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/scanner-types/distroless-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No <code>common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container permissions <code>true</code> Yes"},{"location":"helm-charts/scanner-types/distroless-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>distroless-target-helm</code> No <code>testPod.image</code> Test pod image <code>gcr.io/distroless/base:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sleep\", \"3600\"]</code> No"},{"location":"helm-charts/scanner-types/distroless-scanner/#debug-container-configuration","title":"Debug Container Configuration","text":"Parameter Description Default Required <code>debugContainer.image</code> Debug container image <code>alpine:latest</code> No <code>debugContainer.command</code> Debug container command <code>null</code> No <code>debugContainer.args</code> Debug container arguments <code>null</code> No <code>debugContainer.timeout</code> Debug container timeout in seconds <code>600</code> No"},{"location":"helm-charts/scanner-types/distroless-scanner/#scanning-configuration-inherited-from-common-scanner","title":"Scanning Configuration (Inherited from common-scanner)","text":"Parameter Description Default Required <code>common-scanner.safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>common-scanner.safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>common-scanner.safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/scanner-types/distroless-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/scanner-types/distroless-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Generate kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n\n# Run distroless scan against test pod\n./kubernetes-scripts/scan-distroless-container.sh inspec-test distroless-target-helm distroless ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#using-with-existing-distroless-applications","title":"Using with Existing Distroless Applications","text":"<p>For scanning existing distroless application containers:</p> <pre><code># Generate kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh prod-scanning inspec-scanner ./kubeconfig.yaml\n\n# Run scan against distroless application container\n./kubernetes-scripts/scan-distroless-container.sh prod-scanning my-distroless-app application-container ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#using-with-saf-cli-for-compliance-validation","title":"Using with SAF CLI for Compliance Validation","text":"<pre><code># Run scan with compliance validation\n./kubernetes-scripts/scan-distroless-container.sh prod-scanning my-distroless-app application-container \\\n  ./examples/cinc-profiles/container-baseline \\\n  --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/scanner-types/distroless-scanner/#limitations","title":"Limitations","text":"<ol> <li>Kubernetes Version Requirement: Requires Kubernetes 1.16+ for ephemeral container support</li> <li>Command Execution: Cannot execute commands in the target container, only filesystem access</li> <li>Profile Compatibility: Standard profiles that rely on command execution won't work properly</li> <li>Alpha/Beta Feature: Ephemeral containers were in alpha/beta stage in earlier Kubernetes versions</li> </ol>"},{"location":"helm-charts/scanner-types/distroless-scanner/#related-documentation","title":"Related Documentation","text":"<ul> <li>Common Scanner</li> <li>Kubernetes API Scanner</li> <li>Sidecar Scanner</li> <li>Security Considerations</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/scanner-types/inventory/","title":"Scanner Types Directory Inventory","text":"<p>This document provides a directory overview of all scanner type-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/scanner-types/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/scanner-types directory contains documentation for all scanner types:</p> <ul> <li>index.md: Overview of all scanner types and selection guidance</li> <li>inventory.md: This directory listing</li> <li>common-scanner.md: Documentation for the Common Scanner chart</li> <li>standard-scanner.md: Documentation for the Kubernetes API Scanner chart</li> <li>distroless-scanner.md: Documentation for the Debug Container Scanner chart</li> <li>sidecar-scanner.md: Documentation for the Sidecar Container Scanner chart</li> </ul>"},{"location":"helm-charts/scanner-types/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The scanner types section provides:</p> <ul> <li>Introduction to different scanner approaches</li> <li>Detailed documentation for each scanner chart</li> <li>Configuration options and examples</li> <li>Use cases and limitations for each approach</li> <li>Cross-references to related security and infrastructure documentation</li> </ul>"},{"location":"helm-charts/scanner-types/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Overview</li> <li>Infrastructure Documentation</li> <li>Usage &amp; Customization Guides</li> <li>Security Considerations</li> <li>Operations &amp; Troubleshooting</li> </ul>"},{"location":"helm-charts/scanner-types/sidecar-scanner/","title":"Sidecar Container Scanner","text":"<p>Directory Context</p> <p>This document is part of the Scanner Types Directory. See the Scanner Types Directory Inventory for related resources.</p>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#overview","title":"Overview","text":"<p>The <code>sidecar-scanner</code> chart implements the Sidecar Container Approach for universal container scanning in Kubernetes. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specialized components for scanning using process namespace sharing.</p> <p>The Sidecar Container Approach deploys a scanner container alongside the target container in the same pod, using Kubernetes shared process namespace feature to access the target container's filesystem and processes.</p>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#components","title":"Components","text":""},{"location":"helm-charts/scanner-types/sidecar-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo pod with target and scanner containers</li> <li>Demonstrates sidecar scanning approach</li> <li> <p>Shows process namespace sharing configuration</p> </li> <li> <p>ConfigMap: Profiles</p> </li> <li>CINC Auditor profiles for container scanning</li> <li> <p>Pre-packaged compliance profiles</p> </li> <li> <p>ConfigMap: Thresholds</p> </li> <li>Compliance threshold configurations</li> <li>Custom threshold settings for the sidecar approach</li> </ol> <p>This chart primarily relies on components from its dependencies:</p> <ul> <li><code>common-scanner</code>: Scanning scripts and SAF CLI integration</li> <li><code>scanner-infrastructure</code>: Core RBAC, service accounts, and security model</li> </ul>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#features","title":"Features","text":""},{"location":"helm-charts/scanner-types/sidecar-scanner/#sidecar-container-scanning","title":"Sidecar Container Scanning","text":"<p>The Sidecar Container Approach provides these capabilities:</p> <ul> <li>Universal Container Support: Works with both standard and distroless containers</li> <li>Process Namespace Sharing: Access to target container processes and filesystem</li> <li>Pre-Deployment Integration: Sidecar is deployed with the target container</li> <li>Immediate Scanning: Can scan immediately after container startup</li> <li>Result Persistence: Can store results in shared volumes</li> </ul>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Increased Attack Surface: Persistent sidecar container increases the attack surface</li> <li>Process Namespace Breach: Violates process isolation between containers</li> <li>Resource Overhead: Additional container in every pod adds resource overhead</li> <li>One Process Per Container: Violates the Docker best practice of \"one process per container\"</li> </ul>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/scanner-types/sidecar-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app\n</code></pre>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#installation-with-custom-scanner-image","title":"Installation with Custom Scanner Image","text":"<pre><code># Install with custom scanner image and profiles\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=registry.example.com/cinc-auditor:5.18.14 \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=200m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/scanner-types/sidecar-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/scanner-types/sidecar-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>sidecar-target</code> No <code>testPod.targetImage</code> Target container image <code>nginx:latest</code> No <code>testPod.shareProcessNamespace</code> Enable process namespace sharing <code>true</code> Yes"},{"location":"helm-charts/scanner-types/sidecar-scanner/#scanner-configuration","title":"Scanner Configuration","text":"Parameter Description Default Required <code>scanner.image</code> Scanner container image <code>chef/inspec:5.18.14</code> No <code>scanner.command</code> Scanner container command <code>null</code> No <code>scanner.args</code> Scanner container arguments <code>null</code> No <code>scanner.resources.requests.cpu</code> CPU request <code>100m</code> No <code>scanner.resources.requests.memory</code> Memory request <code>256Mi</code> No <code>scanner.resources.limits.cpu</code> CPU limit <code>200m</code> No <code>scanner.resources.limits.memory</code> Memory limit <code>512Mi</code> No"},{"location":"helm-charts/scanner-types/sidecar-scanner/#profile-configuration","title":"Profile Configuration","text":"Parameter Description Default Required <code>profiles.default.enabled</code> Enable default profile <code>true</code> No <code>profiles.default.path</code> Default profile path <code>/profiles/container-baseline</code> No <code>profiles.custom</code> Custom profile configuration <code>[]</code> No"},{"location":"helm-charts/scanner-types/sidecar-scanner/#results-configuration","title":"Results Configuration","text":"Parameter Description Default Required <code>results.directory</code> Results directory in scanner <code>/results</code> No <code>results.format</code> Results output format <code>json</code> No <code>results.thresholdEnabled</code> Enable threshold validation <code>true</code> No"},{"location":"helm-charts/scanner-types/sidecar-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/scanner-types/sidecar-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Check if pod is ready\nkubectl wait --for=condition=ready pod/sidecar-target -n inspec-test\n\n# Check scan results\nkubectl exec -n inspec-test sidecar-target -c scanner -- ls -la /results\n\n# Copy results locally\nkubectl cp inspec-test/sidecar-target:/results/scan-results.json ./results.json -c scanner\n\n# Process results with SAF CLI\nsaf summary --input ./results.json --output-md ./summary.md\n</code></pre>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#using-with-existing-applications","title":"Using with Existing Applications","text":"<p>For scanning existing applications, you would typically add the sidecar container to your application pod specification:</p> <pre><code># Example application pod with scanner sidecar\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-application\n  namespace: prod-scanning\nspec:\n  shareProcessNamespace: true  # Important for sidecar scanning\n  containers:\n  - name: application\n    image: my-application:latest\n  - name: scanner\n    image: chef/inspec:5.18.14\n    command: [\"sh\", \"-c\"]\n    args:\n    - |\n      inspec exec /profiles/container-baseline -t proc://1/root --reporter json:/results/scan-results.json;\n      touch /results/scan-complete;\n      sleep 3600;\n    volumeMounts:\n    - name: results\n      mountPath: /results\n    - name: profiles\n      mountPath: /profiles\n  volumes:\n  - name: results\n    emptyDir: {}\n  - name: profiles\n    configMap:\n      name: inspec-profiles\n</code></pre> <p>Alternatively, use the scan script:</p> <pre><code># Deploy application with scanner sidecar\n./kubernetes-scripts/scan-with-sidecar.sh prod-scanning my-app:latest ./profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#limitations","title":"Limitations","text":"<ol> <li>Security Boundary Violation: Process namespace sharing breaks container isolation</li> <li>Resource Overhead: Additional container per pod increases resource consumption</li> <li>Deployment Changes: Requires modifications to application deployment manifests</li> <li>Shared Lifecycle: Scanner container lifecycle tied to target container</li> </ol>"},{"location":"helm-charts/scanner-types/sidecar-scanner/#related-documentation","title":"Related Documentation","text":"<ul> <li>Common Scanner</li> <li>Kubernetes API Scanner</li> <li>Debug Container Scanner</li> <li>Security Considerations</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/scanner-types/standard-scanner/","title":"Kubernetes API Scanner (Standard)","text":"<p>Directory Context</p> <p>This document is part of the Scanner Types Directory. See the Scanner Types Directory Inventory for related resources.</p>"},{"location":"helm-charts/scanner-types/standard-scanner/#overview","title":"Overview","text":"<p>The <code>standard-scanner</code> chart implements the Kubernetes API Approach for container scanning, which is our recommended enterprise approach for scanning containers with shell access. This chart builds on the <code>common-scanner</code> and <code>scanner-infrastructure</code> charts, adding specific resources for standard container scanning.</p> <p>The Kubernetes API Approach uses the <code>train-k8s-container</code> transport plugin for CINC Auditor to directly scan containers via the Kubernetes API, providing the most efficient and secure scanning method.</p>"},{"location":"helm-charts/scanner-types/standard-scanner/#components","title":"Components","text":""},{"location":"helm-charts/scanner-types/standard-scanner/#key-resources-created","title":"Key Resources Created","text":"<ol> <li>Test Pod (Optional)</li> <li>Demo pod for testing and validation</li> <li>Standard Linux container with shell</li> <li>Demonstrates scanning capabilities</li> </ol> <p>This chart primarily relies on components from its dependencies:</p> <ul> <li><code>common-scanner</code>: Scanning scripts and SAF CLI integration</li> <li><code>scanner-infrastructure</code>: RBAC, service accounts, and security model</li> </ul>"},{"location":"helm-charts/scanner-types/standard-scanner/#features","title":"Features","text":""},{"location":"helm-charts/scanner-types/standard-scanner/#direct-container-scanning","title":"Direct Container Scanning","text":"<p>The Kubernetes API Approach provides these advantages:</p> <ul> <li>Minimal Resource Footprint: Uses only <code>kubectl exec</code> for scanning</li> <li>No Additional Containers: Doesn't require debug or sidecar containers</li> <li>Streamlined Security Model: Simplest and most secure approach</li> <li>Fast Execution: Direct access to container without intermediate layers</li> <li>Enterprise Recommended: Ideal for production environments</li> </ul>"},{"location":"helm-charts/scanner-types/standard-scanner/#security-benefits","title":"Security Benefits","text":"<ul> <li>Minimal Attack Surface: Smallest possible attack surface</li> <li>Container Integrity: No modifications to target containers</li> <li>One Process Per Container: Maintains Docker best practice of one process per container</li> <li>Strong Resource Boundaries: Clear separation between scanner and target</li> </ul>"},{"location":"helm-charts/scanner-types/standard-scanner/#installation-options","title":"Installation Options","text":""},{"location":"helm-charts/scanner-types/standard-scanner/#basic-installation-local-development","title":"Basic Installation (Local Development)","text":"<pre><code># Install with test pod for local testing\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#production-installation","title":"Production Installation","text":"<pre><code># Install for production use without test pod\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set testPod.deploy=false \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#installation-with-custom-thresholds","title":"Installation with Custom Thresholds","text":"<pre><code># Install with custom compliance thresholds\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.safCli.thresholdConfig.compliance.min=90 \\\n  --set common-scanner.safCli.thresholdConfig.failed.critical.max=0 \\\n  --set common-scanner.safCli.thresholdConfig.failed.high.max=0\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"helm-charts/scanner-types/standard-scanner/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.serviceAccount.name</code> Service account name <code>inspec-scanner</code> No"},{"location":"helm-charts/scanner-types/standard-scanner/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>inspec-target-helm</code> No <code>testPod.image</code> Test pod image <code>busybox:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sh\", \"-c\", \"while true; do sleep 3600; done\"]</code> No"},{"location":"helm-charts/scanner-types/standard-scanner/#scanning-configuration-inherited-from-common-scanner","title":"Scanning Configuration (Inherited from common-scanner)","text":"Parameter Description Default Required <code>common-scanner.safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>common-scanner.safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>common-scanner.safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/scanner-types/standard-scanner/#usage-examples","title":"Usage Examples","text":""},{"location":"helm-charts/scanner-types/standard-scanner/#local-testing-with-test-pod","title":"Local Testing with Test Pod","text":"<p>After installing with the test pod enabled:</p> <pre><code># Generate kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh inspec-test inspec-scanner ./kubeconfig.yaml\n\n# Run scan against test pod\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://inspec-test/inspec-target-helm/busybox\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#using-with-existing-applications","title":"Using with Existing Applications","text":"<p>For scanning existing application containers:</p> <pre><code># Generate kubeconfig\n./kubernetes-scripts/generate-kubeconfig.sh prod-scanning inspec-scanner ./kubeconfig.yaml\n\n# Run scan against application container\nKUBECONFIG=./kubeconfig.yaml cinc-auditor exec ./examples/cinc-profiles/container-baseline \\\n  -t k8s-container://prod-scanning/my-application-pod/application-container\n\n# Alternatively, use the scan script\n./kubernetes-scripts/scan-container.sh prod-scanning my-application-pod application-container ./examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#using-with-saf-cli-for-compliance-validation","title":"Using with SAF CLI for Compliance Validation","text":"<pre><code># Run scan with compliance validation\n./kubernetes-scripts/scan-container.sh prod-scanning my-application-pod application-container \\\n  ./examples/cinc-profiles/container-baseline \\\n  --threshold-file=./threshold.yml\n</code></pre>"},{"location":"helm-charts/scanner-types/standard-scanner/#related-documentation","title":"Related Documentation","text":"<ul> <li>Common Scanner</li> <li>Distroless Scanner</li> <li>Sidecar Scanner</li> <li>Security Considerations</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/security/","title":"Helm Chart Security","text":"<p>Directory Inventory</p> <p>See the Security Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/security/#overview","title":"Overview","text":"<p>This section outlines security considerations for deploying and using the Secure Kubernetes Container Scanning Helm charts. Security is a core design principle of our solution, with all charts implementing a least-privilege model, short-lived credentials, and other security best practices.</p>"},{"location":"helm-charts/security/#security-architecture","title":"Security Architecture","text":""},{"location":"helm-charts/security/#security-first-design","title":"Security-First Design","text":"<p>Our Helm charts implement a layered security architecture:</p> <ol> <li>Core Security Layer (scanner-infrastructure)</li> <li>Least-privilege RBAC implementation</li> <li>Short-lived access tokens</li> <li>Namespace isolation</li> <li> <p>Service account permissions</p> </li> <li> <p>Operational Security Layer (common-scanner)</p> </li> <li>Secure script execution</li> <li>Result data protection</li> <li> <p>Failure handling</p> </li> <li> <p>Approach-Specific Security Controls</p> </li> <li>Different security models for each scanning approach</li> <li>Approach-specific hardening options</li> </ol>"},{"location":"helm-charts/security/#security-documentation","title":"Security Documentation","text":"<p>The security documentation is organized into the following sections:</p> <ul> <li>Best Practices: Recommended security practices for deploying and using the Helm charts</li> <li>RBAC Hardening: Detailed guidance for securing RBAC configurations</li> <li>Risk Assessment: Security risk assessment for each Helm chart component</li> </ul>"},{"location":"helm-charts/security/#security-considerations-by-scanning-approach","title":"Security Considerations by Scanning Approach","text":""},{"location":"helm-charts/security/#kubernetes-api-approach-standard-scanner","title":"Kubernetes API Approach (standard-scanner)","text":"<p>This approach offers the strongest security posture:</p> <ul> <li>Minimal Attack Surface: Uses only Kubernetes API exec</li> <li>No Additional Containers: Maintains container isolation</li> <li>Clean Security Boundary: Clear separation between scanner and target</li> </ul>"},{"location":"helm-charts/security/#debug-container-approach-distroless-scanner","title":"Debug Container Approach (distroless-scanner)","text":"<p>This approach has specific security considerations:</p> <ul> <li>Temporary Attack Surface Increase: Ephemeral debug container</li> <li>Process Namespace Consideration: Debug container can access target processes</li> <li>Limited Duration: Container exists only during scanning</li> </ul>"},{"location":"helm-charts/security/#sidecar-container-approach-sidecar-scanner","title":"Sidecar Container Approach (sidecar-scanner)","text":"<p>This approach has the highest security impact:</p> <ul> <li>Persistent Attack Surface Increase: Sidecar container remains with pod</li> <li>Process Namespace Sharing: Breaks container isolation boundary</li> <li>Resource Consumption: Additional container in every pod</li> </ul>"},{"location":"helm-charts/security/#getting-started-with-security","title":"Getting Started with Security","text":"<p>To implement a secure scanning solution:</p> <ol> <li>Review the Security Best Practices for deployment recommendations</li> <li>Follow the RBAC Hardening guide for proper access control</li> <li>Understand the Risk Assessment for each component</li> <li>Choose the appropriate scanning approach based on your security requirements</li> <li>Implement the recommended security controls for your environment</li> </ol>"},{"location":"helm-charts/security/best-practices/","title":"Helm Chart Security Best Practices","text":"<p>Directory Context</p> <p>This document is part of the Security Directory. See the Security Directory Inventory for related resources.</p>"},{"location":"helm-charts/security/best-practices/#overview","title":"Overview","text":"<p>This document outlines security best practices for deploying and using the Secure Kubernetes Container Scanning Helm charts. Following these practices will help ensure a secure deployment that minimizes potential security risks.</p>"},{"location":"helm-charts/security/best-practices/#rbac-hardening","title":"RBAC Hardening","text":"<p>Implement strict RBAC controls:</p> <pre><code># Use resource name restrictions for maximum security\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app\n</code></pre> <p>This configuration limits the scanner's access to only pods with the specific label and name.</p>"},{"location":"helm-charts/security/best-practices/#token-lifecycle-management","title":"Token Lifecycle Management","text":"<p>Minimize token lifespan for enhanced security:</p> <pre><code># Reduce token validity period for production environments\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set token.duration=15  # 15 minutes\n</code></pre> <p>Always generate fresh tokens for each scanning operation:</p> <pre><code># Generate a short-lived token before each scan\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml\n\n# Run scan with the fresh token\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n\n# Remove token after scan\nrm ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/security/best-practices/#network-security","title":"Network Security","text":"<p>Implement network policies to restrict scanner communication:</p> <pre><code># network-policy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-policy\n  namespace: scanning-namespace\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: scanning-namespace\n    - podSelector:\n        matchLabels:\n          scan-target: \"true\"\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - protocol: TCP\n      port: 443  # Kubernetes API\n</code></pre> <p>Apply the network policy:</p> <pre><code>kubectl apply -f network-policy.yaml\n</code></pre>"},{"location":"helm-charts/security/best-practices/#secure-container-configuration","title":"Secure Container Configuration","text":"<p>Enforce security features in scanner containers:</p> <pre><code># Apply security hardening for sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.securityContext.runAsNonRoot=true \\\n  --set scanner.securityContext.runAsUser=10000 \\\n  --set scanner.securityContext.readOnlyRootFilesystem=true \\\n  --set scanner.securityContext.allowPrivilegeEscalation=false \\\n  --set scanner.securityContext.capabilities.drop[0]=ALL\n</code></pre> <p>For the debug container approach:</p> <pre><code># Apply security hardening for debug containers\nhelm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.securityContext.runAsNonRoot=true \\\n  --set debugContainer.securityContext.runAsUser=10000 \\\n  --set debugContainer.securityContext.readOnlyRootFilesystem=true\n</code></pre>"},{"location":"helm-charts/security/best-practices/#namespace-isolation","title":"Namespace Isolation","text":"<p>Use dedicated namespaces for scanning operations:</p> <pre><code># Create dedicated namespace with proper labels\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanner-namespace \\\n  --set namespace.labels.purpose=security-scanning \\\n  --set namespace.labels.data-sensitivity=restricted\n</code></pre>"},{"location":"helm-charts/security/best-practices/#resource-limitations","title":"Resource Limitations","text":"<p>Apply resource limits to all scanner components:</p> <pre><code># Set resource limits for sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=200m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre>"},{"location":"helm-charts/security/best-practices/#secret-management","title":"Secret Management","text":"<p>Integrate with external secret management systems:</p> <pre><code># AWS Secrets Manager integration\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/secrets-access-role\n</code></pre>"},{"location":"helm-charts/security/best-practices/#approach-specific-security-practices","title":"Approach-Specific Security Practices","text":""},{"location":"helm-charts/security/best-practices/#standard-scanner-kubernetes-api","title":"Standard Scanner (Kubernetes API)","text":"<pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.token.duration=15 \\\n  --set common-scanner.safCli.failOnThresholdError=true\n</code></pre>"},{"location":"helm-charts/security/best-practices/#distroless-scanner-debug-container","title":"Distroless Scanner (Debug Container)","text":"<pre><code>helm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.token.duration=15 \\\n  --set debugContainer.securityContext.runAsNonRoot=true \\\n  --set debugContainer.securityContext.runAsUser=10000 \\\n  --set debugContainer.securityContext.readOnlyRootFilesystem=true \\\n  --set debugContainer.timeout=300  # Limit debug container lifetime\n</code></pre>"},{"location":"helm-charts/security/best-practices/#sidecar-scanner","title":"Sidecar Scanner","text":"<pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set scanner.securityContext.runAsNonRoot=true \\\n  --set scanner.securityContext.runAsUser=10000 \\\n  --set scanner.securityContext.readOnlyRootFilesystem=true \\\n  --set scanner.securityContext.allowPrivilegeEscalation=false \\\n  --set scanner.securityContext.capabilities.drop[0]=ALL\n</code></pre>"},{"location":"helm-charts/security/best-practices/#security-incident-response","title":"Security Incident Response","text":"<p>Prepare for security incidents with these steps:</p> <ol> <li>Token Revocation: Script to revoke all scanner tokens</li> </ol> <pre><code>#!/bin/bash\n# revoke-scanner-tokens.sh\nNAMESPACE=\"scanning-namespace\"\nSERVICE_ACCOUNT=\"inspec-scanner\"\n\n# Find all secrets for the service account\nSECRETS=$(kubectl get serviceaccount $SERVICE_ACCOUNT -n $NAMESPACE -o json | jq -r '.secrets[].name')\n\n# Delete each secret to force recreation\nfor SECRET in $SECRETS; do\n  kubectl delete secret $SECRET -n $NAMESPACE\ndone\n\necho \"All tokens for $SERVICE_ACCOUNT in $NAMESPACE have been revoked.\"\n</code></pre> <ol> <li>Scanner Shutdown: Process to immediately stop all scanning operations</li> </ol> <pre><code># Delete all scanner pods\nkubectl delete pods -n scanning-namespace -l role=scanner\n\n# Revoke RBAC temporarily if needed\nkubectl delete rolebinding -n scanning-namespace scanner-rolebinding\n</code></pre>"},{"location":"helm-charts/security/best-practices/#security-standards-alignment","title":"Security Standards Alignment","text":"<p>Our Helm charts align with key security standards and frameworks:</p>"},{"location":"helm-charts/security/best-practices/#cis-kubernetes-benchmark","title":"CIS Kubernetes Benchmark","text":"<ul> <li>RBAC Limitation: Strict role-based access control</li> <li>Namespace Segregation: Isolated scanning namespace</li> <li>Service Account Controls: Dedicated service accounts with minimal permissions</li> <li>Secret Management: Proper handling of token secrets</li> </ul>"},{"location":"helm-charts/security/best-practices/#nist-sp-800-190-container-security","title":"NIST SP 800-190 Container Security","text":"<ul> <li>Least Privilege: Minimal permissions for scanning operations</li> <li>Container Isolation: Maintaining container boundaries where possible</li> <li>Image Security: Support for scanning image content</li> <li>Runtime Security: Controlled access to container runtimes</li> </ul>"},{"location":"helm-charts/security/best-practices/#comprehensive-security-checklist","title":"Comprehensive Security Checklist","text":"<ul> <li> Use the most secure scanning approach for your environment</li> <li> Implement strict RBAC controls with resource name restrictions</li> <li> Keep token lifetimes short (15-30 minutes)</li> <li> Apply security contexts to all scanner containers</li> <li> Implement network policies to restrict scanner communications</li> <li> Set appropriate resource limits and requests</li> <li> Use dedicated namespaces for scanning operations</li> <li> Integrate with cloud provider security features</li> <li> Prepare incident response procedures</li> <li> Regularly update and audit your scanning infrastructure</li> <li> Remove sensitive data from scan results</li> <li> Properly secure compliance reports</li> </ul>"},{"location":"helm-charts/security/best-practices/#related-documentation","title":"Related Documentation","text":"<ul> <li>RBAC Hardening</li> <li>Risk Assessment</li> <li>Infrastructure RBAC</li> <li>Infrastructure Service Accounts</li> </ul>"},{"location":"helm-charts/security/inventory/","title":"Security Directory Inventory","text":"<p>This document provides a directory overview of all security-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/security/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/security directory contains documentation for security aspects of the Helm charts:</p> <ul> <li>index.md: Overview of security considerations</li> <li>inventory.md: This directory listing</li> <li>best-practices.md: Security best practices for Helm chart deployment</li> <li>rbac-hardening.md: Guide for hardening RBAC configurations</li> <li>risk-assessment.md: Security risk assessment by chart component</li> </ul>"},{"location":"helm-charts/security/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The security section provides:</p> <ul> <li>Introduction to the security architecture of the Helm charts</li> <li>Detailed security best practices for different deployment scenarios</li> <li>Guidance for implementing and hardening RBAC controls</li> <li>Risk assessment for each chart component</li> <li>Security considerations for different scanning approaches</li> </ul>"},{"location":"helm-charts/security/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Overview</li> <li>Scanner Types Documentation</li> <li>Infrastructure Documentation</li> <li>Usage &amp; Customization</li> <li>Operations &amp; Troubleshooting</li> </ul>"},{"location":"helm-charts/security/rbac-hardening/","title":"RBAC Hardening Guide","text":"<p>Directory Context</p> <p>This document is part of the Security Directory. See the Security Directory Inventory for related resources.</p>"},{"location":"helm-charts/security/rbac-hardening/#overview","title":"Overview","text":"<p>This guide provides detailed instructions for hardening the Role-Based Access Control (RBAC) configuration in the Secure Kubernetes Container Scanning Helm charts. Proper RBAC hardening is essential for maintaining a secure scanning environment and adhering to the principle of least privilege.</p>"},{"location":"helm-charts/security/rbac-hardening/#understanding-scanner-rbac-requirements","title":"Understanding Scanner RBAC Requirements","text":"<p>The scanner requires these core permissions:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\", \"create\"]\n</code></pre> <p>For the debug container approach, additional permissions are needed:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"update\", \"patch\"]\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#rbac-hardening-techniques","title":"RBAC Hardening Techniques","text":""},{"location":"helm-charts/security/rbac-hardening/#1-resource-name-restrictions","title":"1. Resource Name Restrictions","text":"<p>Limit access to specific pod names:</p> <pre><code># Install with resource name restrictions\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.resourceNames[0]=app-pod-1 \\\n  --set rbac.resourceNames[1]=app-pod-2\n</code></pre> <p>This creates a role that can only access the specifically named pods:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\", \"create\"]\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#2-label-selector-restrictions","title":"2. Label Selector Restrictions","text":"<p>Use label selectors for dynamic access control:</p> <pre><code># Install with label selector restrictions\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app \\\n  --set rbac.podSelectorLabels.scannable=true\n</code></pre> <p>This creates a role that can only access pods with specific labels.</p>"},{"location":"helm-charts/security/rbac-hardening/#3-namespace-scoping","title":"3. Namespace Scoping","text":"<p>Limit scanner access to specific namespaces:</p> <pre><code># Create namespace-specific scanner infrastructure\nhelm install dev-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=dev-namespace \\\n  --set rbac.roleName=dev-scanner-role\n\nhelm install prod-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=prod-namespace \\\n  --set rbac.roleName=prod-scanner-role\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#4-verb-limitation","title":"4. Verb Limitation","text":"<p>Restrict the verbs to only those required:</p> <pre><code># Customize RBAC verbs for specific resources\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.rules.core.verbs[0]=get \\\n  --set rbac.rules.core.verbs[1]=list \\\n  --set rbac.rules.core.verbs[2]=create \\\n  --set rbac.rules.ephemeralContainers.enabled=true \\\n  --set rbac.rules.ephemeralContainers.verbs[0]=update\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#5-disable-unused-permissions","title":"5. Disable Unused Permissions","text":"<p>Disable permissions that are not needed:</p> <pre><code># Disable ephemeral container permissions for standard scanner\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled=false\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#advanced-rbac-hardening","title":"Advanced RBAC Hardening","text":""},{"location":"helm-charts/security/rbac-hardening/#time-based-rbac","title":"Time-Based RBAC","text":"<p>Implement time-based access with TokenRequest API:</p> <pre><code># Generate short-lived token (15 minutes)\nkubectl create token inspec-scanner -n scanning-namespace --duration=15m &gt; token.txt\n\n# Use token for scanning\nKUBECONFIG=/path/to/kubeconfig \\\nK8S_AUTH_TOKEN=$(cat token.txt) \\\n./kubernetes-scripts/scan-container.sh scanning-namespace target-pod container-name ./profiles/container-baseline\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#dynamic-rbac","title":"Dynamic RBAC","text":"<p>For CI/CD pipelines, create temporary RBAC bindings:</p> <pre><code># Create temporary role binding for CI job\nkubectl create rolebinding ci-scanner-binding \\\n  --role=scanner-role \\\n  --serviceaccount=scanning-namespace:inspec-scanner \\\n  --namespace=scanning-namespace \\\n  --dry-run=client -o yaml | \\\n  kubectl apply -f -\n\n# Run scans\n\n# Clean up after scanning\nkubectl delete rolebinding ci-scanner-binding -n scanning-namespace\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#rbac-validation","title":"RBAC Validation","text":""},{"location":"helm-charts/security/rbac-hardening/#verify-rbac-configuration","title":"Verify RBAC Configuration","text":"<p>Check that RBAC permissions are properly restricted:</p> <pre><code># Check role permissions\nkubectl get role scanner-role -n scanning-namespace -o yaml\n\n# Check role binding\nkubectl get rolebinding scanner-rolebinding -n scanning-namespace -o yaml\n\n# Verify service account has proper binding\nkubectl get rolebinding -n scanning-namespace -o json | \\\n  jq '.items[] | select(.subjects[] | select(.kind==\"ServiceAccount\" and .name==\"inspec-scanner\"))'\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#test-access-limitations","title":"Test Access Limitations","text":"<p>Validate that access is properly limited:</p> <pre><code># Try to access pod in another namespace (should fail)\nKUBECONFIG=./scanner-kubeconfig.yaml kubectl get pods -n other-namespace\n\n# Try to access pod without proper labels (should fail)\nKUBECONFIG=./scanner-kubeconfig.yaml kubectl exec -it non-target-pod -n scanning-namespace -- ls\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#rbac-hardening-matrix","title":"RBAC Hardening Matrix","text":"<p>The following matrix outlines the recommended RBAC hardening settings for each deployment scenario:</p> Deployment Scenario Resource Names Label Selector Namespace Scope Short-lived Tokens Special Considerations Development Optional Yes Dedicated namespace 1 hour Less restrictive for testing CI/CD Pipeline No Yes CI namespace 15 minutes Dynamic creation/deletion Production Yes Yes Prod namespace 15 minutes Most restrictive Multi-tenant Yes Yes Tenant namespace 15 minutes Complete isolation"},{"location":"helm-charts/security/rbac-hardening/#implementation-examples","title":"Implementation Examples","text":""},{"location":"helm-charts/security/rbac-hardening/#production-environment","title":"Production Environment","text":"<pre><code># Production environment with maximum security\nhelm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=prod-scanning \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.resourceNames[0]=app-pod-1 \\\n  --set rbac.resourceNames[1]=app-pod-2 \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.environment=production \\\n  --set rbac.podSelectorLabels.scan-target=true \\\n  --set rbac.rules.ephemeralContainers.enabled=false\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#multi-tenant-environment","title":"Multi-Tenant Environment","text":"<pre><code># Tenant A infrastructure\nhelm install tenant-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=tenant-a-namespace \\\n  --set rbac.roleName=tenant-a-scanner-role \\\n  --set rbac.roleBindingName=tenant-a-scanner-rolebinding \\\n  --set serviceAccount.name=tenant-a-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.tenant=tenant-a\n\n# Tenant B infrastructure\nhelm install tenant-b-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=tenant-b-namespace \\\n  --set rbac.roleName=tenant-b-scanner-role \\\n  --set rbac.roleBindingName=tenant-b-scanner-rolebinding \\\n  --set serviceAccount.name=tenant-b-scanner \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.tenant=tenant-b\n</code></pre>"},{"location":"helm-charts/security/rbac-hardening/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Best Practices</li> <li>Risk Assessment</li> <li>Infrastructure RBAC</li> <li>Infrastructure Service Accounts</li> </ul>"},{"location":"helm-charts/security/risk-assessment/","title":"Security Risk Assessment","text":"<p>Directory Context</p> <p>This document is part of the Security Directory. See the Security Directory Inventory for related resources.</p>"},{"location":"helm-charts/security/risk-assessment/#overview","title":"Overview","text":"<p>This document provides a comprehensive security risk assessment for each component of the Secure Kubernetes Container Scanning Helm charts. Understanding these risks will help you implement appropriate security controls and make informed decisions about which scanning approach best meets your security requirements.</p>"},{"location":"helm-charts/security/risk-assessment/#risk-assessment-by-chart","title":"Risk Assessment by Chart","text":""},{"location":"helm-charts/security/risk-assessment/#scanner-infrastructure","title":"scanner-infrastructure","text":"Risk Severity Mitigation Excessive RBAC permissions High Use resource names and label selectors Long-lived tokens Medium Set short token duration (15-30 minutes) Namespace pollution Medium Use dedicated scanning namespace Service account misuse Medium Use dedicated service account with minimal permissions Cross-namespace access Medium Limit RBAC to specific namespaces Token leakage High Implement token rotation and secure storage"},{"location":"helm-charts/security/risk-assessment/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Excessive RBAC Permissions: Implement the principle of least privilege by restricting permissions to only what is necessary.</li> </ol> <pre><code>helm install scanner-infrastructure ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=scanning-namespace \\\n  --set rbac.useResourceNames=true \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.app=target-app\n</code></pre> <ol> <li>Long-lived Tokens: Set short token durations and implement token rotation.</li> </ol> <pre><code># Generate short-lived token\n./kubernetes-scripts/generate-kubeconfig.sh scanning-namespace inspec-scanner ./kubeconfig.yaml --duration=15m\n\n# Remove token after use\nrm ./kubeconfig.yaml\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#common-scanner","title":"common-scanner","text":"Risk Severity Mitigation Script injection Medium Use configMaps with verified script content Insecure result storage Medium Implement proper result handling and cleanup Threshold bypassing Low Enable failOnThresholdError option Script path traversal Medium Validate and sanitize script inputs Untrusted profiles Medium Use verified profiles from trusted sources"},{"location":"helm-charts/security/risk-assessment/#mitigation-strategies_1","title":"Mitigation Strategies","text":"<ol> <li>Script Injection: Ensure all script content is verified and comes from trusted sources.</li> </ol> <pre><code># Verify script content before creating ConfigMap\nkubectl create configmap scanner-scripts \\\n  --from-file=./verified-scripts \\\n  --dry-run=client -o yaml | kubectl apply -f -\n</code></pre> <ol> <li>Insecure Result Storage: Implement proper result handling and cleanup.</li> </ol> <pre><code># Delete results after processing\nkubectl exec -n scanning-namespace scanner-pod -- rm -rf /results/*\n\n# Use ephemeral volumes for results\nvolumes:\n- name: results\n  emptyDir: {}\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#standard-scanner-kubernetes-api-approach","title":"standard-scanner (Kubernetes API Approach)","text":"Risk Severity Mitigation Unauthorized container access Medium Use resource name restrictions in RBAC Command execution in container Medium Use read-only access where possible Profile privilege escalation Low Review profiles for security implications Transport plugin vulnerabilities Low Keep transport plugin updated"},{"location":"helm-charts/security/risk-assessment/#mitigation-strategies_2","title":"Mitigation Strategies","text":"<ol> <li>Unauthorized Container Access: Use RBAC with resource name restrictions.</li> </ol> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.resourceNames[0]=app-pod-1\n</code></pre> <ol> <li>Command Execution: Limit commands executed in target containers.</li> </ol> <pre><code># Use scanner with minimal command execution\ncinc-auditor exec ./profiles/container-baseline -t k8s-container://scanning-namespace/app-pod-1/container --sudo=false\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#distroless-scanner-debug-container-approach","title":"distroless-scanner (Debug Container Approach)","text":"Risk Severity Mitigation Debug container privileges High Apply security context constraints to debug container Process namespace access Medium Limit scanning duration Ephemeral container persistence Low Ensure proper cleanup after scanning Host kernel vulnerabilities Medium Keep Kubernetes updated with security patches Container escape Medium Implement multiple layers of security controls"},{"location":"helm-charts/security/risk-assessment/#mitigation-strategies_3","title":"Mitigation Strategies","text":"<ol> <li>Debug Container Privileges: Apply strict security contexts.</li> </ol> <pre><code>helm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.securityContext.runAsNonRoot=true \\\n  --set debugContainer.securityContext.runAsUser=10000 \\\n  --set debugContainer.securityContext.readOnlyRootFilesystem=true\n</code></pre> <ol> <li>Process Namespace Access: Limit the duration of debug container existence.</li> </ol> <pre><code>helm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set debugContainer.timeout=300  # 5 minutes\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#sidecar-scanner-sidecar-container-approach","title":"sidecar-scanner (Sidecar Container Approach)","text":"Risk Severity Mitigation Process namespace sharing High Apply strict security context to scanner container Persistent sidecar presence Medium Consider approach tradeoffs carefully Resource consumption Low Set appropriate resource limits Container isolation breach High Implement compensating security controls Shared kernel vulnerabilities Medium Keep Kubernetes updated with security patches"},{"location":"helm-charts/security/risk-assessment/#mitigation-strategies_4","title":"Mitigation Strategies","text":"<ol> <li>Process Namespace Sharing: Apply strict security contexts to the scanner container.</li> </ol> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.securityContext.runAsNonRoot=true \\\n  --set scanner.securityContext.runAsUser=10000 \\\n  --set scanner.securityContext.readOnlyRootFilesystem=true \\\n  --set scanner.securityContext.allowPrivilegeEscalation=false \\\n  --set scanner.securityContext.capabilities.drop[0]=ALL\n</code></pre> <ol> <li>Persistent Sidecar Presence: Consider the security implications of a persistent scanner container.</li> </ol> <pre><code># For highest security, consider using the Kubernetes API approach instead\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#approach-risk-comparison","title":"Approach Risk Comparison","text":"Security Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Attack Surface Minimal Temporary Increase Persistent Increase Container Isolation Preserved Temporary Breach Persistent Breach Resource Overhead Minimal Temporary Persistent Command Execution Direct in Container Limited Limited Security Boundary Maintained Temporarily Breached Persistently Breached Overall Risk Low Medium High"},{"location":"helm-charts/security/risk-assessment/#risk-mitigations-by-deployment-environment","title":"Risk Mitigations by Deployment Environment","text":""},{"location":"helm-charts/security/risk-assessment/#development-environment","title":"Development Environment","text":"<p>Development environments can implement less restrictive security controls:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=dev-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.environment=development\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#production-environment","title":"Production Environment","text":"<p>Production environments should implement maximum security controls:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useResourceNames=true \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.environment=production \\\n  --set common-scanner.safCli.failOnThresholdError=true\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#multi-tenant-environment","title":"Multi-Tenant Environment","text":"<p>Multi-tenant environments require strict isolation:</p> <pre><code># Separate infrastructure for each tenant\nhelm install tenant-a-scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=tenant-a-namespace \\\n  --set rbac.roleName=tenant-a-scanner-role \\\n  --set rbac.useLabelSelector=true \\\n  --set rbac.podSelectorLabels.tenant=tenant-a\n</code></pre>"},{"location":"helm-charts/security/risk-assessment/#security-standards-compliance","title":"Security Standards Compliance","text":"<p>The Helm charts can be configured to align with these security standards:</p>"},{"location":"helm-charts/security/risk-assessment/#cis-kubernetes-benchmark","title":"CIS Kubernetes Benchmark","text":"<ul> <li>RBAC Limitation: Strict role-based access control</li> <li>Namespace Segregation: Isolated scanning namespace</li> <li>Service Account Controls: Dedicated service accounts with minimal permissions</li> <li>Secret Management: Proper handling of token secrets</li> </ul>"},{"location":"helm-charts/security/risk-assessment/#nist-sp-800-190-container-security","title":"NIST SP 800-190 Container Security","text":"<ul> <li>Least Privilege: Minimal permissions for scanning operations</li> <li>Container Isolation: Maintaining container boundaries where possible</li> <li>Image Security: Support for scanning image content</li> <li>Runtime Security: Controlled access to container runtimes</li> </ul>"},{"location":"helm-charts/security/risk-assessment/#conclusion","title":"Conclusion","text":"<p>The Kubernetes API Approach (standard-scanner) provides the strongest security posture and is recommended for production environments. However, all approaches implement strong security controls to minimize risk when properly configured.</p> <p>For the most secure deployment:</p> <ol> <li>Use the Kubernetes API Approach where possible</li> <li>Implement strict RBAC controls with resource name restrictions</li> <li>Keep token lifetimes short (15-30 minutes)</li> <li>Apply security contexts to all scanner containers</li> <li>Implement network policies to restrict scanner communications</li> <li>Regularly update and audit your scanning infrastructure</li> </ol>"},{"location":"helm-charts/security/risk-assessment/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Best Practices</li> <li>RBAC Hardening</li> <li>Kubernetes API Scanner</li> <li>Debug Container Scanner</li> <li>Sidecar Container Scanner</li> </ul>"},{"location":"helm-charts/usage/","title":"Usage &amp; Customization","text":"<p>Directory Inventory</p> <p>See the Usage Directory Inventory for a complete listing of files and resources in this directory.</p>"},{"location":"helm-charts/usage/#overview","title":"Overview","text":"<p>This section provides guidance on how to use and customize the Helm charts for Kubernetes container scanning. The charts are designed to be highly flexible, allowing you to adapt them to your specific environment and requirements.</p>"},{"location":"helm-charts/usage/#deployment-options","title":"Deployment Options","text":"<p>Our Helm charts support various deployment scenarios:</p>"},{"location":"helm-charts/usage/#local-development-and-testing","title":"Local Development and Testing","text":"<p>For local development and testing (such as with Minikube or Kind), our charts provide simplified installation with test pods and examples:</p> <pre><code># Install for local testing with included test pods\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre> <p>This setup is ideal for:</p> <ul> <li>Learning how the scanning solution works</li> <li>Testing custom profiles and configurations</li> <li>Developing new scanning approaches</li> <li>Local demonstration and validation</li> </ul>"},{"location":"helm-charts/usage/#production-deployment","title":"Production Deployment","text":"<p>For production environments, our charts support enterprise-grade deployment patterns:</p> <pre><code># Install core infrastructure in production namespace\nhelm install scanner-infra ./helm-charts/scanner-infrastructure \\\n  --set targetNamespace=security-prod \\\n  --set rbac.useLabelSelector=true \\\n  --set serviceAccount.annotations.\"eks.amazonaws.com/role-arn\"=arn:aws:iam::123456789012:role/scanner-role\n\n# Install scanning components with production values\nhelm install scanner-components ./helm-charts/common-scanner \\\n  --set scanner-infrastructure.targetNamespace=security-prod \\\n  --set safCli.thresholdConfig.compliance.min=90 \\\n  --values ./production-values.yaml\n</code></pre> <p>Production features include:</p> <ul> <li>External auth provider integration (OIDC, AWS IAM, etc.)</li> <li>Custom threshold configurations</li> <li>Resource limits and requests</li> <li>Network policies and security constraints</li> <li>Integration with external monitoring and logging</li> </ul>"},{"location":"helm-charts/usage/#customization-options","title":"Customization Options","text":"<p>Our Helm charts provide extensive customization options:</p> <ul> <li>Customization Guide: Detailed instructions for customizing the Helm charts</li> <li>Configuration Reference: Complete reference for all configuration options</li> <li>Values Files: Information on creating custom values files for different environments</li> </ul>"},{"location":"helm-charts/usage/#getting-started","title":"Getting Started","text":"<p>To get started using the Helm charts:</p> <ol> <li>Choose the appropriate scanner type for your containers:</li> <li>Kubernetes API Scanner for standard containers</li> <li>Debug Container Scanner for distroless containers</li> <li> <p>Sidecar Container Scanner for universal approach</p> </li> <li> <p>Follow the installation instructions for your chosen scanner type</p> </li> <li> <p>Customize the charts for your environment using the Customization Guide</p> </li> <li> <p>Learn about Security Considerations for secure deployment</p> </li> <li> <p>Explore Operations for troubleshooting and maintenance</p> </li> </ol>"},{"location":"helm-charts/usage/configuration/","title":"Helm Chart Configuration Reference","text":"<p>Directory Context</p> <p>This document is part of the Usage Directory. See the Usage Directory Inventory for related resources.</p>"},{"location":"helm-charts/usage/configuration/#overview","title":"Overview","text":"<p>This document provides a comprehensive reference for all configuration options available in the Secure Kubernetes Container Scanning Helm charts. Use this reference to understand the available parameters and their usage.</p>"},{"location":"helm-charts/usage/configuration/#scanner-infrastructure-chart","title":"scanner-infrastructure Chart","text":""},{"location":"helm-charts/usage/configuration/#core-configuration","title":"Core Configuration","text":"Parameter Description Default Required <code>targetNamespace</code> Namespace for scanner resources <code>inspec-test</code> Yes <code>createNamespace</code> Create namespace if it doesn't exist <code>true</code> No"},{"location":"helm-charts/usage/configuration/#service-account-configuration","title":"Service Account Configuration","text":"Parameter Description Default Required <code>serviceAccount.create</code> Create service account <code>true</code> No <code>serviceAccount.name</code> Service account name <code>inspec-scanner</code> No <code>serviceAccount.annotations</code> Service account annotations <code>{}</code> No <code>serviceAccount.automountToken</code> Automount API token <code>true</code> No"},{"location":"helm-charts/usage/configuration/#rbac-configuration","title":"RBAC Configuration","text":"Parameter Description Default Required <code>rbac.create</code> Create RBAC resources <code>true</code> No <code>rbac.roleName</code> Role name <code>scanner-role</code> No <code>rbac.roleBindingName</code> RoleBinding name <code>scanner-rolebinding</code> No <code>rbac.clusterWide</code> Use cluster-wide permissions <code>false</code> No <code>rbac.useResourceNames</code> Restrict to specific pod names <code>false</code> No <code>rbac.resourceNames</code> List of allowed pod names <code>[]</code> No <code>rbac.useLabelSelector</code> Use label selector <code>false</code> No <code>rbac.podSelectorLabels</code> Pod selector labels <code>{}</code> No <code>rbac.rules.core.enabled</code> Enable core permissions <code>true</code> No <code>rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container permissions <code>false</code> No <code>rbac.extraRules</code> Additional RBAC rules <code>[]</code> No"},{"location":"helm-charts/usage/configuration/#scripts-configuration","title":"Scripts Configuration","text":"Parameter Description Default Required <code>scripts.configMap.create</code> Create script ConfigMap <code>true</code> No <code>scripts.configMap.name</code> Script ConfigMap name <code>scanner-scripts</code> No"},{"location":"helm-charts/usage/configuration/#common-scanner-chart","title":"common-scanner Chart","text":""},{"location":"helm-charts/usage/configuration/#core-configuration_1","title":"Core Configuration","text":"Parameter Description Default Required <code>scanner-infrastructure.enabled</code> Enable scanner-infrastructure dependency <code>true</code> No <code>scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes"},{"location":"helm-charts/usage/configuration/#script-configuration","title":"Script Configuration","text":"Parameter Description Default Required <code>scripts.generate</code> Generate helper scripts <code>true</code> No <code>scripts.directory</code> Directory for scripts <code>/tmp/inspec-scanner</code> No <code>scripts.includeScanScript</code> Include scan-container.sh <code>true</code> No <code>scripts.includeDistrolessScanScript</code> Include distroless scanning script <code>true</code> No <code>scripts.includeSidecarScanScript</code> Include sidecar scanning script <code>true</code> No"},{"location":"helm-charts/usage/configuration/#saf-cli-configuration","title":"SAF CLI Configuration","text":"Parameter Description Default Required <code>safCli.enabled</code> Enable SAF CLI integration <code>true</code> No <code>safCli.thresholdFilePath</code> External threshold file path <code>\"\"</code> No <code>safCli.failOnThresholdError</code> Fail on threshold errors <code>false</code> No"},{"location":"helm-charts/usage/configuration/#threshold-configuration","title":"Threshold Configuration","text":"Parameter Description Default Required <code>safCli.thresholdConfig.compliance.min</code> Minimum compliance score <code>70</code> No <code>safCli.thresholdConfig.failed.critical.max</code> Maximum critical failures <code>0</code> No <code>safCli.thresholdConfig.failed.high.max</code> Maximum high failures <code>2</code> No <code>safCli.thresholdConfig.failed.medium.max</code> Maximum medium failures <code>5</code> No <code>safCli.thresholdConfig.failed.low.max</code> Maximum low failures <code>10</code> No <code>safCli.thresholdConfig.skipped.total.max</code> Maximum skipped controls <code>5</code> No"},{"location":"helm-charts/usage/configuration/#standard-scanner-chart-kubernetes-api-approach","title":"standard-scanner Chart (Kubernetes API Approach)","text":""},{"location":"helm-charts/usage/configuration/#core-configuration_2","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.enabled</code> Enable common-scanner dependency <code>true</code> No <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes"},{"location":"helm-charts/usage/configuration/#test-pod-configuration","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>inspec-target-helm</code> No <code>testPod.image</code> Test pod image <code>busybox:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sh\", \"-c\", \"while true; do sleep 3600; done\"]</code> No <code>testPod.resources</code> Test pod resource limits/requests <code>{}</code> No"},{"location":"helm-charts/usage/configuration/#distroless-scanner-chart-debug-container-approach","title":"distroless-scanner Chart (Debug Container Approach)","text":""},{"location":"helm-charts/usage/configuration/#core-configuration_3","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.enabled</code> Enable common-scanner dependency <code>true</code> No <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes <code>common-scanner.scanner-infrastructure.rbac.rules.ephemeralContainers.enabled</code> Enable ephemeral container permissions <code>true</code> Yes"},{"location":"helm-charts/usage/configuration/#test-pod-configuration_1","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>distroless-target-helm</code> No <code>testPod.image</code> Test pod image <code>gcr.io/distroless/base:latest</code> No <code>testPod.command</code> Test pod command <code>[\"/bin/sleep\", \"3600\"]</code> No <code>testPod.resources</code> Test pod resource limits/requests <code>{}</code> No"},{"location":"helm-charts/usage/configuration/#debug-container-configuration","title":"Debug Container Configuration","text":"Parameter Description Default Required <code>debugContainer.image</code> Debug container image <code>alpine:latest</code> No <code>debugContainer.command</code> Debug container command <code>null</code> No <code>debugContainer.args</code> Debug container arguments <code>null</code> No <code>debugContainer.timeout</code> Debug container timeout in seconds <code>600</code> No <code>debugContainer.securityContext</code> Debug container security context <code>{}</code> No"},{"location":"helm-charts/usage/configuration/#sidecar-scanner-chart-sidecar-container-approach","title":"sidecar-scanner Chart (Sidecar Container Approach)","text":""},{"location":"helm-charts/usage/configuration/#core-configuration_4","title":"Core Configuration","text":"Parameter Description Default Required <code>common-scanner.enabled</code> Enable common-scanner dependency <code>true</code> No <code>common-scanner.scanner-infrastructure.targetNamespace</code> Target namespace <code>inspec-test</code> Yes"},{"location":"helm-charts/usage/configuration/#test-pod-configuration_2","title":"Test Pod Configuration","text":"Parameter Description Default Required <code>testPod.deploy</code> Deploy test pod <code>false</code> No <code>testPod.name</code> Test pod name <code>sidecar-target</code> No <code>testPod.targetImage</code> Target container image <code>nginx:latest</code> No <code>testPod.shareProcessNamespace</code> Enable process namespace sharing <code>true</code> Yes <code>testPod.resources</code> Test pod resource limits/requests <code>{}</code> No"},{"location":"helm-charts/usage/configuration/#scanner-configuration","title":"Scanner Configuration","text":"Parameter Description Default Required <code>scanner.image</code> Scanner container image <code>chef/inspec:5.18.14</code> No <code>scanner.command</code> Scanner container command <code>null</code> No <code>scanner.args</code> Scanner container arguments <code>null</code> No <code>scanner.resources.requests.cpu</code> CPU request <code>100m</code> No <code>scanner.resources.requests.memory</code> Memory request <code>256Mi</code> No <code>scanner.resources.limits.cpu</code> CPU limit <code>200m</code> No <code>scanner.resources.limits.memory</code> Memory limit <code>512Mi</code> No <code>scanner.securityContext</code> Scanner container security context <code>{}</code> No"},{"location":"helm-charts/usage/configuration/#profile-configuration","title":"Profile Configuration","text":"Parameter Description Default Required <code>profiles.default.enabled</code> Enable default profile <code>true</code> No <code>profiles.default.path</code> Default profile path <code>/profiles/container-baseline</code> No <code>profiles.custom</code> Custom profile configuration <code>[]</code> No"},{"location":"helm-charts/usage/configuration/#results-configuration","title":"Results Configuration","text":"Parameter Description Default Required <code>results.directory</code> Results directory in scanner <code>/results</code> No <code>results.format</code> Results output format <code>json</code> No <code>results.thresholdEnabled</code> Enable threshold validation <code>true</code> No"},{"location":"helm-charts/usage/configuration/#deployment-examples","title":"Deployment Examples","text":""},{"location":"helm-charts/usage/configuration/#standard-scanner-local-development","title":"Standard Scanner (Local Development)","text":"<pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=inspec-test \\\n  --set testPod.deploy=true\n</code></pre>"},{"location":"helm-charts/usage/configuration/#distroless-scanner-production","title":"Distroless Scanner (Production)","text":"<pre><code>helm install distroless-scanner ./helm-charts/distroless-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-scanning \\\n  --set common-scanner.scanner-infrastructure.rbac.useLabelSelector=true \\\n  --set common-scanner.scanner-infrastructure.rbac.podSelectorLabels.app=target-app \\\n  --set common-scanner.safCli.thresholdConfig.compliance.min=90\n</code></pre>"},{"location":"helm-charts/usage/configuration/#sidecar-scanner-cicd-integration","title":"Sidecar Scanner (CI/CD Integration)","text":"<pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=ci-cd-scanning \\\n  --set profiles.default.enabled=false \\\n  --set profiles.custom[0].name=ci-profile \\\n  --set profiles.custom[0].configMap=ci-profiles \\\n  --set profiles.custom[0].path=/ci-profile\n</code></pre>"},{"location":"helm-charts/usage/configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Customization Guide</li> <li>Values Files</li> <li>Scanner Types</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/usage/customization/","title":"Helm Chart Customization Guide","text":"<p>Directory Context</p> <p>This document is part of the Usage Directory. See the Usage Directory Inventory for related resources.</p>"},{"location":"helm-charts/usage/customization/#overview","title":"Overview","text":"<p>This guide provides detailed instructions for customizing the Secure Kubernetes Container Scanning Helm charts to meet your specific needs. Our charts are designed to be highly customizable while maintaining security best practices and operational efficiency.</p>"},{"location":"helm-charts/usage/customization/#common-customization-scenarios","title":"Common Customization Scenarios","text":""},{"location":"helm-charts/usage/customization/#1-custom-security-profiles","title":"1. Custom Security Profiles","text":""},{"location":"helm-charts/usage/customization/#adding-custom-cinc-auditor-profiles","title":"Adding Custom CINC Auditor Profiles","text":"<p>To add your own custom compliance profiles:</p> <pre><code># Create a custom profile ConfigMap\nkubectl create configmap custom-profiles -n scanning-namespace \\\n  --from-file=./my-custom-profile\n\n# Reference custom profile in sidecar scanner\nhelm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set profiles.default.enabled=false \\\n  --set profiles.custom[0].name=my-profile \\\n  --set profiles.custom[0].configMap=custom-profiles \\\n  --set profiles.custom[0].path=/my-custom-profile\n</code></pre> <p>Alternatively, build a custom scanner image with embedded profiles:</p> <pre><code># Dockerfile for custom scanner image\nFROM chef/inspec:5.18.14\n\n# Add custom profiles\nCOPY ./my-profiles /profiles\n\n# Add custom scripts\nCOPY ./scripts /scripts\nRUN chmod +x /scripts/*.sh\n</code></pre> <p>Then use this custom image:</p> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.image=my-registry/custom-scanner:latest\n</code></pre>"},{"location":"helm-charts/usage/customization/#2-custom-threshold-configurations","title":"2. Custom Threshold Configurations","text":""},{"location":"helm-charts/usage/customization/#creating-environment-specific-thresholds","title":"Creating Environment-Specific Thresholds","text":"<p>Create different threshold files for various environments:</p> <pre><code># development-threshold.yml\ncompliance:\n  min: 70\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 5\n  medium:\n    max: 10\n</code></pre> <pre><code># production-threshold.yml\ncompliance:\n  min: 95\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\n  medium:\n    max: 2\n</code></pre> <p>Use them in your installations:</p> <pre><code># Development environment\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=dev-namespace \\\n  --set common-scanner.safCli.thresholdFilePath=/path/to/development-threshold.yml\n\n# Production environment\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=prod-namespace \\\n  --set common-scanner.safCli.thresholdFilePath=/path/to/production-threshold.yml\n</code></pre>"},{"location":"helm-charts/usage/customization/#3-resource-management","title":"3. Resource Management","text":""},{"location":"helm-charts/usage/customization/#setting-resource-limits-and-requests","title":"Setting Resource Limits and Requests","text":"<p>For the sidecar scanner, set resource constraints:</p> <pre><code>helm install sidecar-scanner ./helm-charts/sidecar-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set scanner.resources.requests.cpu=100m \\\n  --set scanner.resources.requests.memory=256Mi \\\n  --set scanner.resources.limits.cpu=500m \\\n  --set scanner.resources.limits.memory=512Mi\n</code></pre> <p>For test pods:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set testPod.deploy=true \\\n  --set testPod.resources.requests.cpu=50m \\\n  --set testPod.resources.requests.memory=64Mi \\\n  --set testPod.resources.limits.cpu=100m \\\n  --set testPod.resources.limits.memory=128Mi\n</code></pre>"},{"location":"helm-charts/usage/customization/#advanced-customization-techniques","title":"Advanced Customization Techniques","text":""},{"location":"helm-charts/usage/customization/#creating-custom-value-files","title":"Creating Custom Value Files","text":"<p>For complex configurations, use custom value files:</p> <pre><code># values-production.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: production\n    rbac:\n      useResourceNames: true\n      useLabelSelector: true\n      podSelectorLabels:\n        app: myapp\n        env: production\n      rules:\n        ephemeralContainers:\n          enabled: true\n    serviceAccount:\n      annotations:\n        eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/scanner-role\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: 95\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 0\ntestPod:\n  deploy: false\n</code></pre> <p>Then use it for installation:</p> <pre><code>helm install standard-scanner ./helm-charts/standard-scanner -f values-production.yaml\n</code></pre>"},{"location":"helm-charts/usage/customization/#templating-helm-charts-for-multiple-environments","title":"Templating Helm Charts for Multiple Environments","text":"<p>You can use Kustomize with Helm to manage multiple environments:</p> <pre><code># kustomization.yaml for Development\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nhelmCharts:\n- name: standard-scanner\n  repo: file://../helm-charts\n  releaseName: dev-scanner\n  namespace: development\n  valuesFile: values-development.yaml\n</code></pre> <pre><code># kustomization.yaml for Production\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nhelmCharts:\n- name: standard-scanner\n  repo: file://../helm-charts\n  releaseName: prod-scanner\n  namespace: production\n  valuesFile: values-production.yaml\n</code></pre>"},{"location":"helm-charts/usage/customization/#building-custom-scanner-images","title":"Building Custom Scanner Images","text":"<p>For specialized environments, build custom scanner images:</p> <pre><code># Dockerfile for air-gapped environment scanner\nFROM registry.example.com/chef/inspec:5.18.14\n\n# Add all required profiles\nCOPY ./profiles /profiles\n\n# Add custom scripts\nCOPY ./scripts /scripts\nRUN chmod +x /scripts/*.sh\n\n# Add SAF CLI\nRUN pip install saf-cli==1.2.3\n\n# Add required gems\nRUN inspec plugin install inspec-kubernetes\n</code></pre>"},{"location":"helm-charts/usage/customization/#upgrading-and-migration","title":"Upgrading and Migration","text":""},{"location":"helm-charts/usage/customization/#upgrading-between-chart-versions","title":"Upgrading Between Chart Versions","text":"<p>To upgrade existing chart installations:</p> <pre><code># Check for changes first\nhelm diff upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace\n\n# Perform upgrade\nhelm upgrade standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace\n</code></pre>"},{"location":"helm-charts/usage/customization/#migration-between-scanning-approaches","title":"Migration Between Scanning Approaches","text":"<p>Migrating from Debug Container Approach to Kubernetes API Approach (once distroless support is added):</p> <pre><code># First, uninstall the debug container scanner\nhelm uninstall distroless-scanner\n\n# Then, install the standard scanner with distroless support\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=scanning-namespace \\\n  --set common-scanner.scripts.includeDistrolessScanScript=true \\\n  --set distrolessSupport=true\n</code></pre>"},{"location":"helm-charts/usage/customization/#integration-patterns","title":"Integration Patterns","text":""},{"location":"helm-charts/usage/customization/#gitops-integration","title":"GitOps Integration","text":"<p>For GitOps workflows using tools like ArgoCD or Flux:</p> <pre><code># Example application manifest with scanner sidecar\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: application-with-scanner\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/your-org/your-app\n    targetRevision: HEAD\n    path: helm\n    helm:\n      valueFiles:\n      - values.yaml\n      - scanner-values.yaml\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: application-namespace\n</code></pre>"},{"location":"helm-charts/usage/customization/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Reference</li> <li>Values Files</li> <li>Security Considerations</li> <li>Troubleshooting</li> </ul>"},{"location":"helm-charts/usage/inventory/","title":"Usage &amp; Customization Directory Inventory","text":"<p>This document provides a directory overview of all usage and customization-related resources in the Helm Charts documentation.</p>"},{"location":"helm-charts/usage/inventory/#directory-contents","title":"Directory Contents","text":"<p>The helm-charts/usage directory contains documentation for using and customizing the Helm charts:</p> <ul> <li>index.md: Overview of usage and customization options</li> <li>inventory.md: This directory listing</li> <li>customization.md: Detailed guide for customizing the Helm charts</li> <li>configuration.md: Reference for all configuration options</li> <li>values.md: Guide for creating custom values files</li> </ul>"},{"location":"helm-charts/usage/inventory/#overview-of-content","title":"Overview of Content","text":"<p>The usage section provides:</p> <ul> <li>Introduction to chart deployment patterns</li> <li>Detailed customization options for different environments</li> <li>Complete configuration reference for all charts</li> <li>Examples for common customization scenarios</li> <li>Values file templates and examples</li> </ul>"},{"location":"helm-charts/usage/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Helm Charts Overview</li> <li>Scanner Types Documentation</li> <li>Infrastructure Documentation</li> <li>Security Considerations</li> <li>Operations &amp; Troubleshooting</li> </ul>"},{"location":"helm-charts/usage/values/","title":"Helm Chart Values Files","text":"<p>Directory Context</p> <p>This document is part of the Usage Directory. See the Usage Directory Inventory for related resources.</p>"},{"location":"helm-charts/usage/values/#overview","title":"Overview","text":"<p>This guide explains how to use Helm values files to configure and customize the Secure Kubernetes Container Scanning Helm charts. Values files provide a way to specify multiple configuration options in a single file, making it easier to manage complex configurations and maintain consistency across environments.</p>"},{"location":"helm-charts/usage/values/#basic-values-file-structure","title":"Basic Values File Structure","text":"<p>A values file is a YAML file that contains configuration settings for a Helm chart. The structure mirrors the chart's value hierarchy:</p> <pre><code># Example values.yaml for standard-scanner\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: scanning-namespace\n    rbac:\n      useResourceNames: true\n      resourceNames:\n        - app-pod-1\n        - app-pod-2\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: 90\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 0\ntestPod:\n  deploy: false\n</code></pre>"},{"location":"helm-charts/usage/values/#environment-specific-values-files","title":"Environment-Specific Values Files","text":""},{"location":"helm-charts/usage/values/#development-environment","title":"Development Environment","text":"<pre><code># values-development.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: dev-scanning\n    rbac:\n      useLabelSelector: true\n      podSelectorLabels:\n        environment: development\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: 70\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 5\n        medium:\n          max: 10\ntestPod:\n  deploy: true\n  resources:\n    requests:\n      cpu: 50m\n      memory: 64Mi\n    limits:\n      cpu: 100m\n      memory: 128Mi\n</code></pre>"},{"location":"helm-charts/usage/values/#production-environment","title":"Production Environment","text":"<pre><code># values-production.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: prod-scanning\n    rbac:\n      useLabelSelector: true\n      podSelectorLabels:\n        environment: production\n        scan-target: \"true\"\n    serviceAccount:\n      annotations:\n        eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/scanner-role\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: 95\n      failed:\n        critical:\n          max: 0\n        high:\n          max: 0\n        medium:\n          max: 2\ntestPod:\n  deploy: false\n</code></pre>"},{"location":"helm-charts/usage/values/#scanner-specific-values-files","title":"Scanner-Specific Values Files","text":""},{"location":"helm-charts/usage/values/#kubernetes-api-scanner-standard","title":"Kubernetes API Scanner (Standard)","text":"<pre><code># values-standard-scanner.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: scanning-namespace\n    rbac:\n      rules:\n        core:\n          enabled: true\n        ephemeralContainers:\n          enabled: false\n  scripts:\n    includeScanScript: true\n    includeDistrolessScanScript: false\n    includeSidecarScanScript: false\ntestPod:\n  deploy: true\n  image: ubuntu:20.04\n  command: [\"/bin/sh\", \"-c\", \"while true; do sleep 3600; done\"]\n</code></pre>"},{"location":"helm-charts/usage/values/#debug-container-scanner-distroless","title":"Debug Container Scanner (Distroless)","text":"<pre><code># values-distroless-scanner.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: scanning-namespace\n    rbac:\n      rules:\n        core:\n          enabled: true\n        ephemeralContainers:\n          enabled: true\n  scripts:\n    includeScanScript: false\n    includeDistrolessScanScript: true\n    includeSidecarScanScript: false\ntestPod:\n  deploy: true\n  image: gcr.io/distroless/base:latest\n  command: [\"/bin/sleep\", \"3600\"]\ndebugContainer:\n  image: alpine:3.15\n  timeout: 300\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 10000\n    readOnlyRootFilesystem: true\n</code></pre>"},{"location":"helm-charts/usage/values/#sidecar-container-scanner","title":"Sidecar Container Scanner","text":"<pre><code># values-sidecar-scanner.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: scanning-namespace\n    rbac:\n      rules:\n        core:\n          enabled: true\n  scripts:\n    includeScanScript: false\n    includeDistrolessScanScript: false\n    includeSidecarScanScript: true\ntestPod:\n  deploy: true\n  targetImage: nginx:latest\n  shareProcessNamespace: true\nscanner:\n  image: chef/inspec:5.18.14\n  resources:\n    requests:\n      cpu: 100m\n      memory: 256Mi\n    limits:\n      cpu: 200m\n      memory: 512Mi\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 10000\n    readOnlyRootFilesystem: true\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop:\n        - ALL\nprofiles:\n  default:\n    enabled: true\n  custom:\n    - name: custom-profile\n      configMap: custom-profiles\n      path: /custom-profile\n</code></pre>"},{"location":"helm-charts/usage/values/#cloud-provider-integration-values","title":"Cloud Provider Integration Values","text":""},{"location":"helm-charts/usage/values/#aws-eks","title":"AWS EKS","text":"<pre><code># values-aws.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    serviceAccount:\n      annotations:\n        eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/scanner-role\n</code></pre>"},{"location":"helm-charts/usage/values/#google-gke","title":"Google GKE","text":"<pre><code># values-gke.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    serviceAccount:\n      annotations:\n        iam.gke.io/gcp-service-account: scanner-sa@project-id.iam.gserviceaccount.com\n</code></pre>"},{"location":"helm-charts/usage/values/#azure-aks","title":"Azure AKS","text":"<pre><code># values-aks.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    serviceAccount:\n      annotations:\n        azure.workload.identity/client-id: 00000000-0000-0000-0000-000000000000\n</code></pre>"},{"location":"helm-charts/usage/values/#using-values-files","title":"Using Values Files","text":""},{"location":"helm-charts/usage/values/#installation-with-values-file","title":"Installation with Values File","text":"<pre><code># Install with custom values file\nhelm install standard-scanner ./helm-charts/standard-scanner -f values-standard-scanner.yaml\n</code></pre>"},{"location":"helm-charts/usage/values/#multiple-values-files","title":"Multiple Values Files","text":"<p>You can combine multiple values files:</p> <pre><code># Combine base values with environment-specific values\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  -f values-standard-scanner.yaml \\\n  -f values-production.yaml \\\n  -f values-aws.yaml\n</code></pre> <p>Values are merged with later files taking precedence.</p>"},{"location":"helm-charts/usage/values/#setting-individual-values","title":"Setting Individual Values","text":"<p>You can override specific values:</p> <pre><code># Use values file with specific overrides\nhelm install standard-scanner ./helm-charts/standard-scanner \\\n  -f values-standard-scanner.yaml \\\n  --set common-scanner.scanner-infrastructure.targetNamespace=custom-namespace \\\n  --set testPod.deploy=false\n</code></pre>"},{"location":"helm-charts/usage/values/#template-values-files","title":"Template Values Files","text":""},{"location":"helm-charts/usage/values/#base-template","title":"Base Template","text":"<pre><code># values-template.yaml\ncommon-scanner:\n  scanner-infrastructure:\n    targetNamespace: ${NAMESPACE}\n    rbac:\n      useLabelSelector: true\n      podSelectorLabels:\n        environment: ${ENVIRONMENT}\n  safCli:\n    thresholdConfig:\n      compliance:\n        min: ${COMPLIANCE_MIN}\ntestPod:\n  deploy: ${DEPLOY_TEST_POD}\n</code></pre>"},{"location":"helm-charts/usage/values/#using-with-environment-variables","title":"Using with Environment Variables","text":"<pre><code># Replace variables with environment values\nenvsubst &lt; values-template.yaml &gt; values-generated.yaml\n\n# Install with generated values\nhelm install standard-scanner ./helm-charts/standard-scanner -f values-generated.yaml\n</code></pre>"},{"location":"helm-charts/usage/values/#values-validation","title":"Values Validation","text":"<p>Validate your values file before applying:</p> <pre><code># Validate values file\nhelm install --debug --dry-run standard-scanner ./helm-charts/standard-scanner -f values.yaml\n</code></pre>"},{"location":"helm-charts/usage/values/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Reference</li> <li>Customization Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":"<p>Common Abbreviations</p> <ul> <li>HTML: Hyper Text Markup Language</li> <li>WCAG: Web Content Accessibility Guidelines</li> <li>RBAC: Role-Based Access Control</li> <li>CINC: CINC Is Not Chef</li> <li>SAF: Security Automation Framework</li> <li>CI/CD: Continuous Integration/Continuous Deployment</li> <li>API: Application Programming Interface</li> <li>YAML: YAML Ain't Markup Language</li> <li>SAST: Static Application Security Testing</li> <li>DAST: Dynamic Application Security Testing</li> <li>SCA: Software Composition Analysis</li> <li>SBOM: Software Bill of Materials</li> <li>CIS: Center for Internet Security</li> <li>NIST: National Institute of Standards and Technology</li> <li>K8s: Kubernetes</li> </ul>"},{"location":"integration/","title":"CI/CD Integration","text":"<p>This section provides comprehensive guidance on integrating the Kube CINC Secure Scanner with various CI/CD platforms.</p>"},{"location":"integration/#integration-overview","title":"Integration Overview","text":"<p>The Kube CINC Secure Scanner can be integrated with popular CI/CD platforms to automate container security scanning as part of your deployment pipeline. This allows you to catch security issues early in the development lifecycle and ensure that only compliant containers are deployed to your environments.</p>"},{"location":"integration/#integration-categories","title":"Integration Categories","text":"<p>Our integration documentation is organized into the following categories:</p> <ul> <li>CI/CD Platforms - Integration guides for specific CI/CD platforms</li> <li>Integration Workflows - Workflows for integrating different scanning approaches</li> <li>Integration Examples - Practical examples of CI/CD integrations</li> <li>Integration Configuration - Configuration guidance for CI/CD integrations</li> </ul>"},{"location":"integration/#getting-started","title":"Getting Started","text":"<p>To get started with CI/CD integration, follow these steps:</p> <ol> <li>Review the Approach Mapping to select the appropriate scanning approach</li> <li>Choose your CI/CD Platform and follow the platform-specific guide</li> <li>Implement the appropriate Integration Workflow for your selected approach</li> <li>Configure your integration using the Configuration Guide</li> <li>Reference the Integration Examples for practical implementation guidance</li> </ol>"},{"location":"integration/#best-practices","title":"Best Practices","text":"<p>When integrating with CI/CD platforms, follow these best practices:</p> <ol> <li>Use dedicated service accounts with limited permissions</li> <li>Implement appropriate security controls for access to scan results</li> <li>Configure appropriate thresholds for failing builds based on scan results</li> <li>Use caching to improve performance where possible</li> <li>Include remediation guidance in scan result notifications</li> </ol>"},{"location":"integration/#implementation-examples","title":"Implementation Examples","text":"<p>For practical implementation examples, see:</p> <ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"integration/#related-resources","title":"Related Resources","text":"<ul> <li>Scanning Approaches</li> <li>Advanced Configuration</li> <li>Scanning Thresholds</li> </ul>"},{"location":"integration/approach-mapping/","title":"CI/CD Integration by Scanning Approach","text":"<p>This document provides a comprehensive mapping of our CI/CD examples to each scanning approach, helping you choose the right workflow for your specific container scanning needs.</p>"},{"location":"integration/approach-mapping/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach is our recommended method for scanning containers in production environments. Support for distroless containers is currently in progress through enhancements to the train-k8s-container plugin.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code>name: CI/CD Pipeline with CINC Auditor Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Define test application\n        run: |\n          # Create a simple application for testing\n          mkdir -p ./app\n\n          # Create a minimal Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages to test vulnerability scanning\n          RUN apk add --no-cache bash curl wget\n\n          # Add a sample script\n          COPY hello.sh /hello.sh\n          RUN chmod +x /hello.sh\n\n          # Set CMD\n          CMD [\"/bin/sh\", \"-c\", \"while true; do /hello.sh; sleep 300; done\"]\n          EOF\n\n          # Create a simple script file\n          cat &gt; ./app/hello.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n          echo \"Hello from test container! The time is $(date)\"\n          echo \"Running as user: $(whoami)\"\n          echo \"OS release: $(cat /etc/os-release | grep PRETTY_NAME)\"\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build container image\n        run: |\n          # Configure to use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image\n          docker build -t test-app:${{ github.event.inputs.image_tag }} ./app\n\n          # List images to confirm\n          docker images | grep test-app\n\n      - name: Create Kubernetes deployment\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n            labels:\n              app: test-app\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  security-scan: \"enabled\"\n              spec:\n                containers:\n                - name: app\n                  image: test-app:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Get pod name\n          POD_NAME=$(kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l app=test-app -o jsonpath='{.items[0].metadata.name}')\n          echo \"APP_POD=${POD_NAME}\" &gt;&gt; $GITHUB_ENV\n\n          # Show pods\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Set up CINC Auditor\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Create a custom profile for application scanning\n          mkdir -p ./app-scan-profile\n\n          # Create profile files\n          cat &gt; ./app-scan-profile/inspec.yml &lt;&lt; 'EOF'\n          name: app-scan-profile\n          title: Custom Application Container Scan\n          maintainer: Security Team\n          copyright: Security Team\n          license: Apache-2.0\n          summary: A custom profile for scanning containerized applications\n          version: 0.1.0\n          supports:\n            platform: os\n          EOF\n\n          mkdir -p ./app-scan-profile/controls\n\n          cat &gt; ./app-scan-profile/controls/container_checks.rb &lt;&lt; 'EOF'\n          control 'container-1.1' do\n            impact 0.7\n            title 'Ensure container is not running as root'\n            desc 'Containers should not run as root when possible'\n\n            describe command('whoami') do\n              its('stdout') { should_not cmp 'root' }\n            end\n          end\n\n          control 'container-1.2' do\n            impact 0.5\n            title 'Check container OS version'\n            desc 'Verify the container OS version'\n\n            describe file('/etc/os-release') do\n              it { should exist }\n              its('content') { should include 'Alpine' }\n            end\n          end\n\n          control 'container-1.3' do\n            impact 0.3\n            title 'Check for unnecessary packages'\n            desc 'Container should not have unnecessary packages'\n\n            describe package('curl') do\n              it { should be_installed }\n            end\n\n            describe package('wget') do\n              it { should be_installed }\n            end\n          end\n\n          control 'container-1.4' do\n            impact 0.7\n            title 'Check for sensitive files'\n            desc 'Container should not have sensitive files'\n\n            describe file('/etc/shadow') do\n              it { should exist }\n              it { should_not be_readable.by('others') }\n            end\n          end\n          EOF\n\n      - name: Setup secure scanning infrastructure\n        run: |\n          # Create a unique ID for this run\n          RUN_ID=$(date +%s)\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          EOF\n\n          # Create role with label-based access\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: cinc-scanner-role-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            # No resourceNames restriction - use label selector in code\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            # No resourceNames restriction - use label selector in code\n          EOF\n\n          # Create rolebinding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: cinc-scanner-binding-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          subjects:\n          - kind: ServiceAccount\n            name: cinc-scanner-${RUN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          roleRef:\n            kind: Role\n            name: cinc-scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Setup SAF-CLI\n        run: |\n          # Install Node.js (should already be installed on GitHub runners)\n          node --version || echo \"Node.js not installed\"\n\n          # Install SAF-CLI globally\n          npm install -g @mitre/saf\n\n          # Verify installation\n          saf --version\n\n      - name: Run security scan with CINC Auditor\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token cinc-scanner-${RUN_ID} -n ${{ github.event.inputs.scan_namespace }} --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Verify we can access the pod with our labels\n          POD_NAME=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${{ github.event.inputs.scan_namespace }} -l security-scan=enabled -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$POD_NAME\" ]; then\n            echo \"Error: No pod found with security-scan=enabled label\"\n            exit 1\n          fi\n          echo \"Found pod to scan: ${POD_NAME}\"\n\n          # Run the CINC Auditor scan\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ./app-scan-profile \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:scan-results.json\n\n          SCAN_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Also run a standard profile for comparison\n          echo \"Running standard DevSec Linux Baseline for comparison:\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}/${POD_NAME}/app \\\n            --reporter cli json:baseline-results.json || true\n\n      - name: Generate scan summary with SAF-CLI\n        run: |\n          # Create summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\"\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\"\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n          # Generate summary for baseline results too\n          echo \"Generating baseline summary with SAF-CLI:\"\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Create a combined summary for GitHub step summary\n          echo \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            baseline-results.json\n            scan-summary.md\n            baseline-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }}\n</code></pre> <p>This workflow implements:</p> <ul> <li>Complete CI/CD pipeline with build, deploy, and scan steps</li> <li>Standard Kubernetes API-based scanning</li> <li>SAF-CLI integration for threshold checking</li> <li>Quality gates enforcement options</li> </ul>"},{"location":"integration/approach-mapping/#dynamic-rbac-scanning","title":"Dynamic RBAC Scanning","text":"<pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      scan_label:\n        description: 'Label to use for scanning'\n        required: true\n        default: 'scan-target=true'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  dynamic-scan:\n    name: Dynamic RBAC Pod Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          saf --version\n\n      - name: Create test infrastructure\n        run: |\n          # Extract label key and value\n          LABEL_KEY=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.scan_label }}\" | cut -d= -f2)\n\n          # Create test namespace\n          kubectl create namespace dynamic-scan\n\n          # Create a unique identifier for this run\n          RUN_ID=\"run-$(date +%s)\"\n          echo \"RUN_ID=${RUN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create multiple test pods with different images and labels\n          for i in {1..3}; do\n            cat &lt;&lt;EOF | kubectl apply -f -\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: pod-${i}-${RUN_ID}\n              namespace: dynamic-scan\n              labels:\n                app: test-pod-${i}\n                ${LABEL_KEY}: \"${i == 1 &amp;&amp; \"${LABEL_VALUE}\" || \"false\"}\"\n            spec:\n              containers:\n              - name: container\n                image: ${{ github.event.inputs.target_image }}\n                command: [\"sleep\", \"infinity\"]\n            EOF\n          done\n\n          # Wait for pods to be running\n          kubectl wait --for=condition=ready pod -l app=test-pod-1 -n dynamic-scan --timeout=120s\n\n          # Get the name of the pod with our scan label\n          TARGET_POD=$(kubectl get pods -n dynamic-scan -l ${LABEL_KEY}=${LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_KEY}=${LABEL_VALUE}\"\n            exit 1\n          fi\n          echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; $GITHUB_ENV\n\n          # Show all pods in the namespace\n          kubectl get pods -n dynamic-scan --show-labels\n\n      - name: Set up label-based RBAC\n        run: |\n          # Extract label for RBAC\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          EOF\n\n          # Create role that allows access only to pods with specific label\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${RUN_ID}\n            namespace: dynamic-scan\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: scanner-binding-${RUN_ID}\n            namespace: dynamic-scan\n          subjects:\n          - kind: ServiceAccount\n            name: scanner-sa-${RUN_ID}\n            namespace: dynamic-scan\n          roleRef:\n            kind: Role\n            name: scanner-role-${RUN_ID}\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n      - name: Run scan on labeled pod\n        run: |\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=15m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scan-kubeconfig.yaml\n\n          # Find the target pod by label\n          LABEL_SELECTOR=\"${{ github.event.inputs.scan_label }}\"\n          echo \"Looking for pods with label: ${LABEL_SELECTOR}\"\n          TARGET_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan -l ${LABEL_SELECTOR} -o jsonpath='{.items[0].metadata.name}')\n          if [ -z \"$TARGET_POD\" ]; then\n            echo \"Error: No pod found with label ${LABEL_SELECTOR} using restricted access\"\n            exit 1\n          fi\n          echo \"Found target pod: ${TARGET_POD}\"\n\n          # Get container name\n          CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n dynamic-scan -o jsonpath='{.spec.containers[0].name}')\n          echo \"Container name: ${CONTAINER_NAME}\"\n\n          # Test access to pod\n          echo \"Testing pod access with restricted token:\"\n          KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n dynamic-scan\n\n          # Run CINC Auditor scan\n          echo \"Running CINC Auditor scan on dynamic-scan/${TARGET_POD}/${CONTAINER_NAME}\"\n          KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.cinc_profile }} \\\n            -t k8s-container://dynamic-scan/${TARGET_POD}/${CONTAINER_NAME} \\\n            --reporter cli json:scan-results.json\n\n          # Save scan exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n          # Process results with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i scan-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Verify RBAC restrictions\n        run: |\n          # Generate token for scanning\n          TOKEN=$(kubectl create token scanner-sa-${RUN_ID} -n dynamic-scan --duration=5m)\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; test-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: dynamic-scan\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          echo \"## RBAC Security Verification\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check what we CAN do\n          echo \"Verifying what we CAN do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Can list pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl get pods -n dynamic-scan &gt; /dev/null &amp;&amp; \n            echo \"\u2705 Can list pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot list pods\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Can exec into labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${TARGET_POD} &amp;&amp;\n            echo \"\u2705 Can exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u274c Cannot exec into target pod\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # Check what we CANNOT do\n          echo \"Verifying what we CANNOT do with restricted RBAC:\" | tee -a $GITHUB_STEP_SUMMARY\n          echo \"Cannot create pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can create pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot create pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          echo \"Cannot delete pods:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i delete pods -n dynamic-scan &amp;&amp; \n            echo \"\u274c Security issue: Can delete pods\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot delete pods (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n          # For non-labeled pods, we should be able to list them but not exec into them\n          OTHER_POD=$(kubectl get pods -n dynamic-scan -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n          echo \"Cannot exec into non-labeled pod:\" | tee -a $GITHUB_STEP_SUMMARY\n          KUBECONFIG=test-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n dynamic-scan --resource-name=${OTHER_POD} &amp;&amp; \n            echo \"\u274c Security issue: Can exec into non-target pod\" | tee -a $GITHUB_STEP_SUMMARY || \n            echo \"\u2705 Cannot exec into non-target pod (expected)\" | tee -a $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC results\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete namespace dynamic-scan\n</code></pre> <p>This workflow implements:</p> <ul> <li>Label-based pod selection for targeted scanning</li> <li>Least-privilege RBAC model</li> <li>Dynamic service account and token creation</li> </ul>"},{"location":"integration/approach-mapping/#setup-and-scan","title":"Setup and Scan","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements:</p> <ul> <li>Scanning pods in existing clusters</li> <li>Using externally provided kubeconfig</li> <li>Limited-duration token generation</li> <li>Annotation-based profile selection</li> </ul>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#standard-pipeline","title":"Standard Pipeline","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements:</p> <ul> <li>Standard Kubernetes API approach</li> <li>Four-stage pipeline (deploy, scan, report, cleanup)</li> <li>SAF-CLI integration for report generation</li> <li>Threshold-based quality gates</li> </ul>"},{"location":"integration/approach-mapping/#dynamic-rbac-scanning_1","title":"Dynamic RBAC Scanning","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  KUBERNETES_NAMESPACE: \"dynamic-scan-$CI_PIPELINE_ID\"\n  TARGET_IMAGE: \"busybox:latest\"\n  SCAN_LABEL_KEY: \"scan-target\"\n  SCAN_LABEL_VALUE: \"true\"\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\" # Token duration in minutes\n\n# Allow overriding variables through pipeline triggers or UI\n.dynamic_variables: &amp;dynamic_variables\n  TARGET_IMAGE: ${TARGET_IMAGE}\n  SCAN_LABEL_KEY: ${SCAN_LABEL_KEY}\n  SCAN_LABEL_VALUE: ${SCAN_LABEL_VALUE}\n  CINC_PROFILE: ${CINC_PROFILE}\n  THRESHOLD_VALUE: ${THRESHOLD_VALUE}\n  ADDITIONAL_PROFILE_ANNOTATION: \"${ADDITIONAL_PROFILE_ANNOTATION}\"  # Optional annotation for specifying additional profiles\n\nsetup_test_environment:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create test namespace\n    - kubectl create namespace ${KUBERNETES_NAMESPACE}\n\n    # Create multiple test pods with different images and labels\n    - |\n      # Create 3 pods, but only mark the first one for scanning\n      for i in {1..3}; do\n        cat &lt;&lt;EOF | kubectl apply -f -\n        apiVersion: v1\n        kind: Pod\n        metadata:\n          name: pod-${i}\n          namespace: ${KUBERNETES_NAMESPACE}\n          labels:\n            app: test-pod-${i}\n            ${SCAN_LABEL_KEY}: \"$([ $i -eq 1 ] &amp;&amp; echo \"${SCAN_LABEL_VALUE}\" || echo \"false\")\"\n          annotations:\n            scan-profile: \"${CINC_PROFILE}\"\n            $([ -n \"${ADDITIONAL_PROFILE_ANNOTATION}\" ] &amp;&amp; echo \"${ADDITIONAL_PROFILE_ANNOTATION}\" || echo \"\")\n        spec:\n          containers:\n          - name: container\n            image: ${TARGET_IMAGE}\n            command: [\"sleep\", \"infinity\"]\n        EOF\n      done\n\n    # Wait for pods to be ready\n    - kubectl wait --for=condition=ready pod -l app=test-pod-1 -n ${KUBERNETES_NAMESPACE} --timeout=120s\n\n    # Get the name of the pod with our scan label\n    - |\n      TARGET_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$TARGET_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n        exit 1\n      fi\n      echo \"TARGET_POD=${TARGET_POD}\" &gt;&gt; deploy.env\n\n    # Save scan profile from annotations if available\n    - |\n      SCAN_PROFILE=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}')\n      if [ -n \"$SCAN_PROFILE\" ]; then\n        echo \"Found scan profile annotation: ${SCAN_PROFILE}\"\n        echo \"SCAN_PROFILE=${SCAN_PROFILE}\" &gt;&gt; deploy.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"SCAN_PROFILE=${CINC_PROFILE}\" &gt;&gt; deploy.env\n      fi\n\n    # Show all pods in the namespace\n    - kubectl get pods -n ${KUBERNETES_NAMESPACE} --show-labels\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_dynamic_rbac:\n  stage: scan\n  needs: [setup_test_environment]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      EOF\n\n    # Create role with label-based access\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role\n        namespace: ${KUBERNETES_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding\n        namespace: ${KUBERNETES_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa\n        namespace: ${KUBERNETES_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token\n    - |\n      TOKEN=$(kubectl create token scanner-sa -n ${KUBERNETES_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_security_scan:\n  stage: scan\n  needs: [setup_test_environment, create_dynamic_rbac]\n  script:\n    # Create kubeconfig with restricted token\n    - |\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scan-kubeconfig.yaml\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n    # Install train-k8s-container plugin\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - npm install -g @mitre/saf\n\n    # Verify the tools\n    - cinc-auditor --version\n    - saf --version\n\n    # Find the target pod by label using the restricted token\n    - |\n      echo \"Looking for pods with label: ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE}\"\n      SCANNED_POD=$(KUBECONFIG=scan-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} -l ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} -o jsonpath='{.items[0].metadata.name}')\n      if [ -z \"$SCANNED_POD\" ]; then\n        echo \"Error: No pod found with label ${SCAN_LABEL_KEY}=${SCAN_LABEL_VALUE} using restricted access\"\n        exit 1\n      fi\n      echo \"Found target pod: ${SCANNED_POD}\"\n\n      # Verify it matches what we expected\n      if [ \"$SCANNED_POD\" != \"$TARGET_POD\" ]; then\n        echo \"Warning: Scanned pod ($SCANNED_POD) doesn't match expected target pod ($TARGET_POD)\"\n      fi\n\n    # Get container name\n    - CONTAINER_NAME=$(kubectl get pod ${TARGET_POD} -n ${KUBERNETES_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n\n    # Run CINC Auditor scan\n    - |\n      echo \"Running CINC Auditor scan on ${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME}\"\n      KUBECONFIG=scan-kubeconfig.yaml cinc-auditor exec ${SCAN_PROFILE} \\\n        -t k8s-container://${KUBERNETES_NAMESPACE}/${TARGET_POD}/${CONTAINER_NAME} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate comprehensive HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\nverify_rbac_restrictions:\n  stage: verify\n  needs: [setup_test_environment, create_dynamic_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a second kubeconfig with restricted token\n    - |\n      cat &gt; verify-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${KUBERNETES_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 verify-kubeconfig.yaml\n\n    # Get a non-target pod name\n    - OTHER_POD=$(kubectl get pods -n ${KUBERNETES_NAMESPACE} -l app=test-pod-2 -o jsonpath='{.items[0].metadata.name}')\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl get pods -n ${KUBERNETES_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${KUBERNETES_NAMESPACE} --resource-name=${TARGET_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n      echo \"Cannot create pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i create pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=verify-kubeconfig.yaml kubectl auth can-i delete pods -n ${KUBERNETES_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n    # Create a security report for MR\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Results\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Details\n\n      - Target Pod: \\`${TARGET_POD}\\`\n      - Container: \\`${CONTAINER_NAME}\\`\n      - Image: \\`${TARGET_IMAGE}\\`\n      - Profile: \\`${SCAN_PROFILE}\\`\n\n      For full results, see the scan artifacts.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\ncleanup:\n  stage: cleanup\n  needs: [setup_test_environment]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete namespace ${KUBERNETES_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements:</p> <ul> <li>Label-based pod targeting</li> <li>Restricted RBAC permissions</li> <li>Time-bound access credentials</li> </ul>"},{"location":"integration/approach-mapping/#gitlab-services-variant","title":"GitLab Services Variant","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide:</p> <ul> <li>Pre-configured scanning environment</li> <li>Separation of scanning tools from main job</li> <li>Reduced pipeline setup time</li> </ul>"},{"location":"integration/approach-mapping/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach is our interim solution for scanning distroless containers while we complete full distroless support in the Kubernetes API Approach.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation_1","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#setup-and-scan-with-debug-containers","title":"Setup and Scan with Debug Containers","text":"<pre><code>name: Setup Minikube and Run CINC Auditor Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      minikube_version:\n        description: 'Minikube version to use'\n        required: true\n        default: 'v1.32.0'\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  setup-and-scan:\n    name: Setup minikube and run CINC Auditor scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup minikube\n        id: minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          minikube-version: ${{ github.event.inputs.minikube_version }}\n          kubernetes-version: ${{ github.event.inputs.kubernetes_version }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          minikube status\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create namespace and test pod\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create test pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: inspec-target\n            namespace: inspec-test\n            labels:\n              app: inspec-target\n              scan-target: \"true\"\n          spec:\n            containers:\n            - name: busybox\n              image: busybox:latest\n              command: [\"sleep\", \"infinity\"]\n          EOF\n\n          # Wait for pod to be running\n          kubectl wait --for=condition=ready pod/inspec-target -n inspec-test --timeout=120s\n\n          # Verify pod is running\n          kubectl get pods -n inspec-test\n\n      - name: Set up RBAC configuration\n        run: |\n          # Create service account\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: ServiceAccount\n          metadata:\n            name: inspec-scanner\n            namespace: inspec-test\n          EOF\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: inspec-test\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"inspec-target\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"inspec-target\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: inspec-test\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: inspec-test\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n inspec-test\n\n      - name: Generate restricted kubeconfig\n        run: |\n          # Get token\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: inspec-test\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set proper permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n inspec-test\n\n      - name: Run CINC Auditor scan with restricted access\n        run: |\n          # Download CINC profile\n          if [[ \"${{ github.event.inputs.cinc_profile }}\" == http* ]]; then\n            # If it's a URL, use it directly\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          elif [[ \"${{ github.event.inputs.cinc_profile }}\" == */* ]]; then\n            # If it's a profile from Chef Supermarket (e.g., dev-sec/linux-baseline)\n            PROFILE=\"${{ github.event.inputs.cinc_profile }}\"\n          else\n            # If it's a local path\n            PROFILE=\"./${{ github.event.inputs.cinc_profile }}\"\n          fi\n\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n            -t k8s-container://inspec-test/inspec-target/busybox \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\ncompliance:\n  min: ${{ github.event.inputs.threshold }}\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\nEOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${{ github.event.inputs.threshold }}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements:</p> <ul> <li>Setup of a minikube cluster for testing</li> <li>Deployment of test containers including distroless containers</li> <li>Configuration for ephemeral debug containers</li> <li>Scanning with CINC Auditor through debug containers</li> </ul>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation_1","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#existing-cluster-with-debug-containers","title":"Existing Cluster with Debug Containers","text":"<pre><code>stages:\n  - prepare\n  - scan\n  - verify\n  - cleanup\n\nvariables:\n  # Default values - override in UI or with pipeline parameters\n  SCAN_NAMESPACE: \"default\"  # Existing namespace where pods are deployed\n  TARGET_LABEL_SELECTOR: \"scan-target=true\"  # Label to identify target pods\n  CINC_PROFILE: \"dev-sec/linux-baseline\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  DURATION_MINUTES: \"15\"  # Token duration in minutes\n\n# Define workflow\nworkflow:\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"web\"  # Manual trigger from UI\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"  # Scheduled pipeline\n    - if: $CI_PIPELINE_SOURCE == \"trigger\"  # API trigger with token\n\n# Find pods to scan in existing cluster\nprepare_scan:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  script:\n    # Configure kubectl with cluster credentials\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create a unique run ID for this pipeline\n    - RUN_ID=\"gl-$CI_PIPELINE_ID-$CI_JOB_ID\"\n    - echo \"RUN_ID=${RUN_ID}\" &gt;&gt; prepare.env\n\n    # Verify the namespace exists\n    - kubectl get namespace ${SCAN_NAMESPACE} || { echo \"Namespace ${SCAN_NAMESPACE} does not exist\"; exit 1; }\n\n    # Find target pods with specified label\n    - |\n      TARGET_PODS=$(kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n      if [ -z \"$TARGET_PODS\" ]; then\n        echo \"No pods found matching label: ${TARGET_LABEL_SELECTOR} in namespace ${SCAN_NAMESPACE}\"\n        exit 1\n      fi\n\n      # Count and list found pods\n      POD_COUNT=$(echo $TARGET_PODS | wc -w)\n      echo \"Found ${POD_COUNT} pods to scan:\"\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR} --show-labels\n\n      # Get the first pod as primary target\n      PRIMARY_POD=$(echo $TARGET_PODS | cut -d' ' -f1)\n      echo \"Primary target pod: ${PRIMARY_POD}\"\n      echo \"PRIMARY_POD=${PRIMARY_POD}\" &gt;&gt; prepare.env\n\n      # Get container name for the primary pod\n      PRIMARY_CONTAINER=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n      echo \"Primary container: ${PRIMARY_CONTAINER}\"\n      echo \"PRIMARY_CONTAINER=${PRIMARY_CONTAINER}\" &gt;&gt; prepare.env\n\n      # Check for custom profile annotation\n      PROFILE_ANNOTATION=$(kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o jsonpath='{.metadata.annotations.scan-profile}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$PROFILE_ANNOTATION\" ]; then\n        echo \"Found profile annotation: ${PROFILE_ANNOTATION}\"\n        echo \"PROFILE=${PROFILE_ANNOTATION}\" &gt;&gt; prepare.env\n      else\n        echo \"Using default profile: ${CINC_PROFILE}\"\n        echo \"PROFILE=${CINC_PROFILE}\" &gt;&gt; prepare.env\n      fi\n  artifacts:\n    reports:\n      dotenv: prepare.env\n\n# Create temporary RBAC for scanning\ncreate_rbac:\n  stage: prepare\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account for scanning\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      EOF\n\n    # Create role with least privilege\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${PRIMARY_POD}\"]\n      EOF\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n        labels:\n          app: security-scanner\n          component: cinc-auditor\n          pipeline: \"${CI_PIPELINE_ID}\"\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-${RUN_ID}\n        namespace: ${SCAN_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${RUN_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n\n    # Generate token for service account\n    - |\n      TOKEN=$(kubectl create token scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --duration=${DURATION_MINUTES}m)\n      SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n      # Save token and cluster info for later stages\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; rbac.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; rbac.env\n  artifacts:\n    reports:\n      dotenv: rbac.env\n\n# Run the security scan with restricted access\nrun_security_scan:\n  stage: scan\n  image: registry.gitlab.com/gitlab-org/security-products/analyzers/container-scanning:5\n  needs: [prepare_scan, create_rbac]\n  script:\n    # Create restricted kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Install CINC Auditor and plugins\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Install SAF CLI\n    - apt-get update &amp;&amp; apt-get install -y npm\n    - npm install -g @mitre/saf\n\n    # Test restricted access\n    - |\n      echo \"Testing restricted access:\"\n      export KUBECONFIG=scanner-kubeconfig.yaml\n      kubectl get pods -n ${SCAN_NAMESPACE} -l ${TARGET_LABEL_SELECTOR}\n\n      echo \"Verifying target pod access:\"\n      kubectl get pod ${PRIMARY_POD} -n ${SCAN_NAMESPACE} -o name || { echo \"Cannot access target pod with restricted token\"; exit 1; }\n\n    # Run the scan\n    - |\n      echo \"Running CINC Auditor scan on ${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER}\"\n      KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${PROFILE} \\\n        -t k8s-container://${SCAN_NAMESPACE}/${PRIMARY_POD}/${PRIMARY_CONTAINER} \\\n        --reporter cli json:scan-results.json\n\n      # Save scan exit code\n      SCAN_EXIT_CODE=$?\n      echo \"SCAN_EXIT_CODE=${SCAN_EXIT_CODE}\" &gt;&gt; scan.env\n      echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n    # Process results with SAF-CLI\n    - |\n      echo \"Generating scan summary with SAF-CLI:\"\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display the summary in the logs\n      cat scan-summary.md\n\n      # Create a threshold file\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0  # No critical failures allowed\n      EOF\n\n      # Apply threshold check\n      echo \"Checking against threshold with min compliance of ${THRESHOLD_VALUE}%:\"\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n      echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce the threshold as a quality gate\n        # exit $THRESHOLD_RESULT\n      fi\n\n      # Generate HTML report\n      saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scan-report.html\n      - threshold.yml\n    reports:\n      dotenv: scan.env\n\n# Verify RBAC permissions are properly restricted\nverify_rbac:\n  stage: verify\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan, create_rbac, run_security_scan]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create restricted kubeconfig for testing\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCAN_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n      chmod 600 scanner-kubeconfig.yaml\n\n    # Check what we CAN do\n    - |\n      echo \"Verifying what we CAN do with restricted RBAC:\"\n      echo \"Can list pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n ${SCAN_NAMESPACE} &gt; /dev/null &amp;&amp; \n        echo \"\u2705 Can list pods\" || \n        echo \"\u274c Cannot list pods\"\n\n      echo \"Can exec into target pod:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${PRIMARY_POD} &amp;&amp;\n        echo \"\u2705 Can exec into target pod\" || \n        echo \"\u274c Cannot exec into target pod\"\n\n    # Check what we CANNOT do\n    - |\n      echo \"Verifying what we CANNOT do with restricted RBAC:\"\n\n      echo \"Cannot create pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can create pods\" || \n        echo \"\u2705 Cannot create pods (expected)\"\n\n      echo \"Cannot delete pods:\"\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i delete pods -n ${SCAN_NAMESPACE} &amp;&amp; \n        echo \"\u274c Security issue: Can delete pods\" || \n        echo \"\u2705 Cannot delete pods (expected)\"\n\n      # Find non-target pod for testing\n      OTHER_POD=$(kubectl get pods -n ${SCAN_NAMESPACE} -l app!=scan-target -o jsonpath='{.items[0].metadata.name}' 2&gt;/dev/null || echo \"\")\n      if [ -n \"$OTHER_POD\" ] &amp;&amp; [ \"$OTHER_POD\" != \"$PRIMARY_POD\" ]; then\n        echo \"Cannot exec into non-target pod:\"\n        KUBECONFIG=scanner-kubeconfig.yaml kubectl auth can-i create pods/exec --subresource=exec -n ${SCAN_NAMESPACE} --resource-name=${OTHER_POD} &amp;&amp; \n          echo \"\u274c Security issue: Can exec into non-target pod\" || \n          echo \"\u2705 Cannot exec into non-target pod (expected)\"\n      fi\n\n    # Create security report\n    - |\n      cat &gt; security-report.md &lt;&lt; EOF\n      # Container Security Scan Report\n\n      ## Scan Details\n\n      - **Pipeline:** ${CI_PIPELINE_ID}\n      - **Target Namespace:** ${SCAN_NAMESPACE}\n      - **Target Pod:** ${PRIMARY_POD}\n      - **Target Container:** ${PRIMARY_CONTAINER}\n      - **CINC Profile:** ${PROFILE}\n      - **Compliance Threshold:** ${THRESHOLD_VALUE}%\n\n      ## RBAC Security Verification\n\n      The scanner service account has properly restricted access:\n      - \u2705 Can list pods in the namespace\n      - \u2705 Can exec into target pods for scanning\n      - \u2705 Cannot create or delete pods\n      - \u2705 Cannot exec into non-target pods\n      - \u2705 Cannot access cluster-wide resources\n\n      ## Scan Results\n\n      $([[ \"${THRESHOLD_RESULT}\" -eq 0 ]] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      See scan artifacts for detailed compliance results.\n      EOF\n  artifacts:\n    paths:\n      - security-report.md\n\n# Always clean up RBAC resources\ncleanup_rbac:\n  stage: cleanup\n  image: bitnami/kubectl:latest\n  needs: [prepare_scan]\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Delete role binding\n    - kubectl delete rolebinding scanner-binding-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete role\n    - kubectl delete role scanner-role-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    # Delete service account\n    - kubectl delete serviceaccount scanner-${RUN_ID} -n ${SCAN_NAMESPACE} --ignore-not-found\n\n    - echo \"RBAC resources cleaned up\"\n</code></pre> <p>This pipeline implements:</p> <ul> <li>Configuration for scanning distroless containers</li> <li>Support for ephemeral debug containers</li> <li>Flexible profile selection</li> </ul>"},{"location":"integration/approach-mapping/#gitlab-services-with-debug-containers","title":"GitLab Services with Debug Containers","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\n# Define a custom service image for CINC Auditor\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job uses the cinc-scanner service container\n  # The service container already has CINC Auditor and the SAF CLI installed\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to service container\n      docker cp scan-kubeconfig.yaml cinc-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n\n      # Run scan in service container\n      docker exec cinc-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        cinc-auditor exec /tmp/profile \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:/tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp cinc-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\n# For distroless containers, we need a specialized approach\nrun_distroless_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  # This job will only run if the DISTROLESS variable is set to \"true\"\n  rules:\n    - if: $DISTROLESS == \"true\"\n  # Use our specialized distroless scanner service container\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Copy kubeconfig and profiles to distroless scanner service container\n      docker cp scan-kubeconfig.yaml distroless-scanner:/tmp/\n      docker cp ${CINC_PROFILE_PATH} distroless-scanner:/tmp/profile\n\n      # Run specialized distroless scan in service container\n      docker exec distroless-scanner bash -c \"\n        KUBECONFIG=/tmp/scan-kubeconfig.yaml \\\n        /opt/scripts/scan-distroless.sh \\\n        ${SCANNER_NAMESPACE} ${TARGET_POD} ${TARGET_CONTAINER} \\\n        /tmp/profile /tmp/scan-results.json\n\n        # Generate scan summary using SAF CLI\n        saf summary --input /tmp/scan-results.json --output-md /tmp/scan-summary.md\n\n        # Check scan against threshold\n        saf threshold -i /tmp/scan-results.json -t ${THRESHOLD_VALUE}\n        echo \\$? &gt; /tmp/threshold_result.txt\n      \"\n\n      # Copy results back from service container\n      docker cp distroless-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp distroless-scanner:/tmp/scan-summary.md ./scan-summary.md\n      docker cp distroless-scanner:/tmp/threshold_result.txt ./threshold_result.txt\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Process threshold result\n      THRESHOLD_RESULT=$(cat threshold_result.txt)\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide:</p> <ul> <li>Specialized service container for distroless scanning</li> <li>Pre-installed dependencies for debug container approach</li> <li>Simplified workflow for distroless container scanning</li> </ul>"},{"location":"integration/approach-mapping/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach is our universal interim solution with minimal privileges that works for both standard and distroless containers.</p>"},{"location":"integration/approach-mapping/#github-actions-implementation_2","title":"GitHub Actions Implementation","text":""},{"location":"integration/approach-mapping/#sidecar-scanner-approach","title":"Sidecar Scanner Approach","text":"<pre><code>name: CINC Auditor Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      kubernetes_version:\n        description: 'Kubernetes version to use'\n        required: true\n        default: 'v1.28.3'\n      target_image:\n        description: 'Target container image to scan'\n        required: true\n        default: 'busybox:latest'\n      is_distroless:\n        description: 'Is the target a distroless container?'\n        required: true\n        default: 'false'\n        type: boolean\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  sidecar-scan:\n    name: Sidecar Container Scan\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Kubernetes\n        id: kind\n        uses: helm/kind-action@v1.8.0\n        with:\n          version: v0.20.0\n          cluster_name: scan-cluster\n          config: |\n            kind: Cluster\n            apiVersion: kind.x-k8s.io/v1alpha4\n            nodes:\n            - role: control-plane\n              kubeadmConfigPatches:\n                - |\n                  kind: InitConfiguration\n                  nodeRegistration:\n                    kubeletExtraArgs:\n                      feature-gates: \"EphemeralContainers=true\"\n                      \"system-reserved\": \"cpu=500m,memory=500Mi\"\n              image: kindest/node:${{ github.event.inputs.kubernetes_version }}\n\n      - name: Get cluster status\n        run: |\n          kubectl get nodes\n          kubectl cluster-info\n\n      - name: Build CINC Auditor Scanner container\n        run: |\n          # Create a Dockerfile for the CINC Auditor scanner container\n          cat &gt; Dockerfile.scanner &lt;&lt; EOF\n          FROM ruby:3.0-slim\n\n          # Install dependencies\n          RUN apt-get update &amp;&amp; apt-get install -y \\\n              curl \\\n              gnupg \\\n              procps \\\n              nodejs \\\n              npm \\\n              &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n          # Install CINC Auditor\n          RUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n          # Install SAF CLI\n          RUN npm install -g @mitre/saf\n\n          # Copy profiles\n          COPY examples/cinc-profiles/container-baseline /opt/profiles/container-baseline\n\n          # Verify installation\n          RUN cinc-auditor --version &amp;&amp; \\\n              saf --version\n\n          # Create a simple script to scan in sidecar mode\n          RUN echo '#!/bin/bash \\n\\\n          TARGET_PID=\\$(ps aux | grep -v grep | grep \"\\$1\" | head -1 | awk \"{print \\\\\\$2}\") \\n\\\n          echo \"Target process identified: PID \\$TARGET_PID\" \\n\\\n          \\n\\\n          cinc-auditor exec /opt/profiles/\\$2 \\\\\\n\\\n            -b os=linux \\\\\\n\\\n            --target=/proc/\\$TARGET_PID/root \\\\\\n\\\n            --reporter cli json:/results/scan-results.json \\n\\\n          \\n\\\n          saf summary --input /results/scan-results.json --output-md /results/scan-summary.md \\n\\\n          \\n\\\n          saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml \\n\\\n          echo \\$? &gt; /results/threshold-result.txt \\n\\\n          \\n\\\n          touch /results/scan-complete \\n\\\n          ' &gt; /usr/local/bin/run-scanner\n\n          RUN chmod +x /usr/local/bin/run-scanner\n\n          # Default command\n          CMD [\"/bin/bash\"]\n          EOF\n\n          # Build the scanner image\n          docker build -t cinc-scanner:latest -f Dockerfile.scanner .\n\n          # Load the image into kind\n          kind load docker-image cinc-scanner:latest --name scan-cluster\n\n      - name: Create namespace and prepare environment\n        run: |\n          # Create namespace\n          kubectl create namespace inspec-test\n\n          # Create threshold ConfigMap\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${{ github.event.inputs.threshold }}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          kubectl create configmap inspec-thresholds \\\n            --from-file=threshold.yml=threshold.yml \\\n            -n inspec-test\n\n      - name: Deploy pod with scanner sidecar\n        run: |\n          # Create the pod with shared process namespace\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: app-scanner\n            namespace: inspec-test\n            labels:\n              app: scanner-pod\n          spec:\n            shareProcessNamespace: true  # Enable shared process namespace\n            containers:\n            # Target container to be scanned\n            - name: target\n              image: ${{ github.event.inputs.target_image }}\n              command: [\"sleep\", \"3600\"]\n\n            # CINC Auditor scanner sidecar\n            - name: scanner\n              image: cinc-scanner:latest\n              command: \n              - \"/bin/bash\"\n              - \"-c\"\n              - |\n                # Wait for the main container to start\n                sleep 10\n\n                echo \"Starting CINC Auditor scan...\"\n\n                # Use the script to find process and run scanner\n                run-scanner \"sleep 3600\" \"container-baseline\" \n\n                # Keep container running briefly to allow result retrieval\n                echo \"Scan complete. Results available in /results directory.\"\n                sleep 300\n              volumeMounts:\n              - name: shared-results\n                mountPath: /results\n              - name: thresholds\n                mountPath: /opt/thresholds\n\n            volumes:\n            - name: shared-results\n              emptyDir: {}\n            - name: thresholds\n              configMap:\n                name: inspec-thresholds\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/app-scanner -n inspec-test --timeout=300s\n\n          # Verify the pod is ready\n          kubectl get pod app-scanner -n inspec-test\n\n      - name: Wait for scan to complete and retrieve results\n        run: |\n          # Wait for scan to complete\n          echo \"Waiting for scan to complete...\"\n          until kubectl exec -it app-scanner -n inspec-test -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n            echo \"Scan in progress...\"\n            sleep 5\n          done\n\n          # Retrieve scan results\n          echo \"Retrieving scan results...\"\n          kubectl cp inspec-test/app-scanner:/results/scan-results.json ./scan-results.json -c scanner\n          kubectl cp inspec-test/app-scanner:/results/scan-summary.md ./scan-summary.md -c scanner\n\n          # Check threshold result\n          if kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n            THRESHOLD_RESULT=$(kubectl exec -it app-scanner -n inspec-test -c scanner -- cat /results/threshold-result.txt)\n            echo \"THRESHOLD_RESULT=${THRESHOLD_RESULT}\" &gt;&gt; $GITHUB_ENV\n\n            if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n              echo \"\u2705 Security scan passed threshold requirements\"\n            else\n              echo \"\u274c Security scan failed to meet threshold requirements\"\n            fi\n          else\n            echo \"Warning: Threshold result not found\"\n            echo \"THRESHOLD_RESULT=1\" &gt;&gt; $GITHUB_ENV\n          fi\n\n          # Display summary in job output\n          echo \"============= SCAN SUMMARY =============\"\n          cat scan-summary.md\n          echo \"========================================\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate reports\n          saf view -i scan-results.json --output scan-report.html\n          saf generate -i scan-results.json -o csv &gt; results.csv\n          saf generate -i scan-results.json -o junit &gt; junit-results.xml\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Add threshold result to summary\n          if [ \"${{ env.THRESHOLD_RESULT }}\" -eq 0 ]; then\n            echo \"## \u2705 Security scan passed threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else  \n            echo \"## \u274c Security scan failed to meet threshold requirements\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n          echo \"Threshold: ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            scan-results.json\n            scan-summary.md\n            scan-report.html\n            results.csv\n            junit-results.xml\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          kubectl delete namespace inspec-test\n</code></pre> <p>This workflow implements:</p> <ul> <li>Shared process namespace setup</li> <li>Sidecar container deployment with CINC Auditor</li> <li>Process identification and scanning</li> <li>Support for both standard and distroless containers</li> </ul>"},{"location":"integration/approach-mapping/#gitlab-ci-implementation_2","title":"GitLab CI Implementation","text":""},{"location":"integration/approach-mapping/#standard-sidecar-approach","title":"Standard Sidecar Approach","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for CINC profile\n      cat &gt; container-baseline.rb &lt;&lt; EOF\n      # Example CINC Auditor profile for container scanning\n\n      title \"Container Baseline\"\n\n      control \"container-1.1\" do\n        impact 0.7\n        title \"Container files should have proper permissions\"\n        desc \"Critical files in the container should have proper permissions.\"\n\n        describe file('/etc/passwd') do\n          it { should exist }\n          its('mode') { should cmp '0644' }\n        end\n      end\n\n      control \"container-1.2\" do\n        impact 0.5\n        title \"Container should not have unnecessary packages\"\n        desc \"Container should be minimal and not contain unnecessary packages.\"\n\n        describe directory('/var/lib/apt') do\n          it { should_not exist }\n        end\n      end\n      EOF\n\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=container-baseline.rb \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: ruby:3.0-slim\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Install dependencies\n            apt-get update\n            apt-get install -y curl gnupg procps nodejs npm\n\n            # Install CINC Auditor\n            curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n            # Install SAF CLI\n            npm install -g @mitre/saf\n\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=\\$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print \\$2}')\n\n            if [ -z \"\\$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID \\$TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/\\$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=\\$?\n\n            echo \"Scan completed with exit code: \\$SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=\\$?\n                echo \"Threshold validation result: \\$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json ./scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md ./scan-summary.md -c scanner\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline implements:</p> <ul> <li>Pod deployment with shared process namespace</li> <li>Sidecar scanner container configuration</li> <li>Process-based scanning approach</li> </ul>"},{"location":"integration/approach-mapping/#sidecar-with-services","title":"Sidecar with Services","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n  TARGET_IMAGE: \"registry.example.com/my-image:latest\"  # Target image to scan\n  # If scanning a distroless image, set this to true\n  IS_DISTROLESS: \"false\"\n\n# Define a custom service image for CINC Auditor sidecar deployment\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\ndeploy_sidecar_pod:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the namespace if it doesn't exist\n      kubectl get namespace ${SCANNER_NAMESPACE} || kubectl create namespace ${SCANNER_NAMESPACE}\n\n      # Copy profile from within the service container\n      docker cp ${CINC_PROFILE_PATH} cinc-scanner:/tmp/profile\n      docker exec cinc-scanner ls -la /tmp/profile\n\n      # Create ConfigMap for CINC profile from the service container\n      kubectl create configmap inspec-profiles-${CI_PIPELINE_ID} \\\n        --from-file=container-baseline=$(docker exec cinc-scanner find /tmp/profile -name \"*.rb\" | head -1) \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Create ConfigMap for threshold\n      cat &gt; threshold.yml &lt;&lt; EOF\n      compliance:\n        min: ${THRESHOLD_VALUE}\n      failed:\n        critical:\n          max: 0\n      EOF\n\n      kubectl create configmap inspec-thresholds-${CI_PIPELINE_ID} \\\n        --from-file=threshold.yml=threshold.yml \\\n        -n ${SCANNER_NAMESPACE}\n\n      # Deploy the pod with sidecar scanner\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: app-scanner-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: scanner-pod\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        shareProcessNamespace: true  # Enable shared process namespace\n        containers:\n        # Target container to be scanned\n        - name: target\n          image: ${TARGET_IMAGE}\n          command: [\"sleep\", \"3600\"]\n          # For distroless containers, adjust command accordingly\n\n        # CINC Auditor scanner sidecar\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: \n          - \"/bin/bash\"\n          - \"-c\"\n          - |\n            # Wait for the main container to start\n            sleep 10\n\n            echo \"Starting CINC Auditor scan...\"\n\n            # Find the main process of the target container\n            TARGET_PID=$(ps aux | grep -v grep | grep \"sleep 3600\" | head -1 | awk '{print $2}')\n\n            if [ -z \"$TARGET_PID\" ]; then\n              echo \"ERROR: Could not find target process\"\n              exit 1\n            fi\n\n            echo \"Target process identified: PID $TARGET_PID\"\n\n            # Run CINC Auditor against the target filesystem\n            cd /\n            cinc-auditor exec /opt/profiles/container-baseline \\\n              -b os=linux \\\n              --target=/proc/$TARGET_PID/root \\\n              --reporter cli json:/results/scan-results.json\n\n            SCAN_EXIT_CODE=$?\n\n            echo \"Scan completed with exit code: $SCAN_EXIT_CODE\"\n\n            # Process results with SAF\n            if [ -f \"/results/scan-results.json\" ]; then\n              echo \"Processing results with SAF CLI...\"\n              saf summary --input /results/scan-results.json --output-md /results/scan-summary.md\n\n              # Validate against threshold\n              if [ -f \"/opt/thresholds/threshold.yml\" ]; then\n                echo \"Validating against threshold...\"\n                saf threshold -i /results/scan-results.json -t /opt/thresholds/threshold.yml\n                THRESHOLD_RESULT=$?\n                echo \"$THRESHOLD_RESULT\" &gt; /results/threshold-result.txt\n              fi\n            fi\n\n            # Indicate scan is complete\n            touch /results/scan-complete\n\n            # Keep container running briefly to allow result retrieval\n            echo \"Scan complete. Results available in /results directory.\"\n            sleep 300\n          volumeMounts:\n          - name: shared-results\n            mountPath: /results\n          - name: profiles\n            mountPath: /opt/profiles\n          - name: thresholds\n            mountPath: /opt/thresholds\n\n        volumes:\n        - name: shared-results\n          emptyDir: {}\n        - name: profiles\n          configMap:\n            name: inspec-profiles-${CI_PIPELINE_ID}\n        - name: thresholds\n          configMap:\n            name: inspec-thresholds-${CI_PIPELINE_ID}\n      EOF\n\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --timeout=300s\n\n      # Save pod name for later stages\n      echo \"SCANNER_POD=app-scanner-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n    - |\n      # Verify the pod is ready\n      kubectl get pod app-scanner-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE}\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\nretrieve_results:\n  stage: scan\n  needs: [deploy_sidecar_pod]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Wait for scan to complete\n      echo \"Waiting for scan to complete...\"\n      until kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- ls /results/scan-complete &gt;/dev/null 2&gt;&amp;1; do\n        echo \"Scan in progress...\"\n        sleep 5\n      done\n\n      # Retrieve scan results using the service container\n      echo \"Retrieving scan results...\"\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-results.json /tmp/scan-results.json -c scanner\n      kubectl cp ${SCANNER_NAMESPACE}/${SCANNER_POD}:/results/scan-summary.md /tmp/scan-summary.md -c scanner\n\n      # Copy results to service container for processing\n      docker cp /tmp/scan-results.json cinc-scanner:/tmp/\n      docker cp /tmp/scan-summary.md cinc-scanner:/tmp/\n\n      # Process results in the service container\n      docker exec cinc-scanner bash -c \"\n        # Generate normalized report\n        saf normalize -i /tmp/scan-results.json -o /tmp/normalized-results.json\n\n        # Additional report processing\n        saf view -i /tmp/scan-results.json --output /tmp/scan-report.html\n      \"\n\n      # Copy processed results back\n      docker cp cinc-scanner:/tmp/normalized-results.json ./normalized-results.json\n      docker cp cinc-scanner:/tmp/scan-report.html ./scan-report.html\n      docker cp cinc-scanner:/tmp/scan-results.json ./scan-results.json\n      docker cp cinc-scanner:/tmp/scan-summary.md ./scan-summary.md\n\n      # Check threshold result\n      if kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt &gt;/dev/null 2&gt;&amp;1; then\n        THRESHOLD_RESULT=$(kubectl exec -it ${SCANNER_POD} -n ${SCANNER_NAMESPACE} -c scanner -- cat /results/threshold-result.txt)\n        echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n        if [ \"${THRESHOLD_RESULT}\" -eq 0 ]; then\n          echo \"\u2705 Security scan passed threshold requirements\"\n        else\n          echo \"\u274c Security scan failed to meet threshold requirements\"\n        fi\n      else\n        echo \"Warning: Threshold result not found\"\n        echo \"THRESHOLD_PASSED=1\" &gt;&gt; scan.env\n      fi\n\n      # Display summary in job output\n      echo \"============= SCAN SUMMARY =============\"\n      cat scan-summary.md\n      echo \"========================================\"\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - normalized-results.json\n      - scan-report.html\n    reports:\n      dotenv: scan.env\n\n# This example shows how to utilize the service container \n# to generate specialized reports from the scan results\ngenerate_report:\n  stage: report\n  needs: [retrieve_results]\n  script:\n    - |\n      # Use the service container to generate comprehensive reports\n      docker cp scan-results.json cinc-scanner:/tmp/\n\n      # Generate multiple report formats in the service container\n      docker exec cinc-scanner bash -c \"\n        cd /tmp\n\n        # Generate HTML report\n        saf view -i scan-results.json --output enhanced-report.html\n\n        # Generate CSV report\n        saf generate -i scan-results.json -o csv &gt; results.csv\n\n        # Generate Excel report\n        saf generate -i scan-results.json -o xlsx &gt; results.xlsx\n\n        # Generate JUnit report for CI integration\n        saf generate -i scan-results.json -o junit &gt; junit.xml\n      \"\n\n      # Copy all reports back\n      docker cp cinc-scanner:/tmp/enhanced-report.html ./enhanced-report.html\n      docker cp cinc-scanner:/tmp/results.csv ./results.csv\n      docker cp cinc-scanner:/tmp/results.xlsx ./results.xlsx\n      docker cp cinc-scanner:/tmp/junit.xml ./junit.xml\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      $([ \"${THRESHOLD_PASSED}\" -eq 0 ] &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\")\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the enhanced report artifacts.\n\n      * HTML Report: enhanced-report.html\n      * CSV Report: results.csv\n      * Excel Report: results.xlsx\n      * JUnit Report: junit.xml\n      EOF\n  artifacts:\n    paths:\n      - enhanced-report.html\n      - results.csv\n      - results.xlsx\n      - junit.xml\n      - scan-report.md\n    reports:\n      junit: junit.xml\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [retrieve_results]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${SCANNER_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-profiles-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete configmap/inspec-thresholds-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre> <p>This pipeline uses GitLab services to provide:</p> <ul> <li>Pre-configured sidecar scanner service</li> <li>Simplified deployment and configuration</li> <li>Consistent scanning environment</li> </ul>"},{"location":"integration/approach-mapping/#choosing-the-right-example","title":"Choosing the Right Example","text":"<p>Use this guide to select the appropriate CI/CD implementation:</p> <ol> <li>For Standard Containers in Production:</li> <li>GitHub: Use <code>github-workflow-examples/existing-cluster-scanning.yml</code></li> <li> <p>GitLab: Use <code>gitlab-pipeline-examples/gitlab-ci.yml</code> or <code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code></p> </li> <li> <p>For Distroless Containers:</p> </li> <li>GitHub: Use <code>github-workflow-examples/setup-and-scan.yml</code> with distroless configuration</li> <li> <p>GitLab: Use <code>gitlab-pipeline-examples/existing-cluster-scanning.yml</code> with distroless configuration or <code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code> with distroless service</p> </li> <li> <p>For Universal Scanning (both standard and distroless):</p> </li> <li>GitHub: Use <code>github-workflow-examples/sidecar-scanner.yml</code></li> <li> <p>GitLab: Use <code>gitlab-pipeline-examples/gitlab-ci-sidecar.yml</code> or <code>gitlab-pipeline-examples/gitlab-ci-sidecar-with-services.yml</code></p> </li> <li> <p>For Local Development and Testing:</p> </li> <li>GitHub: Use <code>github-workflow-examples/setup-and-scan.yml</code></li> <li>GitLab: Use <code>gitlab-pipeline-examples/gitlab-ci.yml</code> with minikube setup</li> </ol>"},{"location":"integration/approach-mapping/#features-comparison","title":"Features Comparison","text":"Feature Kubernetes API Approach Debug Container Approach Sidecar Container Approach Standard Container Support \u2705 Best approach \u2705 Supported \u2705 Supported Distroless Container Support \ud83d\udd04 In progress \u2705 Best interim approach \u2705 Supported No Pod Modification Required \u2705 Yes \u274c No \u274c No Minimal Privileges \u2705 Yes \u274c No \u2705 Yes GitHub Actions Support \u2705 Yes \u2705 Yes \u2705 Yes GitLab CI Support \u2705 Yes \u2705 Yes \u2705 Yes GitLab Services Support \u2705 Yes \u2705 Yes \u2705 Yes"},{"location":"integration/gitlab-services-analysis/","title":"Analysis: GitLab CI Services for Container Scanning","text":"<p>This document provides an analysis of using GitLab CI/CD Services for enhancing our container scanning workflow.</p>"},{"location":"integration/gitlab-services-analysis/#executive-summary","title":"Executive Summary","text":"<p>GitLab CI Services provide an excellent way to improve our container scanning workflow, particularly for distroless containers. The services approach allows us to create specialized, pre-configured environments for scanning while maintaining a clean separation between the scanning tools and the CI/CD job itself.</p> <p>Recommendation: Implement GitLab CI Services for our scanning workflow to improve maintainability, consistency, and support for both standard and distroless container scanning approaches.</p>"},{"location":"integration/gitlab-services-analysis/#key-findings","title":"Key Findings","text":""},{"location":"integration/gitlab-services-analysis/#benefits","title":"Benefits","text":"<ol> <li> <p>Pre-configured Scanning Environment: Services allow us to create Docker images with CINC Auditor, the train-k8s-container plugin, and the SAF CLI pre-installed, eliminating the need to install these in each job.</p> </li> <li> <p>Support for Both Scanning Approaches: Different service containers can be created for standard and distroless container scanning, supporting both our approaches without complicating the CI/CD configuration.</p> </li> <li> <p>Improved Consistency: Every scan job uses the exact same scanning environment, reducing variability and potential issues across different runners.</p> </li> <li> <p>Reduced Setup Time: By moving the installation of dependencies to the container build process, we reduce the runtime of each job significantly.</p> </li> <li> <p>Better Isolation: Scanning tools are isolated from the CI/CD environment, reducing potential conflicts with other job dependencies.</p> </li> </ol>"},{"location":"integration/gitlab-services-analysis/#potential-challenges","title":"Potential Challenges","text":"<ol> <li> <p>Additional Complexity: Introducing services adds another layer to the CI/CD configuration, which may be challenging for users to understand initially.</p> </li> <li> <p>Docker-in-Docker Requirements: Services require either Docker socket access or Docker-in-Docker service, which may not be available in all CI/CD environments.</p> </li> <li> <p>Maintenance Overhead: Scanner service images need to be maintained and updated as dependencies change.</p> </li> </ol>"},{"location":"integration/gitlab-services-analysis/#implementation-recommendations","title":"Implementation Recommendations","text":""},{"location":"integration/gitlab-services-analysis/#1-create-specialized-service-images","title":"1. Create Specialized Service Images","text":"<p>Build and maintain two specialized Docker images:</p> <ul> <li>Standard Scanner Image: Contains CINC Auditor with the train-k8s-container plugin for scanning standard containers.</li> <li>Distroless Scanner Image: Includes the additional tooling needed for our distroless container scanning approach.</li> </ul>"},{"location":"integration/gitlab-services-analysis/#2-provide-clear-documentation","title":"2. Provide Clear Documentation","text":"<p>Create clear documentation that explains:</p> <ul> <li>How services are used in the scanning workflow</li> <li>When to use standard vs. distroless scanning</li> <li>How to troubleshoot common issues</li> </ul>"},{"location":"integration/gitlab-services-analysis/#3-cicd-configuration-examples","title":"3. CI/CD Configuration Examples","text":"<p>Provide both basic examples for simple setups and advanced examples that leverage services for more complex scenarios.</p>"},{"location":"integration/gitlab-services-analysis/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Services add some overhead due to additional container startup</li> <li>Balance this with the time saved by not installing dependencies in each job</li> <li>Consider caching strategies for service images</li> </ul>"},{"location":"integration/gitlab-services-analysis/#comparison-with-github-actions","title":"Comparison with GitHub Actions","text":"<p>While GitHub Actions doesn't provide an exact equivalent to GitLab CI Services, similar benefits can be achieved using:</p> <ul> <li>Custom container actions</li> <li>Service containers feature</li> <li>Job containers that come pre-configured with necessary tools</li> </ul> <p>For GitHub Actions integration, we recommend a similar approach of creating specialized containers while accounting for the differences in how GitHub Actions handles services.</p>"},{"location":"integration/gitlab-services-analysis/#next-steps","title":"Next Steps","text":"<ol> <li>Build and publish the scanner service Docker images</li> <li>Update GitLab CI example templates to demonstrate services usage</li> <li>Enhance documentation to explain the services approach</li> <li>Create parallel GitHub Actions examples for cross-platform compatibility</li> </ol>"},{"location":"integration/gitlab-services-analysis/#conclusion","title":"Conclusion","text":"<p>GitLab CI Services provide a significant enhancement to our container scanning workflow without overcomplicating it. By creating specialized, pre-configured scanner images, we can improve consistency, reduce setup time, and better support both standard and distroless container scanning approaches. The benefits outweigh the additional complexity, making services an excellent choice for improving our GitLab CI integration.</p>"},{"location":"integration/inventory/","title":"Integration Directory Contents","text":"<p>This page provides an inventory of all files in the integration section of the documentation.</p>"},{"location":"integration/inventory/#main-files","title":"Main Files","text":"File Description index.md Overview of CI/CD integration options approach-mapping.md Mapping of scanning approaches to CI/CD platforms index.md General overview of integration capabilities gitlab-services-analysis.md Analysis of GitLab Services integration approach"},{"location":"integration/inventory/#subdirectories","title":"Subdirectories","text":"Directory Description platforms/ Integration guides for specific CI/CD platforms workflows/ Workflows for integrating different scanning approaches examples/ Practical examples of CI/CD integrations configuration/ Configuration guidance for CI/CD integrations"},{"location":"integration/inventory/#platform-integration-files","title":"Platform Integration Files","text":"File Description platforms/index.md Overview of CI/CD platform integrations platforms/github-actions.md GitHub Actions integration guide platforms/gitlab-ci.md GitLab CI integration guide platforms/gitlab-services.md GitLab Services integration guide Jenkins Integration Jenkins integration guide (coming soon) Azure DevOps Integration Azure DevOps integration guide (coming soon) Custom Platforms Integration Custom CI/CD platform integration guide (coming soon)"},{"location":"integration/inventory/#workflow-integration-files","title":"Workflow Integration Files","text":"File Description workflows/index.md Overview of integration workflows workflows/standard-container.md Standard container workflow integration workflows/distroless-container.md Distroless container workflow integration workflows/sidecar-container.md Sidecar container workflow integration workflows/security-workflows.md Security-focused integration workflows"},{"location":"integration/inventory/#example-files","title":"Example Files","text":"File Description examples/index.md Overview of integration examples examples/github-examples.md GitHub Actions examples examples/gitlab-examples.md GitLab CI examples GitLab Services Examples GitLab Services examples (coming soon) Custom Integration Examples Custom integration examples (coming soon)"},{"location":"integration/inventory/#configuration-files","title":"Configuration Files","text":"File Description configuration/index.md Overview of integration configuration configuration/environment-variables.md Environment variable configuration configuration/secrets-management.md Secrets and credential management configuration/thresholds-integration.md Threshold configuration for CI/CD pipelines configuration/reporting.md Results reporting configuration"},{"location":"integration/inventory/#related-directories","title":"Related Directories","text":"<ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>Examples</li> </ul>"},{"location":"integration/inventory/#related-links","title":"Related Links","text":"<ul> <li>Scanning Approaches</li> <li>Kubernetes Setup</li> <li>Advanced Configuration</li> </ul>"},{"location":"integration/configuration/","title":"Integration Configuration","text":"<p>This section provides documentation on configuring container scanning integrations in CI/CD environments.</p>"},{"location":"integration/configuration/#overview","title":"Overview","text":"<p>Proper configuration is essential for successful container scanning in CI/CD pipelines. This section covers various configuration aspects, including:</p> <ul> <li>Environment Variables: Managing configuration parameters across different environments</li> <li>Secrets Management: Securely handling sensitive information in CI/CD pipelines</li> <li>Thresholds Integration: Implementing compliance thresholds for automated quality gates</li> <li>Reporting Configuration: Generating and distributing scan results in various formats</li> </ul>"},{"location":"integration/configuration/#key-configuration-considerations","title":"Key Configuration Considerations","text":"<p>When configuring container scanning in CI/CD pipelines, consider the following factors:</p> <ol> <li>Security: Ensure credentials and sensitive information are properly secured</li> <li>Flexibility: Allow configuration to adapt to different environments (dev, staging, prod)</li> <li>Maintainability: Use consistent naming conventions and documented parameters</li> <li>Reproducibility: Ensure configuration produces consistent results across runs</li> <li>Integration: Enable interoperability with existing security tools and processes</li> </ol>"},{"location":"integration/configuration/#common-configuration-patterns","title":"Common Configuration Patterns","text":"<p>The following patterns are commonly used when configuring container scanning:</p>"},{"location":"integration/configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Configure different scanning parameters based on the target environment:</p> <pre><code>variables:\n  # Base settings\n  SCANNER_LOG_LEVEL: info\n  RESULTS_DIR: ./scan-results\n\n  # Environment-specific thresholds\n  THRESHOLD_DEVELOP: 50\n  THRESHOLD_STAGING: 70\n  THRESHOLD_PRODUCTION: 90\n</code></pre>"},{"location":"integration/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Adapt scanning behavior based on build parameters:</p> <pre><code># Determine threshold based on branch\nif [ \"$CI_COMMIT_BRANCH\" == \"main\" ]; then\n  THRESHOLD=$THRESHOLD_PRODUCTION\nelif [ \"$CI_COMMIT_BRANCH\" == \"staging\" ]; then\n  THRESHOLD=$THRESHOLD_STAGING\nelse\n  THRESHOLD=$THRESHOLD_DEVELOP\nfi\n</code></pre>"},{"location":"integration/configuration/#component-specific-configuration","title":"Component-Specific Configuration","text":"<p>Apply different scanning configurations based on component type:</p> <pre><code># For API containers\nif [[ \"$CONTAINER_TYPE\" == \"api\" ]]; then\n  PROFILE=\"api-security-profile\"\n  THRESHOLD=90\n# For database containers\nelif [[ \"$CONTAINER_TYPE\" == \"db\" ]]; then\n  PROFILE=\"database-security-profile\"\n  THRESHOLD=95\n# Default configuration\nelse\n  PROFILE=\"default-security-profile\"\n  THRESHOLD=80\nfi\n</code></pre>"},{"location":"integration/configuration/#getting-started","title":"Getting Started","text":"<p>To get started with container scanning configuration, review the following pages:</p> <ul> <li>Environment Variables - Learn how to configure scanner parameters</li> <li>Secrets Management - Securely manage sensitive information</li> <li>Thresholds Integration - Configure compliance thresholds</li> <li>Reporting Configuration - Set up results visualization and reporting</li> </ul>"},{"location":"integration/configuration/#related-resources","title":"Related Resources","text":"<ul> <li>GitHub Actions Integration</li> <li>GitLab CI/CD Integration</li> <li>Standard Container Workflow</li> <li>Distroless Container Workflow</li> <li>Sidecar Container Workflow</li> </ul>"},{"location":"integration/configuration/environment-variables/","title":"Environment Variables for Integration","text":"<p>This page documents environment variables used for container scanning integrations.</p>"},{"location":"integration/configuration/environment-variables/#overview","title":"Overview","text":"<p>Environment variables provide a flexible way to configure container scanning across different CI/CD environments. They allow you to:</p> <ul> <li>Separate configuration from implementation</li> <li>Manage sensitive information securely</li> <li>Maintain consistent configuration across environments</li> <li>Easily override defaults when needed</li> </ul>"},{"location":"integration/configuration/environment-variables/#common-environment-variables","title":"Common Environment Variables","text":"<p>The following environment variables are commonly used across all scanning approaches:</p> Variable Description Default Used In <code>KUBE_NAMESPACE</code> Kubernetes namespace where pods are located <code>default</code> All workflows <code>KUBECONFIG</code> Path to Kubernetes configuration file None (Required) All workflows <code>KUBE_CONTEXT</code> Kubernetes context to use Current context All workflows <code>INSPEC_PROFILE</code> InSpec/CINC profile to use for scanning None (Required) All workflows <code>THRESHOLD_SCORE</code> Minimum passing score (0-100) <code>70</code> All workflows <code>SCANNER_LOG_LEVEL</code> Log level for scanner (debug, info, warn, error) <code>info</code> All workflows <code>RESULTS_DIR</code> Directory for scan results <code>./results</code> All workflows <code>REPORT_FORMAT</code> Format for scan reports (json, xml, html) <code>json</code> All workflows"},{"location":"integration/configuration/environment-variables/#kubernetes-api-approach-variables","title":"Kubernetes API Approach Variables","text":"<p>These variables are specific to scanning standard containers using the Kubernetes API:</p> Variable Description Default Used In <code>KUBE_POD_NAME</code> Name of the pod to scan None (Required) Standard container scanning <code>KUBE_CONTAINER_NAME</code> Name of the container to scan First container in pod Standard container scanning <code>SCANNER_TRANSPORT</code> Transport mechanism for scanner <code>k8s-container</code> Standard container scanning <code>SCANNER_SA_NAME</code> Service account name for scanner <code>scanner-sa</code> Standard container scanning <code>SCANNER_ROLE_NAME</code> Role name for scanner <code>scanner-role</code> Standard container scanning <code>SCANNER_TOKEN_DURATION</code> Duration for scanner token <code>15m</code> Standard container scanning"},{"location":"integration/configuration/environment-variables/#debug-container-approach-variables","title":"Debug Container Approach Variables","text":"<p>These variables are specific to scanning distroless containers using the debug container approach:</p> Variable Description Default Used In <code>DISTROLESS_POD_NAME</code> Name of the distroless pod to scan None (Required) Distroless container scanning <code>DISTROLESS_CONTAINER_NAME</code> Name of the distroless container to scan First container in pod Distroless container scanning <code>DEBUG_CONTAINER_IMAGE</code> Image for debug container <code>busybox:latest</code> Distroless container scanning <code>DEBUG_CONTAINER_NAME</code> Name for debug container <code>debugger</code> Distroless container scanning <code>DEBUG_SA_NAME</code> Service account name for debug container <code>debug-scanner-sa</code> Distroless container scanning <code>DEBUG_ROLE_NAME</code> Role name for debug container <code>debug-scanner-role</code> Distroless container scanning <code>DEBUG_TOKEN_DURATION</code> Duration for debug container token <code>30m</code> Distroless container scanning"},{"location":"integration/configuration/environment-variables/#sidecar-container-approach-variables","title":"Sidecar Container Approach Variables","text":"<p>These variables are specific to scanning containers using the sidecar approach:</p> Variable Description Default Used In <code>SIDECAR_SCANNER_IMAGE</code> Image for sidecar scanner <code>cincproject/auditor:latest</code> Sidecar container scanning <code>SIDECAR_CONTAINER_NAME</code> Name for sidecar container <code>scanner</code> Sidecar container scanning <code>TARGET_CONTAINER_NAME</code> Name of the target container First container in pod Sidecar container scanning <code>SHARE_PROCESS_NAMESPACE</code> Enable shared process namespace <code>true</code> Sidecar container scanning <code>SCANNER_MOUNT_PATH</code> Mount path for scanner results <code>/tmp/results</code> Sidecar container scanning"},{"location":"integration/configuration/environment-variables/#label-based-scanning-variables","title":"Label-Based Scanning Variables","text":"<p>These variables are used for dynamic label-based scanning:</p> Variable Description Default Used In <code>LABEL_SELECTOR</code> Label selector for pods (format: key=value) None (Required) Label-based scanning <code>SCAN_ALL_CONTAINERS</code> Scan all containers in matching pods <code>false</code> Label-based scanning <code>LABEL_SA_NAME</code> Service account name for label scanner <code>label-scanner-sa</code> Label-based scanning <code>LABEL_ROLE_NAME</code> Role name for label scanner <code>label-scanner-role</code> Label-based scanning"},{"location":"integration/configuration/environment-variables/#secret-management-variables","title":"Secret Management Variables","text":"<p>These variables are related to managing secrets for scanning:</p> Variable Description Default Used In <code>KUBE_CONFIG_SECRET</code> Base64-encoded Kubernetes config None All workflows <code>SCANNER_TOKEN</code> Token for scanner service account None All workflows <code>REGISTRY_USERNAME</code> Username for container registry None Workflows with custom images <code>REGISTRY_PASSWORD</code> Password for container registry None Workflows with custom images <code>REGISTRY_URL</code> URL for container registry None Workflows with custom images"},{"location":"integration/configuration/environment-variables/#example-github-actions-configuration","title":"Example: GitHub Actions Configuration","text":"<p>In GitHub Actions, you can set environment variables at the workflow level:</p> <pre><code>name: Container Security Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n\nenv:\n  KUBE_NAMESPACE: ${{ github.event.inputs.namespace }}\n  INSPEC_PROFILE: dev-sec/linux-baseline\n  THRESHOLD_SCORE: 70\n  SCANNER_LOG_LEVEL: info\n  RESULTS_DIR: ./scan-results\n  REPORT_FORMAT: json\n  SCANNER_SA_NAME: github-scanner-sa\n  SCANNER_TOKEN_DURATION: 15m\n</code></pre>"},{"location":"integration/configuration/environment-variables/#example-gitlab-cicd-configuration","title":"Example: GitLab CI/CD Configuration","text":"<p>In GitLab CI/CD, you can set variables at the pipeline level:</p> <pre><code>variables:\n  KUBE_NAMESPACE: default\n  INSPEC_PROFILE: dev-sec/linux-baseline\n  THRESHOLD_SCORE: 70\n  SCANNER_LOG_LEVEL: info\n  RESULTS_DIR: ./scan-results\n  REPORT_FORMAT: json\n  SCANNER_SA_NAME: gitlab-scanner-sa\n  SCANNER_TOKEN_DURATION: 15m\n</code></pre>"},{"location":"integration/configuration/environment-variables/#related-resources","title":"Related Resources","text":"<ul> <li>Secrets Management</li> <li>GitHub Actions Integration Guide</li> <li>GitLab CI/CD Integration Guide</li> <li>GitLab Services Integration Guide</li> <li>Standard Container Workflow</li> <li>Distroless Container Workflow</li> <li>Sidecar Container Workflow</li> <li>Threshold Configuration</li> </ul>"},{"location":"integration/configuration/inventory/","title":"Integration Configuration Inventory","text":"<p>This page provides an inventory of all configuration documentation for container scanning integrations.</p>"},{"location":"integration/configuration/inventory/#configuration-files","title":"Configuration Files","text":"File Description Key Topics index.md Overview of configuration options Common patterns, key considerations environment-variables.md Environment variable documentation Common variables, approach-specific variables secrets-management.md Managing secrets in CI/CD pipelines Secret types, platform-specific practices thresholds-integration.md Configuring compliance thresholds Threshold types, progressive implementation reporting.md Configuring scan result reporting Report types, visualization, distribution"},{"location":"integration/configuration/inventory/#configuration-by-integration-type","title":"Configuration by Integration Type","text":""},{"location":"integration/configuration/inventory/#github-actions-configuration","title":"GitHub Actions Configuration","text":"<p>The following files contain GitHub Actions-specific configuration information:</p> <ul> <li>Environment Variables</li> <li>Secrets Management</li> <li>Thresholds Integration</li> <li>Reporting Configuration</li> </ul>"},{"location":"integration/configuration/inventory/#gitlab-cicd-configuration","title":"GitLab CI/CD Configuration","text":"<p>The following files contain GitLab CI/CD-specific configuration information:</p> <ul> <li>Environment Variables</li> <li>Secrets Management</li> <li>Thresholds Integration</li> <li>Reporting Configuration</li> </ul>"},{"location":"integration/configuration/inventory/#configuration-by-scanning-approach","title":"Configuration by Scanning Approach","text":""},{"location":"integration/configuration/inventory/#standard-container-scanning","title":"Standard Container Scanning","text":"<p>Variables and configuration for scanning standard containers using the Kubernetes API approach:</p> <ul> <li>Kubernetes API Approach Variables</li> <li>Standard Container Workflow Configuration</li> </ul>"},{"location":"integration/configuration/inventory/#distroless-container-scanning","title":"Distroless Container Scanning","text":"<p>Variables and configuration for scanning distroless containers using the debug container approach:</p> <ul> <li>Debug Container Approach Variables</li> <li>Distroless Container Workflow Configuration</li> </ul>"},{"location":"integration/configuration/inventory/#sidecar-container-scanning","title":"Sidecar Container Scanning","text":"<p>Variables and configuration for scanning containers using the sidecar approach:</p> <ul> <li>Sidecar Container Approach Variables</li> <li>Sidecar Container Workflow Configuration</li> </ul>"},{"location":"integration/configuration/inventory/#security-configuration","title":"Security Configuration","text":"<p>Security-related configuration for scanning:</p> <ul> <li>Label-Based Scanning Variables</li> <li>Secret Management Variables</li> <li>Temporary Credentials Workflow</li> <li>Creating Least-Privilege RBAC Roles</li> </ul>"},{"location":"integration/configuration/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>GitHub Actions Integration Guide</li> <li>GitLab CI/CD Integration Guide</li> <li>GitLab Services Integration Guide</li> <li>Standard Container Workflow</li> <li>Distroless Container Workflow</li> <li>Sidecar Container Workflow</li> <li>Security Workflows</li> <li>SAF CLI Documentation</li> </ul>"},{"location":"integration/configuration/reporting/","title":"Reporting Configuration","text":"<p>This page documents reporting options for container scanning results in CI/CD integrations.</p>"},{"location":"integration/configuration/reporting/#overview","title":"Overview","text":"<p>Effective reporting of container scanning results is crucial for:</p> <ul> <li>Visualizing compliance status</li> <li>Tracking security improvements over time</li> <li>Communicating findings to different stakeholders</li> <li>Integrating with existing security dashboards</li> <li>Meeting compliance documentation requirements</li> </ul>"},{"location":"integration/configuration/reporting/#report-types","title":"Report Types","text":"<p>The Kube CINC Secure Scanner supports multiple report types to meet different needs:</p>"},{"location":"integration/configuration/reporting/#1-json-reports","title":"1. JSON Reports","text":"<p>JSON reports provide machine-readable structured data ideal for processing and integration:</p> <pre><code># Generate JSON report\ncinc-auditor exec profile -t target --reporter json:results.json\n</code></pre> <p>Example JSON structure:</p> <pre><code>{\n  \"platform\": {\n    \"name\": \"kubernetes\",\n    \"release\": \"1.24.0\"\n  },\n  \"profiles\": [\n    {\n      \"name\": \"linux-baseline\",\n      \"version\": \"2.4.0\",\n      \"controls\": [\n        {\n          \"id\": \"os-01\",\n          \"title\": \"Ensure password expiry is set\",\n          \"status\": \"passed\",\n          \"results\": [...]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"integration/configuration/reporting/#2-html-reports-via-heimdall-lite","title":"2. HTML Reports via Heimdall Lite","text":"<p>HTML reports are generated through the Heimdall Lite interface, which can be launched via the SAF CLI:</p> <pre><code># Launch Heimdall Lite for interactive visualization\nsaf view heimdall -i results.json\n</code></pre> <p>From the Heimdall Lite interface, users can:</p> <ul> <li>Interactively explore results</li> <li>Filter by status, impact, and other attributes</li> <li>Export to HTML for sharing</li> <li>Print reports directly</li> </ul>"},{"location":"integration/configuration/reporting/#3-markdown-reports","title":"3. Markdown Reports","text":"<p>Markdown reports are ideal for integration with Git platforms like GitHub and GitLab:</p> <pre><code># Generate Markdown summary\nsaf view summary -i results.json --format markdown --output summary.md\n</code></pre> <p>Example Markdown output:</p> <pre><code># Scan Results Summary\n\n## Linux Baseline Profile\n- **Status**: Passed\n- **Score**: 85/100\n- **Controls**: 40 total, 34 passed, 6 failed\n\n### Failed Controls\n1. \u26a0\ufe0f **os-05**: Ensure password complexity\n2. \u26a0\ufe0f **os-10**: Verify file permissions\n</code></pre>"},{"location":"integration/configuration/reporting/#4-junitxml-reports","title":"4. JUnit/XML Reports","text":"<p>JUnit/XML reports integrate with CI/CD test reporting frameworks:</p> <pre><code># Generate JUnit XML report\nsaf convert hdf2junit -i results.json -o results.xml\n</code></pre> <p>Benefits:</p> <ul> <li>Native integration with Jenkins, GitLab, and other CI systems</li> <li>Test result visualization</li> <li>Historical test tracking</li> <li>Build status integration</li> </ul>"},{"location":"integration/configuration/reporting/#integrating-reports-in-cicd-platforms","title":"Integrating Reports in CI/CD Platforms","text":""},{"location":"integration/configuration/reporting/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code>- name: Process scan results\n  run: |\n    # Install SAF CLI\n    npm install -g @mitre/saf\n\n    # Generate scan summary\n    saf view summary -i scan-results.json --format markdown --output scan-summary.md\n\n    # Create GitHub summary\n    echo \"## Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n    cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n    # Optional: Launch Heimdall for report viewing (if running interactively)\n    # saf view heimdall -i scan-results.json\n\n  # Upload results as artifacts\n- name: Upload scan results\n  uses: actions/upload-artifact@v3\n  with:\n    name: scan-results\n    path: |\n      scan-results.json\n      scan-summary.md\n</code></pre>"},{"location":"integration/configuration/reporting/#gitlab-cicd-integration","title":"GitLab CI/CD Integration","text":"<pre><code>process_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Generate scan summary\n    - saf view summary -i scan-results.json --format markdown --output scan-summary.md\n\n    # Create JUnit report for GitLab integration\n    - saf convert hdf2junit -i scan-results.json -o scan-results.xml\n\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      junit: scan-results.xml\n</code></pre>"},{"location":"integration/configuration/reporting/#threshold-validation-in-cicd","title":"Threshold Validation in CI/CD","text":"<p>The SAF CLI provides threshold validation capabilities to implement quality gates in CI/CD pipelines:</p> <pre><code># GitHub Actions example\n- name: Validate scan results against thresholds\n  run: |\n    # Create threshold file\n    cat &gt; threshold.yaml &lt;&lt; EOF\n    compliance:\n      overall: 80\n      failed:\n        total: 0\n        critical: 0\n    EOF\n\n    # Validate results against threshold\n    saf validate threshold -i scan-results.json -T threshold.yaml\n\n    # Store exit code to determine pass/fail\n    THRESHOLD_RESULT=$?\n\n    # Add result to GitHub summary\n    echo \"## Threshold Check\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    if [ $THRESHOLD_RESULT -eq 0 ]; then\n      echo \"\u2705 **PASSED** - Met security thresholds\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    else\n      echo \"\u274c **FAILED** - Did not meet security thresholds\" &gt;&gt; $GITHUB_STEP_SUMMARY\n      exit 1  # Fail the workflow if threshold not met\n    fi\n</code></pre> <p>Example threshold file:</p> <pre><code>compliance:\n  overall: 80  # Overall compliance must be at least 80%\n  failed:\n    total: 5   # No more than 5 failed controls allowed\n    critical: 0 # No critical controls allowed to fail\n</code></pre>"},{"location":"integration/configuration/reporting/#visualizing-results-with-heimdall","title":"Visualizing Results with Heimdall","text":"<p>The SAF CLI can launch a local Heimdall Lite instance to visualize scan results:</p> <pre><code># GitLab CI example for interactive visualization\nvisualize_results:\n  stage: visualize\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n    - apt-get update &amp;&amp; apt-get install -y firefox-esr xvfb\n  script:\n    # Start Heimdall Lite in background\n    - saf view heimdall -i scan-results.json -p 8000 &amp;\n\n    # Capture screenshot of visualization\n    - sleep 5  # Wait for server to start\n    - xvfb-run firefox-esr --headless --screenshot http://localhost:8000\n\n    # Rename and save screenshot\n    - mv screenshot.png scan-visualization.png\n  artifacts:\n    paths:\n      - scan-visualization.png\n</code></pre>"},{"location":"integration/configuration/reporting/#converting-between-formats","title":"Converting Between Formats","text":"<p>The SAF CLI can convert between multiple formats for integration with other security tools:</p> <pre><code># Convert InSpec JSON to HDF format\nsaf convert inspec2hdf -i inspec_results.json -o hdf_results.json\n\n# Convert HDF to DISA Checklist format (CKL)\nsaf convert hdf2ckl -i hdf_results.json -o checklist.ckl\n\n# Convert HDF to CSV format\nsaf convert hdf2csv -i hdf_results.json -o results.csv\n\n# Convert HDF to AWS Security Findings Format (ASFF)\nsaf convert hdf2asff -i hdf_results.json -o aws_findings.json\n</code></pre>"},{"location":"integration/configuration/reporting/#automated-report-distribution","title":"Automated Report Distribution","text":""},{"location":"integration/configuration/reporting/#email-integration","title":"Email Integration","text":"<p>Send reports via email after completion:</p> <pre><code># GitLab CI example\nemail_report:\n  stage: report\n  dependencies:\n    - process_results\n  script:\n    - apt-get update &amp;&amp; apt-get install -y mailutils\n    - |\n      mail -s \"Container Security Scan Results - $CI_PROJECT_NAME\" \\\n      -a scan-results.json \\\n      security-team@example.com &lt;&lt;EOF\n      The container security scan for $CI_PROJECT_NAME has completed.\n\n      Summary:\n      $(cat scan-summary.md)\n\n      Full results are attached as JSON.\n      EOF\n</code></pre>"},{"location":"integration/configuration/reporting/#slackteams-integration","title":"Slack/Teams Integration","text":"<p>Post report summaries to communication channels:</p> <pre><code># GitHub Actions example\n- name: Post to Slack\n  uses: slackapi/slack-github-action@v1.23.0\n  with:\n    payload: |\n      {\n        \"text\": \"Container Security Scan Results\",\n        \"blocks\": [\n          {\n            \"type\": \"header\",\n            \"text\": {\n              \"type\": \"plain_text\",\n              \"text\": \"Container Security Scan Results\"\n            }\n          },\n          {\n            \"type\": \"section\",\n            \"text\": {\n              \"type\": \"mrkdwn\",\n              \"text\": \"$(cat scan-summary.md)\"\n            }\n          },\n          {\n            \"type\": \"actions\",\n            \"elements\": [\n              {\n                \"type\": \"button\",\n                \"text\": {\n                  \"type\": \"plain_text\",\n                  \"text\": \"View Full Report\"\n                },\n                \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"\n              }\n            ]\n          }\n        ]\n      }\n  env:\n    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n    SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK\n</code></pre>"},{"location":"integration/configuration/reporting/#security-dashboard-integration","title":"Security Dashboard Integration","text":""},{"location":"integration/configuration/reporting/#splunk-integration","title":"Splunk Integration","text":"<pre><code># Configure Splunk connection\nexport SPLUNK_URL=\"https://splunk.example.com:8088\"\nexport SPLUNK_TOKEN=\"your-splunk-hec-token\"\n\n# Convert and upload to Splunk\nsaf convert hdf2splunk -i scan-results.json --url $SPLUNK_URL --token $SPLUNK_TOKEN --index security_scans\n</code></pre>"},{"location":"integration/configuration/reporting/#custom-dashboard-integration","title":"Custom Dashboard Integration","text":"<p>Use the JSON format for integration with custom dashboards:</p> <pre><code># Process for dashboard integration\ncat &gt; dashboard-integration.js &lt;&lt; EOF\n#!/usr/bin/env node\nconst fs = require('fs');\nconst results = JSON.parse(fs.readFileSync('scan-results.json', 'utf8'));\n\n// Extract key metrics\nconst totalControls = results.profiles[0].controls.length;\nconst passedControls = results.profiles[0].controls.filter(c =&gt; c.status === 'passed').length;\nconst failedControls = totalControls - passedControls;\nconst score = (passedControls / totalControls) * 100;\n\n// Process results for dashboard\n// ... dashboard integration code ...\nEOF\n</code></pre>"},{"location":"integration/configuration/reporting/#compliance-reporting","title":"Compliance Reporting","text":"<p>Create compliance reports by combining SAF CLI capabilities:</p> <pre><code># Generate summary report\nsaf view summary -i scan-results.json --format markdown --output compliance-summary.md\n\n# Extract failed controls for remediation\njq '.profiles[].controls[] | select(.status != \"passed\")' scan-results.json &gt; remediation-needed.json\n\n# Launch Heimdall for interactive compliance exploration\nsaf view heimdall -i scan-results.json\n</code></pre>"},{"location":"integration/configuration/reporting/#evidence-collection","title":"Evidence Collection","text":"<p>Collect and organize compliance evidence:</p> <pre><code># GitHub Actions example for evidence collection\n- name: Collect compliance evidence\n  run: |\n    # Create evidence package\n    mkdir -p evidence\n    cp scan-results.json evidence/\n    cp scan-summary.md evidence/\n\n    # Add scan metadata\n    cat &gt; evidence/metadata.json &lt;&lt; EOF\n    {\n      \"scan_date\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\",\n      \"scan_id\": \"${{ github.run_id }}\",\n      \"repository\": \"${{ github.repository }}\",\n      \"target\": \"${POD_NAME}\",\n      \"profile\": \"${INSPEC_PROFILE}\"\n    }\n    EOF\n\n    # Create evidence archive\n    tar -czf evidence.tar.gz evidence/\n\n    # Upload to evidence storage\n    aws s3 cp evidence.tar.gz s3://compliance-evidence/$(date +%Y/%m/%d)/${CI_PROJECT_NAME}/\n</code></pre>"},{"location":"integration/configuration/reporting/#historical-comparison","title":"Historical Comparison","text":"<p>To track security posture over time, implement a manual tracking system:</p> <pre><code># Create a historical record\nmkdir -p historical-results/$(date +%Y/%m/%d)\ncp scan-results.json historical-results/$(date +%Y-%m-%d)/\n\n# Generate summary file with key metrics\nsaf view summary -i scan-results.json --format json &gt; metrics-$(date +%Y-%m-%d).json\n\n# To compare results over time, you can use custom scripts\ncat &gt; compare-results.js &lt;&lt; EOF\n#!/usr/bin/env node\nconst fs = require('fs');\nconst path = require('path');\n\n// Get historical metrics files\nconst metricsDir = './';\nconst metricFiles = fs.readdirSync(metricsDir)\n  .filter(file =&gt; file.startsWith('metrics-') &amp;&amp; file.endsWith('.json'))\n  .sort();\n\n// Extract and display trend data\nconst trends = metricFiles.map(file =&gt; {\n  const data = JSON.parse(fs.readFileSync(path.join(metricsDir, file)));\n  const date = file.replace('metrics-', '').replace('.json', '');\n  return {\n    date,\n    score: data.compliance_score || data.score\n  };\n});\n\nconsole.table(trends);\nEOF\n\nchmod +x compare-results.js\n./compare-results.js\n</code></pre>"},{"location":"integration/configuration/reporting/#related-resources","title":"Related Resources","text":"<ul> <li>Environment Variables for Integration</li> <li>Thresholds Integration</li> <li>GitHub Actions Integration Guide</li> <li>GitLab CI/CD Integration Guide</li> <li>SAF CLI Documentation</li> <li>Security Workflows</li> </ul>"},{"location":"integration/configuration/secrets-management/","title":"Secrets Management for Container Scanning","text":"<p>This page outlines best practices for managing secrets when integrating container scanning into CI/CD pipelines.</p>"},{"location":"integration/configuration/secrets-management/#overview","title":"Overview","text":"<p>Container scanning often requires access to Kubernetes clusters, container registries, and other sensitive resources. Proper secrets management is critical for:</p> <ul> <li>Protecting cluster access credentials</li> <li>Securing container registry authentication</li> <li>Managing service account tokens securely</li> <li>Implementing the principle of least privilege</li> <li>Preventing secrets from being exposed in logs or outputs</li> </ul>"},{"location":"integration/configuration/secrets-management/#types-of-secrets","title":"Types of Secrets","text":"<p>When integrating container scanning, you'll typically need to manage these types of secrets:</p> <ol> <li>Kubernetes Authentication:</li> <li>Kubeconfig files</li> <li>Service account tokens</li> <li> <p>API server certificates</p> </li> <li> <p>Container Registry Authentication:</p> </li> <li>Registry usernames and passwords</li> <li>Registry access tokens</li> <li> <p>Docker config.json files</p> </li> <li> <p>Scanning Credentials:</p> </li> <li>Profile repository access tokens</li> <li>Compliance API keys</li> <li> <p>Report repository credentials</p> </li> <li> <p>Temporary Credentials:</p> </li> <li>Short-lived service account tokens</li> <li>Limited-scope access tokens</li> <li>Ephemeral certificates</li> </ol>"},{"location":"integration/configuration/secrets-management/#best-practices","title":"Best Practices","text":""},{"location":"integration/configuration/secrets-management/#general-security-practices","title":"General Security Practices","text":"<ul> <li>Never store secrets in code repositories</li> <li>Limit secret access to only the jobs and stages that require them</li> <li>Use environment variables to inject secrets into pipelines</li> <li>Implement secret rotation policies</li> <li>Always validate inputs to prevent injection attacks</li> <li>Audit secret usage regularly</li> </ul>"},{"location":"integration/configuration/secrets-management/#cicd-platform-specific-practices","title":"CI/CD Platform-Specific Practices","text":""},{"location":"integration/configuration/secrets-management/#github-actions","title":"GitHub Actions","text":"<ol> <li>Use GitHub Secrets for sensitive data:</li> </ol> <pre><code>- name: Setup Kubernetes access\n  run: |\n    echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n    export KUBECONFIG=kubeconfig.yaml\n</code></pre> <ol> <li>Limit secret exposure with environment isolation:</li> </ol> <pre><code>jobs:\n  scan:\n    environment: production\n    env:\n      SCANNER_TOKEN: ${{ secrets.SCANNER_TOKEN }}\n</code></pre> <ol> <li>Use OIDC for cloud provider authentication:</li> </ol> <pre><code>- name: Configure AWS credentials\n  uses: aws-actions/configure-aws-credentials@v1\n  with:\n    role-to-assume: ${{ secrets.AWS_ROLE }}\n    aws-region: us-east-1\n</code></pre>"},{"location":"integration/configuration/secrets-management/#gitlab-cicd","title":"GitLab CI/CD","text":"<ol> <li>Use GitLab CI/CD Variables:</li> </ol> <pre><code>before_script:\n  - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n  - export KUBECONFIG=kubeconfig.yaml\n</code></pre> <ol> <li>Use masked variables to prevent accidental exposure:</li> </ol> <pre><code># In GitLab CI/CD settings, mark variables as \"Masked\"\n</code></pre> <ol> <li>Limit variable scope by environment:</li> </ol> <pre><code># In GitLab CI/CD settings, set variables with a specific environment scope\n</code></pre> <ol> <li>Use CI/CD file variables for per-pipeline secrets:</li> </ol> <pre><code>variables:\n  SCANNER_TOKEN: $CI_JOB_TOKEN\n</code></pre>"},{"location":"integration/configuration/secrets-management/#kubernetes-secret-management","title":"Kubernetes Secret Management","text":"<ol> <li>Create time-limited service accounts:</li> </ol> <pre><code># Create short-lived token (Kubernetes 1.22+)\nTOKEN=$(kubectl create token scanner-sa --duration=15m)\n</code></pre> <ol> <li>Create least-privilege RBAC roles:</li> </ol> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"specific-pod-name\"]\n</code></pre> <ol> <li>Use namespaced resources to limit access scope:</li> </ol> <pre><code># Create rolebinding in specific namespace\nkubectl create rolebinding scanner-binding \\\n  --role=scanner-role \\\n  --serviceaccount=default:scanner-sa \\\n  -n target-namespace\n</code></pre> <ol> <li>Include Job/Pipeline IDs in resource names for traceability:</li> </ol> <pre><code>metadata:\n  name: scanner-sa-${CI_JOB_ID}\n  annotations:\n    ci-job: \"${CI_JOB_ID}\"\n    pipeline: \"${CI_PIPELINE_ID}\"\n</code></pre>"},{"location":"integration/configuration/secrets-management/#temporary-credentials-workflow","title":"Temporary Credentials Workflow","text":"<p>Here's a recommended workflow for managing temporary credentials in scanning pipelines:</p> <ol> <li>Create a temporary service account:</li> </ol> <pre><code>kubectl create serviceaccount scanner-sa-${CI_JOB_ID} -n ${NAMESPACE}\n</code></pre> <ol> <li>Create a restricted role with specific pod access:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role-${CI_JOB_ID}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\nEOF\n</code></pre> <ol> <li>Bind the role to the service account:</li> </ol> <pre><code>kubectl create rolebinding scanner-binding-${CI_JOB_ID} \\\n  --role=scanner-role-${CI_JOB_ID} \\\n  --serviceaccount=${NAMESPACE}:scanner-sa-${CI_JOB_ID} \\\n  -n ${NAMESPACE}\n</code></pre> <ol> <li>Generate a short-lived token:</li> </ol> <pre><code>TOKEN=$(kubectl create token scanner-sa-${CI_JOB_ID} -n ${NAMESPACE} --duration=15m)\n</code></pre> <ol> <li>Use the token for scanning:</li> </ol> <pre><code># Create scanner kubeconfig\ncat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: ${KUBE_SERVER}\n    certificate-authority-data: ${KUBE_CA_DATA}\n  name: k8s-cluster\ncontexts:\n- context:\n    cluster: k8s-cluster\n    user: scanner-user\n    namespace: ${NAMESPACE}\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n</code></pre> <ol> <li>Clean up after scanning:</li> </ol> <pre><code>kubectl delete rolebinding scanner-binding-${CI_JOB_ID} -n ${NAMESPACE}\nkubectl delete role scanner-role-${CI_JOB_ID} -n ${NAMESPACE}\nkubectl delete serviceaccount scanner-sa-${CI_JOB_ID} -n ${NAMESPACE}\n</code></pre>"},{"location":"integration/configuration/secrets-management/#managing-secrets-in-container-registry-authentication","title":"Managing Secrets in Container Registry Authentication","text":"<p>When scanning containers that require pulling from private registries:</p> <ol> <li>Use docker config secrets:</li> </ol> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: registry-credentials\ntype: kubernetes.io/dockerconfigjson\ndata:\n  .dockerconfigjson: &lt;base64-encoded-docker-config&gt;\n</code></pre> <ol> <li>Reference secrets in pod definition:</li> </ol> <pre><code>spec:\n  imagePullSecrets:\n  - name: registry-credentials\n</code></pre> <ol> <li>Securely inject credentials in CI/CD:</li> </ol> <pre><code>before_script:\n  - echo \"$REGISTRY_PASSWORD\" | docker login -u \"$REGISTRY_USERNAME\" --password-stdin $REGISTRY_URL\n</code></pre>"},{"location":"integration/configuration/secrets-management/#sanitizing-output-and-avoiding-secret-leakage","title":"Sanitizing Output and Avoiding Secret Leakage","text":"<p>To prevent accidental exposure of secrets in logs and reports:</p> <ol> <li>Sanitize scan output:</li> </ol> <pre><code># Replace sensitive data in outputs\nsed -i 's/sensitive-data-pattern/[REDACTED]/g' scan-results.json\n</code></pre> <ol> <li>Use log filters in CI/CD pipelines:</li> </ol> <pre><code># GitLab CI/CD filter pattern\nvariables:\n  SECURE_LOG_LEVEL: info\n  CI_DEBUG_TRACE: \"false\"\n</code></pre> <ol> <li>Set token variables as secrets in your CI/CD system:</li> <li>GitHub Actions: <code>${{ secrets.TOKEN_NAME }}</code></li> <li> <p>GitLab CI/CD: Masked variables</p> </li> <li> <p>Avoid using debug output for workflows with secrets:</p> </li> </ol> <pre><code># Only enable debug on non-sensitive stages\ndebug:\n  if: github.event.inputs.enable_debug == 'true'\n</code></pre> <ol> <li>Use credential helpers when possible:</li> <li>AWS: <code>aws-cli</code> credential helper</li> <li>GCP: <code>gcloud</code> credential helper</li> <li>Azure: <code>az</code> credential helper</li> </ol>"},{"location":"integration/configuration/secrets-management/#automated-secret-rotation","title":"Automated Secret Rotation","text":"<p>For long-running scanning pipelines or environments, implement automated secret rotation:</p> <ol> <li>Create periodic jobs to rotate credentials:</li> </ol> <pre><code># GitLab CI/CD schedule for rotating credentials\nsecret-rotation:\n  stage: maintenance\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n  script:\n    - ./rotate-credentials.sh\n</code></pre> <ol> <li>Store rotation timestamps:</li> </ol> <pre><code># Record when credentials were last rotated\necho \"Last rotated: $(date)\" &gt; rotation-timestamp.txt\n</code></pre> <ol> <li>Implement graceful credential handover:</li> </ol> <pre><code># Create new credentials before invalidating old ones\nNEW_TOKEN=$(create-new-token)\nupdate-token-consumers \"$NEW_TOKEN\"\ninvalidate-old-token\n</code></pre>"},{"location":"integration/configuration/secrets-management/#related-resources","title":"Related Resources","text":"<ul> <li>Environment Variables for Integration</li> <li>GitHub Actions Integration Guide</li> <li>GitLab CI/CD Integration Guide</li> <li>Kubernetes API Approach</li> <li>Standard Container Workflow</li> <li>Security Workflows</li> <li>RBAC Documentation</li> <li>Service Accounts Documentation</li> </ul>"},{"location":"integration/configuration/thresholds-integration/","title":"Thresholds Integration","text":"<p>This page documents how to integrate threshold-based compliance assessment in container scanning workflows.</p>"},{"location":"integration/configuration/thresholds-integration/#overview","title":"Overview","text":"<p>Threshold-based scanning allows you to:</p> <ul> <li>Define minimum compliance levels for container security</li> <li>Automate pass/fail decisions in CI/CD pipelines</li> <li>Implement security gates in deployment workflows</li> <li>Customize compliance requirements by environment or container type</li> <li>Track security trends over time</li> </ul>"},{"location":"integration/configuration/thresholds-integration/#threshold-concepts","title":"Threshold Concepts","text":""},{"location":"integration/configuration/thresholds-integration/#compliance-score","title":"Compliance Score","text":"<p>The compliance score is a numerical value (0-100) representing the percentage of controls that passed during a scan. It is calculated as:</p> <pre><code>Compliance Score = (Passed Controls / Total Controls) \u00d7 100\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#threshold-value","title":"Threshold Value","text":"<p>The threshold value is the minimum compliance score required for a scan to be considered successful. For example:</p> <ul> <li>Threshold = 70: At least 70% of controls must pass</li> <li>Threshold = 100: All controls must pass (zero tolerance)</li> <li>Threshold = 0: No controls need to pass (reporting only)</li> </ul>"},{"location":"integration/configuration/thresholds-integration/#threshold-types","title":"Threshold Types","text":"<p>Thresholds can be applied at different levels of granularity:</p> <ol> <li>Global threshold: Applied to the overall scan score</li> <li>Control category threshold: Applied to specific categories of controls</li> <li>Impact level threshold: Applied based on the impact level of findings</li> <li>Custom attribute threshold: Applied based on custom attributes in controls</li> </ol>"},{"location":"integration/configuration/thresholds-integration/#implementing-thresholds","title":"Implementing Thresholds","text":""},{"location":"integration/configuration/thresholds-integration/#using-saf-cli-for-threshold-checking","title":"Using SAF CLI for Threshold Checking","text":"<p>The SAF CLI provides built-in threshold checking capabilities:</p> <pre><code># Basic threshold check (exit code indicates pass/fail)\nsaf threshold -i scan-results.json -t 70\n\n# Category-specific thresholds\nsaf threshold -i scan-results.json -c '{\"security\": 80, \"compliance\": 70, \"performance\": 60}'\n\n# Impact-based thresholds\nsaf threshold -i scan-results.json -m '{\"critical\": 100, \"high\": 90, \"medium\": 70, \"low\": 50}'\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#threshold-configuration-files","title":"Threshold Configuration Files","text":"<p>Complex threshold configurations can be defined in YAML format:</p> <pre><code># threshold.yml\nglobal: 70  # Global threshold\n\n# Category-specific thresholds\ncategories:\n  security: 80\n  compliance: 75\n  performance: 60\n\n# Impact-based thresholds\nimpact:\n  critical: 100  # Zero tolerance for critical issues\n  high: 90\n  medium: 70\n  low: 50\n\n# Control-specific overrides\ncontrols:\n  - id: \"CIS-1.2.3\"\n    threshold: 100  # Must pass\n  - id: \"NIST-AC-*\"\n    threshold: 90   # Pattern matching for control IDs\n</code></pre> <p>To use a threshold configuration file:</p> <pre><code>saf threshold -i scan-results.json -f threshold.yml\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#integration-with-cicd-pipelines","title":"Integration with CI/CD Pipelines","text":""},{"location":"integration/configuration/thresholds-integration/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code>- name: Process scan results\n  run: |\n    # Install SAF CLI\n    npm install -g @mitre/saf\n\n    # Generate scan summary\n    saf summary --input scan-results.json --output-md scan-summary.md\n\n    # Apply threshold check\n    saf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\n    THRESHOLD_RESULT=$?\n\n    # Create GitHub summary\n    echo \"## Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n    cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n    echo \"## Threshold Check\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    if [ $THRESHOLD_RESULT -eq 0 ]; then\n      echo \"\u2705 **PASSED** - Met or exceeded threshold of ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    else\n      echo \"\u274c **FAILED** - Did not meet threshold of ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n      exit 1  # Fail the workflow if threshold not met\n    fi\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#gitlab-cicd-integration","title":"GitLab CI/CD Integration","text":"<pre><code>process_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Generate scan summary\n    - saf summary --input scan-results.json --output-md scan-summary.md\n\n    # Apply threshold check\n    - saf threshold -i scan-results.json -t $THRESHOLD_SCORE\n    - if [ $? -ne 0 ]; then echo \"Threshold check failed\"; exit 1; fi\n\n    # Generate report\n    - saf report -i scan-results.json -o scan-report.html\n\n    # Create JUnit report for GitLab integration\n    - saf convert -i scan-results.json --output-format junit --output scan-results.xml\n\n  artifacts:\n    paths:\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      junit: scan-results.xml\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#environment-specific-threshold-strategies","title":"Environment-Specific Threshold Strategies","text":""},{"location":"integration/configuration/thresholds-integration/#development-environments","title":"Development Environments","text":"<p>For development environments, use more lenient thresholds focused on education:</p> <pre><code># dev-threshold.yml\nglobal: 50  # More lenient global threshold\n\nimpact:\n  critical: 90  # Focus on critical issues\n  high: 70\n  medium: 50\n  low: 0       # Ignore low impact issues\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#stagingqa-environments","title":"Staging/QA Environments","text":"<p>For staging environments, use moderate thresholds with increasing strictness:</p> <pre><code># staging-threshold.yml\nglobal: 70  # Moderate global threshold\n\nimpact:\n  critical: 100  # Zero tolerance for critical issues\n  high: 90\n  medium: 70\n  low: 50\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#production-environments","title":"Production Environments","text":"<p>For production environments, use strict thresholds with limited exceptions:</p> <pre><code># production-threshold.yml\nglobal: 90  # Strict global threshold\n\nimpact:\n  critical: 100  # Zero tolerance for critical issues\n  high: 100     # Zero tolerance for high impact issues\n  medium: 90\n  low: 70\n\n# Production exceptions (documented and time-limited)\nexceptions:\n  - id: \"CIS-1.2.3\"\n    reason: \"Legacy system support - resolution planned Q2 2023\"\n    expiration: \"2023-06-30\"\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#progressive-threshold-implementation","title":"Progressive Threshold Implementation","text":"<p>For teams new to security scanning, implement a progressive threshold strategy:</p> <ol> <li>Baseline phase: Run scans with threshold set to 0 (reporting only)</li> <li>Assessment phase: Set threshold at current baseline score</li> <li>Improvement phase: Increase threshold by 5-10% per release cycle</li> <li>Optimization phase: Fine-tune category and impact thresholds</li> <li>Maintenance phase: Maintain high threshold with periodic reviews</li> </ol> <p>Example implementation in CI/CD:</p> <pre><code>variables:\n  # Progressive thresholds by branch\n  THRESHOLD_DEVELOP: 50\n  THRESHOLD_STAGING: 70\n  THRESHOLD_MAIN: 90\n\nprocess_results:\n  script:\n    # Set threshold based on branch\n    - |\n      if [ \"$CI_COMMIT_BRANCH\" == \"main\" ]; then\n        THRESHOLD=$THRESHOLD_MAIN\n      elif [ \"$CI_COMMIT_BRANCH\" == \"staging\" ]; then\n        THRESHOLD=$THRESHOLD_STAGING\n      else\n        THRESHOLD=$THRESHOLD_DEVELOP\n      fi\n\n    # Apply threshold check\n    - saf threshold -i scan-results.json -t $THRESHOLD\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#custom-threshold-templates","title":"Custom Threshold Templates","text":"<p>Create reusable threshold templates for different types of containers:</p>"},{"location":"integration/configuration/thresholds-integration/#api-server-template","title":"API Server Template","text":"<pre><code># api-server-threshold.yml\nglobal: 85\n\ncategories:\n  security: 90\n  compliance: 85\n  api-specific: 90\n  performance: 70\n\ncontrol_groups:\n  network-security: 95\n  authentication: 100\n  authorization: 100\n  data-protection: 90\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#database-container-template","title":"Database Container Template","text":"<pre><code># database-threshold.yml\nglobal: 90\n\ncategories:\n  security: 95\n  compliance: 90\n  data-protection: 100\n  performance: 70\n\ncontrol_groups:\n  data-encryption: 100\n  access-control: 100\n  configuration: 90\n  backup-recovery: 90\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#frontend-container-template","title":"Frontend Container Template","text":"<pre><code># frontend-threshold.yml\nglobal: 80\n\ncategories:\n  security: 85\n  compliance: 80\n  user-interface: 75\n  performance: 80\n\ncontrol_groups:\n  input-validation: 100\n  output-encoding: 100\n  asset-management: 80\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#threshold-reporting-and-visualization","title":"Threshold Reporting and Visualization","text":"<p>Integrate threshold results into reporting dashboards:</p> <pre><code># Generate threshold compliance report\nsaf threshold -i scan-results.json -f threshold.yml --report threshold-report.json\n\n# Generate trend analysis\nsaf trend -d ./historical-results/ -o threshold-trends.json\n\n# Generate visualization\nsaf visualize -i threshold-trends.json -o threshold-chart.html\n</code></pre>"},{"location":"integration/configuration/thresholds-integration/#related-resources","title":"Related Resources","text":"<ul> <li>Environment Variables for Integration</li> <li>GitHub Actions Integration Guide</li> <li>GitLab CI/CD Integration Guide</li> <li>Standard Container Workflow</li> <li>Security Workflows</li> <li>Reporting Configuration</li> <li>Advanced Thresholds Configuration</li> </ul>"},{"location":"integration/examples/","title":"Integration Examples","text":"<p>This section provides practical examples of integrating the Kube CINC Secure Scanner with various CI/CD platforms.</p>"},{"location":"integration/examples/#overview","title":"Overview","text":"<p>To help you implement container security scanning in your CI/CD pipeline, we provide concrete examples for various platforms and scanning approaches.</p>"},{"location":"integration/examples/#example-categories","title":"Example Categories","text":"<p>Our integration examples are organized by platform:</p> <ul> <li>GitHub Actions Examples - Examples for GitHub's native CI/CD service</li> <li>GitLab CI Examples - Examples for GitLab's CI/CD pipelines</li> <li>GitLab Services Examples - Examples using GitLab's Services feature (coming soon)</li> <li>Custom Integration Examples - Examples for other CI/CD platforms (coming soon)</li> </ul>"},{"location":"integration/examples/#example-implementation-guides","title":"Example Implementation Guides","text":"<p>Each example includes:</p> <ol> <li>Complete workflow definitions ready to use in your CI/CD pipeline</li> <li>Step-by-step implementation instructions</li> <li>Configuration options for customizing the integration</li> <li>Best practices for efficient and secure implementation</li> </ol>"},{"location":"integration/examples/#future-examples","title":"Future Examples","text":""},{"location":"integration/examples/#gitlab-services-examples","title":"GitLab Services Examples","text":"<p>The upcoming GitLab Services examples will include:</p> <ul> <li>Service-oriented scanner integration</li> <li>GitLab-specific configuration for various scanning approaches</li> <li>Security best practices for GitLab Services environment</li> </ul>"},{"location":"integration/examples/#custom-integration-examples","title":"Custom Integration Examples","text":"<p>Future custom integration examples will cover:</p> <ul> <li>Adapting workflows to less common CI/CD platforms</li> <li>Patterns for creating your own integrations</li> <li>Platform-agnostic strategies for container scanning</li> </ul>"},{"location":"integration/examples/#external-example-resources","title":"External Example Resources","text":"<p>For additional example files, see the dedicated example directories:</p> <ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"integration/examples/#related-resources","title":"Related Resources","text":"<ul> <li>CI/CD Platforms</li> <li>Integration Workflows</li> <li>Integration Configuration</li> <li>Approach Mapping</li> </ul>"},{"location":"integration/examples/github-examples/","title":"GitHub Actions Integration Examples","text":"<p>This page provides practical examples of integrating container scanning with GitHub Actions.</p>"},{"location":"integration/examples/github-examples/#overview","title":"Overview","text":"<p>GitHub Actions offers a flexible CI/CD platform for integrating the Kube CINC Secure Scanner. These examples demonstrate real-world implementations for various scanning approaches.</p>"},{"location":"integration/examples/github-examples/#standard-container-scanning-example","title":"Standard Container Scanning Example","text":"<p>This example demonstrates scanning standard containers using the Kubernetes API approach:</p> <pre><code>name: Standard Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      pod_name:\n        description: 'Pod to scan'\n        required: true\n      container_name:\n        description: 'Container to scan'\n        required: true\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes access\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create service account\n          kubectl create serviceaccount scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${{ github.event.inputs.pod_name }}\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding scanner-binding \\\n            --role=scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token\n          TOKEN=$(kubectl create token scanner-sa -n ${{ github.event.inputs.namespace }} --duration=15m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n      - name: Run container scan\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Run scan\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.profile }} \\\n            -t k8s-container://${{ github.event.inputs.namespace }}/${{ github.event.inputs.pod_name }}/${{ github.event.inputs.container_name }} \\\n            --reporter json:scan-results.json cli\n\n      - name: Process scan results\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate scan summary\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Apply threshold check\n          saf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\n          THRESHOLD_RESULT=$?\n\n          # Create GitHub summary\n          echo \"## Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          echo \"## Threshold Check\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          if [ $THRESHOLD_RESULT -eq 0 ]; then\n            echo \"\u2705 **PASSED** - Met or exceeded threshold of ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c **FAILED** - Did not meet threshold of ${{ github.event.inputs.threshold }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          fi\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount scanner-sa -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/examples/github-examples/#dynamic-rbac-scanning-example","title":"Dynamic RBAC Scanning Example","text":"<p>This example demonstrates scanning pods based on dynamic label selection:</p> <pre><code>name: Dynamic RBAC Pod Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      label_selector:\n        description: 'Label selector (format: key=value)'\n        required: true\n        default: 'scan=true'\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes access\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Parse label selector\n          LABEL_KEY=$(echo \"${{ github.event.inputs.label_selector }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.label_selector }}\" | cut -d= -f2)\n\n          # Create service account\n          kubectl create serviceaccount label-scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role with label selector\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: label-scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding label-scanner-binding \\\n            --role=label-scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:label-scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token\n          TOKEN=$(kubectl create token label-scanner-sa -n ${{ github.event.inputs.namespace }} --duration=15m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n      - name: Scan labeled pods\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Find pods with matching label\n          PODS=$(kubectl get pods -n ${{ github.event.inputs.namespace }} -l ${{ github.event.inputs.label_selector }} -o name | cut -d/ -f2)\n\n          if [ -z \"$PODS\" ]; then\n            echo \"No pods found with label ${{ github.event.inputs.label_selector }}\"\n            exit 1\n          fi\n\n          echo \"Found pods with label ${{ github.event.inputs.label_selector }}:\"\n          echo \"$PODS\"\n\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Create summary header for GitHub\n          echo \"## Dynamic Label Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          echo \"Label selector: \\`${{ github.event.inputs.label_selector }}\\`\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"Pods found: $(echo \"$PODS\" | wc -l)\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          echo \"---\" &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Scan each pod\n          for POD in $PODS; do\n            echo \"Scanning pod: $POD\"\n\n            # Get first container name\n            CONTAINER=$(kubectl get pod $POD -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.containers[0].name}')\n\n            # Run scan\n            KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.profile }} \\\n              -t k8s-container://${{ github.event.inputs.namespace }}/$POD/$CONTAINER \\\n              --reporter json:$POD-results.json cli\n\n            # Process results\n            saf summary --input $POD-results.json --output-md $POD-summary.md\n\n            # Add to GitHub summary\n            echo \"### Results for pod: $POD\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            cat $POD-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"---\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          done\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: labeled-scan-results\n          path: |\n            *-results.json\n            *-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding label-scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role label-scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount label-scanner-sa -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/examples/github-examples/#complete-cicd-pipeline-example","title":"Complete CI/CD Pipeline Example","text":"<p>This example demonstrates a complete CI/CD pipeline with build, deploy, scan, and quality gates:</p> <pre><code>name: CI/CD Pipeline with Container Scanning\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Image tag to build'\n        required: true\n        default: 'latest'\n      scan_namespace:\n        description: 'Namespace for deployment and scanning'\n        required: true\n        default: 'default'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    outputs:\n      image_tag: ${{ steps.set-tag.outputs.image_tag }}\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Set image tag\n        id: set-tag\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]; then\n            echo \"image_tag=${{ github.event.inputs.image_tag }}\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"image_tag=sha-$(git rev-parse --short HEAD)\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Build Docker image\n        run: |\n          docker build -t myapp:${{ steps.set-tag.outputs.image_tag }} .\n\n          # For demo purposes, we're not pushing to a registry\n          # In a real scenario, you would push the image here\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    outputs:\n      pod_name: ${{ steps.deploy.outputs.pod_name }}\n    steps:\n      - name: Set namespace\n        id: namespace\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]; then\n            echo \"namespace=${{ github.event.inputs.scan_namespace }}\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"namespace=default\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Setup Kubernetes\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n      - name: Deploy to Kubernetes\n        id: deploy\n        run: |\n          # Generate a unique name for this deployment\n          POD_NAME=\"myapp-${{ github.run_id }}\"\n          echo \"pod_name=$POD_NAME\" &gt;&gt; $GITHUB_OUTPUT\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: $POD_NAME\n            namespace: ${{ steps.namespace.outputs.namespace }}\n            labels:\n              app: myapp\n              scan: \"true\"\n              github-run: \"${{ github.run_id }}\"\n          spec:\n            containers:\n            - name: app\n              image: myapp:${{ needs.build.outputs.image_tag }}\n              # For demo, we're using a locally built image\n              # In reality, you'd use an image from a registry\n              imagePullPolicy: Never\n              command: [\"sleep\", \"3600\"]\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/$POD_NAME -n ${{ steps.namespace.outputs.namespace }} --timeout=120s\n\n  scan:\n    needs: [build, deploy]\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set namespace\n        id: namespace\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]; then\n            echo \"namespace=${{ github.event.inputs.scan_namespace }}\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"namespace=default\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Set threshold\n        id: threshold\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]; then\n            echo \"value=${{ github.event.inputs.threshold }}\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"value=70\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Setup scanner access\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create service account with limited permissions\n          kubectl create serviceaccount pipeline-scanner-sa -n ${{ steps.namespace.outputs.namespace }}\n\n          # Create role limited to the specific pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: pipeline-scanner-role\n            namespace: ${{ steps.namespace.outputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${{ needs.deploy.outputs.pod_name }}\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding pipeline-scanner-binding \\\n            --role=pipeline-scanner-role \\\n            --serviceaccount=${{ steps.namespace.outputs.namespace }}:pipeline-scanner-sa \\\n            -n ${{ steps.namespace.outputs.namespace }}\n\n          # Generate token\n          TOKEN=$(kubectl create token pipeline-scanner-sa -n ${{ steps.namespace.outputs.namespace }} --duration=15m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n      - name: Run container scan\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ steps.namespace.outputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Run scan (using both a custom profile and a baseline)\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ steps.namespace.outputs.namespace }}/${{ needs.deploy.outputs.pod_name }}/app \\\n            --reporter json:baseline-results.json cli\n\n      - name: Process scan results\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate scan summary\n          saf summary --input baseline-results.json --output-md baseline-summary.md\n\n          # Apply threshold check\n          saf threshold -i baseline-results.json -t ${{ steps.threshold.outputs.value }}\n          THRESHOLD_RESULT=$?\n\n          # Create GitHub summary\n          echo \"## Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          echo \"### Linux Baseline\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          cat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          echo \"## Threshold Check\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          if [ $THRESHOLD_RESULT -eq 0 ]; then\n            echo \"\u2705 **PASSED** - Met or exceeded threshold of ${{ steps.threshold.outputs.value }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c **FAILED** - Did not meet threshold of ${{ steps.threshold.outputs.value }}%\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            # Uncomment to fail the workflow if threshold not met\n            # exit 1\n          fi\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: pipeline-scan-results\n          path: |\n            *-results.json\n            *-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding pipeline-scanner-binding -n ${{ steps.namespace.outputs.namespace }}\n          kubectl delete role pipeline-scanner-role -n ${{ steps.namespace.outputs.namespace }}\n          kubectl delete serviceaccount pipeline-scanner-sa -n ${{ steps.namespace.outputs.namespace }}\n\n  cleanup:\n    needs: [build, deploy, scan]\n    if: always()\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set namespace\n        id: namespace\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]; then\n            echo \"namespace=${{ github.event.inputs.scan_namespace }}\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"namespace=default\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Cleanup resources\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Delete the pod\n          kubectl delete pod ${{ needs.deploy.outputs.pod_name }} -n ${{ steps.namespace.outputs.namespace }}\n</code></pre>"},{"location":"integration/examples/github-examples/#using-github-actions-for-distroless-container-scanning","title":"Using GitHub Actions for Distroless Container Scanning","text":"<p>This example demonstrates scanning distroless containers using the debug container approach:</p> <pre><code>name: Distroless Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      distroless_pod:\n        description: 'Distroless pod to scan'\n        required: true\n      distroless_container:\n        description: 'Distroless container to scan'\n        required: true\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan_distroless:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes with debug container permissions\n        run: |\n          echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create service account\n          kubectl create serviceaccount debug-scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role with debug container permissions\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: debug-scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/ephemeralcontainers\"]\n            verbs: [\"get\", \"update\"]\n            resourceNames: [\"${{ github.event.inputs.distroless_pod }}\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding debug-scanner-binding \\\n            --role=debug-scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:debug-scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token\n          TOKEN=$(kubectl create token debug-scanner-sa -n ${{ github.event.inputs.namespace }} --duration=30m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Create debug container\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Get pod JSON\n          POD_JSON=$(kubectl get pod ${{ github.event.inputs.distroless_pod }} -n ${{ github.event.inputs.namespace }} -o json)\n\n          # Add debug container\n          PATCHED_POD=$(echo \"$POD_JSON\" | jq --arg target \"${{ github.event.inputs.distroless_container }}\" '.spec.ephemeralContainers += [{\n            \"name\": \"debugger\",\n            \"image\": \"busybox:latest\",\n            \"command\": [\"sleep\", \"3600\"],\n            \"targetContainerName\": $target\n          }]')\n\n          # Apply patch\n          echo \"$PATCHED_POD\" | kubectl replace --raw /api/v1/namespaces/${{ github.event.inputs.namespace }}/pods/${{ github.event.inputs.distroless_pod }}/ephemeralcontainers -f -\n\n          # Wait for debug container to start\n          sleep 10\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      - name: Scan through debug container\n        run: |\n          # Create scan script\n          cat &gt; scan-distroless.sh &lt;&lt; 'EOF'\n          #!/bin/sh\n          # Get target container's root filesystem\n          TARGET_PROC_ROOT=\"/proc/1/root\"\n          PROFILE=\"$1\"\n\n          # Create results directory\n          mkdir -p /tmp/results\n\n          # Run InSpec with chroot\n          cinc-auditor exec \"$PROFILE\" --target chroot://$TARGET_PROC_ROOT --reporter json:/tmp/results/results.json\n\n          # Output results\n          cat /tmp/results/results.json\n          EOF\n\n          # Copy script to debug container\n          export KUBECONFIG=kubeconfig.yaml\n          kubectl cp -n ${{ github.event.inputs.namespace }} scan-distroless.sh ${{ github.event.inputs.distroless_pod }}:scan-distroless.sh -c debugger\n          kubectl exec -n ${{ github.event.inputs.namespace }} ${{ github.event.inputs.distroless_pod }} -c debugger -- chmod +x /scan-distroless.sh\n\n          # Run scan\n          kubectl exec -n ${{ github.event.inputs.namespace }} ${{ github.event.inputs.distroless_pod }} -c debugger -- /scan-distroless.sh ${{ github.event.inputs.profile }} &gt; distroless-results.json\n\n      - name: Process scan results\n        run: |\n          # Install SAF CLI\n          npm install -g @mitre/saf\n\n          # Generate scan summary\n          saf summary --input distroless-results.json --output-md distroless-summary.md\n\n          # Create GitHub summary\n          echo \"## Distroless Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat distroless-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: distroless-scan-results\n          path: |\n            distroless-results.json\n            distroless-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding debug-scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role debug-scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount debug-scanner-sa -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/examples/github-examples/#related-resources","title":"Related Resources","text":"<ul> <li>GitHub Actions Integration Guide</li> <li>Standard Container Workflow</li> <li>Distroless Container Workflow</li> <li>Sidecar Container Workflow</li> <li>Security Workflows</li> <li>Approach Mapping</li> <li>GitHub Workflow Examples</li> </ul>"},{"location":"integration/examples/gitlab-examples/","title":"GitLab CI/CD Integration Examples","text":"<p>This page provides practical examples of integrating container scanning with GitLab CI/CD pipelines.</p>"},{"location":"integration/examples/gitlab-examples/#overview","title":"Overview","text":"<p>GitLab CI/CD offers powerful capabilities for integrating the Kube CINC Secure Scanner. These examples demonstrate real-world implementations for various scanning approaches.</p>"},{"location":"integration/examples/gitlab-examples/#basic-container-scanning-example","title":"Basic Container Scanning Example","text":"<p>This example demonstrates basic container scanning using the Kubernetes API approach:</p> <pre><code>image: debian:stable-slim\n\nvariables:\n  KUBE_NAMESPACE: default\n  KUBE_POD_NAME: target-app\n  KUBE_CONTAINER_NAME: app\n  INSPEC_PROFILE: dev-sec/linux-baseline\n  THRESHOLD_SCORE: 70\n\nstages:\n  - scan\n  - process\n  - cleanup\n\nscan:\n  stage: scan\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release\n    - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n    - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Setup Kubernetes access\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account with limited scope\n    - kubectl create serviceaccount scanner-sa -n $KUBE_NAMESPACE\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role\n        namespace: $KUBE_NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"$KUBE_POD_NAME\"]\n      EOF\n    - kubectl create rolebinding scanner-binding --role=scanner-role --serviceaccount=$KUBE_NAMESPACE:scanner-sa -n $KUBE_NAMESPACE\n\n    # Generate token\n    - TOKEN=$(kubectl create token scanner-sa -n $KUBE_NAMESPACE --duration=15m)\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $KUBE_NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n  script:\n    # Run scan\n    - KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec $INSPEC_PROFILE -t k8s-container://$KUBE_NAMESPACE/$KUBE_POD_NAME/$KUBE_CONTAINER_NAME --reporter json:scan-results.json cli\n\n  artifacts:\n    paths:\n      - scan-results.json\n    expire_in: 1 week\n\nprocess_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Generate scan summary\n    - saf summary --input scan-results.json --output-md scan-summary.md\n\n    # Apply threshold check\n    - saf threshold -i scan-results.json -t $THRESHOLD_SCORE\n    - if [ $? -ne 0 ]; then echo \"Threshold check failed\"; exit 1; fi\n\n    # Generate HTML report\n    - saf report -i scan-results.json -o scan-report.html\n\n  artifacts:\n    paths:\n      - scan-summary.md\n      - scan-report.html\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n  script:\n    - kubectl delete rolebinding scanner-binding -n $KUBE_NAMESPACE\n    - kubectl delete role scanner-role -n $KUBE_NAMESPACE\n    - kubectl delete serviceaccount scanner-sa -n $KUBE_NAMESPACE\n  when: always\n</code></pre>"},{"location":"integration/examples/gitlab-examples/#dynamic-rbac-scanning-example","title":"Dynamic RBAC Scanning Example","text":"<p>This example demonstrates scanning pods based on label selectors:</p> <pre><code>image: debian:stable-slim\n\nvariables:\n  KUBE_NAMESPACE: default\n  LABEL_SELECTOR: scan=true\n  INSPEC_PROFILE: dev-sec/linux-baseline\n\nstages:\n  - scan\n  - process\n  - cleanup\n\nscan:\n  stage: scan\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release jq\n    - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n    - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Setup Kubernetes access\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Parse label selector\n    - LABEL_KEY=$(echo \"$LABEL_SELECTOR\" | cut -d= -f1)\n    - LABEL_VALUE=$(echo \"$LABEL_SELECTOR\" | cut -d= -f2)\n\n    # Create service account\n    - kubectl create serviceaccount label-scanner-sa -n $KUBE_NAMESPACE\n\n    # Create role with label selector\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: label-scanner-role\n        namespace: $KUBE_NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      EOF\n\n    # Create role binding\n    - kubectl create rolebinding label-scanner-binding --role=label-scanner-role --serviceaccount=$KUBE_NAMESPACE:label-scanner-sa -n $KUBE_NAMESPACE\n\n    # Generate token\n    - TOKEN=$(kubectl create token label-scanner-sa -n $KUBE_NAMESPACE --duration=15m)\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $KUBE_NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n  script:\n    # Find pods with matching label\n    - PODS=$(kubectl get pods -n $KUBE_NAMESPACE -l $LABEL_SELECTOR -o name | cut -d/ -f2)\n\n    - if [ -z \"$PODS\" ]; then\n    -   echo \"No pods found with label $LABEL_SELECTOR\"\n    -   exit 1\n    - fi\n\n    - echo \"Found pods with label $LABEL_SELECTOR:\"\n    - echo \"$PODS\"\n\n    # Scan each pod\n    - mkdir -p scan-results\n    - |\n      for POD in $PODS; do\n        echo \"Scanning pod: $POD\"\n\n        # Get first container name\n        CONTAINER=$(kubectl get pod $POD -n $KUBE_NAMESPACE -o jsonpath='{.spec.containers[0].name}')\n\n        # Run scan\n        KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec $INSPEC_PROFILE \\\n          -t k8s-container://$KUBE_NAMESPACE/$POD/$CONTAINER \\\n          --reporter json:scan-results/$POD-results.json cli\n      done\n\n  artifacts:\n    paths:\n      - scan-results/\n    expire_in: 1 week\n\nprocess_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Process each result file\n    - mkdir -p scan-reports\n    - |\n      for RESULT_FILE in scan-results/*-results.json; do\n        POD_NAME=$(basename $RESULT_FILE | cut -d- -f1)\n\n        # Generate scan summary\n        saf summary --input $RESULT_FILE --output-md scan-reports/$POD_NAME-summary.md\n\n        # Generate HTML report\n        saf report -i $RESULT_FILE -o scan-reports/$POD_NAME-report.html\n      done\n\n    # Generate combined report\n    - echo \"# Scan Results for Pods with Label $LABEL_SELECTOR\" &gt; combined-summary.md\n    - for SUMMARY in scan-reports/*-summary.md; do\n    -   POD_NAME=$(basename $SUMMARY | cut -d- -f1)\n    -   echo \"## Pod: $POD_NAME\" &gt;&gt; combined-summary.md\n    -   cat $SUMMARY &gt;&gt; combined-summary.md\n    -   echo &gt;&gt; combined-summary.md\n    - done\n\n  artifacts:\n    paths:\n      - scan-reports/\n      - combined-summary.md\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n  script:\n    - kubectl delete rolebinding label-scanner-binding -n $KUBE_NAMESPACE\n    - kubectl delete role label-scanner-role -n $KUBE_NAMESPACE\n    - kubectl delete serviceaccount label-scanner-sa -n $KUBE_NAMESPACE\n  when: always\n</code></pre>"},{"location":"integration/examples/gitlab-examples/#sidecar-container-with-services-example","title":"Sidecar Container with Services Example","text":"<p>This example demonstrates using GitLab's CI/CD services feature for sidecar container scanning:</p> <pre><code>image: debian:stable-slim\n\nvariables:\n  KUBE_NAMESPACE: default\n  TARGET_POD_NAME: app-pod\n  INSPEC_PROFILE: dev-sec/linux-baseline\n  THRESHOLD_SCORE: 70\n\nservices:\n  - name: registry.gitlab.com/your-org/cinc-scanner:latest\n    alias: scanner\n\nstages:\n  - scan\n  - process\n\nbefore_script:\n  - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release\n  - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n  - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n  - apt-get update &amp;&amp; apt-get install -y kubectl\n  - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n  - export KUBECONFIG=kubeconfig.yaml\n\nscan:\n  stage: scan\n  script:\n    # Create pod with shared process namespace\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: $TARGET_POD_NAME\n        namespace: $KUBE_NAMESPACE\n      spec:\n        shareProcessNamespace: true\n        containers:\n        - name: app\n          image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}\n          # Your container configuration here\n        - name: scanner\n          image: registry.gitlab.com/your-org/cinc-scanner:latest\n          command: [\"sleep\", \"600\"]  # Keep the container alive for scanning\n      EOF\n\n    # Wait for pod to be ready\n    - kubectl wait --for=condition=ready pod/$TARGET_POD_NAME -n $KUBE_NAMESPACE --timeout=120s\n\n    # Run scan using the sidecar container\n    - |\n      kubectl exec -n $KUBE_NAMESPACE $TARGET_POD_NAME -c scanner -- bash -c \"\n        cinc-auditor exec $INSPEC_PROFILE --target chroot:///proc/1/root --reporter json:/tmp/scan-results.json\n      \"\n\n    # Retrieve results\n    - kubectl cp $KUBE_NAMESPACE/$TARGET_POD_NAME:/tmp/scan-results.json scan-results.json -c scanner\n\n  artifacts:\n    paths:\n      - scan-results.json\n    expire_in: 1 week\n\nprocess_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Generate scan summary\n    - saf summary --input scan-results.json --output-md scan-summary.md\n\n    # Apply threshold check\n    - saf threshold -i scan-results.json -t $THRESHOLD_SCORE\n    - if [ $? -ne 0 ]; then echo \"Threshold check failed\"; exit 1; fi\n\n    # Generate HTML report\n    - saf report -i scan-results.json -o scan-report.html\n\n  artifacts:\n    paths:\n      - scan-summary.md\n      - scan-report.html\n    reports:\n      junit: scan-results.xml\n    expire_in: 1 week\n\nafter_script:\n  - kubectl delete pod $TARGET_POD_NAME -n $KUBE_NAMESPACE\n</code></pre>"},{"location":"integration/examples/gitlab-examples/#distroless-container-scanning-example","title":"Distroless Container Scanning Example","text":"<p>This example demonstrates scanning distroless containers using the debug container approach:</p> <pre><code>image: debian:stable-slim\n\nvariables:\n  KUBE_NAMESPACE: default\n  DISTROLESS_POD: distroless-app\n  DISTROLESS_CONTAINER: app\n  INSPEC_PROFILE: dev-sec/linux-baseline\n\nstages:\n  - setup\n  - scan\n  - process\n  - cleanup\n\nsetup:\n  stage: setup\n  script:\n    - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release jq\n    - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n    - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n\n    # Setup Kubernetes access\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create service account with debug container permissions\n    - kubectl create serviceaccount debug-scanner-sa -n $KUBE_NAMESPACE\n\n    # Create role with debug container permissions\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: debug-scanner-role\n        namespace: $KUBE_NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/ephemeralcontainers\"]\n        verbs: [\"get\", \"update\"]\n        resourceNames: [\"$DISTROLESS_POD\"]\n      EOF\n\n    # Create role binding\n    - kubectl create rolebinding debug-scanner-binding --role=debug-scanner-role --serviceaccount=$KUBE_NAMESPACE:debug-scanner-sa -n $KUBE_NAMESPACE\n\n    # Generate token\n    - TOKEN=$(kubectl create token debug-scanner-sa -n $KUBE_NAMESPACE --duration=30m)\n    - echo \"SCANNER_TOKEN=$TOKEN\" &gt; scanner-token.txt\n\n  artifacts:\n    paths:\n      - scanner-token.txt\n      - kubeconfig.yaml\n\nscan:\n  stage: scan\n  dependencies:\n    - setup\n  script:\n    - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release jq\n    - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n    - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - export KUBECONFIG=kubeconfig.yaml\n    - export SCANNER_TOKEN=$(cat scanner-token.txt)\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $KUBE_NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $SCANNER_TOKEN\n      EOF\n\n    # Get pod JSON\n    - POD_JSON=$(kubectl get pod $DISTROLESS_POD -n $KUBE_NAMESPACE -o json)\n\n    # Add debug container\n    - |\n      PATCHED_POD=$(echo \"$POD_JSON\" | jq --arg target \"$DISTROLESS_CONTAINER\" '.spec.ephemeralContainers += [{\n        \"name\": \"debugger\",\n        \"image\": \"busybox:latest\",\n        \"command\": [\"sleep\", \"3600\"],\n        \"targetContainerName\": $target\n      }]')\n\n    # Apply patch\n    - echo \"$PATCHED_POD\" | kubectl replace --raw /api/v1/namespaces/$KUBE_NAMESPACE/pods/$DISTROLESS_POD/ephemeralcontainers -f -\n\n    # Wait for debug container to start\n    - sleep 10\n\n    # Install CINC in the ephemeral container\n    - curl -L https://omnitruck.cinc.sh/install.sh &gt; install-cinc.sh\n\n    # Create scan script\n    - |\n      cat &gt; scan-distroless.sh &lt;&lt; 'EOF'\n      #!/bin/sh\n      # Get target container's root filesystem\n      TARGET_PROC_ROOT=\"/proc/1/root\"\n      PROFILE=\"$1\"\n\n      # Create results directory\n      mkdir -p /tmp/results\n\n      # Run InSpec with chroot\n      cinc-auditor exec \"$PROFILE\" --target chroot://$TARGET_PROC_ROOT --reporter json:/tmp/results/results.json\n\n      # Output results\n      cat /tmp/results/results.json\n      EOF\n\n    # Copy scripts to debug container\n    - export KUBECONFIG=scanner-kubeconfig.yaml\n    - kubectl cp -n $KUBE_NAMESPACE install-cinc.sh $DISTROLESS_POD:install-cinc.sh -c debugger\n    - kubectl cp -n $KUBE_NAMESPACE scan-distroless.sh $DISTROLESS_POD:scan-distroless.sh -c debugger\n    - kubectl exec -n $KUBE_NAMESPACE $DISTROLESS_POD -c debugger -- chmod +x /scan-distroless.sh\n    - kubectl exec -n $KUBE_NAMESPACE $DISTROLESS_POD -c debugger -- chmod +x /install-cinc.sh\n\n    # Install CINC in debug container\n    - kubectl exec -n $KUBE_NAMESPACE $DISTROLESS_POD -c debugger -- sh -c \"apk add --no-cache bash &amp;&amp; /install-cinc.sh -P cinc-auditor\"\n\n    # Run scan\n    - kubectl exec -n $KUBE_NAMESPACE $DISTROLESS_POD -c debugger -- /scan-distroless.sh $INSPEC_PROFILE &gt; distroless-results.json\n\n  artifacts:\n    paths:\n      - distroless-results.json\n    expire_in: 1 week\n\nprocess_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Generate scan summary\n    - saf summary --input distroless-results.json --output-md distroless-summary.md\n\n    # Generate HTML report\n    - saf report -i distroless-results.json -o distroless-report.html\n\n  artifacts:\n    paths:\n      - distroless-summary.md\n      - distroless-report.html\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  dependencies:\n    - setup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - export KUBECONFIG=kubeconfig.yaml\n  script:\n    - kubectl delete rolebinding debug-scanner-binding -n $KUBE_NAMESPACE\n    - kubectl delete role debug-scanner-role -n $KUBE_NAMESPACE\n    - kubectl delete serviceaccount debug-scanner-sa -n $KUBE_NAMESPACE\n  when: always\n</code></pre>"},{"location":"integration/examples/gitlab-examples/#existing-cluster-integration-example","title":"Existing Cluster Integration Example","text":"<p>This example demonstrates scanning pods in an existing Kubernetes cluster:</p> <pre><code>image: debian:stable-slim\n\nvariables:\n  KUBE_NAMESPACE: production\n  LABEL_SELECTOR: component=api\n  INSPEC_PROFILE: dev-sec/linux-baseline\n  THRESHOLD_SCORE: 85\n\nstages:\n  - scan\n  - process\n  - cleanup\n\nscan:\n  stage: scan\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y curl apt-transport-https ca-certificates gnupg lsb-release jq\n    - curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\n    - echo \"deb https://apt.kubernetes.io/ kubernetes-xenial main\" | tee /etc/apt/sources.list.d/kubernetes.list\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Setup Kubernetes access\n    - echo \"$PROD_KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create time-limited service account with least privilege\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-temp-sa\n        namespace: $KUBE_NAMESPACE\n        annotations:\n          gitlab.io/ci-job: \"${CI_JOB_ID}\"\n          gitlab.io/pipeline: \"${CI_PIPELINE_ID}\"\n      EOF\n\n    # Create role with label-based permissions\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-temp-role\n        namespace: $KUBE_NAMESPACE\n        annotations:\n          gitlab.io/ci-job: \"${CI_JOB_ID}\"\n          gitlab.io/pipeline: \"${CI_PIPELINE_ID}\"\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n        resourceNames: []  # Will be filled dynamically\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: []  # Will be filled dynamically\n      EOF\n\n    # Find pods with matching label\n    - PODS=$(kubectl get pods -n $KUBE_NAMESPACE -l $LABEL_SELECTOR -o name | cut -d/ -f2)\n\n    - if [ -z \"$PODS\" ]; then\n    -   echo \"No pods found with label $LABEL_SELECTOR\"\n    -   exit 1\n    - fi\n\n    - echo \"Found pods with label $LABEL_SELECTOR:\"\n    - echo \"$PODS\"\n\n    # Update role with specific pod names\n    - |\n      POD_NAMES_JSON=\"[]\"\n      for POD in $PODS; do\n        POD_NAMES_JSON=$(echo $POD_NAMES_JSON | jq --arg pod \"$POD\" '. + [$pod]')\n      done\n\n      ROLE_JSON=$(kubectl get role scanner-temp-role -n $KUBE_NAMESPACE -o json)\n\n      # Update pod/get rule\n      UPDATED_ROLE=$(echo $ROLE_JSON | jq --argjson pods \"$POD_NAMES_JSON\" '.rules[0].resourceNames = $pods')\n\n      # Update pod/exec rule\n      UPDATED_ROLE=$(echo $UPDATED_ROLE | jq --argjson pods \"$POD_NAMES_JSON\" '.rules[1].resourceNames = $pods')\n\n      # Apply updated role\n      echo $UPDATED_ROLE | kubectl apply -f -\n\n    # Create role binding\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-temp-binding\n        namespace: $KUBE_NAMESPACE\n        annotations:\n          gitlab.io/ci-job: \"${CI_JOB_ID}\"\n          gitlab.io/pipeline: \"${CI_PIPELINE_ID}\"\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-temp-sa\n        namespace: $KUBE_NAMESPACE\n      roleRef:\n        apiGroup: rbac.authorization.k8s.io\n        kind: Role\n        name: scanner-temp-role\n      EOF\n\n    # Generate token\n    - TOKEN=$(kubectl create token scanner-temp-sa -n $KUBE_NAMESPACE --duration=15m)\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $KUBE_NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n  script:\n    # Scan each pod\n    - mkdir -p scan-results\n    - |\n      for POD in $PODS; do\n        echo \"Scanning pod: $POD\"\n\n        # Get first container name\n        CONTAINER=$(kubectl get pod $POD -n $KUBE_NAMESPACE -o jsonpath='{.spec.containers[0].name}')\n\n        # Run scan\n        KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec $INSPEC_PROFILE \\\n          -t k8s-container://$KUBE_NAMESPACE/$POD/$CONTAINER \\\n          --reporter json:scan-results/$POD-results.json cli\n      done\n\n  artifacts:\n    paths:\n      - scan-results/\n    expire_in: 1 week\n\nprocess_results:\n  stage: process\n  image: node:16-alpine\n  dependencies:\n    - scan\n  before_script:\n    - npm install -g @mitre/saf\n  script:\n    # Process each result file\n    - mkdir -p scan-reports\n    - |\n      for RESULT_FILE in scan-results/*-results.json; do\n        if [ -f \"$RESULT_FILE\" ]; then\n          POD_NAME=$(basename $RESULT_FILE | cut -d- -f1)\n\n          # Generate scan summary\n          saf summary --input $RESULT_FILE --output-md scan-reports/$POD_NAME-summary.md\n\n          # Apply threshold check\n          echo \"Checking threshold for $POD_NAME\"\n          saf threshold -i $RESULT_FILE -t $THRESHOLD_SCORE\n          THRESHOLD_RESULT=$?\n\n          if [ $THRESHOLD_RESULT -ne 0 ]; then\n            echo \"Pod $POD_NAME failed threshold check!\"\n            FAILED_PODS=\"$FAILED_PODS $POD_NAME\"\n          fi\n\n          # Generate HTML report\n          saf report -i $RESULT_FILE -o scan-reports/$POD_NAME-report.html\n        fi\n      done\n\n    # Generate combined report\n    - echo \"# Security Scan Results for Production Pods\" &gt; combined-report.md\n    - echo \"Label selector: \\`$LABEL_SELECTOR\\`\" &gt;&gt; combined-report.md\n    - echo \"Threshold: $THRESHOLD_SCORE%\" &gt;&gt; combined-report.md\n    - echo &gt;&gt; combined-report.md\n\n    - if [ -n \"$FAILED_PODS\" ]; then\n    -   echo \"## Failed Pods\" &gt;&gt; combined-report.md\n    -   echo \"The following pods did not meet the minimum security threshold:\" &gt;&gt; combined-report.md\n    -   echo &gt;&gt; combined-report.md\n    -   for POD in $FAILED_PODS; do\n    -     echo \"- $POD\" &gt;&gt; combined-report.md\n    -   done\n    -   echo &gt;&gt; combined-report.md\n    -   # Fail job if any pods failed threshold check\n    -   echo \"Some pods failed security threshold check\"\n    -   exit 1\n    - fi\n\n  artifacts:\n    paths:\n      - scan-reports/\n      - combined-report.md\n    expire_in: 1 week\n\ncleanup:\n  stage: cleanup\n  before_script:\n    - apt-get update &amp;&amp; apt-get install -y kubectl\n    - echo \"$PROD_KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n  script:\n    - kubectl delete rolebinding scanner-temp-binding -n $KUBE_NAMESPACE\n    - kubectl delete role scanner-temp-role -n $KUBE_NAMESPACE\n    - kubectl delete serviceaccount scanner-temp-sa -n $KUBE_NAMESPACE\n  when: always\n</code></pre>"},{"location":"integration/examples/gitlab-examples/#related-resources","title":"Related Resources","text":"<ul> <li>GitLab CI/CD Integration Guide</li> <li>GitLab Services Integration Guide</li> <li>Standard Container Workflow</li> <li>Distroless Container Workflow</li> <li>Sidecar Container Workflow</li> <li>Security Workflows</li> <li>Approach Mapping</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"integration/examples/inventory/","title":"Integration Examples Files","text":"<p>This page provides an inventory of all files in the integration examples section.</p>"},{"location":"integration/examples/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of integration examples github-examples.md GitHub Actions examples gitlab-examples.md GitLab CI examples GitLab Services Examples GitLab Services examples (coming soon) Custom Integration Examples Custom integration examples (coming soon)"},{"location":"integration/examples/inventory/#related-directories","title":"Related Directories","text":"<ul> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> <li>CI/CD Platforms</li> <li>Integration Workflows</li> <li>Integration Configuration</li> </ul>"},{"location":"integration/platforms/","title":"CI/CD Platform Integrations","text":"<p>This section provides detailed documentation on integrating the Kube CINC Secure Scanner with various CI/CD platforms.</p>"},{"location":"integration/platforms/#overview","title":"Overview","text":"<p>The Kube CINC Secure Scanner supports integration with multiple CI/CD platforms to enable automated container security scanning as part of your deployment pipeline.</p>"},{"location":"integration/platforms/#supported-platforms","title":"Supported Platforms","text":"<p>We provide detailed integration guides for the following CI/CD platforms:</p> <ul> <li>GitHub Actions - Integration with GitHub's native CI/CD service</li> <li>GitLab CI - Integration with GitLab's CI/CD pipelines</li> <li>GitLab Services - Advanced integration using GitLab's Services feature</li> <li>Jenkins - Integration with Jenkins pipelines (coming soon)</li> <li>Azure DevOps - Integration with Azure DevOps pipelines (coming soon)</li> <li>Custom Platforms - Guidance for integrating with other CI/CD platforms (coming soon)</li> </ul>"},{"location":"integration/platforms/#platform-selection-considerations","title":"Platform Selection Considerations","text":"<p>When selecting a CI/CD platform for integration, consider the following factors:</p> <ol> <li>Existing Infrastructure: If you already use a particular CI/CD platform, integrating with that platform may be the most straightforward option.</li> <li>Container Support: Ensure the platform has good support for container-based workflows.</li> <li>Kubernetes Integration: Platforms with native Kubernetes integration simplify the setup process.</li> <li>Security Features: Consider the platform's security features, such as secrets management.</li> <li>Scalability: Ensure the platform can handle your desired scan frequency and volume.</li> </ol>"},{"location":"integration/platforms/#future-platform-support","title":"Future Platform Support","text":"<p>We are actively working on adding detailed integration guides for:</p>"},{"location":"integration/platforms/#jenkins-integration","title":"Jenkins Integration","text":"<p>Jenkins integration will provide:</p> <ul> <li>Pipeline templates for Jenkins</li> <li>Step-by-step integration guides</li> <li>Best practices for Jenkins-specific configurations</li> </ul>"},{"location":"integration/platforms/#azure-devops-integration","title":"Azure DevOps Integration","text":"<p>Azure DevOps integration will include:</p> <ul> <li>YAML pipeline templates</li> <li>Detailed integration steps</li> <li>Security considerations for Azure environments</li> </ul>"},{"location":"integration/platforms/#custom-platform-integration","title":"Custom Platform Integration","text":"<p>For other CI/CD platforms, we will provide:</p> <ul> <li>Generic integration patterns</li> <li>Platform-agnostic configuration</li> <li>Adapting workflows to various environments</li> </ul>"},{"location":"integration/platforms/#related-resources","title":"Related Resources","text":"<ul> <li>Integration Workflows</li> <li>Integration Examples</li> <li>Integration Configuration</li> <li>Approach Mapping</li> </ul>"},{"location":"integration/platforms/github-actions/","title":"GitHub Actions Integration","text":"<p>This guide explains how to use GitHub Actions for secure Kubernetes container scanning with CINC Auditor (using the train-k8s-container plugin) and MITRE SAF-CLI.</p> <p>Strategic Priority: We strongly recommend the Kubernetes API Approach using the train-k8s-container plugin for enterprise-grade container scanning. Our highest priority is enhancing this plugin to support distroless containers. See Approach Comparison and Security Compliance for more details.</p>"},{"location":"integration/platforms/github-actions/#available-workflows","title":"Available Workflows","text":"<p>We provide three GitHub Actions workflow examples:</p> <ol> <li>Basic Setup and Scan - Sets up a minikube cluster and runs a basic scan against a container</li> <li>Dynamic RBAC Scanning - Demonstrates dynamic pod selection by labels with secure RBAC</li> <li>CI/CD Pipeline - Complete pipeline that builds, deploys, scans a container, and processes results with SAF-CLI</li> </ol>"},{"location":"integration/platforms/github-actions/#setup-instructions","title":"Setup Instructions","text":""},{"location":"integration/platforms/github-actions/#1-repository-setup","title":"1. Repository Setup","text":"<ol> <li>Create a new GitHub repository or use an existing one</li> <li>Copy the workflow files from the <code>docs/github-workflow-examples</code> directory to <code>.github/workflows</code> in your repository</li> <li>Commit and push the changes</li> </ol>"},{"location":"integration/platforms/github-actions/#2-workflow-permissions","title":"2. Workflow Permissions","text":"<p>Ensure your GitHub Actions workflows have appropriate permissions:</p> <ol> <li>Go to your repository Settings &gt; Actions &gt; General</li> <li>Under \"Workflow permissions\", select \"Read and write permissions\"</li> <li>Check \"Allow GitHub Actions to create and approve pull requests\"</li> </ol>"},{"location":"integration/platforms/github-actions/#running-the-workflows","title":"Running the Workflows","text":""},{"location":"integration/platforms/github-actions/#basic-setup-and-scan","title":"Basic Setup and Scan","text":"<p>This workflow sets up a minikube cluster and runs a basic scan against a busybox container:</p> <ol> <li>Navigate to the Actions tab in your repository</li> <li>Select the \"Setup Minikube and Run CINC Auditor Scan\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Minikube version: Version of minikube to use (default: v1.32.0)</li> <li>Kubernetes version: Version of Kubernetes to use (default: v1.28.3)</li> <li>CINC profile: Profile to run (default: dev-sec/linux-baseline)</li> <li>Click Run workflow to start the scan</li> </ol> <p>The workflow will:</p> <ul> <li>Set up a minikube cluster</li> <li>Create a test pod</li> <li>Configure restricted RBAC</li> <li>Run CINC Auditor against the container</li> <li>Upload the scan results as artifacts</li> </ul>"},{"location":"integration/platforms/github-actions/#dynamic-rbac-configuration","title":"Dynamic RBAC Scanning","text":"<p>This workflow demonstrates more advanced scanning with dynamic pod targeting:</p> <ol> <li>Navigate to the Actions tab</li> <li>Select the \"Dynamic RBAC Pod Scanning\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Target container image: Container image to scan</li> <li>Scan label: Label to identify the target container (format: key=value)</li> <li>CINC profile: Profile to run</li> <li>Click Run workflow</li> </ol> <p>The workflow will:</p> <ul> <li>Create multiple pods but only label one for scanning</li> <li>Set up label-based RBAC</li> <li>Run CINC Auditor against the labeled container only</li> <li>Verify that access is properly restricted</li> <li>Upload the results as artifacts</li> </ul>"},{"location":"integration/platforms/github-actions/#cicd-pipeline-with-saf-cli","title":"CI/CD Pipeline with SAF-CLI","text":"<p>This workflow demonstrates a complete CI/CD pipeline with security scanning and quality gates:</p> <ol> <li>Navigate to the Actions tab</li> <li>Select the \"CI/CD Pipeline with CINC Auditor Scanning\" workflow</li> <li>Click Run workflow</li> <li>Configure the parameters:</li> <li>Image tag: Tag for the container image</li> <li>Scan namespace: Kubernetes namespace for deployment and scanning</li> <li>Threshold: Minimum passing score (0-100) for security checks</li> <li>Click Run workflow</li> </ol> <p>The workflow will:</p> <ul> <li>Create a simple test application</li> <li>Build a container image</li> <li>Deploy it to Kubernetes</li> <li>Set up secure scanning access</li> <li>Run custom security checks with CINC Auditor</li> <li>Generate reports with SAF-CLI</li> <li>Apply threshold checks for quality gates</li> <li>Upload all results as artifacts</li> </ul>"},{"location":"integration/platforms/github-actions/#mitre-saf-cli-integration","title":"MITRE SAF-CLI Integration","text":""},{"location":"integration/platforms/github-actions/#overview","title":"Overview","text":"<p>The workflow uses MITRE SAF-CLI for processing scan results and implementing quality gates. SAF-CLI provides:</p> <ol> <li>Formatted summaries (Markdown, JSON, etc.)</li> <li>Threshold-based quality gates</li> <li>Visualization capabilities</li> </ol>"},{"location":"integration/platforms/github-actions/#saf-cli-commands-used","title":"SAF-CLI Commands Used","text":""},{"location":"integration/platforms/github-actions/#summary-generation","title":"Summary Generation","text":"<pre><code># Generate a markdown summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Display the summary in the logs\ncat scan-summary.md\n</code></pre>"},{"location":"integration/platforms/github-actions/#threshold-checks","title":"Threshold Checks","text":"<pre><code># Check against threshold value (exits with non-zero if below threshold)\nsaf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\nTHRESHOLD_EXIT_CODE=$?\n\nif [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\n  # Uncomment to enforce the threshold as a quality gate\n  # exit $THRESHOLD_EXIT_CODE\nfi\n</code></pre>"},{"location":"integration/platforms/github-actions/#advanced-thresholds","title":"Advanced Thresholds","text":"<p>For more granular control, you can extend the threshold command:</p> <pre><code># Zero critical failures, max 2 high severity failures, 70% overall\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/platforms/github-actions/#github-step-summary-integration","title":"GitHub Step Summary Integration","text":"<pre><code># Create a combined summary for GitHub step summary\necho \"## Custom Application Profile Results\" &gt; $GITHUB_STEP_SUMMARY\ncat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\necho \"## Linux Baseline Results\" &gt;&gt; $GITHUB_STEP_SUMMARY\ncat baseline-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>"},{"location":"integration/platforms/github-actions/#customizing-the-workflows","title":"Customizing the Workflows","text":""},{"location":"integration/platforms/github-actions/#using-your-own-profiles","title":"Using Your Own Profiles","text":"<p>To use your own CINC Auditor profiles:</p> <ol> <li>Create a profile in your repository (e.g., <code>./profiles/my-custom-profile</code>)</li> <li>When running the workflow, enter <code>./profiles/my-custom-profile</code> as the profile parameter</li> </ol> <p>Or use a profile from a URL:</p> <ol> <li>Host your profile in a Git repository</li> <li>When running the workflow, enter the URL of your profile</li> </ol>"},{"location":"integration/platforms/github-actions/#integrating-with-pull-requests","title":"Integrating with Pull Requests","text":"<p>You can modify the workflows to run on pull requests:</p> <ol> <li>Edit the workflow file</li> <li>Update the <code>on:</code> section to include pull requests:</li> </ol> <pre><code>on:\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n    # keep existing inputs\n</code></pre> <ol> <li>Add comment reporting using SAF-CLI output:</li> </ol> <pre><code>- name: Comment on PR with scan results\n  if: github.event_name == 'pull_request'\n  uses: actions/github-script@v6\n  with:\n    github-token: ${{ secrets.GITHUB_TOKEN }}\n    script: |\n      const fs = require('fs');\n      const summary = fs.readFileSync('scan-summary.md', 'utf8');\n\n      github.rest.issues.createComment({\n        issue_number: context.issue.number,\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        body: `## Security Scan Results\\n\\n${summary}\\n\\n[View detailed results](${artifactsUrl})`\n      });\n</code></pre>"},{"location":"integration/platforms/github-actions/#enforcing-quality-gates","title":"Enforcing Quality Gates","text":"<p>To enforce quality gates in your workflow:</p> <ol> <li>Edit the workflow file</li> <li>Modify the threshold check to exit on failure:</li> </ol> <pre><code>- name: Check security threshold\n  run: |\n    # Apply threshold check\n    saf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\n    if [ $? -ne 0 ]; then\n      echo \"\u274c Security scan failed to meet threshold requirements\"\n      exit 1\n    fi\n</code></pre>"},{"location":"integration/platforms/github-actions/#security-considerations","title":"Security Considerations","text":""},{"location":"integration/platforms/github-actions/#github-secrets","title":"GitHub Secrets","text":"<p>For production use, consider storing sensitive configuration in GitHub Secrets:</p> <ol> <li>Go to repository Settings &gt; Secrets and variables &gt; Actions</li> <li>Create secrets for:</li> <li><code>KUBE_CONFIG</code>: Base64-encoded kubeconfig (for external clusters)</li> <li><code>CINC_LICENSE</code>: License acceptance for CINC Auditor (if needed)</li> </ol>"},{"location":"integration/platforms/github-actions/#rbac-best-practices","title":"RBAC Best Practices","text":"<p>The workflows demonstrate secure RBAC patterns:</p> <ol> <li>Use time-limited tokens (15 minutes)</li> <li>Clean up resources after scanning</li> <li>Only grant necessary permissions</li> <li>Use label selectors for dynamic targeting</li> </ol>"},{"location":"integration/platforms/github-actions/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/platforms/github-actions/#common-issues","title":"Common Issues","text":"<ol> <li>Minikube startup fails - Increase resource limits in the action</li> <li>Plugin installation fails - Check network connectivity or use pre-built images</li> <li>Scan access denied - Verify RBAC permissions and token validity</li> <li>SAF-CLI installation fails - Ensure Node.js is available in the runner</li> </ol>"},{"location":"integration/platforms/github-actions/#saf-cli-debugging","title":"SAF-CLI Debugging","text":"<p>If you encounter issues with SAF-CLI:</p> <pre><code># Check SAF-CLI version\nsaf --version\n\n# Run with debug flag\nsaf threshold -i scan-results.json -t 70 --debug\n\n# Validate JSON format\njq . scan-results.json &gt; /dev/null &amp;&amp; echo \"Valid JSON\" || echo \"Invalid JSON\"\n</code></pre>"},{"location":"integration/platforms/github-actions/#references","title":"References","text":"<ul> <li>CINC Auditor Documentation</li> <li>MITRE SAF-CLI Documentation</li> <li>GitHub Actions Documentation</li> <li>Minikube GitHub Action</li> <li>Kubernetes RBAC Documentation</li> </ul>"},{"location":"integration/platforms/github-actions/#related-integration-resources","title":"Related Integration Resources","text":"<ul> <li>Standard Container Workflow Integration</li> <li>Distroless Container Workflow Integration</li> <li>Sidecar Container Workflow Integration</li> <li>GitHub Actions Examples</li> <li>Integration Configuration</li> </ul>"},{"location":"integration/platforms/gitlab-ci/","title":"GitLab CI/CD Integration","text":"<p>This guide explains how to integrate secure container scanning using CINC Auditor with the train-k8s-container plugin into GitLab CI/CD pipelines.</p> <p>Strategic Priority: We strongly recommend the Kubernetes API Approach using the train-k8s-container plugin for enterprise-grade container scanning. Our highest priority is enhancing this plugin to support distroless containers. See Approach Comparison and Security Compliance for more details.</p>"},{"location":"integration/platforms/gitlab-ci/#overview","title":"Overview","text":"<p>The integration handles these key steps:</p> <ol> <li>Creating a container to scan in Kubernetes</li> <li>Generating dynamic, restricted access to that container</li> <li>Running CINC Auditor with the train-k8s-container transport</li> <li>Using MITRE SAF-CLI for results processing and quality gates</li> <li>Cleaning up temporary resources</li> </ol>"},{"location":"integration/platforms/gitlab-ci/#prerequisites","title":"Prerequisites","text":""},{"location":"integration/platforms/gitlab-ci/#gitlab-runner-setup","title":"GitLab Runner Setup","text":"<ol> <li>A GitLab Runner with access to your Kubernetes cluster</li> <li>The runner needs:</li> <li>kubectl installed</li> <li>Access to the cluster (kubeconfig)</li> <li>Permissions to create service accounts and roles</li> <li>Node.js installed (for SAF-CLI)</li> </ol>"},{"location":"integration/platforms/gitlab-ci/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ol> <li>A namespace for the scanner infrastructure</li> <li>Permission to create and manage:</li> <li>Pods</li> <li>Service accounts</li> <li>Roles and RoleBindings</li> </ol>"},{"location":"integration/platforms/gitlab-ci/#configuration","title":"Configuration","text":""},{"location":"integration/platforms/gitlab-ci/#gitlab-ci-variables","title":"GitLab CI Variables","text":"<p>Set up these CI/CD variables in GitLab:</p> <ul> <li><code>KUBE_CONFIG</code>: Base64-encoded kubeconfig with permissions to manage RBAC</li> <li><code>SCANNER_NAMESPACE</code>: The namespace for scanner resources</li> <li><code>CINC_PROFILE_PATH</code>: Path to the CINC Auditor profile to run</li> <li><code>THRESHOLD_VALUE</code>: Minimum passing score (0-100) for security scans</li> </ul>"},{"location":"integration/platforms/gitlab-ci/#gitlab-ciyml-example-with-saf-cli","title":".gitlab-ci.yml Example with SAF-CLI","text":"<pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=30m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#using-the-saf-cli-in-your-pipeline","title":"Using the SAF-CLI in Your Pipeline","text":"<p>The MITRE SAF-CLI provides powerful capabilities for security scan results:</p>"},{"location":"integration/platforms/gitlab-ci/#installation","title":"Installation","text":"<pre><code># Install SAF-CLI\nnpm install -g @mitre/saf\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#generate-summaries","title":"Generate Summaries","text":"<pre><code># Create a markdown summary\nsaf summary --input scan-results.json --output-md scan-summary.md\n\n# Create a JSON summary\nsaf summary --input scan-results.json --output scan-summary.json\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#threshold-quality-gates","title":"Threshold Quality Gates","text":"<pre><code># Check against a threshold (exits with non-zero if below threshold)\nsaf threshold -i scan-results.json -t 70\n\n# More advanced threshold options\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#visualization-and-reports","title":"Visualization and Reports","text":"<pre><code># Generate a standalone HTML report\nsaf view -i scan-results.json --output report.html\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#security-enhancements","title":"Security Enhancements","text":""},{"location":"integration/platforms/gitlab-ci/#pipeline-specific-token-durations","title":"Pipeline-Specific Token Durations","text":"<p>Adjust token durations based on scan complexity:</p> <pre><code># For simple scans\nTOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --duration=15m)\n\n# For complex scans\nTOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --duration=60m)\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#pipeline-specific-namespaces","title":"Pipeline-Specific Namespaces","text":"<p>For stricter isolation, create a dedicated namespace per pipeline:</p> <pre><code>deploy_container:\n  script:\n    - |\n      # Create namespace with unique name\n      kubectl create namespace ${SCANNER_NAMESPACE}-${CI_PIPELINE_ID}\n\n      # Set variable for other stages\n      echo \"PIPELINE_NAMESPACE=${SCANNER_NAMESPACE}-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n\n      # Create pod in isolated namespace\n      # ...\n\ncleanup:\n  script:\n    - |\n      # Delete entire namespace\n      kubectl delete namespace ${PIPELINE_NAMESPACE}\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#implementing-quality-gates","title":"Implementing Quality Gates","text":"<p>You can configure the pipeline to fail based on scan results:</p> <pre><code>run_scan:\n  script:\n    # ... run scan ...\n\n    # Threshold check\n    saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n    THRESHOLD_RESULT=$?\n\n    # Fail the pipeline if below threshold\n    exit ${THRESHOLD_RESULT}\n</code></pre> <p>For more advanced quality gates:</p> <pre><code># Zero critical failures, at most 2 high failures, overall score of 70%\nsaf threshold -i scan-results.json -t 70 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/platforms/gitlab-ci/#common-issues","title":"Common Issues","text":"<ol> <li>SAF-CLI installation fails: Make sure Node.js is installed correctly on your runner</li> <li>Token expiration: If scans take longer than expected, increase the token duration</li> <li>Threshold failures: Adjust threshold values or temporarily disable enforcement during initial implementation</li> </ol>"},{"location":"integration/platforms/gitlab-ci/#debugging","title":"Debugging","text":"<p>Add these steps to your pipeline for better visibility:</p> <pre><code># Display SAF-CLI version\nsaf --version\n\n# Debug specific controls that are failing\njq '.profiles[0].controls[] | select(.status==\"failed\") | {id, title, status}' scan-results.json\n\n# Examine compliance score\njq '.profiles[0].statistics.percent_passed' scan-results.json\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#security-dashboard-integration","title":"Security Dashboard Integration","text":"<p>GitLab provides built-in security dashboard capabilities that can be integrated with CINC Auditor scan results:</p>"},{"location":"integration/platforms/gitlab-ci/#converting-scan-results-for-gitlab-security-dashboard","title":"Converting Scan Results for GitLab Security Dashboard","text":"<ol> <li>Create a converter script to transform CINC results into GitLab Security Report format:</li> </ol> <pre><code>convert_results:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install jq for JSON processing\n      apt-get update &amp;&amp; apt-get install -y jq\n\n      # Convert CINC report to GitLab security report format\n      jq -r '\n        {\n          \"version\": \"2.0\",\n          \"vulnerabilities\": [\n            .profiles[0].controls[] | \n            select(.status==\"failed\") | \n            {\n              \"id\": .id,\n              \"category\": \"container_scanning\",\n              \"name\": .title,\n              \"message\": .desc,\n              \"description\": .desc,\n              \"severity\": (\n                if .impact &gt;= 0.7 then \"Critical\" \n                elif .impact &gt;= 0.4 then \"High\"\n                elif .impact &gt;= 0.2 then \"Medium\"\n                else \"Low\" end\n              ),\n              \"solution\": .refs[0].url,\n              \"scanner\": {\n                \"id\": \"cinc_auditor\",\n                \"name\": \"CINC Auditor\"\n              },\n              \"location\": {\n                \"image\": env.TARGET_IMAGE,\n                \"operating_system\": \"Linux\",\n                \"dependency\": {\n                  \"package\": {}\n                }\n              },\n              \"identifiers\": [\n                {\n                  \"type\": \"cinc_control\",\n                  \"name\": .id,\n                  \"value\": .id\n                }\n              ]\n            }\n          ],\n          \"scan\": {\n            \"scanner\": {\n              \"id\": \"cinc_auditor\",\n              \"name\": \"CINC Auditor\",\n              \"version\": \"5.0.0\",\n              \"vendor\": {\n                \"name\": \"CINC Project\"\n              }\n            },\n            \"analyzer\": {\n              \"id\": \"container_scanning\",\n              \"name\": \"Container Scanning\",\n              \"version\": \"1.0\",\n              \"vendor\": {\n                \"name\": \"GitLab\"\n              }\n            },\n            \"type\": \"container_scanning\",\n            \"start_time\": \"\",\n            \"end_time\": \"\",\n            \"status\": \"success\"\n          }\n        }\n      ' scan-results.json &gt; gl-container-scanning-report.json\n  artifacts:\n    reports:\n      container_scanning: gl-container-scanning-report.json\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#using-gitlab-security-dashboards","title":"Using GitLab Security Dashboards","text":"<p>Once you have converted the reports, they will be automatically integrated into GitLab's security features:</p> <ol> <li>The Security Dashboard in the Security section of your project</li> <li>The Security tab in Merge Requests</li> <li>The Vulnerability Report for tracking security issues</li> </ol>"},{"location":"integration/platforms/gitlab-ci/#compliance-reports","title":"Compliance Reports","text":"<p>For compliance focused reports, you can also configure the pipeline to generate:</p> <pre><code>compliance_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Generate compliance summary report\n      saf compliance-overview -i scan-results.json -o gl-compliance-report.json\n\n      # Display summary in job\n      cat gl-compliance-report.json | jq .\n  artifacts:\n    paths:\n      - gl-compliance-report.json\n    reports:\n      compliance_report:\n        report_format: json\n        report_type: sast\n        report_path: gl-compliance-report.json\n</code></pre>"},{"location":"integration/platforms/gitlab-ci/#related-integration-resources","title":"Related Integration Resources","text":"<ul> <li>Standard Container Workflow Integration</li> <li>Distroless Container Workflow Integration</li> <li>Sidecar Container Workflow Integration</li> <li>GitLab Examples</li> <li>GitLab Services Integration</li> <li>Integration Configuration</li> </ul>"},{"location":"integration/platforms/gitlab-services/","title":"GitLab CI Integration with Services","text":"<p>This document explains how to use GitLab CI/CD services with the Kubernetes CINC Secure Scanner for enhanced container scanning workflows.</p>"},{"location":"integration/platforms/gitlab-services/#overview","title":"Overview","text":"<p>GitLab CI/CD services allow you to run Docker containers alongside your CI/CD jobs. These service containers can provide additional functionality and dependencies without cluttering your main job container. For our scanning workflows, services can provide a consistent, pre-configured environment for running CINC Auditor scans.</p>"},{"location":"integration/platforms/gitlab-services/#benefits-of-using-services","title":"Benefits of Using Services","text":"<ol> <li>Pre-installed Dependencies: Service containers can have CINC Auditor, the train-k8s-container plugin, and the SAF CLI pre-installed.</li> <li>Isolation: Scanning tools are isolated from your application code and build tools.</li> <li>Consistency: Every scan job uses the exact same scanning environment.</li> <li>Specialized Containers: Different service containers can be used for different types of scans (standard vs. distroless).</li> <li>Reduced Setup Time: Eliminates the need to install dependencies in each job.</li> </ol>"},{"location":"integration/platforms/gitlab-services/#implementation","title":"Implementation","text":""},{"location":"integration/platforms/gitlab-services/#creating-scanner-service-images","title":"Creating Scanner Service Images","text":"<p>Create Docker images for your scanning services:</p>"},{"location":"integration/platforms/gitlab-services/#standard-scanner-image","title":"Standard Scanner Image","text":"<pre><code>FROM ruby:3.0-slim\n\n# Install dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl \\\n    gnupg \\\n    nodejs \\\n    npm \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install CINC Auditor\nRUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n# Install train-k8s-container plugin\nRUN cinc-auditor plugin install train-k8s-container\n\n# Install SAF CLI\nRUN npm install -g @mitre/saf\n\n# Set up a working directory\nWORKDIR /opt/scanner\n\nENTRYPOINT [\"sleep\", \"infinity\"]\n</code></pre>"},{"location":"integration/platforms/gitlab-services/#distroless-scanner-image","title":"Distroless Scanner Image","text":"<pre><code>FROM ruby:3.0-slim\n\n# Install dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl \\\n    gnupg \\\n    nodejs \\\n    npm \\\n    kubectl \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install CINC Auditor\nRUN curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n# Install train-k8s-container plugin\nRUN cinc-auditor plugin install train-k8s-container\n\n# Install SAF CLI\nRUN npm install -g @mitre/saf\n\n# Copy specialized scripts\nCOPY scripts/scan-distroless.sh /opt/scripts/\nRUN chmod +x /opt/scripts/scan-distroless.sh\n\n# Set up a working directory\nWORKDIR /opt/scanner\n\nENTRYPOINT [\"sleep\", \"infinity\"]\n</code></pre>"},{"location":"integration/platforms/gitlab-services/#using-scanner-services-in-gitlab-ci","title":"Using Scanner Services in GitLab CI","text":"<p>See the <code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code> file in the repository for a complete implementation. Here's how to define services in your <code>.gitlab-ci.yml</code> file:</p> <pre><code># Define a global service for all jobs\nservices:\n  - name: registry.example.com/cinc-auditor-scanner:latest\n    alias: cinc-scanner\n    entrypoint: [\"sleep\", \"infinity\"]\n\n# Or define a service for a specific job\nrun_distroless_scan:\n  services:\n    - name: registry.example.com/distroless-scanner:latest\n      alias: distroless-scanner\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    # Job commands that interact with the service\n</code></pre>"},{"location":"integration/platforms/gitlab-services/#communication-between-jobs-and-services","title":"Communication Between Jobs and Services","text":"<p>To interact with service containers:</p> <ol> <li>Docker Commands: Use <code>docker cp</code> and <code>docker exec</code> to copy files and run commands in service containers.</li> <li>File Exchange: Use temporary files to exchange data between the job and service containers.</li> <li>Container Networking: Service containers are accessible via their alias hostnames.</li> </ol>"},{"location":"integration/platforms/gitlab-services/#considerations","title":"Considerations","text":""},{"location":"integration/platforms/gitlab-services/#advantages","title":"Advantages","text":"<ul> <li>Clean separation of concerns</li> <li>Pre-built, consistent scanning environment</li> <li>Reduced pipeline setup time</li> <li>Support for both standard and distroless scanning approaches</li> </ul>"},{"location":"integration/platforms/gitlab-services/#potential-challenges","title":"Potential Challenges","text":"<ul> <li>Complexity: Adds another layer to the CI/CD configuration</li> <li>Docker-in-Docker: Requires Docker socket access or Docker-in-Docker service</li> <li>Performance: Additional overhead from running multiple containers</li> <li>Maintenance: Scanner service images need to be maintained and updated</li> </ul>"},{"location":"integration/platforms/gitlab-services/#complete-example","title":"Complete Example","text":"<p>See the <code>gitlab-pipeline-examples/gitlab-ci-with-services.yml</code> file in the repository for a complete example of integrating scanner services into your GitLab CI/CD pipeline.</p>"},{"location":"integration/platforms/gitlab-services/#workflow-diagram","title":"Workflow Diagram","text":"<p>For a visual representation of how GitLab CI services integrate with the scanning workflow, see the Workflow Diagrams document.</p>"},{"location":"integration/platforms/gitlab-services/#related-integration-resources","title":"Related Integration Resources","text":"<ul> <li>Standard Container Workflow Integration</li> <li>Distroless Container Workflow Integration</li> <li>Sidecar Container Workflow Integration</li> <li>GitLab CI Integration</li> <li>GitLab Services Analysis</li> <li>Integration Configuration</li> </ul>"},{"location":"integration/platforms/inventory/","title":"CI/CD Platform Integration Files","text":"<p>This page provides an inventory of all files in the platform integration section.</p>"},{"location":"integration/platforms/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of CI/CD platform integrations github-actions.md GitHub Actions integration guide gitlab-ci.md GitLab CI integration guide gitlab-services.md GitLab Services integration guide Jenkins Jenkins integration guide (coming soon) Azure DevOps Azure DevOps integration guide (coming soon) Custom Platforms Custom CI/CD platform integration guide (coming soon)"},{"location":"integration/platforms/inventory/#related-directories","title":"Related Directories","text":"<ul> <li>Integration Workflows</li> <li>Integration Examples</li> <li>Integration Configuration</li> <li>GitHub Workflow Examples</li> <li>GitLab Pipeline Examples</li> </ul>"},{"location":"integration/workflows/","title":"Integration Workflows","text":"<p>This section provides detailed documentation on integrating various scanning workflows with CI/CD platforms.</p>"},{"location":"integration/workflows/#overview","title":"Overview","text":"<p>The Kube CINC Secure Scanner supports multiple scanning approaches, each with its own integration workflow. This section describes how to integrate each scanning approach with CI/CD platforms.</p>"},{"location":"integration/workflows/#supported-workflows","title":"Supported Workflows","text":"<p>We provide detailed integration workflows for the following scanning approaches:</p> <ul> <li>Standard Container Workflow - Integrating the standard container scanning approach</li> <li>Distroless Container Workflow - Integrating the distroless container scanning approach</li> <li>Sidecar Container Workflow - Integrating the sidecar container scanning approach</li> <li>Security Workflows - Security-focused integration workflows</li> </ul>"},{"location":"integration/workflows/#workflow-selection-considerations","title":"Workflow Selection Considerations","text":"<p>When selecting a workflow for integration, consider the following factors:</p> <ol> <li>Container Types: The types of containers you need to scan (standard, distroless, etc.)</li> <li>Kubernetes Features: The features available in your Kubernetes environment</li> <li>Security Requirements: Your specific security and compliance requirements</li> <li>Performance Considerations: The performance impact of different scanning approaches</li> <li>Integration Complexity: The complexity of integrating each workflow with your CI/CD platform</li> </ol>"},{"location":"integration/workflows/#related-resources","title":"Related Resources","text":"<ul> <li>CI/CD Platforms</li> <li>Integration Examples</li> <li>Integration Configuration</li> <li>Approach Mapping</li> </ul>"},{"location":"integration/workflows/distroless-container/","title":"Distroless Container Scanning Workflow Integration","text":"<p>This page explains how to integrate the distroless container scanning workflow into CI/CD pipelines, focusing on the debug container approach.</p>"},{"location":"integration/workflows/distroless-container/#overview","title":"Overview","text":"<p>The distroless container scanning workflow uses ephemeral debug containers to provide a shell environment for scanning containers that don't include a shell, such as distroless containers. This approach is our recommended interim solution for distroless containers until direct support is available in the train-k8s-container plugin.</p>"},{"location":"integration/workflows/distroless-container/#integration-workflow","title":"Integration Workflow","text":"<p>The integration workflow for distroless container scanning involves:</p> <ol> <li>Creating a service account with appropriate RBAC permissions</li> <li>Generating a short-lived token for authentication</li> <li>Creating an ephemeral debug container with access to the target container's filesystem</li> <li>Running CINC Auditor from within the debug container using a chroot approach</li> <li>Processing results with the SAF CLI</li> <li>Cleaning up resources</li> </ol>"},{"location":"integration/workflows/distroless-container/#cicd-platform-integration","title":"CI/CD Platform Integration","text":""},{"location":"integration/workflows/distroless-container/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>To integrate the distroless container scanning workflow into GitHub Actions:</p> <ol> <li>Create a GitHub Actions workflow file in your repository:</li> <li>Location: <code>.github/workflows/distroless-scan.yml</code></li> <li>This example assumes Kubernetes v1.23+ with ephemeral containers support</li> </ol> <pre><code>name: Distroless Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      pod_name:\n        description: 'Pod name to scan'\n        required: true\n      container_name:\n        description: 'Container name to scan'\n        required: true\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes credentials\n        run: |\n          # Setup kubeconfig\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create service account with enhanced permissions for debug containers\n          kubectl create serviceaccount debug-scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role with debug container permissions\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: debug-scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/ephemeralcontainers\"]\n            verbs: [\"get\", \"update\"]\n            resourceNames: [\"${{ github.event.inputs.pod_name }}\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding debug-scanner-binding \\\n            --role=debug-scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:debug-scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token (valid for 30 minutes)\n          TOKEN=$(kubectl create token debug-scanner-sa -n ${{ github.event.inputs.namespace }} --duration=30m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Create debug container and scan\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Create the debug container\n          POD_JSON=$(kubectl get pod ${{ github.event.inputs.pod_name }} -n ${{ github.event.inputs.namespace }} -o json)\n\n          # Add the debug container\n          PATCHED_POD=$(echo \"$POD_JSON\" | jq --arg target \"${{ github.event.inputs.container_name }}\" '.spec.ephemeralContainers += [{\n            \"name\": \"debugger\",\n            \"image\": \"busybox:latest\",\n            \"command\": [\"sleep\", \"3600\"],\n            \"targetContainerName\": $target\n          }]')\n\n          # Apply the patch to add ephemeral container\n          export KUBECONFIG=kubeconfig.yaml\n          echo \"$PATCHED_POD\" | kubectl replace --raw /api/v1/namespaces/${{ github.event.inputs.namespace }}/pods/${{ github.event.inputs.pod_name }}/ephemeralcontainers -f -\n\n          # Wait for debug container to start\n          sleep 10\n\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Create an InSpec wrapper script to run in the debug container\n          cat &gt; scan-distroless.sh &lt;&lt; 'EOF'\n          #!/bin/sh\n          # Extract the target container's process root directory\n          TARGET_PROC_ROOT=\"/proc/1/root\"\n          PROFILE_PATH=\"$1\"\n\n          # Create temporary directory for results\n          mkdir -p /tmp/results\n\n          # Run InSpec with chroot\n          cinc-auditor exec \"$PROFILE_PATH\" --target chroot://$TARGET_PROC_ROOT --reporter json:/tmp/results/results.json\n\n          # Output the results\n          cat /tmp/results/results.json\n          EOF\n\n          # Copy and execute the script in the debug container\n          kubectl cp -n ${{ github.event.inputs.namespace }} scan-distroless.sh ${{ github.event.inputs.pod_name }}:scan-distroless.sh -c debugger\n          kubectl exec -n ${{ github.event.inputs.namespace }} ${{ github.event.inputs.pod_name }} -c debugger -- chmod +x /scan-distroless.sh\n\n          # Run CINC Auditor through the debug container\n          kubectl exec -n ${{ github.event.inputs.namespace }} ${{ github.event.inputs.pod_name }} -c debugger -- /scan-distroless.sh ${{ github.event.inputs.profile }} &gt; scan-results.json\n\n      - name: Process results with SAF CLI\n        run: |\n          npm install -g @mitre/saf\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Generate the report for GitHub\n          echo \"## Distroless Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: distroless-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding debug-scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role debug-scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount debug-scanner-sa -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/workflows/distroless-container/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>To integrate the distroless container scanning workflow into GitLab CI:</p> <ol> <li>Create a <code>.gitlab-ci.yml</code> file in your repository:</li> </ol> <pre><code>stages:\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  NAMESPACE: \"default\"\n  POD_NAME: \"distroless-pod\"\n  CONTAINER_NAME: \"distroless-container\"\n  PROFILE: \"dev-sec/linux-baseline\"\n\nscan_distroless_container:\n  stage: scan\n  image: \n    name: ruby:3.0-slim\n    entrypoint: [\"\"]\n  script:\n    # Setup environment\n    - apt-get update &amp;&amp; apt-get install -y curl gnupg kubectl nodejs npm jq\n\n    # Setup kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Setup service account and RBAC\n    - kubectl create serviceaccount debug-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: debug-scanner-role-$CI_PIPELINE_ID\n        namespace: $NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/ephemeralcontainers\"]\n        verbs: [\"get\", \"update\"]\n        resourceNames: [\"$POD_NAME\"]\n      EOF\n    - kubectl create rolebinding debug-scanner-binding-$CI_PIPELINE_ID --role=debug-scanner-role-$CI_PIPELINE_ID --serviceaccount=$NAMESPACE:debug-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n\n    # Generate token\n    - TOKEN=$(kubectl create token debug-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --duration=30m)\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n    # Create the debug container\n    - POD_JSON=$(kubectl get pod $POD_NAME -n $NAMESPACE -o json)\n    - |\n      PATCHED_POD=$(echo \"$POD_JSON\" | jq --arg target \"$CONTAINER_NAME\" '.spec.ephemeralContainers += [{\n        \"name\": \"debugger\",\n        \"image\": \"busybox:latest\",\n        \"command\": [\"sleep\", \"3600\"],\n        \"targetContainerName\": $target\n      }]')\n\n    # Apply the patch to add ephemeral container\n    - echo \"$PATCHED_POD\" | kubectl replace --raw /api/v1/namespaces/$NAMESPACE/pods/$POD_NAME/ephemeralcontainers -f -\n\n    # Wait for debug container to start\n    - sleep 10\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n\n    # Create an InSpec wrapper script to run in the debug container\n    - |\n      cat &gt; scan-distroless.sh &lt;&lt; 'EOF'\n      #!/bin/sh\n      # Extract the target container's process root directory\n      TARGET_PROC_ROOT=\"/proc/1/root\"\n      PROFILE_PATH=\"$1\"\n\n      # Create temporary directory for results\n      mkdir -p /tmp/results\n\n      # Run InSpec with chroot\n      cinc-auditor exec \"$PROFILE_PATH\" --target chroot://$TARGET_PROC_ROOT --reporter json:/tmp/results/results.json\n\n      # Output the results\n      cat /tmp/results/results.json\n      EOF\n\n    # Copy and execute the script in the debug container\n    - kubectl cp -n $NAMESPACE scan-distroless.sh $POD_NAME:scan-distroless.sh -c debugger\n    - kubectl exec -n $NAMESPACE $POD_NAME -c debugger -- chmod +x /scan-distroless.sh\n\n    # Run CINC Auditor through the debug container\n    - kubectl exec -n $NAMESPACE $POD_NAME -c debugger -- /scan-distroless.sh $PROFILE &gt; scan-results.json\n\n    # Process results with SAF CLI\n    - npm install -g @mitre/saf\n    - saf summary --input scan-results.json --output-md scan-summary.md\n    - cat scan-summary.md\n\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scanner-kubeconfig.yaml\n\ngenerate_report:\n  stage: report\n  image: node:16\n  script:\n    - npm install -g @mitre/saf\n    - saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-report.html\n\ncleanup:\n  stage: cleanup\n  image: bitnami/kubectl\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete rolebinding debug-scanner-binding-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete role debug-scanner-role-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete serviceaccount debug-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n</code></pre>"},{"location":"integration/workflows/distroless-container/#configuration","title":"Configuration","text":"<p>When configuring the distroless container scanning workflow, you should set the following parameters:</p> <ol> <li>Namespace: The Kubernetes namespace where the target pod is running</li> <li>Pod Name: The name of the pod containing the container to scan</li> <li>Container Name: The name of the container within the pod to scan</li> <li>Profile Path: The CINC Auditor profile to use for scanning</li> <li>Debug Container Image: The image to use for the debug container (default: busybox:latest)</li> <li>Token Duration: Duration for the short-lived authentication token (default: 30 minutes)</li> <li>SAF CLI Settings: Configuration for threshold validation and reporting</li> </ol> <p>These settings can be configured through environment variables as detailed in the Environment Variables documentation.</p>"},{"location":"integration/workflows/distroless-container/#best-practices","title":"Best Practices","text":"<p>When integrating the distroless container scanning workflow, follow these best practices:</p> <ol> <li>Kubernetes Version Check: Ensure your Kubernetes cluster supports ephemeral containers</li> <li>Enhanced RBAC Permissions: The debug container approach requires additional permissions compared to standard scanning</li> <li>Token Duration: Use slightly longer token durations (30 minutes) as debugging might take more time</li> <li>Resource Cleanup: Always clean up temporary resources, even on job failure</li> <li>Error Handling: Implement robust error handling for the debug container creation</li> <li>Security Communication: Clearly communicate the enhanced permissions required for this approach</li> </ol>"},{"location":"integration/workflows/distroless-container/#security-considerations","title":"Security Considerations","text":"<ul> <li>Store Kubernetes credentials as secrets/variables in your CI/CD platform</li> <li>Debug containers require additional permissions compared to standard scanning</li> <li>The ephemeral containers feature may not be available in all Kubernetes environments</li> <li>This approach requires <code>pods/ephemeralcontainers</code> permissions, which are more extensive than the standard approach</li> </ul>"},{"location":"integration/workflows/distroless-container/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/workflows/distroless-container/#common-issues","title":"Common Issues","text":"<ol> <li>Ephemeral Container Creation Fails:</li> <li>Verify Kubernetes version supports ephemeral containers (v1.23+)</li> <li>Check RBAC includes permissions for <code>pods/ephemeralcontainers</code></li> <li> <p>Ensure feature gate is enabled if using older Kubernetes versions</p> </li> <li> <p>Script Execution Failures:</p> </li> <li>Check the debug container is running properly</li> <li>Verify the target container path is accessible</li> <li> <p>Confirm the shell script has executable permissions</p> </li> <li> <p>Scan Failures:</p> </li> <li>Check chroot access to the target container filesystem</li> <li>Verify profile compatibility with distroless environment</li> <li>Check the target process root directory exists</li> </ol>"},{"location":"integration/workflows/distroless-container/#related-resources","title":"Related Resources","text":"<ul> <li>Debug Container Approach</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>GitLab Services Integration</li> <li>Approach Mapping</li> </ul>"},{"location":"integration/workflows/inventory/","title":"Integration Workflow Files","text":"<p>This page provides an inventory of all files in the integration workflows section.</p>"},{"location":"integration/workflows/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of integration workflows standard-container.md Standard container workflow integration distroless-container.md Distroless container workflow integration sidecar-container.md Sidecar container workflow integration security-workflows.md Security-focused integration workflows"},{"location":"integration/workflows/inventory/#related-directories","title":"Related Directories","text":"<ul> <li>CI/CD Platforms</li> <li>Integration Examples</li> <li>Integration Configuration</li> <li>Scanning Approaches</li> </ul>"},{"location":"integration/workflows/security-workflows/","title":"Security-Focused Integration Workflows","text":"<p>This page outlines security-focused workflows for integrating container scanning into CI/CD pipelines, with an emphasis on security best practices and enhanced RBAC models.</p>"},{"location":"integration/workflows/security-workflows/#overview","title":"Overview","text":"<p>Security is a primary concern when integrating container scanning into CI/CD pipelines. This document focuses on integrating enhanced security practices into scanning workflows, including:</p> <ol> <li>RBAC best practices</li> <li>Secure token handling</li> <li>Token revocation</li> <li>Least privilege implementation</li> <li>Credentials protection</li> <li>Audit logging</li> </ol>"},{"location":"integration/workflows/security-workflows/#enhanced-rbac-integration","title":"Enhanced RBAC Integration","text":""},{"location":"integration/workflows/security-workflows/#label-based-rbac-workflow","title":"Label-Based RBAC Workflow","text":"<p>The label-based RBAC workflow enhances security by allowing scanning only of containers with specific labels:</p> <pre><code># Enhanced security using label selectors\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  resourceNames: []\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  labelSelector: \n    matchExpressions:\n    - key: scan-enabled\n      operator: In\n      values: [\"true\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  labelSelector: \n    matchExpressions:\n    - key: scan-enabled\n      operator: In\n      values: [\"true\"]\n</code></pre>"},{"location":"integration/workflows/security-workflows/#implementing-label-based-rbac-in-github-actions","title":"Implementing Label-Based RBAC in GitHub Actions","text":"<pre><code>name: Secure Label-Based Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'production'\n      label_selector:\n        description: 'Label selector (format: key=value)'\n        required: true\n        default: 'scan-enabled=true'\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup secure RBAC with label selector\n        run: |\n          # Setup kubeconfig\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Extract key and value from label selector\n          LABEL_KEY=$(echo \"${{ github.event.inputs.label_selector }}\" | cut -d= -f1)\n          LABEL_VALUE=$(echo \"${{ github.event.inputs.label_selector }}\" | cut -d= -f2)\n\n          # Create service account\n          kubectl create serviceaccount secure-scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role with label selector\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: secure-scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: []\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding secure-scanner-binding \\\n            --role=secure-scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:secure-scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token with short duration (15 minutes)\n          TOKEN=$(kubectl create token secure-scanner-sa -n ${{ github.event.inputs.namespace }} --duration=15m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Run secure scan\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n          # Create scanner kubeconfig\n          cat &gt; secure-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Get pods with the specified label\n          LABEL_SELECTOR=\"${{ github.event.inputs.label_selector }}\"\n          PODS=$(kubectl get pods -n ${{ github.event.inputs.namespace }} -l $LABEL_SELECTOR -o name | cut -d/ -f2)\n\n          # Check if any pods match the label\n          if [ -z \"$PODS\" ]; then\n            echo \"No pods found with label $LABEL_SELECTOR\"\n            exit 1\n          fi\n\n          # Scan each matching pod\n          for POD in $PODS; do\n            echo \"Scanning pod: $POD\"\n\n            # Get the first container in the pod\n            CONTAINER=$(kubectl get pod $POD -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.containers[0].name}')\n\n            # Run scan\n            KUBECONFIG=secure-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.profile }} \\\n              -t k8s-container://${{ github.event.inputs.namespace }}/$POD/$CONTAINER \\\n              --reporter json:$POD-results.json\n\n            # Process results\n            npm install -g @mitre/saf\n            saf summary --input $POD-results.json --output-md $POD-summary.md\n\n            echo \"## Scan Results for $POD\" &gt;&gt; $GITHUB_STEP_SUMMARY\n            cat $POD-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n            echo \"---\" &gt;&gt; $GITHUB_STEP_SUMMARY\n          done\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: secure-scan-results\n          path: |\n            *-results.json\n            *-summary.md\n\n      - name: Cleanup and revoke token\n        if: always()\n        run: |\n          # Delete RBAC resources to immediately revoke access\n          kubectl delete rolebinding secure-scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role secure-scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount secure-scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Secure deletion of kubeconfig\n          shred -u secure-kubeconfig.yaml\n</code></pre>"},{"location":"integration/workflows/security-workflows/#implementing-label-based-rbac-in-gitlab-ci","title":"Implementing Label-Based RBAC in GitLab CI","text":"<pre><code>stages:\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  NAMESPACE: \"production\"\n  LABEL_SELECTOR: \"scan-enabled=true\"\n  PROFILE: \"dev-sec/linux-baseline\"\n  TOKEN_DURATION: \"15m\"\n\nsetup_and_scan:\n  stage: scan\n  image: \n    name: ruby:3.0-slim\n    entrypoint: [\"\"]\n  script:\n    # Setup environment\n    - apt-get update &amp;&amp; apt-get install -y curl gnupg kubectl nodejs npm\n\n    # Setup kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Extract key and value from label selector\n    - LABEL_KEY=$(echo \"$LABEL_SELECTOR\" | cut -d= -f1)\n    - LABEL_VALUE=$(echo \"$LABEL_SELECTOR\" | cut -d= -f2)\n\n    # Setup secure service account and RBAC\n    - kubectl create serviceaccount secure-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: secure-scanner-role-$CI_PIPELINE_ID\n        namespace: $NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n      EOF\n    - kubectl create rolebinding secure-scanner-binding-$CI_PIPELINE_ID --role=secure-scanner-role-$CI_PIPELINE_ID --serviceaccount=$NAMESPACE:secure-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n\n    # Generate secure token\n    - TOKEN=$(kubectl create token secure-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --duration=$TOKEN_DURATION)\n\n    # Create secure scanner kubeconfig\n    - |\n      cat &gt; secure-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n    # Get pods with the specified label\n    - PODS=$(kubectl get pods -n $NAMESPACE -l $LABEL_SELECTOR -o name | cut -d/ -f2)\n\n    # Check if any pods match the label\n    - |\n      if [ -z \"$PODS\" ]; then\n        echo \"No pods found with label $LABEL_SELECTOR\"\n        exit 1\n      fi\n\n    # Install CINC Auditor\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n    - npm install -g @mitre/saf\n\n    # Scan each matching pod\n    - |\n      for POD in $PODS; do\n        echo \"Scanning pod: $POD\"\n\n        # Get the first container in the pod\n        CONTAINER=$(kubectl get pod $POD -n $NAMESPACE -o jsonpath='{.spec.containers[0].name}')\n\n        # Run scan\n        KUBECONFIG=secure-kubeconfig.yaml cinc-auditor exec $PROFILE \\\n          -t k8s-container://$NAMESPACE/$POD/$CONTAINER \\\n          --reporter json:$POD-results.json\n\n        # Process results\n        saf summary --input $POD-results.json --output-md $POD-summary.md\n        echo \"Results for $POD:\"\n        cat $POD-summary.md\n        echo \"---\"\n      done\n\n    # Audit logging\n    - |\n      echo \"Security Scan Audit Log\" &gt; audit-log.txt\n      echo \"Timestamp: $(date -u)\" &gt;&gt; audit-log.txt\n      echo \"Pipeline: $CI_PIPELINE_ID\" &gt;&gt; audit-log.txt\n      echo \"Namespace: $NAMESPACE\" &gt;&gt; audit-log.txt\n      echo \"Label Selector: $LABEL_SELECTOR\" &gt;&gt; audit-log.txt\n      echo \"Token Duration: $TOKEN_DURATION\" &gt;&gt; audit-log.txt\n      echo \"Pods Scanned: $PODS\" &gt;&gt; audit-log.txt\n\n    # Secure token handling\n    - shred -u secure-kubeconfig.yaml\n\n  artifacts:\n    paths:\n      - \"*-results.json\"\n      - \"*-summary.md\"\n      - \"audit-log.txt\"\n\ncleanup:\n  stage: cleanup\n  image: bitnami/kubectl\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete rolebinding secure-scanner-binding-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete role secure-scanner-role-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete serviceaccount secure-scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - shred -u kubeconfig.yaml\n</code></pre>"},{"location":"integration/workflows/security-workflows/#security-enhancements-for-cicd-integration","title":"Security Enhancements for CI/CD Integration","text":""},{"location":"integration/workflows/security-workflows/#short-lived-tokens","title":"Short-lived Tokens","text":"<p>Always use short-lived tokens with explicit durations:</p> <pre><code># Generate token with 15-minute duration\nTOKEN=$(kubectl create token scanner-sa -n $NAMESPACE --duration=15m)\n</code></pre>"},{"location":"integration/workflows/security-workflows/#immediate-token-revocation","title":"Immediate Token Revocation","text":"<p>Implement immediate token revocation after scanning:</p> <pre><code># Delete RBAC resources to immediately revoke access\nkubectl delete rolebinding scanner-binding -n $NAMESPACE\nkubectl delete role scanner-role -n $NAMESPACE\nkubectl delete serviceaccount scanner-sa -n $NAMESPACE\n</code></pre>"},{"location":"integration/workflows/security-workflows/#secure-credential-handling","title":"Secure Credential Handling","text":"<p>Implement secure handling of credentials:</p> <pre><code># Secure deletion of sensitive files\nshred -u kubeconfig.yaml\n\n# Avoid storing tokens in variables when possible\nKUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec $PROFILE -t k8s-container://...\n</code></pre>"},{"location":"integration/workflows/security-workflows/#audit-logging","title":"Audit Logging","text":"<p>Add comprehensive audit logging to your scanning workflows:</p> <pre><code># Create audit log\necho \"Security Scan Audit Log\" &gt; audit-log.txt\necho \"Timestamp: $(date -u)\" &gt;&gt; audit-log.txt\necho \"CI Job: $CI_JOB_ID\" &gt;&gt; audit-log.txt\necho \"Namespace: $NAMESPACE\" &gt;&gt; audit-log.txt\necho \"Pod: $POD\" &gt;&gt; audit-log.txt\necho \"Container: $CONTAINER\" &gt;&gt; audit-log.txt\necho \"Profile: $PROFILE\" &gt;&gt; audit-log.txt\necho \"Token Duration: 15m\" &gt;&gt; audit-log.txt\n</code></pre>"},{"location":"integration/workflows/security-workflows/#cicd-security-best-practices","title":"CI/CD Security Best Practices","text":"<p>When implementing container scanning in CI/CD pipelines, follow these security best practices:</p> <ol> <li>Least Privilege Principle: Provide only the minimum required permissions</li> <li>Short-lived Credentials: Use tokens with the shortest practical lifetime</li> <li>Secure Storage: Store sensitive data in secure CI/CD variables/secrets</li> <li>Immediate Cleanup: Clean up resources immediately after scanning</li> <li>Audit Logging: Implement comprehensive audit logging for all scan operations</li> <li>Token Revocation: Actively revoke tokens after use instead of waiting for expiration</li> <li>Secure Outputs: Handle scan results securely, especially for security findings</li> <li>Secure Credential Handling: Avoid exposing credentials in logs or command lines</li> <li>CI/CD Pipeline Security: Ensure the CI/CD pipeline itself is secure</li> <li>Separate Service Accounts: Use dedicated service accounts for scanning operations</li> </ol>"},{"location":"integration/workflows/security-workflows/#related-resources","title":"Related Resources","text":"<ul> <li>RBAC Configuration</li> <li>Label-Based RBAC</li> <li>Service Accounts</li> <li>Tokens</li> <li>Security Analysis</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> </ul>"},{"location":"integration/workflows/sidecar-container/","title":"Sidecar Container Scanning Workflow Integration","text":"<p>This page explains how to integrate the sidecar container scanning workflow into CI/CD pipelines, providing a universal solution for both standard and distroless containers.</p>"},{"location":"integration/workflows/sidecar-container/#overview","title":"Overview","text":"<p>The sidecar container scanning workflow uses a shared process namespace to allow a sidecar container with CINC Auditor to scan the main container's filesystem. This approach works for both standard and distroless containers and requires minimal RBAC permissions compared to the debug container approach.</p>"},{"location":"integration/workflows/sidecar-container/#integration-workflow","title":"Integration Workflow","text":"<p>The integration workflow for sidecar container scanning involves:</p> <ol> <li>Creating a pod with shared process namespace and a sidecar container</li> <li>Running CINC Auditor from the sidecar container to scan the main container's filesystem</li> <li>Extracting and processing scan results</li> <li>Cleaning up resources after scanning</li> </ol>"},{"location":"integration/workflows/sidecar-container/#cicd-platform-integration","title":"CI/CD Platform Integration","text":""},{"location":"integration/workflows/sidecar-container/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>To integrate the sidecar container scanning workflow into GitHub Actions:</p> <ol> <li>Create a GitHub Actions workflow file in your repository:</li> <li>Location: <code>.github/workflows/sidecar-scan.yml</code></li> <li>See the sample code below or reference <code>github-workflow-examples/sidecar-scanner.yml</code></li> </ol> <pre><code>name: Sidecar Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      application_image:\n        description: 'Application container image to scan'\n        required: true\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes credentials\n        run: |\n          # Setup kubeconfig\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n      - name: Create sidecar scanner pod\n        run: |\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: v1\n          kind: Pod\n          metadata:\n            name: sidecar-scanner-${{ github.run_id }}\n            namespace: ${{ github.event.inputs.namespace }}\n          spec:\n            shareProcessNamespace: true\n            containers:\n            - name: app\n              image: ${{ github.event.inputs.application_image }}\n              command: [\"sleep\", \"3600\"]\n            - name: scanner\n              image: registry.example.com/cinc-auditor-scanner:latest\n              command: [\"sleep\", \"3600\"]\n              securityContext:\n                privileged: false\n            restartPolicy: Never\n          EOF\n\n          # Wait for pod to be ready\n          kubectl wait --for=condition=ready pod/sidecar-scanner-${{ github.run_id }} -n ${{ github.event.inputs.namespace }} --timeout=120s\n\n      - name: Create scanning script\n        run: |\n          cat &gt; scan-sidecar.sh &lt;&lt; 'EOF'\n          #!/bin/bash\n\n          # Extract target container's PID\n          TARGET_PID=$(pgrep -xo sleep)\n          if [ -z \"$TARGET_PID\" ]; then\n            echo \"Error: Could not find target container PID\"\n            exit 1\n          fi\n\n          # Use target container's process namespace\n          TARGET_ROOT=\"/proc/${TARGET_PID}/root\"\n\n          # Run CINC Auditor scan using chroot\n          PROFILE=\"$1\"\n          cinc-auditor exec \"$PROFILE\" --target chroot://$TARGET_ROOT --reporter json:/tmp/scan-results.json\n\n          # Output results\n          cat /tmp/scan-results.json\n          EOF\n\n          # Copy script to scanner container\n          kubectl cp -n ${{ github.event.inputs.namespace }} scan-sidecar.sh sidecar-scanner-${{ github.run_id }}:scan-sidecar.sh -c scanner\n          kubectl exec -n ${{ github.event.inputs.namespace }} sidecar-scanner-${{ github.run_id }} -c scanner -- chmod +x /scan-sidecar.sh\n\n      - name: Run scan\n        run: |\n          # Execute scan in sidecar container\n          kubectl exec -n ${{ github.event.inputs.namespace }} sidecar-scanner-${{ github.run_id }} -c scanner -- /scan-sidecar.sh \"${{ github.event.inputs.profile }}\" &gt; scan-results.json\n\n      - name: Process results with SAF CLI\n        run: |\n          npm install -g @mitre/saf\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Generate report for GitHub\n          echo \"## Sidecar Container Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: sidecar-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete pod sidecar-scanner-${{ github.run_id }} -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/workflows/sidecar-container/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>To integrate the sidecar container scanning workflow into GitLab CI:</p> <ol> <li>Create a <code>.gitlab-ci.yml</code> file in your repository:</li> <li>See the sample code below or reference <code>gitlab-pipeline-examples/gitlab-ci-sidecar.yml</code></li> </ol> <pre><code>stages:\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  NAMESPACE: \"default\"\n  APPLICATION_IMAGE: \"alpine:latest\"\n  PROFILE: \"dev-sec/linux-baseline\"\n\nscan_with_sidecar:\n  stage: scan\n  image: bitnami/kubectl\n  script:\n    # Setup kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create sidecar scanner pod\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: sidecar-scanner-${CI_PIPELINE_ID}\n        namespace: ${NAMESPACE}\n      spec:\n        shareProcessNamespace: true\n        containers:\n        - name: app\n          image: ${APPLICATION_IMAGE}\n          command: [\"sleep\", \"3600\"]\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: [\"sleep\", \"3600\"]\n          securityContext:\n            privileged: false\n        restartPolicy: Never\n      EOF\n\n    # Wait for pod to be ready\n    - kubectl wait --for=condition=ready pod/sidecar-scanner-${CI_PIPELINE_ID} -n ${NAMESPACE} --timeout=120s\n\n    # Create scanning script\n    - |\n      cat &gt; scan-sidecar.sh &lt;&lt; 'EOF'\n      #!/bin/bash\n\n      # Extract target container's PID\n      TARGET_PID=$(pgrep -xo sleep)\n      if [ -z \"$TARGET_PID\" ]; then\n        echo \"Error: Could not find target container PID\"\n        exit 1\n      fi\n\n      # Use target container's process namespace\n      TARGET_ROOT=\"/proc/${TARGET_PID}/root\"\n\n      # Run CINC Auditor scan using chroot\n      PROFILE=\"$1\"\n      cinc-auditor exec \"$PROFILE\" --target chroot://$TARGET_ROOT --reporter json:/tmp/scan-results.json\n\n      # Output results\n      cat /tmp/scan-results.json\n      EOF\n\n    # Copy script to scanner container\n    - kubectl cp -n ${NAMESPACE} scan-sidecar.sh sidecar-scanner-${CI_PIPELINE_ID}:scan-sidecar.sh -c scanner\n    - kubectl exec -n ${NAMESPACE} sidecar-scanner-${CI_PIPELINE_ID} -c scanner -- chmod +x /scan-sidecar.sh\n\n    # Run scan\n    - kubectl exec -n ${NAMESPACE} sidecar-scanner-${CI_PIPELINE_ID} -c scanner -- /scan-sidecar.sh \"${PROFILE}\" &gt; scan-results.json\n\n    # Install and run SAF CLI\n    - apt-get update &amp;&amp; apt-get install -y nodejs npm\n    - npm install -g @mitre/saf\n    - saf summary --input scan-results.json --output-md scan-summary.md\n    - cat scan-summary.md\n\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n\ngenerate_report:\n  stage: report\n  image: node:16\n  script:\n    - npm install -g @mitre/saf\n    - saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-report.html\n\ncleanup:\n  stage: cleanup\n  image: bitnami/kubectl\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete pod sidecar-scanner-${CI_PIPELINE_ID} -n ${NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"integration/workflows/sidecar-container/#gitlab-ci-with-services","title":"GitLab CI with Services","text":"<p>GitLab CI offers an enhanced approach using services for the sidecar scanner:</p> <pre><code>stages:\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  NAMESPACE: \"default\"\n  APPLICATION_IMAGE: \"alpine:latest\"\n  PROFILE: \"dev-sec/linux-baseline\"\n\nscan_with_sidecar_service:\n  stage: scan\n  image: bitnami/kubectl\n  services:\n    - name: registry.example.com/cinc-auditor-scanner:latest\n      alias: scanner-service\n      entrypoint: [\"sleep\", \"infinity\"]\n  script:\n    # Setup kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Create sidecar scanner pod with service\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: sidecar-scanner-${CI_PIPELINE_ID}\n        namespace: ${NAMESPACE}\n      spec:\n        shareProcessNamespace: true\n        containers:\n        - name: app\n          image: ${APPLICATION_IMAGE}\n          command: [\"sleep\", \"3600\"]\n        - name: scanner\n          image: registry.example.com/cinc-auditor-scanner:latest\n          command: [\"sleep\", \"3600\"]\n          securityContext:\n            privileged: false\n        restartPolicy: Never\n      EOF\n\n    # Wait for pod to be ready\n    - kubectl wait --for=condition=ready pod/sidecar-scanner-${CI_PIPELINE_ID} -n ${NAMESPACE} --timeout=120s\n\n    # Use the scanner service for running the scan\n    - docker exec -i scanner-service bash -c \"cinc-auditor exec ${PROFILE} --target k8s://${NAMESPACE}/sidecar-scanner-${CI_PIPELINE_ID}/app --reporter json:/tmp/scan-results.json\"\n    - docker cp scanner-service:/tmp/scan-results.json ./scan-results.json\n\n    # Process results\n    - apt-get update &amp;&amp; apt-get install -y nodejs npm\n    - npm install -g @mitre/saf\n    - saf summary --input scan-results.json --output-md scan-summary.md\n    - cat scan-summary.md\n\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n\n# Additional stages for report generation and cleanup\n</code></pre>"},{"location":"integration/workflows/sidecar-container/#configuration","title":"Configuration","text":"<p>When configuring the sidecar container scanning workflow, you should set the following parameters:</p> <ol> <li>Namespace: The Kubernetes namespace where the scanner pod will be created</li> <li>Application Image: The container image to scan</li> <li>Scanner Image: The CINC Auditor scanner image to use as sidecar</li> <li>Profile Path: The CINC Auditor profile to use for scanning</li> <li>Process Identifier: Method to identify the target process (default: first sleep process)</li> <li>SAF CLI Settings: Configuration for threshold validation and reporting</li> </ol> <p>These settings can be configured through environment variables as detailed in the Environment Variables documentation.</p>"},{"location":"integration/workflows/sidecar-container/#best-practices","title":"Best Practices","text":"<p>When integrating the sidecar container scanning workflow, follow these best practices:</p> <ol> <li>Container Setup: Always use the <code>shareProcessNamespace: true</code> setting in the pod spec</li> <li>Image Selection: Use pre-built CINC Auditor scanner images for the sidecar container</li> <li>Process Identification: Implement robust process identification for finding the target container</li> <li>Error Handling: Include proper error handling for cases where the process can't be found</li> <li>Result Extraction: Ensure scan results are properly extracted from the sidecar container</li> <li>Resource Cleanup: Always clean up scanner pods after completion</li> </ol>"},{"location":"integration/workflows/sidecar-container/#security-considerations","title":"Security Considerations","text":"<ul> <li>The sidecar approach requires minimal RBAC permissions compared to other approaches</li> <li>No need for ephemeral container or enhanced pod/exec permissions</li> <li>The pod spec requires shared process namespace, which is a security consideration</li> <li>The sidecar container does not need privileged access</li> <li>This approach requires modifying the pod specification, which may not be suitable for all workflows</li> </ul>"},{"location":"integration/workflows/sidecar-container/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/workflows/sidecar-container/#common-issues","title":"Common Issues","text":"<ol> <li>Process Identification Failures:</li> <li>Verify the target container is running the expected process</li> <li>Check that the process search command is correct for your container</li> <li> <p>Consider using alternative process identification methods (e.g., by container name)</p> </li> <li> <p>Shared Namespace Issues:</p> </li> <li>Verify Kubernetes version supports shared process namespaces</li> <li>Check that the pod spec includes <code>shareProcessNamespace: true</code></li> <li> <p>Ensure the cluster configuration allows shared process namespaces</p> </li> <li> <p>Scan Failures:</p> </li> <li>Check the target container's filesystem is accessible from the sidecar</li> <li>Verify the chroot path is correct</li> <li>Ensure the CINC Auditor profile is compatible with the target environment</li> </ol>"},{"location":"integration/workflows/sidecar-container/#related-resources","title":"Related Resources","text":"<ul> <li>Sidecar Container Approach</li> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>GitLab Services Integration</li> <li>Approach Mapping</li> </ul>"},{"location":"integration/workflows/standard-container/","title":"Standard Container Scanning Workflow Integration","text":"<p>This page explains how to integrate the standard container scanning workflow into CI/CD pipelines, focusing on the Kubernetes API approach.</p>"},{"location":"integration/workflows/standard-container/#overview","title":"Overview","text":"<p>The standard container scanning workflow uses the train-k8s-container plugin to scan containers via the Kubernetes API. This is our recommended approach for standard containers in production environments.</p>"},{"location":"integration/workflows/standard-container/#integration-workflow","title":"Integration Workflow","text":"<p>The integration workflow for standard container scanning involves:</p> <ol> <li>Creating a service account with appropriate RBAC permissions</li> <li>Generating a short-lived token for authentication</li> <li>Running CINC Auditor with the train-k8s-container plugin</li> <li>Processing results with the SAF CLI</li> <li>Cleaning up resources</li> </ol>"},{"location":"integration/workflows/standard-container/#cicd-platform-integration","title":"CI/CD Platform Integration","text":""},{"location":"integration/workflows/standard-container/#github-actions-integration","title":"GitHub Actions Integration","text":"<p>To integrate the standard container scanning workflow into GitHub Actions:</p> <ol> <li>Create a GitHub Actions workflow file in your repository:</li> <li>Location: <code>.github/workflows/container-scan.yml</code></li> <li>See the sample code below or reference <code>github-workflow-examples/existing-cluster-scanning.yml</code></li> </ol> <pre><code>name: Kubernetes Container Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace'\n        required: true\n        default: 'default'\n      pod_name:\n        description: 'Pod name to scan'\n        required: true\n      container_name:\n        description: 'Container name to scan'\n        required: true\n      profile:\n        description: 'InSpec profile to use'\n        required: true\n        default: 'dev-sec/linux-baseline'\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup Kubernetes credentials\n        run: |\n          # Setup kubeconfig\n          echo \"${{ secrets.KUBE_CONFIG }}\" &gt; kubeconfig.yaml\n          export KUBECONFIG=kubeconfig.yaml\n\n          # Create service account with limited permissions\n          kubectl create serviceaccount scanner-sa -n ${{ github.event.inputs.namespace }}\n\n          # Create role with limited permissions\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role\n            namespace: ${{ github.event.inputs.namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${{ github.event.inputs.pod_name }}\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding scanner-binding \\\n            --role=scanner-role \\\n            --serviceaccount=${{ github.event.inputs.namespace }}:scanner-sa \\\n            -n ${{ github.event.inputs.namespace }}\n\n          # Generate token (valid for 15 minutes)\n          TOKEN=$(kubectl create token scanner-sa -n ${{ github.event.inputs.namespace }} --duration=15m)\n          echo \"SCANNER_TOKEN=$TOKEN\" &gt;&gt; $GITHUB_ENV\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n      - name: Run container scan\n        run: |\n          # Create scanner kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt;EOF\n          apiVersion: v1\n          kind: Config\n          clusters:\n          - cluster:\n              server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n              certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n            name: k8s-cluster\n          contexts:\n          - context:\n              cluster: k8s-cluster\n              user: scanner-user\n              namespace: ${{ github.event.inputs.namespace }}\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${{ env.SCANNER_TOKEN }}\n          EOF\n\n          # Run scan\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec ${{ github.event.inputs.profile }} \\\n            -t k8s-container://${{ github.event.inputs.namespace }}/${{ github.event.inputs.pod_name }}/${{ github.event.inputs.container_name }} \\\n            --reporter json:scan-results.json\n\n      - name: Process results with SAF CLI\n        run: |\n          npm install -g @mitre/saf\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Generate the report for GitHub\n          echo \"## Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v3\n        with:\n          name: scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup\n        if: always()\n        run: |\n          kubectl delete rolebinding scanner-binding -n ${{ github.event.inputs.namespace }}\n          kubectl delete role scanner-role -n ${{ github.event.inputs.namespace }}\n          kubectl delete serviceaccount scanner-sa -n ${{ github.event.inputs.namespace }}\n</code></pre>"},{"location":"integration/workflows/standard-container/#gitlab-ci-integration","title":"GitLab CI Integration","text":"<p>To integrate the standard container scanning workflow into GitLab CI:</p> <ol> <li>Create a <code>.gitlab-ci.yml</code> file in your repository:</li> <li>See the sample code below or reference <code>gitlab-pipeline-examples/gitlab-ci.yml</code></li> </ol> <pre><code>stages:\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  NAMESPACE: \"default\"\n  POD_NAME: \"app-pod\"\n  CONTAINER_NAME: \"app-container\"\n  PROFILE: \"dev-sec/linux-baseline\"\n\nscan_container:\n  stage: scan\n  image: \n    name: ruby:3.0-slim\n    entrypoint: [\"\"]\n  script:\n    # Setup environment\n    - apt-get update &amp;&amp; apt-get install -y curl gnupg kubectl nodejs npm\n\n    # Setup kubectl\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n\n    # Setup service account and RBAC\n    - kubectl create serviceaccount scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-$CI_PIPELINE_ID\n        namespace: $NAMESPACE\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"$POD_NAME\"]\n      EOF\n    - kubectl create rolebinding scanner-binding-$CI_PIPELINE_ID --role=scanner-role-$CI_PIPELINE_ID --serviceaccount=$NAMESPACE:scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE\n\n    # Generate token\n    - TOKEN=$(kubectl create token scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --duration=15m)\n\n    # Install CINC Auditor and plugin\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n\n    # Create scanner kubeconfig\n    - |\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      clusters:\n      - cluster:\n          server: $(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')\n          certificate-authority-data: $(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')\n        name: k8s-cluster\n      contexts:\n      - context:\n          cluster: k8s-cluster\n          user: scanner-user\n          namespace: $NAMESPACE\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: $TOKEN\n      EOF\n\n    # Run scan\n    - KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec $PROFILE -t k8s-container://$NAMESPACE/$POD_NAME/$CONTAINER_NAME --reporter json:scan-results.json\n\n    # Process results with SAF CLI\n    - npm install -g @mitre/saf\n    - saf summary --input scan-results.json --output-md scan-summary.md\n    - cat scan-summary.md\n\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n      - scanner-kubeconfig.yaml\n\ngenerate_report:\n  stage: report\n  image: node:16\n  script:\n    - npm install -g @mitre/saf\n    - saf view -i scan-results.json --output scan-report.html\n  artifacts:\n    paths:\n      - scan-report.html\n\ncleanup:\n  stage: cleanup\n  image: bitnami/kubectl\n  when: always\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - kubectl delete rolebinding scanner-binding-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete role scanner-role-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n    - kubectl delete serviceaccount scanner-sa-$CI_PIPELINE_ID -n $NAMESPACE --ignore-not-found\n</code></pre>"},{"location":"integration/workflows/standard-container/#configuration","title":"Configuration","text":"<p>When configuring the standard container scanning workflow, you should set the following parameters:</p> <ol> <li>Namespace: The Kubernetes namespace where the target pod is running</li> <li>Pod Name: The name of the pod containing the container to scan</li> <li>Container Name: The name of the container within the pod to scan</li> <li>Profile Path: The CINC Auditor profile to use for scanning</li> <li>Token Duration: Duration for the short-lived authentication token (default: 15 minutes)</li> <li>SAF CLI Settings: Configuration for threshold validation and reporting</li> </ol> <p>These settings can be configured through environment variables as detailed in the Environment Variables documentation.</p>"},{"location":"integration/workflows/standard-container/#best-practices","title":"Best Practices","text":"<p>When integrating the standard container scanning workflow, follow these best practices:</p> <ol> <li>Limited Scope: Always scope RBAC permissions to the specific pods being scanned</li> <li>Short-lived Tokens: Use tokens with short durations (15-30 minutes)</li> <li>Resource Cleanup: Always clean up temporary resources, even on job failure</li> <li>SAF CLI Integration: Use the SAF CLI to generate human-readable reports</li> <li>Failure Handling: Configure proper error handling for scan failures</li> <li>CI Variables: Use CI variables for flexible configuration</li> </ol>"},{"location":"integration/workflows/standard-container/#security-considerations","title":"Security Considerations","text":"<ul> <li>Store Kubernetes credentials as secrets/variables in your CI/CD platform</li> <li>Avoid storing tokens or kubeconfig files in the repository</li> <li>Always use the least privilege principle for RBAC configurations</li> <li>Ensure token expiration is properly set to minimize exposure</li> </ul>"},{"location":"integration/workflows/standard-container/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integration/workflows/standard-container/#common-issues","title":"Common Issues","text":"<ol> <li>Access Denied Errors:</li> <li>Verify the token is valid and not expired</li> <li>Check RBAC permissions are properly configured</li> <li> <p>Ensure the pod name matches exactly</p> </li> <li> <p>Plugin Installation Failures:</p> </li> <li>Verify network connectivity</li> <li>Check Ruby and gem versions compatibility</li> <li> <p>Consider using pre-built Docker images with the plugin installed</p> </li> <li> <p>Scan Failures:</p> </li> <li>Check the plugin version is compatible with your Kubernetes version</li> <li>Ensure the pod and container exist and are running</li> <li>Verify the profile path is correct</li> </ol>"},{"location":"integration/workflows/standard-container/#related-resources","title":"Related Resources","text":"<ul> <li>GitHub Actions Integration</li> <li>GitLab CI Integration</li> <li>GitLab Services Integration</li> <li>Approach Mapping</li> <li>Kubernetes API Approach</li> </ul>"},{"location":"kubernetes-scripts/","title":"Kubernetes Scripts","text":"<p>This directory contains links to the scanning and Kubernetes setup scripts used in the Kube CINC Secure Scanner project.</p>"},{"location":"kubernetes-scripts/#available-scripts","title":"Available Scripts","text":"<ul> <li>scan-container.sh: Scan standard containers using the Kubernetes API approach</li> <li>scan-distroless-container.sh: Scan distroless containers using the debug container approach</li> <li>scan-with-sidecar.sh: Scan containers using the sidecar container approach</li> <li>setup-minikube.sh: Set up a Minikube environment for testing</li> <li>generate-kubeconfig.sh: Generate a kubeconfig file with appropriate permissions</li> </ul>"},{"location":"kubernetes-scripts/#script-details","title":"Script Details","text":""},{"location":"kubernetes-scripts/#scan-containersh","title":"scan-container.sh","text":"<pre><code>Usage: ./scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>This script scans standard containers using the Kubernetes API approach (train-k8s-container transport). It requires a namespace, pod name, container name, and a path to an InSpec profile.</p>"},{"location":"kubernetes-scripts/#scan-distroless-containersh","title":"scan-distroless-container.sh","text":"<pre><code>Usage: ./scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>This script scans distroless containers by creating an ephemeral debug container and using a chroot approach to access the container filesystem.</p>"},{"location":"kubernetes-scripts/#scan-with-sidecarsh","title":"scan-with-sidecar.sh","text":"<pre><code>Usage: ./scan-with-sidecar.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>This script scans containers using a sidecar container approach with shared process namespace.</p>"},{"location":"kubernetes-scripts/#setup-minikubesh","title":"setup-minikube.sh","text":"<pre><code>Usage: ./setup-minikube.sh [--with-distroless]\n</code></pre> <p>This script sets up a Minikube environment for testing. The <code>--with-distroless</code> flag adds support for distroless container scanning.</p>"},{"location":"kubernetes-scripts/#generate-kubeconfigsh","title":"generate-kubeconfig.sh","text":"<pre><code>Usage: ./generate-kubeconfig.sh &lt;service-account&gt; &lt;namespace&gt; &lt;context&gt;\n</code></pre> <p>This script generates a kubeconfig file with appropriate permissions for a given service account, namespace, and context.</p>"},{"location":"kubernetes-scripts/#usage-examples","title":"Usage Examples","text":""},{"location":"kubernetes-scripts/#scanning-a-standard-container","title":"Scanning a Standard Container","text":"<pre><code>./scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"kubernetes-scripts/#scanning-a-distroless-container","title":"Scanning a Distroless Container","text":"<pre><code>./scan-distroless-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"kubernetes-scripts/#scanning-with-sidecar-approach","title":"Scanning with Sidecar Approach","text":"<pre><code>./scan-with-sidecar.sh default test-pod examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"kubernetes-scripts/#setting-up-minikube","title":"Setting Up Minikube","text":"<pre><code>./setup-minikube.sh --with-distroless\n</code></pre>"},{"location":"kubernetes-scripts/#generating-a-kubeconfig-file","title":"Generating a Kubeconfig File","text":"<pre><code>./generate-kubeconfig.sh scanner-sa default my-scanner-context\n</code></pre>"},{"location":"kubernetes-scripts/inventory/","title":"Kubernetes Scripts Directory Inventory","text":"<p>This directory contains symlinks to the Kubernetes scripts located in the project's scripts directory.</p>"},{"location":"kubernetes-scripts/inventory/#files","title":"Files","text":"<ul> <li>index.md - Overview and detailed documentation about the scripts</li> <li>scan-container.sh - Script for scanning standard containers</li> <li>scan-distroless-container.sh - Script for scanning distroless containers</li> <li>scan-with-sidecar.sh - Script for scanning with sidecar approach</li> <li>setup-minikube.sh - Script for setting up Minikube</li> <li>generate-kubeconfig.sh - Script for generating kubeconfig files</li> </ul>"},{"location":"kubernetes-scripts/inventory/#purpose","title":"Purpose","text":"<p>These scripts provide the core scanning functionality for the Kube CINC Secure Scanner project. They are organized to be accessible within the documentation while being properly maintained in the scripts directory.</p>"},{"location":"kubernetes-setup/","title":"Kubernetes Setup for Secure Container Scanning","text":"<p>Directory Inventory</p> <p>See the Kubernetes Setup Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This section provides comprehensive documentation on setting up Kubernetes resources required for secure container scanning using CINC Auditor.</p>"},{"location":"kubernetes-setup/#getting-started","title":"Getting Started","text":"<p>Depending on your environment and needs, choose one of these starting points:</p> <ul> <li>Requirements for Existing Kubernetes Clusters - Check if your existing cluster meets the requirements</li> <li>Setting Up Minikube for Local Evaluation - Create a local development environment</li> <li>Kubernetes Setup Best Practices - Security-focused configuration guidance</li> </ul>"},{"location":"kubernetes-setup/#components","title":"Components","text":"<p>The Kubernetes setup for secure container scanning involves several interrelated components:</p>"},{"location":"kubernetes-setup/#kubeconfig-configuration","title":"Kubeconfig Configuration","text":"<p>Proper kubeconfig configuration is essential for secure API interactions with your Kubernetes cluster. This includes:</p> <ul> <li>Creating minimal-access kubeconfig files</li> <li>Configuring secure authentication methods</li> <li>Managing context and namespace isolation</li> </ul> <p>See the Kubeconfig Configuration guide for detailed instructions.</p>"},{"location":"kubernetes-setup/#rbac-configuration","title":"RBAC Configuration","text":"<p>Role-Based Access Control (RBAC) is critical for maintaining security during container scanning operations:</p> <ul> <li>Basic RBAC - Standard RBAC implementation for container scanning</li> <li>Label-based RBAC - More targeted RBAC based on container labels</li> </ul>"},{"location":"kubernetes-setup/#token-management","title":"Token Management","text":"<p>Secure token management ensures temporary, minimal access for scanning operations:</p> <ul> <li>Short-lived token generation</li> <li>Token scope limitations</li> <li>Token usage and renewal patterns</li> </ul> <p>See the Token Management guide for implementation details.</p>"},{"location":"kubernetes-setup/#service-account-setup","title":"Service Account Setup","text":"<p>Service accounts provide the identity for scanning operations:</p> <ul> <li>Creating dedicated service accounts</li> <li>Configuring appropriate permissions</li> <li>Linking service accounts to roles</li> </ul> <p>See the Service Accounts guide for complete instructions.</p>"},{"location":"kubernetes-setup/#environment-types","title":"Environment Types","text":"<p>We support different Kubernetes environments, each with specific requirements and recommendations:</p>"},{"location":"kubernetes-setup/#local-development-and-testing","title":"Local Development and Testing","text":"<p>For local testing and evaluation:</p> <ul> <li>Minikube Setup - Detailed guide for setting up Minikube</li> <li>3-node local cluster for realistic testing</li> <li>Scriptable setup process</li> </ul>"},{"location":"kubernetes-setup/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>For continuous integration environments:</p> <ul> <li>Service account-based authentication</li> <li>Short-lived tokens</li> <li>Pipeline-specific permissions</li> </ul>"},{"location":"kubernetes-setup/#production-environments","title":"Production Environments","text":"<p>For production scanning:</p> <ul> <li>Enhanced security controls</li> <li>High-availability configurations</li> <li>Strict network policies</li> </ul>"},{"location":"kubernetes-setup/#security-considerations","title":"Security Considerations","text":"<p>All components of the Kubernetes setup follow security best practices:</p> <ol> <li>Least Privilege Access: Components are configured to use minimal required permissions</li> <li>Temporary Access: Token-based authentication provides time-limited access</li> <li>Isolation: Configuration ensures isolation between scanning operations</li> <li>Auditability: All actions are auditable through standard Kubernetes mechanisms</li> </ol> <p>For comprehensive security guidance, see:</p> <ul> <li>Security Overview</li> <li>Kubernetes Setup Best Practices</li> <li>RBAC Security Configuration</li> </ul>"},{"location":"kubernetes-setup/best-practices/","title":"Kubernetes Setup Best Practices","text":""},{"location":"kubernetes-setup/best-practices/#overview","title":"Overview","text":"<p>This guide provides best practices for setting up Kubernetes environments for secure container scanning. Following these practices ensures that your scanning infrastructure is secure, reliable, and follows the principle of least privilege.</p>"},{"location":"kubernetes-setup/best-practices/#security-first-practices","title":"Security-First Practices","text":""},{"location":"kubernetes-setup/best-practices/#namespace-isolation","title":"Namespace Isolation","text":"<p>Always use dedicated namespaces for scanning operations:</p> <pre><code># Create a dedicated namespace\nkubectl create namespace scanner-ns\n\n# Run all scanner operations in this namespace\nkubectl -n scanner-ns apply -f scanner-resources.yaml\n</code></pre> <p>Benefits:</p> <ul> <li>Isolates scanner resources from other workloads</li> <li>Allows namespace-specific RBAC controls</li> <li>Simplifies resource management and cleanup</li> </ul>"},{"location":"kubernetes-setup/best-practices/#least-privilege-rbac","title":"Least Privilege RBAC","text":"<p>Create role-based access controls that provide only the minimum necessary permissions:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: scanner-ns\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # Optionally restrict to specific pod names\n  resourceNames: [\"target-pod-1\", \"target-pod-2\"]\n</code></pre> <p>Benefits:</p> <ul> <li>Minimizes potential damage from compromised credentials</li> <li>Follows security principle of least privilege</li> <li>Creates clear audit trails for scanner actions</li> </ul>"},{"location":"kubernetes-setup/best-practices/#ephemeral-credentials","title":"Ephemeral Credentials","text":"<p>Use short-lived credentials for scanning operations:</p> <pre><code># Generate a short-lived token (default 1 hour)\nTOKEN=$(kubectl create token scanner-sa -n scanner-ns)\n\n# Generate a kubeconfig with this token\n./kubernetes-scripts/generate-kubeconfig.sh scanner-sa scanner-ns ./kubeconfig.yaml\n</code></pre> <p>Benefits:</p> <ul> <li>Reduces risk window if credentials are compromised</li> <li>Enforces regular credential rotation</li> <li>Simplifies credential management</li> </ul>"},{"location":"kubernetes-setup/best-practices/#network-policies","title":"Network Policies","text":"<p>Implement network policies to restrict scanner pod communications:</p> <pre><code>kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: scanner-network-policy\n  namespace: scanner-ns\nspec:\n  podSelector:\n    matchLabels:\n      app: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []  # No inbound connections allowed\n  egress:\n  - to:\n    - namespaceSelector: {}  # Allow access to Kubernetes API\n      podSelector:\n        matchLabels:\n          k8s-app: kube-apiserver\n    ports:\n    - protocol: TCP\n      port: 443\n</code></pre> <p>Benefits:</p> <ul> <li>Prevents lateral movement in case of compromise</li> <li>Enforces explicit communication paths</li> <li>Reduces attack surface</li> </ul>"},{"location":"kubernetes-setup/best-practices/#operational-best-practices","title":"Operational Best Practices","text":""},{"location":"kubernetes-setup/best-practices/#resource-limits","title":"Resource Limits","text":"<p>Always set resource limits for scanner components:</p> <pre><code>resources:\n  requests:\n    memory: \"256Mi\"\n    cpu: \"100m\"\n  limits:\n    memory: \"512Mi\"\n    cpu: \"200m\"\n</code></pre> <p>Benefits:</p> <ul> <li>Prevents resource exhaustion attacks</li> <li>Ensures predictable cluster resource utilization</li> <li>Improves scheduler decision making</li> </ul>"},{"location":"kubernetes-setup/best-practices/#liveness-and-readiness-probes","title":"Liveness and Readiness Probes","text":"<p>Implement appropriate health checks for longer-running scanner components:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /health\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 10\nreadinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 2\n  periodSeconds: 5\n</code></pre> <p>Benefits:</p> <ul> <li>Improves reliability and automatic recovery</li> <li>Prevents traffic to non-ready instances</li> <li>Simplifies troubleshooting</li> </ul>"},{"location":"kubernetes-setup/best-practices/#logging-and-monitoring","title":"Logging and Monitoring","text":"<p>Configure comprehensive logging for scanner operations:</p> <pre><code>env:\n- name: LOG_LEVEL\n  value: \"info\"\nvolumeMounts:\n- name: scanner-logs\n  mountPath: /logs\n</code></pre> <p>Benefits:</p> <ul> <li>Creates audit trail for compliance requirements</li> <li>Aids in troubleshooting and debugging</li> <li>Enables operational insights</li> </ul>"},{"location":"kubernetes-setup/best-practices/#cluster-configuration-best-practices","title":"Cluster Configuration Best Practices","text":""},{"location":"kubernetes-setup/best-practices/#api-server-throttling","title":"API Server Throttling","text":"<p>Configure appropriate API server throttling to handle scanner requests:</p> <pre><code># In kube-apiserver configuration\n--max-requests-inflight=800\n--max-mutating-requests-inflight=400\n</code></pre> <p>Benefits:</p> <ul> <li>Prevents API server overload</li> <li>Ensures cluster stability during scanning</li> <li>Maintains responsiveness for critical operations</li> </ul>"},{"location":"kubernetes-setup/best-practices/#admission-controllers","title":"Admission Controllers","text":"<p>Use admission controllers to enforce security policies:</p> <pre><code># In kube-apiserver configuration\n--enable-admission-plugins=PodSecurityPolicy,ResourceQuota,LimitRanger\n</code></pre> <p>Benefits:</p> <ul> <li>Enforces consistent security policies</li> <li>Prevents privileged scanner pods by default</li> <li>Maintains cluster security posture</li> </ul>"},{"location":"kubernetes-setup/best-practices/#feature-gates","title":"Feature Gates","text":"<p>Enable only necessary feature gates for scanning:</p> <pre><code># For distroless scanning in older clusters\n--feature-gates=EphemeralContainers=true\n</code></pre> <p>Benefits:</p> <ul> <li>Reduces potential attack surface</li> <li>Simplifies security analysis</li> <li>Improves stability</li> </ul>"},{"location":"kubernetes-setup/best-practices/#environment-specific-recommendations","title":"Environment-Specific Recommendations","text":""},{"location":"kubernetes-setup/best-practices/#development-and-testing","title":"Development and Testing","text":"<p>For development and testing environments:</p> <ul> <li>Use Minikube with our provided setup script</li> <li>Enable debug logs for scanner components</li> <li>Consider using local filesystem for profiles and results</li> </ul>"},{"location":"kubernetes-setup/best-practices/#cicd-environments","title":"CI/CD Environments","text":"<p>For CI/CD pipeline integration:</p> <ul> <li>Use dedicated service accounts per pipeline</li> <li>Configure short-lived tokens (e.g., 15 minutes)</li> <li>Store sensitive configuration in CI/CD secrets</li> </ul>"},{"location":"kubernetes-setup/best-practices/#production-environments","title":"Production Environments","text":"<p>For production environments:</p> <ul> <li>Implement strict network policies</li> <li>Use node affinity to run scanners on designated nodes</li> <li>Configure comprehensive audit logging</li> <li>Consider using Pod Security Standards</li> </ul>"},{"location":"kubernetes-setup/best-practices/#high-availability-considerations","title":"High Availability Considerations","text":"<p>For production use, consider:</p> <ol> <li>Multiple Scanner Deployments: Deploy scanners across multiple namespaces or clusters</li> <li>Load Balancing: Distribute scanning workloads evenly</li> <li>Failure Domains: Ensure scanners span multiple availability zones</li> <li>Graceful Degradation: Design for partial functionality during outages</li> </ol>"},{"location":"kubernetes-setup/best-practices/#validation-and-compliance","title":"Validation and Compliance","text":"<p>Regularly validate your scanner setup:</p> <pre><code># Validate RBAC configuration\nkubectl auth can-i --as=system:serviceaccount:scanner-ns:scanner-sa get pods -n target-ns\n\n# Validate network policies\nkubectl exec -it network-test -n scanner-ns -- curl -k https://kubernetes.default.svc\n</code></pre>"},{"location":"kubernetes-setup/best-practices/#next-steps","title":"Next Steps","text":"<p>After implementing these best practices:</p> <ul> <li>Configure secure kubeconfig files</li> <li>Set up label-based RBAC for fine-grained control</li> <li>Implement security-focused scanning thresholds</li> </ul>"},{"location":"kubernetes-setup/best-practices/#related-resources","title":"Related Resources","text":"<ul> <li>Existing Cluster Requirements</li> <li>Minikube Setup for Testing</li> <li>Security Principles</li> <li>RBAC Configuration</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/","title":"Requirements for Existing Kubernetes Clusters","text":""},{"location":"kubernetes-setup/existing-cluster-requirements/#overview","title":"Overview","text":"<p>This guide outlines the requirements for using Kube CINC Secure Scanner with your existing Kubernetes cluster. Whether you're running a managed Kubernetes service like EKS, GKE, or AKS, or a self-managed cluster, these requirements ensure successful scanning operations.</p>"},{"location":"kubernetes-setup/existing-cluster-requirements/#kubernetes-version-requirements","title":"Kubernetes Version Requirements","text":"<p>The minimum Kubernetes version required depends on the scanning approach you plan to use:</p> Scanning Approach Minimum Kubernetes Version Notes Standard Container (Kubernetes API) v1.16+ Uses standard <code>kubectl exec</code> functionality Sidecar Container v1.17+ Requires shared process namespace support Debug Container (for distroless) v1.23+ Requires ephemeral containers feature <p>For maximum compatibility and security, we recommend using Kubernetes v1.23 or newer.</p>"},{"location":"kubernetes-setup/existing-cluster-requirements/#feature-gates-and-api-extensions","title":"Feature Gates and API Extensions","text":"<p>Depending on your scanning approach, certain Kubernetes feature gates must be enabled:</p>"},{"location":"kubernetes-setup/existing-cluster-requirements/#for-standard-container-scanning","title":"For Standard Container Scanning","text":"<p>The standard container scanning approach uses the train-k8s-container transport plugin, which requires:</p> <ul> <li><code>kubectl exec</code> functionality</li> <li>Core API endpoints for pods and pod execution</li> </ul> <p>No special feature gates are required for this approach.</p>"},{"location":"kubernetes-setup/existing-cluster-requirements/#for-sidecar-container-scanning","title":"For Sidecar Container Scanning","text":"<p>The sidecar container approach requires:</p> <ul> <li><code>shareProcessNamespace: true</code> functionality (standard in K8s 1.17+)</li> <li>No additional feature gates required</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#for-debug-container-scanning-distroless","title":"For Debug Container Scanning (Distroless)","text":"<p>The debug container approach uses ephemeral containers and requires:</p> <ul> <li>EphemeralContainers feature gate (standard in K8s 1.23+)</li> <li><code>pods/ephemeralcontainers</code> API endpoint enabled</li> <li><code>kubectl debug</code> command support</li> </ul> <p>On older clusters, you may need to explicitly enable the EphemeralContainers feature gate:</p> <pre><code># In kube-apiserver configuration\n--feature-gates=EphemeralContainers=true\n</code></pre>"},{"location":"kubernetes-setup/existing-cluster-requirements/#rbac-requirements","title":"RBAC Requirements","text":"<p>Your cluster must support Role-Based Access Control (RBAC), and you must have permissions to:</p> <ol> <li>Create service accounts</li> <li>Create roles and role bindings</li> <li>Create pods (for sidecar approach)</li> <li>Execute commands in pods</li> <li>Create ephemeral containers (for debug container approach)</li> </ol> <p>The minimum RBAC permissions needed for scanning are:</p> <pre><code>rules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n</code></pre> <p>For distroless container scanning, add:</p> <pre><code>- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"get\", \"create\", \"update\", \"patch\"]\n</code></pre>"},{"location":"kubernetes-setup/existing-cluster-requirements/#networking-requirements","title":"Networking Requirements","text":"<p>The scanning process requires network access from:</p> <ol> <li>Where you run the scanning scripts to the Kubernetes API server</li> <li>The Kubernetes API server to your pod network</li> <li>For CI/CD integrations, your CI/CD pipeline to the Kubernetes API server</li> </ol> <p>If you use network policies or other security controls, ensure they allow:</p> <ul> <li>Outbound traffic from scanner pods to Kubernetes API (typically port 443/TCP)</li> <li>Inbound traffic to your pods on the pod network</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#resource-requirements","title":"Resource Requirements","text":"<p>Scanning operations have minimal resource requirements, but ensure your cluster has:</p> <ul> <li>Available CPU and memory for scanner pods (typically 100m CPU, 256Mi memory)</li> <li>API server capacity to handle additional API requests</li> <li>For distroless scanning, capacity to run ephemeral debug containers</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#validating-your-cluster-compatibility","title":"Validating Your Cluster Compatibility","text":"<p>Run this validation script to check if your cluster meets the requirements:</p> <pre><code># Clone the repository if you haven't already\ngit clone https://github.com/mitre/kube-secure-scanner.git\ncd kube-secure-scanner\n\n# Run the validation checks\n./kubernetes-scripts/validate-cluster.sh\n</code></pre> <p>If the script isn't available, you can manually verify:</p> <pre><code># Check Kubernetes version\nkubectl version --short\n\n# Verify RBAC functionality\nkubectl auth can-i create rolebinding --namespace default\n\n# For distroless scanning, verify ephemeral containers support\nkubectl api-resources | grep ephemeralcontainers\n</code></pre>"},{"location":"kubernetes-setup/existing-cluster-requirements/#special-considerations-for-managed-kubernetes-services","title":"Special Considerations for Managed Kubernetes Services","text":""},{"location":"kubernetes-setup/existing-cluster-requirements/#amazon-eks","title":"Amazon EKS","text":"<ul> <li>Ensure your IAM roles have sufficient permissions</li> <li>For distroless scanning, use EKS 1.23 or newer</li> <li>Consider using EKS managed node groups for easier upgrades</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#google-gke","title":"Google GKE","text":"<ul> <li>Standard GKE should work with all approaches</li> <li>For distroless scanning on older clusters, enable the EphemeralContainers feature gate</li> <li>If using Workload Identity, ensure proper service account mapping</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#microsoft-aks","title":"Microsoft AKS","text":"<ul> <li>Use AKS 1.23+ for all scanning approaches</li> <li>If using Azure AD integration, ensure your user/service principal has sufficient permissions</li> <li>Consider using Azure RBAC for Kubernetes authorization</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#security-considerations","title":"Security Considerations","text":"<p>When configuring your cluster for scanning, follow these security best practices:</p> <ol> <li>Create a dedicated namespace for scanning operations</li> <li>Use service accounts with minimal permissions</li> <li>Generate short-lived tokens for authentication</li> <li>Consider using network policies to isolate scanner pods</li> <li>Monitor API server audit logs for scanning operations</li> <li>Use namespaced resources instead of cluster-wide resources when possible</li> </ol>"},{"location":"kubernetes-setup/existing-cluster-requirements/#next-steps","title":"Next Steps","text":"<p>After confirming your cluster meets the requirements:</p> <ul> <li>Configure RBAC for scanning</li> <li>Set up service accounts</li> <li>Generate secure kubeconfig files</li> <li>Run your first container scan</li> </ul>"},{"location":"kubernetes-setup/existing-cluster-requirements/#related-resources","title":"Related Resources","text":"<ul> <li>Kubernetes Setup Overview</li> <li>Minikube Setup for Testing</li> <li>Kubernetes Best Practices</li> <li>RBAC Configuration</li> </ul>"},{"location":"kubernetes-setup/inventory/","title":"Kubernetes Setup Directory Inventory","text":"<p>This document provides a directory overview of the Kubernetes setup resources and documentation.</p>"},{"location":"kubernetes-setup/inventory/#directory-contents","title":"Directory Contents","text":"<p>The kubernetes-setup directory contains documentation for configuring Kubernetes resources for secure container scanning:</p> <ul> <li>index.md: Main documentation page for Kubernetes setup</li> <li>minikube-setup.md: Guide for setting up Minikube for local testing</li> <li>existing-cluster-requirements.md: Requirements for existing Kubernetes clusters</li> <li>best-practices.md: Best practices for Kubernetes configuration</li> <li>inventory.md: This directory inventory document</li> </ul>"},{"location":"kubernetes-setup/inventory/#setup-components","title":"Setup Components","text":"<p>This directory focuses on the foundational Kubernetes components needed for secure scanning:</p> <ul> <li>Environment Setup: Creating appropriate Kubernetes environments for scanning</li> <li>Cluster Requirements: Verifying and meeting necessary cluster requirements</li> <li>Kubeconfig Configuration: Creating secure and minimal-access kubeconfig files</li> <li>RBAC Configuration: Setting up appropriate role-based access control</li> <li>Token Management: Generating and managing short-lived authentication tokens</li> <li>Service Account Setup: Creating dedicated service accounts with proper permissions</li> </ul>"},{"location":"kubernetes-setup/inventory/#environment-types","title":"Environment Types","text":"<p>Documentation covers different Kubernetes environments:</p> <ul> <li>Local Development: Using Minikube for local testing and evaluation</li> <li>CI/CD Pipelines: Configuration for continuous integration environments</li> <li>Production: Requirements and considerations for production deployments</li> </ul>"},{"location":"kubernetes-setup/inventory/#security-framework","title":"Security Framework","text":"<p>The documentation emphasizes security best practices for container scanning:</p> <ul> <li>Least privilege access principles</li> <li>Temporary access mechanisms</li> <li>Component isolation</li> <li>Audit logging and tracking</li> <li>Network policy configuration</li> <li>Resource limitations</li> </ul>"},{"location":"kubernetes-setup/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>RBAC Configuration</li> <li>Service Accounts</li> <li>Token Management</li> <li>Kubeconfig Configuration</li> <li>Security Overview</li> <li>Kubernetes Scripts</li> </ul>"},{"location":"kubernetes-setup/minikube-setup/","title":"Setting Up Minikube for Local Evaluation","text":""},{"location":"kubernetes-setup/minikube-setup/#overview","title":"Overview","text":"<p>This guide walks you through setting up a local Minikube environment for evaluating and testing the Kube CINC Secure Scanner. Using Minikube provides a controlled, isolated environment to test container scanning functionality without affecting production systems.</p>"},{"location":"kubernetes-setup/minikube-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>A system with sufficient resources:<ul> <li>4+ GB of RAM</li> <li>20+ GB of free disk space</li> <li>2+ CPU cores</li> </ul> </li> <li>One of the following virtualization platforms:<ul> <li>Docker (recommended for macOS and Linux)</li> <li>VirtualBox (works on all platforms)</li> <li>HyperKit (macOS)</li> <li>Hyper-V (Windows)</li> <li>KVM (Linux)</li> </ul> </li> <li>Administrative access to install software</li> </ul>"},{"location":"kubernetes-setup/minikube-setup/#required-software","title":"Required Software","text":"<p>Before beginning the setup, ensure you have the following software installed:</p> <ol> <li>Minikube: For running a local Kubernetes cluster</li> <li>kubectl: For interacting with the Kubernetes cluster</li> <li>CINC Auditor: For running compliance scans</li> <li>SAF CLI (optional): For processing and validating scan results</li> </ol> <p>Our setup script can install these components automatically with the <code>--install-deps</code> flag.</p>"},{"location":"kubernetes-setup/minikube-setup/#using-the-setup-script","title":"Using the Setup Script","text":"<p>The project includes a comprehensive setup script that automates the entire Minikube setup process. This is the recommended approach for most users.</p>"},{"location":"kubernetes-setup/minikube-setup/#basic-setup","title":"Basic Setup","text":"<pre><code># Navigate to the project directory\ncd kube-secure-scanner\n\n# Run the setup script with default options\n./kubernetes-scripts/setup-minikube.sh\n</code></pre> <p>This will:</p> <ul> <li>Check for required dependencies</li> <li>Create a 3-node Minikube cluster</li> <li>Configure RBAC permissions</li> <li>Deploy test pods for scanning</li> <li>Generate a kubeconfig file</li> </ul>"},{"location":"kubernetes-setup/minikube-setup/#advanced-options","title":"Advanced Options","text":"<p>The script supports several configuration options:</p> <pre><code># Get help and see all options\n./kubernetes-scripts/setup-minikube.sh --help\n\n# Setup with automatic dependency installation\n./kubernetes-scripts/setup-minikube.sh --install-deps\n\n# Setup with distroless container support\n./kubernetes-scripts/setup-minikube.sh --with-distroless\n\n# Setup with a custom driver\n./kubernetes-scripts/setup-minikube.sh --driver=virtualbox\n\n# Setup with a specific Kubernetes version\n./kubernetes-scripts/setup-minikube.sh --k8s-version=v1.29.1\n\n# Setup with a custom profile name\n./kubernetes-scripts/setup-minikube.sh --profile=scanner-test\n</code></pre>"},{"location":"kubernetes-setup/minikube-setup/#manual-setup-process","title":"Manual Setup Process","text":"<p>If you prefer to set up Minikube manually, follow these steps:</p> <ol> <li>Start Minikube with Multiple Nodes</li> </ol> <pre><code>minikube start --driver=docker --nodes=3 --kubernetes-version=v1.28.3\n</code></pre> <ol> <li>Create a Namespace for Testing</li> </ol> <pre><code>kubectl create namespace inspec-test\n</code></pre> <ol> <li>Create Service Account and RBAC Resources</li> </ol> <pre><code># Create service account\nkubectl create serviceaccount scanner-sa -n inspec-test\n\n# Create role\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/ephemeralcontainers\"]\n  verbs: [\"get\", \"create\", \"update\", \"patch\"]\nEOF\n\n# Create role binding\nkubectl create rolebinding scanner-rb \\\n  --role=scanner-role \\\n  --serviceaccount=inspec-test:scanner-sa \\\n  -n inspec-test\n</code></pre> <ol> <li>Deploy Test Pods</li> </ol> <pre><code># Standard container\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pod\n  namespace: inspec-test\nspec:\n  containers:\n  - name: container\n    image: busybox:latest\n    command: [\"sleep\", \"3600\"]\nEOF\n</code></pre> <ol> <li>Generate Kubeconfig</li> </ol> <pre><code>./kubernetes-scripts/generate-kubeconfig.sh scanner-sa inspec-test ./kubeconfig.yaml\n</code></pre>"},{"location":"kubernetes-setup/minikube-setup/#verifying-your-setup","title":"Verifying Your Setup","text":"<p>After setup completes, verify that everything is working correctly:</p> <pre><code># Verify nodes are running\nkubectl get nodes\n\n# Verify test pods are running\nkubectl get pods -n inspec-test\n\n# Verify RBAC configuration\nkubectl get roles,rolebindings -n inspec-test\n\n# Test kubeconfig\nKUBECONFIG=./kubeconfig.yaml kubectl get pods -n inspec-test\n</code></pre>"},{"location":"kubernetes-setup/minikube-setup/#running-your-first-scan","title":"Running Your First Scan","text":"<p>Once your environment is set up, run a test scan to verify everything works correctly:</p> <pre><code># Run a scan on the test pod\n./kubernetes-scripts/scan-container.sh inspec-test test-pod container examples/cinc-profiles/container-baseline\n</code></pre>"},{"location":"kubernetes-setup/minikube-setup/#cleanup","title":"Cleanup","text":"<p>When you're done testing, you can clean up the resources:</p> <pre><code># Stop Minikube\nminikube stop\n\n# Delete the cluster\nminikube delete\n</code></pre>"},{"location":"kubernetes-setup/minikube-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kubernetes-setup/minikube-setup/#common-issues","title":"Common Issues","text":"Issue Solution \"Unable to start minikube\" Check for sufficient system resources and try a different driver \"The connection was refused\" Minikube may not be running. Try <code>minikube status</code> and start if needed \"Error: No such container\" Docker may have restarted. Try <code>minikube delete</code> and start again \"Permission denied\" Check RBAC permissions and regenerate kubeconfig"},{"location":"kubernetes-setup/minikube-setup/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered in this guide:</p> <ol> <li>Run <code>minikube logs</code> to check for error messages</li> <li>Check <code>kubectl describe pod &lt;pod-name&gt; -n inspec-test</code> for pod-specific issues</li> <li>Consult the Minikube documentation</li> </ol>"},{"location":"kubernetes-setup/minikube-setup/#next-steps","title":"Next Steps","text":"<p>After successfully setting up your local environment:</p> <ul> <li>Run a standard container scan</li> <li>Scan distroless containers (if set up with <code>--with-distroless</code>)</li> <li>Configure custom thresholds</li> <li>Explore different scanning approaches</li> </ul>"},{"location":"kubernetes-setup/minikube-setup/#related-resources","title":"Related Resources","text":"<ul> <li>Kubernetes Setup Overview</li> <li>Existing Cluster Requirements</li> <li>Kubernetes Best Practices</li> </ul>"},{"location":"learning-paths/","title":"Learning Paths","text":"<p>Welcome to the Kube CINC Secure Scanner learning paths. These guided paths help you implement and use the scanner effectively while maintaining a strong security posture.</p>"},{"location":"learning-paths/#available-learning-paths","title":"Available Learning Paths","text":""},{"location":"learning-paths/#for-new-users","title":"For New Users","text":"<ul> <li>New User Guide - Start here if you're new to Kube CINC Secure Scanner</li> <li>Security-First Implementation - Implement with security as the primary focus</li> </ul>"},{"location":"learning-paths/#core-knowledge","title":"Core Knowledge","text":"<ul> <li>Core Concepts - Understand the fundamental concepts and security principles</li> <li>Implementation Guide - Step-by-step implementation with security validation</li> </ul>"},{"location":"learning-paths/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Advanced Features - Explore advanced features and security capabilities</li> </ul>"},{"location":"learning-paths/#how-to-use-learning-paths","title":"How to Use Learning Paths","text":"<p>Each learning path:</p> <ol> <li>Provides a clear overview and learning objectives</li> <li>Lists prerequisites you should have before starting</li> <li>Includes step-by-step instructions with time estimates</li> <li>Highlights security considerations throughout</li> <li>Shows compliance relevance where applicable</li> <li>Suggests next steps after completion</li> </ol> <p>The paths are designed to be followed sequentially, but you can jump to any specific path based on your needs and experience level.</p>"},{"location":"learning-paths/#security-focus","title":"Security Focus","text":"<p>All learning paths incorporate security best practices and considerations. Look for the security admonitions throughout each path for important security information:</p> <p>Security Emphasis</p> <p>These highlight key security aspects and why they matter.</p> <p>Security Consideration</p> <p>These provide step-specific security guidance.</p>"},{"location":"learning-paths/advanced-features/","title":"Advanced Features","text":""},{"location":"learning-paths/advanced-features/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This learning path focuses on advanced security features and optimizations that enhance the security posture of your Kube CINC Secure Scanner implementation. These features provide deeper security controls and more robust compliance capabilities.</p> <p>This learning path guides you through the advanced features of Kube CINC Secure Scanner. By completing this path, you will understand how to implement advanced security controls, optimize performance, integrate with enterprise security tools, and customize the scanner for specialized environments.</p> <p>Time to complete: 2-3 hours</p> <p>Target audience: Security engineers, DevSecOps engineers, Compliance officers</p> <p>Security level: Advanced</p>"},{"location":"learning-paths/advanced-features/#prerequisites","title":"Prerequisites","text":"<ul> <li> A working Kube CINC Secure Scanner implementation</li> <li> Completed the Implementation Guide learning path</li> <li> Understanding of Kubernetes security concepts</li> <li> Familiarity with container security principles</li> <li> Administrative access to your Kubernetes cluster</li> </ul>"},{"location":"learning-paths/advanced-features/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/advanced-features/#step-1","title":"Step 1: Advanced RBAC Configuration","text":"<p>Security Consideration</p> <p>Fine-grained RBAC is critical for maintaining the principle of least privilege and preventing unauthorized access to sensitive resources.</p> <ol> <li>Implement label-based RBAC for targeted scanning:</li> <li>Review Label-Based RBAC</li> <li>Create namespace labels for controlling scan access:</li> </ol> <pre><code>kubectl label namespace default scan-allowed=true\n</code></pre> <ol> <li>Apply enhanced RBAC configuration:</li> </ol> <pre><code>kubectl apply -f kubernetes/templates/label-rbac.yaml\n</code></pre> <ol> <li>Configure time-bound tokens:</li> <li>Review Token Management</li> <li> <p>Implement token expiration controls</p> </li> <li> <p>Verify RBAC restrictions:</p> </li> </ol> <pre><code># Test access to labeled namespaces\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner list pods -n default\n\n# Test access to unlabeled namespaces (should fail)\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner list pods -n kube-system\n</code></pre> <p>Estimated time: 30 minutes</p> <p>Success criteria: Scanner has restricted access to only labeled namespaces with appropriate time-bound tokens.</p>"},{"location":"learning-paths/advanced-features/#step-2","title":"Step 2: Enhanced Security Controls","text":"<p>Security Consideration</p> <p>Implementing defense-in-depth requires multiple layers of security controls that work together to provide comprehensive protection.</p> <ol> <li>Implement network policies:</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\n  namespace: scanner-system\nspec:\n  podSelector:\n    matchLabels:\n      app: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          scan-allowed: \"true\"\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          scan-allowed: \"true\"\n  - to:\n    - podSelector:\n        matchLabels:\n          app: scanner-results\n</code></pre> <ol> <li>Apply security context enhancements:</li> <li>Review Security Hardening</li> <li>Update Helm values for enhanced pod security:</li> </ol> <pre><code>helm upgrade standard-scanner standard-scanner/ \\\n  --namespace scanner-system \\\n  --set securityContext.readOnlyRootFilesystem=true \\\n  --set securityContext.runAsNonRoot=true \\\n  --set securityContext.runAsUser=10001 \\\n  --set securityContext.allowPrivilegeEscalation=false\n</code></pre> <ol> <li>Implement resource quotas and limits:</li> </ol> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: scanner-quota\n  namespace: scanner-system\nspec:\n  hard:\n    requests.cpu: \"2\"\n    requests.memory: 4Gi\n    limits.cpu: \"4\"\n    limits.memory: 8Gi\nEOF\n</code></pre> <p>Estimated time: 30 minutes</p> <p>Success criteria: Enhanced security controls applied to scanner components with verified restrictions.</p>"},{"location":"learning-paths/advanced-features/#step-3","title":"Step 3: Advanced Thresholds and Reporting","text":"<p>Security Consideration</p> <p>Advanced threshold configurations allow for more granular control over security requirements, helping to balance operational needs with security requirements.</p> <ol> <li>Implement advanced threshold configurations:</li> <li>Review Advanced Thresholds</li> <li>Create environment-specific threshold files:</li> </ol> <pre><code># strict-production.yml\ncompliance:\n  total_pass: 95.0\n  critical_controls_pass: 100.0\nscoring:\n  critical:\n    points: 100\n    maximum_allowed_fail: 0\n  high:\n    points: 40\n    maximum_allowed_fail: 0\n  medium:\n    points: 15\n    maximum_allowed_fail: 2\n  low:\n    points: 5\n    maximum_allowed_fail: 5\n</code></pre> <ol> <li>Configure custom reporting formats:</li> <li>Review Reporting Configuration</li> <li> <p>Set up JSON, XML, and HTML report formats</p> </li> <li> <p>Implement compliance mapping:</p> </li> <li>Map controls to compliance frameworks</li> <li> <p>Create compliance-specific threshold files</p> </li> <li> <p>Test advanced threshold configurations:</p> </li> </ol> <pre><code>./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline examples/strict-production.yml\n</code></pre> <p>Estimated time: 30 minutes</p> <p>Success criteria: Advanced threshold configurations implemented with custom reporting formats.</p>"},{"location":"learning-paths/advanced-features/#step-4","title":"Step 4: Enterprise Integration","text":"<p>Security Consideration</p> <p>When integrating with enterprise systems, ensure proper authentication, secure communication channels, and appropriate access controls.</p> <ol> <li>Integrate with security information and event management (SIEM):</li> <li>Configure report forwarding to SIEM systems</li> <li> <p>Set up alerts for critical findings</p> </li> <li> <p>Implement automated remediation workflows:</p> </li> <li>Create ticket integration for findings</li> <li>Set up notification systems</li> <li> <p>Configure escalation paths</p> </li> <li> <p>Integrate with compliance dashboards:</p> </li> <li>Configure report aggregation</li> <li> <p>Map findings to compliance controls</p> </li> <li> <p>Set up multi-environment scanning:</p> </li> <li>Configure scanning for development, staging, and production</li> <li>Implement different threshold levels per environment</li> </ol> <p>Estimated time: 45 minutes</p> <p>Success criteria: Scanner integrated with enterprise security and compliance systems.</p>"},{"location":"learning-paths/advanced-features/#step-5","title":"Step 5: Custom Profile Development","text":"<p>Security Consideration</p> <p>Custom security profiles allow you to address organization-specific security requirements and enhance your security posture beyond baseline standards.</p> <ol> <li>Create a custom security profile:</li> </ol> <pre><code># custom-controls/controls/01_custom_checks.rb\ncontrol 'CUSTOM-001' do\n  impact 1.0\n  title 'Custom Security Control'\n  desc 'This control verifies organization-specific security requirements'\n\n  describe file('/etc/custom-security-config') do\n    it { should exist }\n    its('content') { should match /security_level=high/ }\n  end\nend\n</code></pre> <ol> <li>Add custom control to your profile:</li> </ol> <pre><code># custom-profile/inspec.yml\nname: custom-container-profile\ntitle: Custom Container Security Profile\nversion: 1.0.0\ndepends:\n  - name: container-baseline\n    path: ../container-baseline\n</code></pre> <ol> <li>Test your custom profile:</li> </ol> <pre><code>./kubernetes-scripts/scan-container.sh default test-pod test-container examples/custom-profile examples/thresholds/strict.yml\n</code></pre> <ol> <li>Implement profile versioning and distribution process:</li> <li>Set up profile versioning</li> <li>Create profile distribution mechanism</li> <li>Document profile customization process</li> </ol> <p>Estimated time: 45 minutes</p> <p>Success criteria: Custom security profile created, tested, and implemented in your scanning workflow.</p>"},{"location":"learning-paths/advanced-features/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations for advanced features:</p> <ul> <li> <p>Custom Security Controls:</p> <ul> <li>Develop controls that address specific organizational security requirements</li> <li>Ensure controls are properly tested and validated</li> <li>Maintain version control for security profiles</li> <li>Document and review custom controls regularly</li> </ul> </li> <li> <p>Enterprise Integration Security:</p> <ul> <li>Secure API tokens and credentials for integration points</li> <li>Implement TLS for all communications</li> <li>Apply the principle of least privilege for integration accounts</li> <li>Audit integration activities regularly</li> </ul> </li> <li> <p>Advanced Defense-in-Depth:</p> <ul> <li>Implement multi-layered security controls</li> <li>Apply network segmentation using network policies</li> <li>Utilize admission controllers for additional security</li> <li>Consider implementing service mesh for enhanced security controls</li> </ul> </li> <li> <p>Operational Security:</p> <ul> <li>Implement secure operational practices</li> <li>Regularly rotate credentials and certificates</li> <li>Monitor scanning activities and resource usage</li> <li>Conduct regular security reviews of scanner configuration</li> </ul> </li> </ul>"},{"location":"learning-paths/advanced-features/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>Organization-Specific Security Requirements - Custom profiles address unique security needs</li> <li>Advanced Compliance Frameworks - Enhanced capabilities for mapping to complex compliance requirements</li> <li>Zero Trust Architecture - Supports implementation of zero trust principles through granular access controls</li> <li>Audit Evidence Collection - Robust reporting capabilities provide detailed evidence for compliance audits</li> <li>Continuous Compliance Monitoring - Advanced threshold configurations enable continuous compliance assessment</li> </ul>"},{"location":"learning-paths/advanced-features/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>Implementing continuous improvement processes for your scanning infrastructure</li> <li>Contributing to the Kube CINC Secure Scanner project</li> <li>Exploring integration with additional security tools and frameworks</li> <li>Developing advanced custom profiles for your specific use cases</li> </ul>"},{"location":"learning-paths/advanced-features/#related-resources","title":"Related Resources","text":"<ul> <li>Custom Integrations</li> <li>Advanced Deployment Topics</li> <li>Risk Mitigations</li> </ul>"},{"location":"learning-paths/core-concepts/","title":"Core Concepts","text":""},{"location":"learning-paths/core-concepts/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Understanding core concepts is essential for making informed security decisions. This learning path establishes a solid foundation in the security principles that underpin Kube CINC Secure Scanner.</p> <p>This learning path introduces the fundamental concepts and security principles of Kube CINC Secure Scanner. By completing this path, you will understand the architecture, scanning approaches, and security considerations that form the foundation of the scanner.</p> <p>Time to complete: 60 minutes</p> <p>Target audience: DevOps engineers, Security professionals, Platform engineers</p> <p>Security level: Basic to Intermediate</p>"},{"location":"learning-paths/core-concepts/#prerequisites","title":"Prerequisites","text":"<ul> <li> Basic understanding of Kubernetes</li> <li> Familiarity with container security concepts</li> <li> Completed the New User Guide or equivalent experience</li> </ul>"},{"location":"learning-paths/core-concepts/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/core-concepts/#step-1","title":"Step 1: Architecture Overview","text":"<p>Security Consideration</p> <p>Understanding the architecture helps you identify potential security boundaries and trust relationships between components.</p> <ol> <li>Review the architecture documentation:</li> <li>Architecture Overview</li> <li>Core Components</li> <li>Security Components</li> <li> <p>Component Communication</p> </li> <li> <p>Study the architecture diagrams:</p> </li> <li>Component Diagrams</li> <li>Deployment Diagrams</li> </ol> <p>Estimated time: 20 minutes</p> <p>Success criteria: You can describe the main components of Kube CINC Secure Scanner and how they interact from a security perspective.</p>"},{"location":"learning-paths/core-concepts/#step-2","title":"Step 2: Scanning Approaches","text":"<p>Security Consideration</p> <p>Each scanning approach has different security implications and tradeoffs that must be understood to make appropriate security decisions.</p> <ol> <li>Learn about the different scanning approaches:</li> <li>Approaches Overview</li> <li>Approach Comparison</li> <li> <p>Decision Matrix</p> </li> <li> <p>Understand the details of each approach:</p> </li> <li>Kubernetes API Approach</li> <li>Sidecar Container Approach</li> <li>Debug Container Approach</li> <li>Direct Commands Approach</li> <li>Helper Scripts Approach</li> </ol> <p>Estimated time: 20 minutes</p> <p>Success criteria: You can explain the security tradeoffs between different scanning approaches and identify which is most appropriate for different security scenarios.</p>"},{"location":"learning-paths/core-concepts/#step-3","title":"Step 3: Security Model","text":"<p>Security Consideration</p> <p>A thorough understanding of the security model helps you implement defense-in-depth strategies appropriate for your environment.</p> <ol> <li>Review the security model documentation:</li> <li>Security Overview</li> <li>Security Principles</li> <li>Threat Model</li> <li> <p>Risk Model</p> </li> <li> <p>Understand potential attack vectors:</p> </li> <li>Attack Vectors</li> <li>Lateral Movement</li> <li> <p>Token Exposure</p> </li> <li> <p>Learn about mitigations:</p> </li> <li>Threat Mitigations</li> <li>Risk Mitigations</li> </ol> <p>Estimated time: 20 minutes</p> <p>Success criteria: You can describe the security model, identify key risks, and explain relevant mitigations.</p>"},{"location":"learning-paths/core-concepts/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations for understanding core concepts:</p> <ul> <li>Trust Boundaries: Understand where trust boundaries exist between components and how they affect security decisions</li> <li>Defense in Depth: Recognize how multiple security controls work together to provide layered defense</li> <li>Security Tradeoffs: Understand the security implications of different architectural and deployment choices</li> <li>Threat Awareness: Identify potential threats to the scanner and how they're mitigated in the design</li> <li>Risk Management: Understand how risk is assessed and managed throughout the scanner's architecture</li> </ul>"},{"location":"learning-paths/core-concepts/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>Security Control Documentation - Provides understanding needed to document security controls for audits</li> <li>Risk Assessment - Establishes foundation for risk assessment activities</li> <li>Security Architecture - Supports documentation of security architecture for compliance frameworks</li> </ul>"},{"location":"learning-paths/core-concepts/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>Security-First Implementation - Implement with security as the primary focus</li> <li>Implementation Guide - Get detailed implementation instructions</li> <li>Advanced Features - Explore advanced security capabilities</li> </ul>"},{"location":"learning-paths/core-concepts/#related-resources","title":"Related Resources","text":"<ul> <li>Executive Summary</li> <li>Architecture Diagrams</li> <li>Security Compliance Documentation</li> </ul>"},{"location":"learning-paths/implementation/","title":"Implementation Guide","text":""},{"location":"learning-paths/implementation/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This learning path ensures that your implementation balances functional requirements with security considerations. By following this path, you'll deploy a secure scanner setup that follows defense-in-depth principles.</p> <p>This learning path guides you through a complete implementation of Kube CINC Secure Scanner. It provides detailed steps for setting up the scanner in different environments with a focus on security, maintainability, and integration.</p> <p>Time to complete: 2-3 hours</p> <p>Target audience: DevOps engineers, Platform engineers, Security engineers</p> <p>Security risk: \ud83d\udfe1 Medium - Involves cluster-level installations and service account configuration</p> <p>Security approach: Implements principle of least privilege, namespace isolation, and secure deployment patterns with proper security context configuration</p>"},{"location":"learning-paths/implementation/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>A secure implementation requires managing permissions across distinct boundaries:</p> <p>1. Cluster Administrative Permissions * Control: Installation of core components, namespace creation, and RBAC setup * Risk area: Overly broad administrative access could compromise cluster security * Mitigation: Use dedicated service accounts with time-limited tokens for installation</p> <p>2. Scanner Runtime Permissions * Control: Scanner's ability to access and scan target containers * Risk area: Excessive permissions could allow unintended container access * Mitigation: Implement granular RBAC with namespace isolation and specific verb limitations</p> <p>3. Integration Permissions * Control: How external systems interact with the scanner infrastructure * Risk area: Integration points could expose scanner capabilities inappropriately * Mitigation: Create dedicated integration service accounts with minimal required access</p>"},{"location":"learning-paths/implementation/#prerequisites","title":"Prerequisites","text":"<ul> <li> Kubernetes cluster with administrative access</li> <li> kubectl installed and configured</li> <li> Helm v3 installed (for Helm-based deployment)</li> <li> Completed the Core Concepts learning path or have equivalent knowledge</li> <li> Understanding of RBAC and Kubernetes security concepts</li> </ul>"},{"location":"learning-paths/implementation/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/implementation/#step-1","title":"Step 1: Environment Preparation","text":"<p>Security Consideration</p> <p>Plan your deployment with security boundaries in mind. Create dedicated namespaces with proper RBAC restrictions to maintain isolation.</p> <ol> <li>Determine your deployment requirements:</li> <li>Review the Decision Matrix to choose the best scanning approach</li> <li>Identify required permissions and resource constraints</li> <li> <p>Document security requirements and boundaries</p> </li> <li> <p>Create a dedicated namespace:</p> </li> </ol> <pre><code>kubectl create namespace scanner-system\n</code></pre> <ol> <li>Apply necessary RBAC configurations:</li> </ol> <pre><code># For standard approach\nkubectl apply -f kubernetes/templates/rbac.yaml -n scanner-system\n\n# For label-based RBAC (more restrictive)\nkubectl apply -f kubernetes/templates/label-rbac.yaml -n scanner-system\n</code></pre> <ol> <li>Verify RBAC permissions:</li> </ol> <pre><code># Test service account permissions\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner list pods -n default\n</code></pre> <p>Estimated time: 30 minutes</p> <p>Success criteria: You have a dedicated namespace with proper RBAC permissions configured.</p>"},{"location":"learning-paths/implementation/#step-2","title":"Step 2: Scanner Infrastructure Deployment","text":"<p>Security Consideration</p> <p>Use appropriate security context settings and resource limits to protect your cluster from potential resource exhaustion or privilege escalation.</p> <ol> <li>Deploy the scanner infrastructure:</li> </ol> <p>Option A: Using Helm Charts (Recommended)</p> <pre><code># Install scanner infrastructure\ncd helm-charts\nhelm install scanner-infra scanner-infrastructure/ \\\n  --namespace scanner-system \\\n  --values scanner-infrastructure/examples/values-production.yaml\n</code></pre> <p>Option B: Using Kubernetes Manifests</p> <pre><code># Apply core manifests\nkubectl apply -f kubernetes/templates/service-account.yaml -n scanner-system\nkubectl apply -f kubernetes/templates/rbac.yaml -n scanner-system\n</code></pre> <ol> <li>Verify infrastructure deployment:</li> </ol> <pre><code>kubectl get serviceaccounts -n scanner-system\nkubectl get roles,rolebindings -n scanner-system\n</code></pre> <ol> <li>Configure scanner security settings:</li> <li>Review and apply security-hardened values from Security Best Practices</li> <li>Apply network policies if needed</li> </ol> <p>Estimated time: 30 minutes</p> <p>Success criteria: Scanner infrastructure components are running and properly configured with security controls.</p>"},{"location":"learning-paths/implementation/#step-3","title":"Step 3: Scanner Deployment Based on Approach","text":"<p>Security Consideration</p> <p>Each scanning approach has different security implications. Ensure you understand the security tradeoffs and implement appropriate mitigations.</p> <p>Choose your scanner deployment based on your selected approach:</p> <p>Option A: Standard Scanner (Kubernetes API)</p> <pre><code>helm install standard-scanner standard-scanner/ \\\n  --namespace scanner-system \\\n  --values standard-scanner/examples/values-ci.yaml\n</code></pre> <p>Option B: Distroless Scanner (Debug Container)</p> <pre><code>helm install distroless-scanner distroless-scanner/ \\\n  --namespace scanner-system \\\n  --values distroless-scanner/examples/values-distroless-golang.yaml\n</code></pre> <p>Option C: Sidecar Scanner</p> <pre><code>helm install sidecar-scanner sidecar-scanner/ \\\n  --namespace scanner-system\n</code></pre> <p>Review your deployment:</p> <pre><code>helm list -n scanner-system\nkubectl get all -n scanner-system\n</code></pre> <p>Configure any specific scanner options:</p> <ul> <li>Review Configuration Reference</li> <li>Adjust resource limits and security context settings</li> <li>Configure threshold values based on your security requirements</li> </ul> <p>Estimated time: 30 minutes</p> <p>Success criteria: Scanner is deployed according to your chosen approach with appropriate security configurations.</p>"},{"location":"learning-paths/implementation/#step-4","title":"Step 4: Testing Your Implementation","text":"<p>Security Consideration</p> <p>Validate that your scanner implementation maintains the security boundaries you've established and doesn't introduce new security risks.</p> <ol> <li>Create a test pod:</li> </ol> <pre><code>kubectl apply -f test-pod.yaml -n default\n</code></pre> <ol> <li>Run your first scan based on your chosen approach:</li> </ol> <p>Standard Scanner</p> <pre><code>./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre> <p>Distroless Scanner</p> <pre><code>./kubernetes-scripts/scan-distroless-container.sh default test-pod test-container examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre> <p>Sidecar Scanner</p> <pre><code>./kubernetes-scripts/scan-with-sidecar.sh default test-pod examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre> <ol> <li>Review scan results:</li> </ol> <pre><code># Check the results file\ncat results/container-scan-results.json\n</code></pre> <ol> <li>Test with multiple containers and scan configurations to ensure everything works as expected.</li> </ol> <p>Estimated time: 30 minutes</p> <p>Success criteria: Successfully performed container scans and received valid results.</p>"},{"location":"learning-paths/implementation/#step-5","title":"Step 5: Integration Setup","text":"<p>Security Consideration</p> <p>When integrating with CI/CD systems, ensure credentials are properly secured and limit privileges to only what's necessary for scanning operations.</p> <ol> <li>Configure integration with your CI/CD platform:</li> </ol> <p>GitHub Actions    - Review GitHub Actions Integration    - Implement workflow using GitHub Workflow Examples</p> <p>GitLab CI    - Review GitLab CI Integration    - Implement pipeline using GitLab Pipeline Examples</p> <ol> <li>Configure threshold values:</li> <li>Review Thresholds Integration</li> <li> <p>Create custom threshold files for different environments</p> </li> <li> <p>Configure reporting:</p> </li> <li>Set up results handling in your CI/CD platform</li> <li>Implement notification mechanisms for scan failures</li> </ol> <p>Estimated time: 30 minutes</p> <p>Success criteria: Scanner is integrated with your CI/CD platform and produces actionable reports.</p>"},{"location":"learning-paths/implementation/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations for implementation:</p> <ul> <li> <p>Defense in Depth:</p> <ul> <li>Apply multiple security controls at different layers</li> <li>Implement least privilege RBAC configurations</li> <li>Use network policies to restrict communication between components</li> <li>Consider pod security policies or Pod Security Standards</li> </ul> </li> <li> <p>Credential Management:</p> <ul> <li>Use short-lived service account tokens</li> <li>Implement proper secret management for sensitive configurations</li> <li>Rotate credentials regularly</li> <li>Review Security Credentials Management</li> </ul> </li> <li> <p>Isolation Strategies:</p> <ul> <li>Run scanner components in dedicated namespaces</li> <li>Implement resource quotas to prevent resource exhaustion</li> <li>Use node selectors or taints/tolerations for specialized workloads</li> </ul> </li> <li> <p>Monitoring and Alerting:</p> <ul> <li>Implement monitoring for scanner components</li> <li>Set up alerts for scanner failures or security issues</li> <li>Log and audit scanner activities</li> </ul> </li> </ul>"},{"location":"learning-paths/implementation/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>Container Security Standards - Implements controls for container security assessment</li> <li>Continuous Monitoring - Establishes continuous security assessment for container environments</li> <li>Change Management - Integrates security scanning into change management processes</li> <li>Vulnerability Management - Creates a workflow for identifying and addressing container security issues</li> </ul>"},{"location":"learning-paths/implementation/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>Advanced Features - Explore advanced security capabilities</li> <li>Security-First Implementation - Enhance security controls</li> <li>Implement advanced configurations from Advanced Topics</li> </ul>"},{"location":"learning-paths/implementation/#related-resources","title":"Related Resources","text":"<ul> <li>Deployment Scenarios</li> <li>Security Components</li> <li>Operations Guide</li> </ul>"},{"location":"learning-paths/implementation/#related-tasks","title":"Related Tasks","text":"<ul> <li>Script Deployment - Deploy using scripts directly</li> <li>Helm Deployment - Deploy using Helm charts</li> <li>Kubernetes Setup - Set up Kubernetes environment</li> <li>RBAC Setup - Configure RBAC permissions</li> <li>Token Management - Manage access tokens</li> <li>Thresholds Configuration - Configure security thresholds</li> <li>GitHub Integration - Integrate with GitHub Actions</li> <li>GitLab Integration - Integrate with GitLab CI</li> </ul>"},{"location":"learning-paths/inventory/","title":"Learning Paths Directory Inventory","text":"<p>This directory contains learning paths that guide users through using Kube CINC Secure Scanner with a security-first approach.</p>"},{"location":"learning-paths/inventory/#files","title":"Files","text":"<ul> <li>index.md - Overview and introduction to learning paths</li> <li>template.md - Template for creating new learning paths</li> <li>new-users.md - Getting started guide for new users</li> <li>security-first.md - Security-optimized implementation path</li> <li>core-concepts.md - Foundation of security principles</li> <li>implementation.md - Implementation with security checks</li> <li>advanced-features.md - Advanced security features</li> </ul>"},{"location":"learning-paths/inventory/#purpose","title":"Purpose","text":"<p>Learning paths provide structured, task-oriented guides that incorporate security considerations at every step. They help different user roles understand and implement Kube CINC Secure Scanner according to their specific needs while maintaining a strong security posture.</p>"},{"location":"learning-paths/new-users/","title":"New User Guide","text":""},{"location":"learning-paths/new-users/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Security is a foundational principle of Kube CINC Secure Scanner. This guide establishes secure practices from the beginning, ensuring your implementation follows security best practices from day one.</p> <p>This learning path guides you through setting up and using Kube CINC Secure Scanner for the first time. By completing this path, you will understand how to deploy the scanner, run your first security scan, and interpret the results while maintaining a strong security posture.</p> <p>Time to complete: 45-60 minutes</p> <p>Target audience: New users, DevOps engineers, Security professionals</p> <p>Security level: Basic</p>"},{"location":"learning-paths/new-users/#prerequisites","title":"Prerequisites","text":"<ul> <li> A running Kubernetes cluster (minikube, kind, or production cluster)</li> <li> kubectl configured to access your cluster</li> <li> Basic understanding of Kubernetes concepts (pods, deployments, namespaces)</li> </ul> <p>Kubernetes Setup</p> <p>If you don't have a Kubernetes cluster set up, follow our Minikube Setup Guide to create a local environment. For existing clusters, check our Existing Cluster Requirements to ensure compatibility.</p>"},{"location":"learning-paths/new-users/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/new-users/#step-1","title":"Step 1: Environment Setup","text":"<p>Security Consideration</p> <p>Always use separate namespaces for scanner components to implement proper isolation and follow the principle of least privilege.</p> <p>In this step, you'll set up your environment to run Kube CINC Secure Scanner.</p> <p> Clone Repository</p> <pre><code>git clone https://github.com/mitre/kube-secure-scanner.git\ncd kube-secure-scanner\n</code></pre> <p> Set Up Minikube</p> <pre><code>./kubernetes-scripts/setup-minikube.sh\n</code></pre> <p> Verify Setup</p> <pre><code>kubectl get pods -A\n</code></pre> <ul> <li> Setup started</li> <li> Repository cloned</li> <li> Minikube running</li> <li> First scan completed</li> </ul> <p>Estimated time: 10 minutes</p> <p>Success criteria: Minikube is running and you can see pods in the kube-system namespace.</p>"},{"location":"learning-paths/new-users/#step-2","title":"Step 2: Understanding Scanner Approaches","text":"<p>Security Consideration</p> <p>Different scanning approaches have different security implications. Understanding these is crucial for making appropriate implementation decisions.</p> <p>Kube CINC Secure Scanner supports multiple approaches for scanning containers:</p> <ul> <li> <p> Documentation</p> <p>Review the approaches documentation:</p> <ul> <li>Approaches Overview</li> <li>Approach Comparison</li> <li>Decision Matrix</li> </ul> </li> <li> <p> Scanning Approaches</p> Standard ContainerSidecar ContainerDebug Container <p>Kubernetes API Approach</p> <ul> <li>Most common approach</li> <li>Uses train-k8s-container transport</li> <li>Best for standard containers</li> <li>Learn more</li> </ul> <p>Process Namespace Sharing</p> <ul> <li>Enhanced isolation</li> <li>Requires pod modifications</li> <li>Works with any container type</li> <li>Learn more</li> </ul> <p>Ephemeral Container Approach</p> <ul> <li>Designed for distroless containers</li> <li>Requires K8s 1.16+ with ephemeral containers</li> <li>No changes to target containers</li> <li>Learn more</li> </ul> </li> </ul> <ul> <li> Setup started</li> <li> Repository cloned</li> <li> Minikube running</li> <li> Approaches reviewed</li> <li> First scan completed</li> </ul> <p>Estimated time: 15 minutes</p> <p>Success criteria: You can explain the different scanning approaches and their security implications.</p>"},{"location":"learning-paths/new-users/#step-3","title":"Step 3: Running Your First Scan","text":"<p>Security Consideration</p> <p>Start with scanning in a non-production environment until you're comfortable with the process and have validated the security implications.</p> <p>Now you'll run your first container security scan:</p> <ol> <li>Create a test pod:</li> </ol> <pre><code>kubectl apply -f test-pod.yaml\n</code></pre> <ol> <li>Wait for the pod to be ready:</li> </ol> <pre><code>kubectl get pods\n</code></pre> <ol> <li>Run a scan using the standard approach:</li> </ol> <pre><code>./kubernetes-scripts/scan-container.sh default test-pod test-container examples/cinc-profiles/container-baseline\n</code></pre> <ol> <li>Review the scan results:</li> </ol> <pre><code># Results are stored in JSON format\ncat results/container-scan-results.json\n</code></pre> <p>Estimated time: 15 minutes</p> <p>Success criteria: You've successfully scanned a container and can view the security assessment results.</p>"},{"location":"learning-paths/new-users/#step-4","title":"Step 4: Understanding Scan Results","text":"<p>Security Consideration</p> <p>Learn to interpret results correctly to avoid false negatives that could leave vulnerabilities unaddressed.</p> <ol> <li>Open and examine the scan results:</li> <li>Identify the controls that passed and failed</li> <li>Understand the severity levels</li> <li> <p>Note recommendations for remediation</p> </li> <li> <p>Learn about thresholds and how they're used to determine scan pass/fail:</p> </li> <li>Basic Thresholds</li> <li>Advanced Thresholds</li> </ol> <p>Estimated time: 10 minutes</p> <p>Success criteria: You can interpret scan results and understand what actions might be needed to address findings.</p>"},{"location":"learning-paths/new-users/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations for new users:</p> <ul> <li>Always use the principle of least privilege when configuring RBAC for the scanner</li> <li>Consider using namespaces to isolate scanner components from your application</li> <li>Evaluate the security implications of each scanning approach before implementation</li> <li>Ensure scan results are securely stored and not exposed to unauthorized users</li> <li>Consider integrating scanning into your CI/CD pipeline for continuous security assessment</li> </ul>"},{"location":"learning-paths/new-users/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>Container Security - Establishes a foundation for systematic container security assessment</li> <li>Configuration Compliance - Helps identify misconfigurations that could violate compliance requirements</li> <li>Continuous Monitoring - Sets up a process for ongoing security monitoring</li> </ul>"},{"location":"learning-paths/new-users/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>Security-First Implementation - Implement with security as the primary focus</li> <li>Core Concepts - Deepen your understanding of fundamental concepts</li> <li>Implementation Guide - Get detailed implementation instructions</li> </ul>"},{"location":"learning-paths/new-users/#related-resources","title":"Related Resources","text":"<ul> <li>Security Overview</li> <li>Configuration Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"learning-paths/security-first/","title":"Security-First Implementation","text":""},{"location":"learning-paths/security-first/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This learning path prioritizes security at every step, ensuring your implementation adheres to security best practices, follows the principle of least privilege, and incorporates defense-in-depth strategies.</p> <p>This learning path guides you through implementing Kube CINC Secure Scanner with security as the primary focus. By following this path, you will create a highly secure implementation that balances security requirements with operational needs.</p> <p>Time to complete: 90-120 minutes</p> <p>Target audience: Security professionals, DevSecOps engineers, Compliance officers</p> <p>Security risk: \ud83d\udfe2 Low - Focuses on security-enhancing implementation patterns</p> <p>Security approach: Implements defense-in-depth strategy with layered security controls, least-privilege access management, and secure-by-design principles</p>"},{"location":"learning-paths/security-first/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>A security-first implementation requires careful management of multiple permission layers:</p> <p>1. Cluster Administrator Permissions * Control: Installation of core components and management of cluster-wide resources * Risk area: Over-provisioned admin accounts could compromise the entire cluster * Mitigation: Use dedicated service accounts for administration with time-limited credentials</p> <p>2. Namespace-Level Security Controls * Control: Isolation between different scanning operations and target resources * Risk area: Cross-namespace access could lead to privilege escalation * Mitigation: Implement strict namespace boundaries with proper RBAC and network policies</p> <p>3. Container Scanner Permissions * Control: Scanner's ability to access and evaluate container content * Risk area: Scanner credentials could be exposed if not properly managed * Mitigation: Generate ephemeral, single-use credentials scoped to specific containers</p>"},{"location":"learning-paths/security-first/#prerequisites","title":"Prerequisites","text":"<ul> <li> Basic understanding of Kubernetes security concepts</li> <li> Familiarity with RBAC and Kubernetes security controls</li> <li> Completed the New User Guide or equivalent experience</li> <li> Administrative access to a Kubernetes cluster</li> </ul>"},{"location":"learning-paths/security-first/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/security-first/#step-1","title":"Step 1: Security Principles Assessment","text":"<p>Security Consideration</p> <p>Understanding the security principles before implementation ensures your design decisions align with security best practices.</p> <ol> <li>Review the security principles documentation:</li> <li>Security Principles Overview</li> <li>Least Privilege Principle</li> <li>Ephemeral Credentials</li> <li>Resource Isolation</li> <li> <p>Secure Transport</p> </li> <li> <p>Complete the security assessment checklist:</p> </li> <li> Identify sensitive data flows in your environment</li> <li> Document security boundaries and trust zones</li> <li> Define minimum required permissions for scanner operation</li> <li> Determine isolation requirements for your environment</li> </ol> <p>Estimated time: 20 minutes</p> <p>Success criteria: Completed security assessment checklist with documented security requirements.</p>"},{"location":"learning-paths/security-first/#step-2","title":"Step 2: Secure Configuration Planning","text":"<p>Security Consideration</p> <p>Properly configured RBAC is critical for maintaining the principle of least privilege and preventing unauthorized access.</p> <ol> <li>Design your RBAC configuration:</li> <li>Review RBAC Configuration and Label-Based RBAC</li> <li>Create roles with minimum necessary permissions</li> <li> <p>Consider using namespace isolation</p> </li> <li> <p>Plan service account configuration:</p> </li> <li>Review Service Accounts</li> <li>Document service account requirements</li> <li> <p>Consider time-limited tokens</p> </li> <li> <p>Review kubeconfig security:</p> </li> <li>Kubeconfig Security</li> <li>Dynamic Kubeconfig Generation</li> </ol> <p>Estimated time: 25 minutes</p> <p>Success criteria: Documented RBAC plan, service account strategy, and kubeconfig security controls.</p>"},{"location":"learning-paths/security-first/#step-3","title":"Step 3: Secure Deployment","text":"<p>Security Consideration</p> <p>Implement defense-in-depth by applying security controls at each layer of your deployment.</p> <ol> <li>Create dedicated namespaces for scanner components:</li> </ol> <pre><code>kubectl create namespace scanner-system\n</code></pre> <ol> <li>Apply RBAC configurations:</li> </ol> <pre><code># Apply your custom RBAC configuration or use the provided template\nkubectl apply -f kubernetes/templates/rbac.yaml\n</code></pre> <ol> <li>Deploy using Helm with security-focused values:</li> <li>Review Helm Security Best Practices</li> <li>Deploy scanner infrastructure with security hardening:</li> </ol> <pre><code>cd helm-charts\nhelm install scanner-infra scanner-infrastructure/ --values scanner-infrastructure/examples/values-production.yaml\n</code></pre> <ol> <li>Verify security controls:</li> </ol> <pre><code># Verify RBAC\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner list pods\n</code></pre> <p>Estimated time: 30 minutes</p> <p>Success criteria: Scanner deployed with RBAC, namespace isolation, and security hardening measures.</p>"},{"location":"learning-paths/security-first/#step-4","title":"Step 4: Security Testing and Validation","text":"<p>Security Consideration</p> <p>Validate security controls to ensure they're effective and identify any gaps that need to be addressed.</p> <ol> <li>Perform security testing:</li> <li>Test RBAC boundaries</li> <li>Verify namespace isolation</li> <li> <p>Attempt to access scanner from unauthorized contexts</p> </li> <li> <p>Run security scan with thresholds:</p> </li> </ol> <pre><code>./kubernetes-scripts/scan-container.sh scanner-system scanner-pod scanner-container examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre> <ol> <li> <p>Review scan results and security indicators.</p> </li> <li> <p>Document security posture and any identified gaps.</p> </li> </ol> <p>Estimated time: 25 minutes</p> <p>Success criteria: Validated security controls and documented security posture.</p>"},{"location":"learning-paths/security-first/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations:</p> <ul> <li> <p>Network Security:</p> <ul> <li>Use network policies to restrict communication between components</li> <li>Implement TLS for all communications</li> <li>Consider using service mesh for additional security controls</li> </ul> </li> <li> <p>Credential Management:</p> <ul> <li>Use short-lived credentials whenever possible</li> <li>Rotate service account tokens regularly</li> <li>Store sensitive configuration in Kubernetes Secrets</li> </ul> </li> <li> <p>Monitoring and Auditing:</p> <ul> <li>Enable audit logging for scanner activities</li> <li>Monitor for unauthorized access attempts</li> <li>Implement alerting for security-relevant events</li> </ul> </li> <li> <p>Compliance Controls:</p> <ul> <li>Document how implementation meets compliance requirements</li> <li>Maintain evidence of security controls for audits</li> <li>Establish regular security review process</li> </ul> </li> </ul>"},{"location":"learning-paths/security-first/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>Kubernetes STIG - Implements controls aligned with DISA Kubernetes STIG requirements</li> <li>CIS Benchmarks - Follows CIS Kubernetes Benchmark recommendations</li> <li>NIST 800-53 - Addresses Access Control (AC), Audit and Accountability (AU), and System and Information Integrity (SI) controls</li> <li>DoD 8500.01 - Supports implementation of security controls required by DoD directives</li> </ul>"},{"location":"learning-paths/security-first/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>Advanced Features - Explore advanced security capabilities</li> <li>Implementation Guide - Get comprehensive implementation details</li> <li>Review Security Risk Model to understand residual risks</li> </ul>"},{"location":"learning-paths/security-first/#related-resources","title":"Related Resources","text":"<ul> <li>Security Risk Assessment</li> <li>Threat Model</li> <li>Compliance Documentation</li> <li>NSA/CISA Kubernetes Hardening Guide Alignment</li> </ul>"},{"location":"learning-paths/template/","title":"Learning Path Template","text":""},{"location":"learning-paths/template/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This section highlights key security aspects of this learning path and why they matter.</p> <p>This learning path guides you through [brief description]. By completing this path, you will understand how to [key outcomes] while maintaining a strong security posture.</p> <p>Time to complete: [estimated time]</p> <p>Target audience: [intended audience - roles/experience level]</p> <p>Security risk: \ud83d\udfe1 Medium - [Brief description of security considerations]</p> <p>Security approach: [Brief description of how security is managed in this learning path]</p>"},{"location":"learning-paths/template/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>[Learning path name] involves multiple distinct permission layers that must be properly managed:</p> <p>1. [Layer Name] Permissions * Control: [What this permission layer governs] * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p> <p>2. [Layer Name] Permissions * Control: [What this permission layer governs]  * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p> <p>3. [Layer Name] Permissions * Control: [What this permission layer governs] * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p>"},{"location":"learning-paths/template/#prerequisites","title":"Prerequisites","text":"<ul> <li> [Prerequisite 1]</li> <li> [Prerequisite 2]</li> <li> [Basic understanding of Kubernetes security concepts]</li> </ul>"},{"location":"learning-paths/template/#learning-path-steps","title":"Learning Path Steps","text":""},{"location":"learning-paths/template/#step-1","title":"Step 1: [First Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 1]</p> <p>Estimated time: [time]</p> <p>Success criteria: [How to know you've completed this step successfully]</p>"},{"location":"learning-paths/template/#step-2","title":"Step 2: [Second Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 2]</p> <p>Estimated time: [time]</p> <p>Success criteria: [How to know you've completed this step successfully]</p>"},{"location":"learning-paths/template/#step-3","title":"Step 3: [Third Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 3]</p> <p>Estimated time: [time]</p> <p>Success criteria: [How to know you've completed this step successfully]</p>"},{"location":"learning-paths/template/#security-considerations","title":"Security Considerations","text":"<p>This section provides a comprehensive overview of security considerations for this learning path:</p> <ul> <li>[Security consideration 1]</li> <li>[Security consideration 2]</li> <li>[Security consideration 3]</li> </ul>"},{"location":"learning-paths/template/#compliance-relevance","title":"Compliance Relevance","text":"<p>This learning path helps address the following compliance requirements:</p> <ul> <li>[Compliance requirement 1] - [How this path helps]</li> <li>[Compliance requirement 2] - [How this path helps]</li> </ul>"},{"location":"learning-paths/template/#next-steps","title":"Next Steps","text":"<p>After completing this learning path, consider:</p> <ul> <li>[Suggested next path 1]</li> <li>[Suggested next path 2]</li> <li>[Suggested advanced security topic]</li> </ul>"},{"location":"learning-paths/template/#related-resources","title":"Related Resources","text":"<ul> <li>[Link to related documentation]</li> <li>[Link to related example]</li> <li>[Link to related security documentation]</li> </ul>"},{"location":"overview/","title":"Technical Architecture Overview","text":"<p>This document provides a solution architect's view of the Secure CINC Auditor Kubernetes Container Scanning platform, covering system components, interactions, and technical implementation details.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Overview Documentation Inventory.</p>"},{"location":"overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph TD\n    classDef controller fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef scanner fill:#bbf,stroke:#333,stroke-width:2px;\n    classDef container fill:#bfb,stroke:#333,stroke-width:2px;\n    classDef rbac fill:#fbb,stroke:#333,stroke-width:2px;\n\n    CI[\"CI/CD System\"]\n    SA[\"Service Account\"] ---|creates token| TOKEN[\"Short-lived Token&lt;br&gt;(15min)\"]\n    TOKEN --&gt;|populates| KC[\"Kubeconfig\"]\n    CINC[\"CINC Auditor&lt;br&gt;InSpec\"] --&gt;|uses| TRANSPORT[\"train-k8s-container&lt;br&gt;Transport\"]\n    TRANSPORT --&gt;|reads| KC\n    TRANSPORT --&gt;|connects to| API[\"Kubernetes API\"]\n    API --&gt;|validates| RBAC[\"RBAC Rules\"]\n    RBAC --&gt;|restricts access to| POD[\"Target Pod\"]\n    POD --&gt;|contains| CONTAINER[\"Container\"]\n    TRANSPORT --&gt;|scans| CONTAINER\n    CINC --&gt;|produces| RESULTS[\"Scan Results\"]\n    RESULTS --&gt;|processed by| SAF[\"MITRE SAF CLI\"]\n    SAF --&gt;|validates against| THRESHOLD[\"Threshold Config\"]\n\n    CI --&gt;|runs| CINC\n    CI --&gt;|uses| SA\n\n    class CINC scanner;\n    class TRANSPORT scanner;\n    class API controller;\n    class RBAC rbac;\n    class POD container;\n    class CONTAINER container;</code></pre>"},{"location":"overview/#core-components","title":"Core Components","text":"Component Purpose Implementation CINC Auditor Security &amp; compliance scanning engine InSpec-compatible open source scanner train-k8s-container Kubernetes transport plugin Custom Ruby transport for InSpec Service Accounts Identity for scanner Kubernetes service account with limited lifespan RBAC Configuration Access control Kubernetes Roles and RoleBindings Token Generator Temporary credentials kubectl create token with 15min expiry Kubeconfig API access configuration Generated config with embedded token Threshold Configuration Compliance validation YAML-based pass/fail criteria MITRE SAF CLI Results processing JSON processor with report generation"},{"location":"overview/#implementation-approaches","title":"Implementation Approaches","text":"<p>The platform implements three technical approaches for container scanning:</p>"},{"location":"overview/#1-kubernetes-api-approach-standard-future-distroless","title":"1. Kubernetes API Approach (Standard + Future Distroless)","text":"<pre><code>sequenceDiagram\n    participant CI as CI/CD Pipeline\n    participant CINC as CINC Auditor\n    participant K8S as Kubernetes API\n    participant POD as Target Pod\n\n    CI-&gt;&gt;K8S: Create temporary token\n    K8S--&gt;&gt;CI: Token (15min validity)\n    CI-&gt;&gt;CINC: Run scan with token\n    CINC-&gt;&gt;K8S: Connect via transport\n    K8S-&gt;&gt;K8S: Validate RBAC permissions\n    K8S-&gt;&gt;POD: Execute commands\n    POD--&gt;&gt;K8S: Command results\n    K8S--&gt;&gt;CINC: Results\n    CINC--&gt;&gt;CI: Scan report</code></pre> <p>Technical characteristics:</p> <ul> <li>Uses standard Kubernetes API (exec into pod)</li> <li>Leverages train-k8s-container transport</li> <li>Most secure and scalable enterprise approach</li> <li>Clean from a compliance perspective</li> <li>Future enhancement will add distroless support</li> </ul>"},{"location":"overview/#2-debug-container-approach-interim-for-distroless","title":"2. Debug Container Approach (Interim for Distroless)","text":"<pre><code>sequenceDiagram\n    participant CI as CI/CD Pipeline\n    participant DEBUG as Debug Container\n    participant POD as Target Pod (Distroless)\n\n    CI-&gt;&gt;K8S: Create temporary token\n    K8S--&gt;&gt;CI: Token (15min validity)\n    CI-&gt;&gt;K8S: Attach debug container\n    K8S-&gt;&gt;POD: Inject debug container\n    CI-&gt;&gt;DEBUG: Run CINC Auditor\n    DEBUG-&gt;&gt;DEBUG: chroot to container filesystem\n    DEBUG-&gt;&gt;POD: Access container filesystem\n    DEBUG--&gt;&gt;CI: Scan results\n    CI-&gt;&gt;K8S: Remove debug container</code></pre> <p>Technical characteristics:</p> <ul> <li>Uses ephemeral debug containers (K8s 1.16+)</li> <li>Requires specific Kubernetes feature flags</li> <li>Uses chroot for filesystem access</li> <li>Interim solution for distroless containers</li> </ul>"},{"location":"overview/#3-sidecar-container-approach-universal-compatibility","title":"3. Sidecar Container Approach (Universal Compatibility)","text":"<pre><code>sequenceDiagram\n    participant CI as CI/CD Pipeline\n    participant SIDECAR as Sidecar Container\n    participant POD as Target Container\n\n    CI-&gt;&gt;K8S: Deploy pod with sidecar\n    K8S-&gt;&gt;POD: Start containers with shared namespace\n    SIDECAR-&gt;&gt;SIDECAR: Find target process\n    SIDECAR-&gt;&gt;POD: Access via /proc/PID/root\n    SIDECAR-&gt;&gt;SIDECAR: Run CINC Auditor scan\n    SIDECAR--&gt;&gt;CI: Retrieve scan results</code></pre> <p>Technical characteristics:</p> <ul> <li>Uses shared process namespace in pod</li> <li>Works with any Kubernetes version</li> <li>Must deploy alongside target container</li> <li>Requires pod modification</li> <li>Universal compatibility approach</li> </ul>"},{"location":"overview/#component-relationships","title":"Component Relationships","text":""},{"location":"overview/#rbac-model","title":"RBAC Model","text":"<pre><code>graph LR\n    SA[Service Account] --&gt;|bound to| ROLE[Role]\n    ROLE --&gt;|permits| GET_PODS[get pods]\n    ROLE --&gt;|permits| LIST_PODS[list pods]\n    ROLE --&gt;|permits| EXEC[create pods/exec]\n    ROLE --&gt;|restricted to| NAMESPACE[namespace]\n    ROLE --&gt;|restricted to| POD_NAMES[pod names]\n    ROLE --&gt;|optional| LABEL_SELECTOR[label selector]</code></pre> <p>The RBAC model provides minimal permissions:</p> <ul> <li><code>get pods</code> - View specific pods</li> <li><code>list pods</code> - List available pods</li> <li><code>create pods/exec</code> - Execute commands in pod</li> <li>Restrictions are applied at namespace, pod, and/or label level</li> </ul>"},{"location":"overview/#scanning-workflow-integration-points","title":"Scanning Workflow Integration Points","text":"<pre><code>graph TD\n    CI[\"CI/CD System\"] --&gt;|triggers| SCAN[Container Scan]\n    SCAN --&gt;|uses| SA[Service Account]\n    SCAN --&gt;|runs| CINC[CINC Auditor]\n    SCAN --&gt;|generates| RESULTS[Scan Results]\n    RESULTS --&gt;|validated by| SAF[MITRE SAF CLI]\n    SAF --&gt;|against| THRESHOLD[Threshold Config]\n    THRESHOLD --&gt;|success/failure| CI\n\n    subgraph \"Integration Points\"\n        SAF\n        THRESHOLD\n        SA\n    end</code></pre>"},{"location":"overview/#deployment-options","title":"Deployment Options","text":"Approach Implementation Best For Shell Scripts Standalone bash scripts Quick setup, testing, custom workflows Helm Charts Modular chart architecture Production environments, GitOps workflows GitLab CI CI/CD pipeline configuration Automated scanning in GitLab GitLab Services Container service configuration Advanced GitLab pipeline integration GitHub Actions Workflow YAML files Automated scanning in GitHub"},{"location":"overview/#directory-structure","title":"Directory Structure","text":"<pre><code>/\n\u251c\u2500\u2500 docs/                    # Documentation\n\u251c\u2500\u2500 scripts/                 # Automation scripts\n\u2502   \u251c\u2500\u2500 generate-kubeconfig.sh  # Generate restricted kubeconfig\n\u2502   \u251c\u2500\u2500 scan-container.sh    # End-to-end container scanning\n\u2502   \u251c\u2500\u2500 scan-distroless-container.sh # Scanning distroless containers\n\u2502   \u2514\u2500\u2500 scan-with-sidecar.sh # Scanning with sidecar container approach\n\u251c\u2500\u2500 kubernetes/              # Kubernetes manifests\n\u2502   \u2514\u2500\u2500 templates/           # Template YAML files\n\u251c\u2500\u2500 helm-charts/             # Modular Helm charts for deployment\n\u2502   \u251c\u2500\u2500 scanner-infrastructure/ # Core RBAC, service accounts\n\u2502   \u251c\u2500\u2500 common-scanner/      # Common scanning components \n\u2502   \u251c\u2500\u2500 standard-scanner/    # Standard container scanning\n\u2502   \u251c\u2500\u2500 distroless-scanner/  # Distroless container scanning\n\u2502   \u2514\u2500\u2500 sidecar-scanner/     # Sidecar approach for container scanning\n\u251c\u2500\u2500 github-workflow-examples/ # GitHub Actions workflow examples\n\u251c\u2500\u2500 gitlab-pipeline-examples/ # GitLab CI examples\n\u2514\u2500\u2500 examples/                # Example resources and profiles\n</code></pre>"},{"location":"overview/#technical-decisions-strategic-direction","title":"Technical Decisions &amp; Strategic Direction","text":""},{"location":"overview/#core-technical-decisions","title":"Core Technical Decisions","text":"<ol> <li>Security-First Design: Using least-privilege RBAC model with temporary credentials</li> <li>Pluggable Architecture: Modular design supporting multiple scanning approaches</li> <li>Transport Plugin: Using train-k8s-container transport for Kubernetes API-based scanning</li> <li>Threshold Validation: Implementing MITRE SAF CLI integration for compliance validation</li> <li>Distroless Strategy: Multi-approach implementation with migration path to unified API approach</li> </ol>"},{"location":"overview/#strategic-technical-direction","title":"Strategic Technical Direction","text":"<p>The project's strategic technical roadmap:</p> <ol> <li>Near-term: Continued support for all three approaches with best-practice implementations</li> <li>Mid-term: Enhance train-k8s-container plugin to support distroless containers</li> <li>Long-term: Converge on the Kubernetes API approach as the universal solution for all container types</li> </ol> <p>For detailed scanning workflows, see Workflow Diagrams.</p>"},{"location":"overview/ascii-diagrams/","title":"ASCII Text-Based Workflow and Architecture Diagrams","text":"<p>This document provides ASCII text-based diagrams for the key workflows and architectures in our project. These diagrams are intended to complement the Mermaid diagrams and provide a more accessible alternative that can be viewed directly in a terminal or without rendering.</p>"},{"location":"overview/ascii-diagrams/#minikube-architecture","title":"Minikube Architecture","text":"<pre><code>+-----------------------------------------------------------------------+\n|                                                                       |\n|                          MINIKUBE CLUSTER                             |\n|                                                                       |\n|  +-------------------------+        +-------------------------+        |\n|  |                         |        |                         |        |\n|  |      CONTROL NODE       |        |      WORKER NODE 1      |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |  kube-apiserver   |  |        |  | Target Containers |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |       etcd        |  |        |  |   Scanner Pods    |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  +-------------------------+        +-------------------------+        |\n|                                                                       |\n|                                                                       |\n|                           +-------------------------+                  |\n|                           |                         |                  |\n|                           |      WORKER NODE 2      |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |  Debug Containers |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |   Sidecar Pods    |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           +-------------------------+                  |\n|                                                                       |\n+-----------------------------------------------------------------------+\n                        |                |                |\n                        |                |                |\n                        v                v                v\n          +------------------+  +------------------+  +------------------+\n          |                  |  |                  |  |                  |\n          |   CINC Profiles  |  | Service Accounts |  |     SAF CLI      |\n          |   (Compliance    |  |    and RBAC      |  |  (Reporting &amp;    |\n          |    Controls)     |  |  (Access Control)|  |  Thresholds)     |\n          |                  |  |                  |  |                  |\n          +------------------+  +------------------+  +------------------+\n</code></pre>"},{"location":"overview/ascii-diagrams/#standard-container-scanning-workflow-approach-1","title":"Standard Container Scanning Workflow (Approach 1)","text":"<pre><code>              START STANDARD CONTAINER SCANNING\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|              STEP 1: SETUP &amp; PREPARATION                 |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |     Identify     |---------&gt;|  Create RBAC and   |    |\n|  |     Target       |          |  Service Account   |    |\n|  |     Container    |          |                    |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Generate Short-lived         |\n|                      |       Security Token               |\n|                      |                                    |\n|                      +------------------------------------+\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Create Restricted            |\n|                      |       Kubeconfig File              |\n|                      |                                    |\n|                      +------------------------------------+\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|                STEP 2: SCANNING EXECUTION                |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Run CINC      |          |    Process with    |    |\n|  |    Auditor with  |&lt;---------|    SAF CLI &amp;       |    |\n|  |    k8s-container |          |    Check Threshold |    |\n|  |    Transport     |          |                    |    |\n|  +------------------+          +--------------------+    |\n|          |                                              |\n|          v                                              |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Generate      |---------&gt;|    Clean up RBAC   |    |\n|  |    Reports and   |          |    &amp; Service       |    |\n|  |    Validations   |          |    Account         |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n                       SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#distroless-container-debug-container-approach-approach-2","title":"Distroless Container - Debug Container Approach (Approach 2)","text":"<pre><code>         START DEBUG CONTAINER APPROACH FOR DISTROLESS CONTAINERS\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 1: ATTACH DEBUG CONTAINER                    |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Identify        |-------&gt;|  Create Ephemeral       |     |\n|  |    Distroless      |        |  Debug Container with   |     |\n|  |    Target Container|        |  kubectl debug command  |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Deploy CINC Auditor in       |     |\n|                       |     Ephemeral Debug Container    |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER  |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Chroot to       |-------&gt;|  Run CINC Auditor       |     |\n|  |    Target Container|        |  Against Target         |     |\n|  |    Filesystem      |        |  Container Root         |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Export Scan Results to       |     |\n|                       |     Host System                  |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Process Results |-------&gt;|  Terminate Debug        |     |\n|  |    with SAF CLI    |        |  Container &amp; Clean Up   |     |\n|  |    Threshold Check |        |  Resources              |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#sidecar-container-approach-approach-3","title":"Sidecar Container Approach (Approach 3)","text":""},{"location":"overview/ascii-diagrams/#ascii-diagram-legacy","title":"ASCII Diagram (Legacy)","text":"<pre><code>            START SIDECAR CONTAINER APPROACH FOR SCANNING\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 1: DEPLOY POD WITH SIDECAR                  |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Deploy Target    |------&gt;|   Deploy Scanner       |       |\n|  |   Container in     |       |   Sidecar Container    |       |\n|  |   Kubernetes Pod   |       |   in Same Pod          |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Enable Shared Process Namespace      ||\n|                      |   Between Containers in Pod            ||\n|                      |   (shareProcessNamespace: true)        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 2: PERFORM SCAN USING SIDECAR               |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Sidecar Finds    |------&gt;|   Access Target        |       |\n|  |   Target Process   |       |   Filesystem via       |       |\n|  |   Using 'ps'       |       |   /proc/PID/root       |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Run CINC Auditor Against             ||\n|                      |   Target Container's Filesystem        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                          |                     |\n|                                          v                     |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Store Results    |------&gt;|   Process Results with |       |\n|  |   in Shared        |       |   SAF CLI &amp; Validate   |       |\n|  |   Volume           |       |   Against Threshold    |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Retrieve Results from Sidecar        ||\n|                      |   via kubectl cp or Volume Mount       ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#mermaid-diagram-wcag-compliant","title":"Mermaid Diagram (WCAG Compliant)","text":"<pre><code>flowchart TD\n    start([Start]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        deploy_target[\"Deploy Target Container in Kubernetes Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container in Same Pod\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace Between Containers\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        find_process[\"Sidecar Finds Target Process Using 'ps'\"] --&gt; access_fs[\"Access Target Filesystem via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target Container's Filesystem\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI &amp; Validate Against Threshold\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar via kubectl cp or Volume Mount\"]\n    end\n\n    step2 --&gt; complete([Scan Complete])\n\n    %% Applying WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step grouping styling\n    style step1 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000\n    style step2 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000</code></pre>"},{"location":"overview/ascii-diagrams/#modified-transport-plugin-approach-approach-1-enterprise","title":"Modified Transport Plugin Approach (Approach 1 - Enterprise)","text":"<pre><code>            START MODIFIED TRANSPORT PLUGIN APPROACH\n                            |\n                            v\n+------------------------------------------------------------+\n|                                                            |\n|          STEP 1: CONTAINER DETECTION AND SETUP             |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Target         |-------&gt;|  Modified            |       |\n|  |  Container      |        |  train-k8s-container |       |\n|  |  Identification |        |  Plugin (Enhanced)   |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                       |                    |\n|                                       v                    |\n|                    +----------------------------------+    |\n|                    |                                  |    |\n|                    |  Auto-Detect if Container        |    |\n|                    |  is Distroless (No Shell)        |    |\n|                    |                                  |    |\n|                    +----------------------------------+    |\n|                             /           \\                  |\n|                            /             \\                 |\n|                           v               v                |\n| +-------------------------+   +---------------------------+|\n| |                         |   |                           ||\n| |  If Regular Container:  |   |  If Distroless Container: ||\n| |  Use Standard Direct    |   |  Automatically Use Debug  ||\n| |  Exec Connection        |   |  Container Fallback       ||\n| |                         |   |                           ||\n| +-------------------------+   +---------------------------+|\n|          |                                   |             |\n|          |                                   v             |\n|          |                    +---------------------------+|\n|          |                    |                           ||\n|          |                    |  Create Temporary Debug   ||\n|          |                    |  Container Automatically  ||\n|          |                    |                           ||\n|          |                    +---------------------------+|\n|          |                                   |             |\n+------------------------------------------------------------+\n                   |                          |\n                   v                          v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 2: SCANNING EXECUTION                    |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Run CINC       |        |  Process Results     |       |\n|  |  Auditor Scan   |-------&gt;|  with SAF CLI &amp;      |       |\n|  |  Transparently  |        |  Check Thresholds    |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 3: CLEANUP (FOR DISTROLESS)              |\n|                                                            |\n|                    +---------------------------+           |\n|                    |                           |           |\n|                    |  If Debug Container Used: |           |\n|                    |  Terminate and Clean Up   |           |\n|                    |  Resources                |           |\n|                    |                           |           |\n|                    +---------------------------+           |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n                          SCAN COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#gitlab-ci-pipeline-with-services","title":"GitLab CI Pipeline with Services","text":"<pre><code>                    GITLAB CI PIPELINE WITH SERVICES\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: PIPELINE SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Start CINC Auditor  |        |\n|  |  Pipeline Begins  |         |  Scanner as a        |        |\n|  |                   |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Deploy Target Container in        |    |\n|                      |  Kubernetes Cluster                |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SECURITY SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Create RBAC &amp;    |--------&gt;|  Generate Short-lived|        |\n|  |  Service Account  |         |  Security Token      |        |\n|  |  in Cluster       |         |                      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Create Restricted kubeconfig      |    |\n|                      |  with Minimal Permissions          |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: SCANNING &amp; REPORTING               |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Execute Scan     |--------&gt;|  Process Results     |        |\n|  |  in Service       |         |  with SAF CLI in     |        |\n|  |  Container        |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Copy Results from Service         |    |\n|                      |  to Pipeline &amp; Generate Reports    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Clean Up Resources in Kubernetes  |    |\n|                      |  (Pods, Service Accounts, RBAC)    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#gitlab-ci-sidecar-approach","title":"GitLab CI Sidecar Approach","text":"<pre><code>                    GITLAB CI SIDECAR APPROACH\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: DEPLOYMENT                         |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Deploy Pod with    |        |\n|  |  Pipeline Begins  |         |  Target Container   |        |\n|  |                   |         |  and Scanner Sidecar|        |\n|  |                   |         |  in Same Pod        |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Enable Shared Process Namespace   |    |\n|                      |  Between Target and Scanner        |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SCANNING                           |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Sidecar Scanner  |--------&gt;|  Scan Target via    |        |\n|  |  Container Starts |         |  /proc Filesystem   |        |\n|  |                   |         |  Access Method      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Store Results in Shared Volume   |    |\n|                      |  and Process with SAF CLI         |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: RESULTS PROCESSING                 |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Retrieve Scan    |--------&gt;|  Process Results    |        |\n|  |  Results from     |         |  and Generate       |        |\n|  |  Sidecar Container|         |  Reports            |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Upload Results as Pipeline       |    |\n|                      |  Artifacts &amp; Clean Up Resources   |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>                   GITHUB ACTIONS WORKFLOW\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster (Kind)         |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Install CINC Auditor &amp;              |    |\n|                    | train-k8s-container Plugin          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: TARGET DEPLOYMENT                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Target    |-------&gt;| Create RBAC &amp;          |        |\n| | Container in     |        | Service Account        |        |\n| | Kubernetes       |        | for Scanner            |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Short-lived Token &amp;        |    |\n|                    | Create Restricted kubeconfig       |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: SCAN &amp; REPORT                       |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Run CINC Auditor |-------&gt;| Process Results with   |        |\n| | Against Target   |        | SAF CLI &amp; Threshold    |        |\n| | Container        |        | Validation             |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Reports, Upload as         |    |\n|                    | GitHub Artifacts &amp; Clean Up         |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#github-actions-sidecar-approach","title":"GitHub Actions Sidecar Approach","text":"<pre><code>                GITHUB ACTIONS SIDECAR APPROACH\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster using Kind     |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Build Scanner Container Image      |    |\n|                    | with CINC Auditor &amp; SAF CLI        |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: DEPLOYMENT &amp; SCANNING               |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Pod with  |-------&gt;| Configure Shared       |        |\n| | Target Container |        | Process Namespace      |        |\n| | and Scanner      |        | Between Containers     |        |\n| | Sidecar          |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Scanner Sidecar Automatically       |    |\n|                    | Finds &amp; Scans Target Container     |    |\n|                    | via /proc/PID/root Access          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: RESULTS PROCESSING                  |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Wait for Scan    |-------&gt;| Retrieve Results       |        |\n| | Completion       |        | from Sidecar Container |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Process Results  |-------&gt;| Upload Results         |        |\n| | with SAF CLI &amp;   |        | as GitHub Artifacts    |        |\n| | Generate Reports |        | &amp; Clean Up Resources   |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"overview/ascii-diagrams/#end-to-end-security-architecture","title":"End-to-End Security Architecture","text":"<pre><code>                   SECURITY ARCHITECTURE\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                SECURITY PRINCIPLES                   |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Principle of   |-----&gt;|   Short-lived    |      |\n|  |   Least          |      |   Token          |      |\n|  |   Privilege      |      |   Generation     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Namespace      |&lt;----&gt;|   No Permanent   |      |\n|  |   Isolation      |      |   Elevated       |      |\n|  |                  |      |   Privileges     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|               IMPLEMENTATION CONTROLS                |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  | Resource-specific|&lt;----&gt;|   Security       |      |\n|  | RBAC Controls    |      |   First Design   |      |\n|  | (Pod-specific)   |      |                  |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Audit Trail    |&lt;----&gt;|   Automatic      |      |\n|  |   of Scan        |      |   Cleanup After  |      |\n|  |   Access         |      |   Scan Completion|      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                COMPLIANCE VALIDATION                 |\n|                                                      |\n|  +--------------------------------------------------+|\n|  |                                                  ||\n|  |            Threshold-based Compliance            ||\n|  |            Validation with SAF CLI               ||\n|  |                                                  ||\n|  |       * Minimum compliance percentage            ||\n|  |       * Maximum critical/high failures           ||\n|  |       * Enforced in CI/CD pipelines              ||\n|  |                                                  ||\n|  +--------------------------------------------------+|\n|                                                      |\n+------------------------------------------------------+\n</code></pre>"},{"location":"overview/ascii-diagrams/#comparison-of-approaches","title":"Comparison of Approaches","text":"<pre><code>+---------------------------------------------------------------------+\n|                                                                     |\n|                        APPROACH COMPARISON                          |\n|                                                                     |\n+---------------------------------------------------------------------+\n|                                                                     |\n|                        KEY CHARACTERISTICS                          |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Works with all      |                |             |                |\n| Kubernetes versions |      No        |     No      |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| Works with          |                |             |                |\n| existing pods       |      Yes       |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| User experience     |    Seamless    |   Complex   |    Medium      |\n| complexity          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Implementation      |    Complex     |   Medium    |    Simple      |\n| difficulty          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                      TECHNICAL REQUIREMENTS                         |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Special K8s         |                |             |                |\n| features needed     |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Ephemeral container |                |             |                |\n| support required    |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Can scan distroless |                |             |                |\n| containers          |      Yes       |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| CI/CD               |                |             |                |\n| integration ease    |    Simple      |   Complex   |    Medium      |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                           IMPLEMENTATION STATUS                     |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Development         | In Progress    | Complete    | Complete       |\n| status              |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Security            |                |             |                |\n| footprint           |    Medium      |   High      |    Medium      |\n+---------------------+----------------+-------------+----------------+\n| Recommended         | Enterprise     | Advanced    | Universal      |\n| usage               | environments   | users       | compatibility  |\n+---------------------+----------------+-------------+----------------+\n| GitHub Actions      |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| GitLab CI           |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n</code></pre>"},{"location":"overview/enterprise-integration-analysis/","title":"Enterprise Integration Analysis","text":"<p>This document analyzes the enterprise integration aspects of the Secure Kubernetes Container Scanning solution, focusing on scalability, maintainability, and user experience considerations for each approach.</p>"},{"location":"overview/enterprise-integration-analysis/#1-scalability-considerations","title":"1. Scalability Considerations","text":""},{"location":"overview/enterprise-integration-analysis/#cluster-level-scalability","title":"Cluster-Level Scalability","text":"Approach Resource Utilization Parallel Scanning Cluster Impact Kubernetes API Approach \ud83d\udfe2 Low (single exec process) \ud83d\udfe2 High (stateless) \ud83d\udfe2 Minimal (API server only) Debug Container Approach \ud83d\udfe0 Medium (ephemeral container) \ud83d\udfe0 Medium (ephemeral limit) \ud83d\udfe0 Moderate (API server + kubelet) Sidecar Container Approach \ud83d\udd34 Higher (persistent sidecar) \ud83d\udfe2 High (pre-deployed) \ud83d\udfe0 Moderate (resource reservation) <p>Analysis:</p> <ul> <li>Kubernetes API Approach provides the lightest resource footprint with minimal cluster impact</li> <li>Debug Container Approach creates moderate load on API server when created dynamically</li> <li>Sidecar Container Approach consumes more persistent resources but distributes load</li> </ul> <p>Recommendations for Scale:</p> <ul> <li>For large clusters (1000+ nodes): Consider distributed scanning with regional controllers</li> <li>For frequent scans (100+ per hour): Pre-deploy sidecar containers to avoid creation overhead</li> <li>For scan batching: Implement rate limiting and queuing for all approaches</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#pipeline-integration-scalability","title":"Pipeline Integration Scalability","text":"Approach Pipeline Parallelism Resource Requirements Multi-Team Support Kubernetes API Approach \ud83d\udfe2 High \ud83d\udfe2 Low \ud83d\udfe2 Simple configuration Debug Container Approach \ud83d\udfe0 Medium \ud83d\udfe0 Medium \ud83d\udfe0 More configuration Sidecar Container Approach \ud83d\udfe0 Medium \ud83d\udfe0 Medium \ud83d\udfe0 More configuration <p>Analysis:</p> <ul> <li>All approaches can scale with pipeline parallelism</li> <li>Kubernetes API Approach has lowest resource requirements per scan</li> <li>All approaches support multi-team usage with proper RBAC segmentation</li> </ul> <p>Recommendations for CI/CD Scale:</p> <ul> <li>Implement dedicated scanning service accounts per team</li> <li>Use dedicated namespaces for scanning operations</li> <li>Consider centralized scanning service for high-volume environments</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#2-maintenance-considerations","title":"2. Maintenance Considerations","text":""},{"location":"overview/enterprise-integration-analysis/#operational-maintenance","title":"Operational Maintenance","text":"Aspect Kubernetes API Approach Debug Container Approach Sidecar Container Approach Upgrade Impact \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Dependency Management \ud83d\udfe2 Simple \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Troubleshooting \ud83d\udfe2 Straightforward \ud83d\udfe0 More complex \ud83d\udfe0 More complex Monitoring \ud83d\udfe2 Standard logs \ud83d\udfe0 Multiple components \ud83d\udfe0 Multiple components <p>Analysis:</p> <ul> <li>Kubernetes API Approach has fewest moving parts and dependencies</li> <li>Debug Container and Sidecar Container approaches require more monitoring points</li> <li>All approaches utilize Kubernetes native logging and events</li> </ul> <p>Maintenance Best Practices:</p> <ul> <li>Document scanner version compatibility with Kubernetes versions</li> <li>Implement automated testing for all scanning approaches after cluster upgrades</li> <li>Create dedicated troubleshooting guides for each approach</li> <li>Monitor scan success rates and duration metrics</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#long-term-sustainability","title":"Long-Term Sustainability","text":"Consideration Kubernetes API Approach Debug Container Approach Sidecar Container Approach Kubernetes Compatibility \ud83d\udfe2 Stable long-term \ud83d\udfe0 Dependent on ephemeral containers \ud83d\udfe2 Stable long-term Future-Proofing \ud83d\udfe2 Core K8s API \ud83d\udfe0 Newer feature \ud83d\udfe2 Core K8s feature Community Support \ud83d\udfe2 Widespread \ud83d\udfe0 Growing \ud83d\udfe2 Widespread Vendor Lock-in Risk \ud83d\udfe2 Low \ud83d\udfe2 Low \ud83d\udfe2 Low Universal Solution \ud83d\udfe2 Yes (with distroless support) \ud83d\udfe0 Limited use cases \ud83d\udfe2 Yes <p>Analysis:</p> <ul> <li>Kubernetes API and Sidecar Container approaches rely on stable, core Kubernetes features</li> <li>Both Kubernetes API and Sidecar Container approaches will be universal solutions</li> <li>The Kubernetes API Approach will be a universal solution once distroless support is implemented</li> <li>Debug Container Approach depends on newer Kubernetes features</li> <li>All approaches avoid vendor lock-in through standard Kubernetes interfaces</li> </ul> <p>Sustainability Recommendations:</p> <ul> <li>Implement version detection in scanning scripts</li> <li>Create compatibility matrix for Kubernetes versions</li> <li>Monitor Kubernetes deprecation notices for impact on scanning approaches</li> <li>Maintain feature parity across all approaches where possible</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#3-user-experience-analysis","title":"3. User Experience Analysis","text":""},{"location":"overview/enterprise-integration-analysis/#developer-experience","title":"Developer Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Learning Curve \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Debugging Ease \ud83d\udfe2 Simple \ud83d\udfe0 More complex \ud83d\udfe0 More complex Local Testing \ud83d\udfe2 Easy \ud83d\udfe0 More setup \ud83d\udfe0 More setup Feedback Speed \ud83d\udfe2 Fast \ud83d\udfe0 Medium \ud83d\udfe2 Fast Container Type Support \ud83d\udfe2 All types (with distroless support) \ud83d\udfe0 Primarily distroless \ud83d\udfe2 All types <p>Analysis:</p> <ul> <li>Kubernetes API Approach provides the most straightforward developer experience</li> <li>Kubernetes API Approach will support all container types once distroless support is implemented</li> <li>Debug Container and Sidecar Container approaches require more understanding of Kubernetes concepts</li> <li>All approaches can be integrated into developer workflows</li> </ul> <p>Developer Experience Recommendations:</p> <ul> <li>Create simplified CLI wrappers for all scanning approaches</li> <li>Provide IDE integrations for scanning operations</li> <li>Build detailed error messages with troubleshooting guidance</li> <li>Implement scan result visualization for quick understanding</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#security-team-experience","title":"Security Team Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Policy Implementation \ud83d\udfe2 Straightforward \ud83d\udfe0 More complex \ud83d\udfe0 More complex Compliance Verification \ud83d\udfe2 Direct evidence \ud83d\udfe2 Direct evidence \ud83d\udfe2 Direct evidence Risk Assessment \ud83d\udfe2 Clear model \ud83d\udfe0 More components \ud83d\udfe0 More components Audit Trail \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs Universal Coverage \ud83d\udfe2 Complete (with distroless support) \ud83d\udfe0 Partial \ud83d\udfe2 Complete Standards Alignment \ud83d\udfe2 High (NIST, CIS, NSA/CISA) \ud83d\udfe2 High \ud83d\udfe2 High <p>Analysis:</p> <ul> <li>All approaches provide strong compliance verification capabilities</li> <li>Kubernetes API Approach has the clearest security model for auditing</li> <li>Kubernetes API Approach will provide complete coverage of all container types with distroless support</li> <li>All approaches support comprehensive logging for audit trails</li> <li>All approaches align with key security standards and benchmarks</li> </ul> <p>Security Experience Recommendations:</p> <ul> <li>Implement scan scheduling with compliance deadlines</li> <li>Create security dashboards for scan coverage and results</li> <li>Develop automated remediation workflows</li> <li>Provide attestation for scan execution and results</li> <li>Map scanning controls to NIST SP 800-190 and CIS Benchmarks</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#operations-team-experience","title":"Operations Team Experience","text":"Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Deployment Complexity \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Resource Management \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Monitoring Requirements \ud83d\udfe2 Basic \ud83d\udfe0 Enhanced \ud83d\udfe0 Enhanced Backup/Restore \ud83d\udfe2 Simple \ud83d\udfe2 Simple \ud83d\udfe2 Simple Universality \ud83d\udfe2 High (with distroless support) \ud83d\udfe0 Medium \ud83d\udfe2 High <p>Analysis:</p> <ul> <li>Kubernetes API Approach is easiest to deploy and manage</li> <li>Kubernetes API Approach will become a universal solution with distroless support</li> <li>Debug Container and Sidecar Container approaches require more operational overhead</li> <li>All approaches have similar backup/restore considerations</li> </ul> <p>Operations Recommendations:</p> <ul> <li>Create Helm charts for all scanning approaches</li> <li>Implement monitoring dashboards for scan operations</li> <li>Develop automated health checks for scanning infrastructure</li> <li>Provide capacity planning guidelines for each approach</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#4-enterprise-integration-patterns","title":"4. Enterprise Integration Patterns","text":""},{"location":"overview/enterprise-integration-analysis/#pattern-1-centralized-scanning-service","title":"Pattern 1: Centralized Scanning Service","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Recommended for enterprise-wide deployment Debug Container Approach \ud83d\udfe0 Limited applicability Primarily for temporary distroless container scanning needs Sidecar Container Approach \ud83d\udfe0 Interim solution Temporary alternative until Kubernetes API Approach supports distroless <p>Implementation:</p> <ul> <li>Central scanning service with dedicated namespace</li> <li>Scanning requests via API or message queue</li> <li>Results stored in central database</li> <li>Role-based access to scan results</li> </ul> <p>Best For: Large enterprises with many teams and strict governance</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-2-distributed-team-ownership","title":"Pattern 2: Distributed Team Ownership","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Simplest adoption path for teams Debug Container Approach \ud83d\udfe0 Situational use For specific debugging scenarios only Sidecar Container Approach \ud83d\udfe0 Temporary solution Additional complexity not ideal for wide team adoption <p>Implementation:</p> <ul> <li>Scanning tools deployed per team</li> <li>Consistent configuration via GitOps</li> <li>Centralized result aggregation</li> <li>Team-specific scanning policies</li> </ul> <p>Best For: Organizations with autonomous teams and strong DevOps culture</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-3-cicd-pipeline-integration","title":"Pattern 3: CI/CD Pipeline Integration","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent fit Simplest and most efficient integration Debug Container Approach \ud83d\udfe0 Limited use case For specialized distroless scanning until API approach supports it Sidecar Container Approach \ud83d\udfe0 Interim solution Workable but with additional complexity <p>Implementation:</p> <ul> <li>Scanning as pipeline stage</li> <li>Dynamic RBAC provisioning</li> <li>Scan results as pipeline artifacts</li> <li>Automatic policy enforcement</li> </ul> <p>Best For: Organizations with mature CI/CD practices</p>"},{"location":"overview/enterprise-integration-analysis/#pattern-4-security-as-a-service","title":"Pattern 4: Security as a Service","text":"Consideration Suitability Notes Kubernetes API Approach \ud83d\udfe2 Excellent foundation Recommended for enterprise-wide security service Debug Container Approach \ud83d\udfe0 Specialized use For specific distroless scenarios during transition Sidecar Container Approach \ud83d\udfe0 Transition solution Temporary approach until Kubernetes API supports distroless <p>Implementation:</p> <ul> <li>Dedicated security team owns scanning infrastructure</li> <li>Self-service portal for scan requests</li> <li>Automated scan scheduling and reporting</li> <li>Integration with security tools ecosystem</li> </ul> <p>Best For: Organizations with dedicated security operations team</p>"},{"location":"overview/enterprise-integration-analysis/#5-integration-with-enterprise-systems","title":"5. Integration with Enterprise Systems","text":""},{"location":"overview/enterprise-integration-analysis/#compatibility-matrix","title":"Compatibility Matrix","text":"Enterprise System Kubernetes API Approach Debug Container Approach Sidecar Container Approach SIEM Integration \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs \ud83d\udfe2 Standard logs CMDB Integration \ud83d\udfe2 Simple mapping \ud83d\udfe2 Simple mapping \ud83d\udfe2 Simple mapping Ticketing Systems \ud83d\udfe2 API integration \ud83d\udfe2 API integration \ud83d\udfe2 API integration Compliance Reporting \ud83d\udfe2 SAF-CLI support \ud83d\udfe2 SAF-CLI support \ud83d\udfe2 SAF-CLI support Vulnerability Management \ud83d\udfe2 Standard format \ud83d\udfe2 Standard format \ud83d\udfe2 Standard format Universal Container Support \ud83d\udfe2 Yes (with distroless support) \ud83d\udfe0 Partial \ud83d\udfe2 Yes <p>Integration Recommendations:</p> <ul> <li>Use SAF-CLI for standardized output across all approaches</li> <li>Implement standard logging format for SIEM integration</li> <li>Create API hooks for ticketing system integration</li> <li>Develop compliance dashboards with drill-down capabilities</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#6-security-standards-alignment","title":"6. Security Standards Alignment","text":"Security Standard Kubernetes API Approach Debug Container Approach Sidecar Container Approach NIST SP 800-190 \ud83d\udfe2 High alignment \ud83d\udfe2 High alignment \ud83d\udfe2 High alignment CIS Docker Benchmark \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment CIS Kubernetes Benchmark \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment NSA/CISA K8s Hardening \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment Docker Best Practices \ud83d\udfe2 High alignment \ud83d\udfe0 Medium alignment \ud83d\udfe0 Medium alignment MITRE ATT&amp;CK for Containers \ud83d\udfe2 Strong mitigations \ud83d\udfe2 Strong mitigations \ud83d\udfe2 Strong mitigations <p>Security Alignment Details:</p> <ol> <li>NIST SP 800-190 Alignment: All approaches implement the recommended controls for container security:</li> <li>Least-privilege access to container resources</li> <li>Proper isolation between containers</li> <li>Validation of container configuration</li> <li> <p>Monitoring of container activities</p> </li> <li> <p>CIS Benchmarks Alignment: The Kubernetes API Approach best aligns with CIS recommendations:</p> </li> <li>Proper RBAC configurations</li> <li>Limited container privileges</li> <li>Resource constraints implementation</li> <li> <p>Container isolation preservation</p> </li> <li> <p>NSA/CISA Kubernetes Hardening: All approaches implement key recommendations:</p> </li> <li>Pod Security Standards implementation</li> <li>Namespace separation and isolation</li> <li>Minimized container capabilities</li> <li> <p>Proper authentication and authorization</p> </li> <li> <p>Docker Best Practices: The Kubernetes API Approach best preserves Docker's \"one application per container\" principle, while the Debug Container and Sidecar approaches temporarily modify this principle for scanning purposes.</p> </li> <li> <p>MITRE ATT&amp;CK Mitigations: All approaches implement controls to mitigate container-specific attack techniques:</p> </li> <li>T1610 (Deploy Container): Prevents unauthorized container deployment</li> <li>T1613 (Container Discovery): Limits visibility to container resources</li> <li>T1543.005 (Container Service): Prevents modification of container configurations</li> </ol>"},{"location":"overview/enterprise-integration-analysis/#7-roi-and-cost-analysis","title":"7. ROI and Cost Analysis","text":"Cost Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Infrastructure Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Implementation Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Training Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Maintenance Cost \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium Long-term Investment Value \ud83d\udfe2 High \ud83d\udfe0 Low \ud83d\udfe0 Medium <p>ROI Considerations:</p> <ul> <li>All approaches provide similar security value</li> <li>Kubernetes API Approach has lowest total cost of ownership</li> <li>Sidecar and Debug Container approaches provide interim distroless container coverage</li> <li>The Kubernetes API Approach will offer the best long-term ROI once distroless support is implemented</li> <li>A universal solution via the Kubernetes API Approach will provide the highest value for enterprise deployments</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#8-enterprise-adoption-roadmap","title":"8. Enterprise Adoption Roadmap","text":""},{"location":"overview/enterprise-integration-analysis/#phase-1-pilot-implementation","title":"Phase 1: Pilot Implementation","text":"<ul> <li>Implement Kubernetes API Approach for standard containers in development environment</li> <li>Train operators and security teams</li> <li>Establish baseline metrics and scanning policies</li> <li>Develop initial integration with enterprise systems</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-2-expanded-coverage-with-interim-solutions","title":"Phase 2: Expanded Coverage with Interim Solutions","text":"<ul> <li>Implement Sidecar Container Approach or Debug Container Approach for distroless containers temporarily</li> <li>Expand to test/staging environments</li> <li>Refine scanning policies and remediation processes</li> <li>Enhance integration with security tools ecosystem</li> <li>Begin development of distroless support for Kubernetes API Approach</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-3-production-deployment","title":"Phase 3: Production Deployment","text":"<ul> <li>Deploy to production environments</li> <li>Complete development of distroless support for Kubernetes API Approach</li> <li>Implement automated compliance reporting</li> <li>Establish scanning governance model</li> <li>Complete enterprise system integrations</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#phase-4-universal-solution-migration","title":"Phase 4: Universal Solution Migration","text":"<ul> <li>Migrate all scanning to Kubernetes API Approach as the universal solution</li> <li>Retire interim solutions (Sidecar and Debug Container approaches)</li> <li>Implement performance optimizations</li> <li>Expand to additional clusters and environments</li> <li>Develop advanced analytics for scanning trends</li> </ul>"},{"location":"overview/enterprise-integration-analysis/#conclusion","title":"Conclusion","text":"<p>Each scanning approach has distinct characteristics that impact enterprise integration. The Kubernetes API Approach offers the simplest integration path with lowest overhead and will become the universal solution once distroless support is implemented. The Debug Container and Sidecar Container approaches provide interim solutions for distroless containers, but with increased complexity.</p> <p>For most enterprises, a strategic phased approach is recommended:</p> <ol> <li>Current State (Transition Period):</li> <li>Use Kubernetes API Approach for all standard containers</li> <li>Use either Debug Container or Sidecar Container approach temporarily for distroless containers</li> <li> <p>Implement consistent tooling and reporting across all approaches</p> </li> <li> <p>Target State (Long-term):</p> </li> <li>Migrate to the Kubernetes API Approach as the universal solution for all container types</li> <li>Benefit from simplified operations, consistent user experience, and lower costs</li> <li>Maintain a single approach for enterprise-wide container scanning</li> <li>Achieve high alignment with industry security standards and frameworks</li> </ol> <p>This analysis provides a foundation for planning enterprise integration of container scanning approaches, considering various factors that impact successful adoption and long-term sustainability, with a clear path toward the recommended Kubernetes API Approach as the universal solution.</p>"},{"location":"overview/executive-summary/","title":"Executive Summary: Secure Kubernetes Container Scanning","text":""},{"location":"overview/executive-summary/#strategic-business-value","title":"Strategic Business Value","text":"<p>The Secure CINC Auditor Kubernetes Container Scanning solution delivers enterprise-grade security scanning for all container types while maintaining robust security posture. This solution addresses critical compliance requirements without compromising your Kubernetes security model.</p>"},{"location":"overview/executive-summary/#business-outcomes","title":"Business Outcomes","text":"<p>Organizations implementing this solution can expect:</p> <ul> <li>40-60% Risk Reduction in container security posture through least-privilege scanning</li> <li>Near 100% Container Coverage including modern distroless containers</li> <li>75% Faster Security Assessments through automated CI/CD integration</li> <li>Regulatory Compliance Alignment with NIST, CIS, DoD, and industry standards</li> </ul>"},{"location":"overview/executive-summary/#implementation-timeline","title":"Implementation Timeline","text":"<pre><code>gantt\n    title Container Scanning Implementation Roadmap\n    dateFormat  YYYY-MM-DD\n    section Phase 1\n    Initial Setup           :a1, 2025-04-01, 7d\n    Standard Container Scanning   :a2, after a1, 14d\n    CI/CD Integration       :a3, after a2, 7d\n    section Phase 2\n    Distroless Container Evaluation  :b1, after a3, 7d\n    Interim Approach Selection    :b2, after b1, 3d\n    Interim Implementation   :b3, after b2, 10d\n    section Phase 3\n    Enterprise-wide Adoption    :c1, after b3, 30d\n    Migration to API Approach   :c2, 2025-07-15, 21d</code></pre>"},{"location":"overview/executive-summary/#strategic-decision-points","title":"Strategic Decision Points","text":""},{"location":"overview/executive-summary/#1-approach-selection","title":"1. Approach Selection","text":"Business Need Recommended Approach Key Benefits Maximum Enterprise Security Kubernetes API Approach \u2022 Least privilege by design\u2022 No container modifications\u2022 Strongest compliance profile Universal Container Coverage Combination Strategy \u2022 API approach for standard containers\u2022 Interim solution for distroless\u2022 Roadmap to universal API approach Immediate Distroless Scanning Sidecar Container Approach \u2022 Works on any cluster\u2022 Simple implementation\u2022 Universal compatibility"},{"location":"overview/executive-summary/#2-compliance-alignment","title":"2. Compliance Alignment","text":"<p>This solution strongly aligns with key regulatory requirements:</p> <ul> <li>NIST SP 800-190 (Container Security)</li> <li>CIS Kubernetes Benchmarks</li> <li>NSA/CISA Kubernetes Hardening Guide</li> <li>DoD 8500.01 and DISA Container Platform SRG</li> <li>Kubernetes STIG (Security Technical Implementation Guide)</li> <li>PCI DSS 4.0 container security requirements</li> <li>HIPAA infrastructure security guidelines</li> </ul> <p>The Kubernetes API Approach achieves 90% alignment with these standards (with near 100% alignment once distroless support is complete), while interim approaches require documented risk acceptance.</p>"},{"location":"overview/executive-summary/#3-investment-protection","title":"3. Investment Protection","text":"<p>Our strategic roadmap ensures your security investment is protected:</p> <ol> <li>Short-term: Implement standard container scanning with the API approach</li> <li>Mid-term: Add distroless container scanning with the most suitable interim approach</li> <li>Long-term: Migrate all scanning to the enhanced API approach once distroless support is complete</li> </ol> <p>This staged approach ensures continuous security coverage while minimizing technical debt.</p>"},{"location":"overview/executive-summary/#risk-mitigation-strategy","title":"Risk Mitigation Strategy","text":"Risk Factor Mitigation Strategy Privileged Access for Scanning Implemented least-privilege model with temporary tokens (15-minute lifespan) Configuration Errors Provided ready-to-use scripts and Helm charts with security controls pre-configured Compliance Documentation Included comprehensive compliance mapping (NIST, CIS, NSA/CISA, DoD) and security analysis for auditors NSA/CISA Hardening Alignment Detailed implementation guidance for all NSA/CISA Kubernetes controls with approach-specific compliance ratings Distroless Container Coverage Multi-approach strategy with planned migration to universal solution"},{"location":"overview/executive-summary/#executive-recommendation","title":"Executive Recommendation","text":"<p>Based on comprehensive security analysis and enterprise integration assessment, we recommend:</p> <ol> <li>Adopt the Kubernetes API Approach for all standard containers immediately</li> <li>Select the Sidecar Container Approach as an interim solution for distroless containers</li> <li>Plan migration to the enhanced API approach within 4-6 months when distroless support is complete</li> </ol> <p>This phased implementation delivers immediate security benefits while positioning your organization for the most secure and compliant long-term solution.</p>"},{"location":"overview/executive-summary/#next-steps-for-decision-makers","title":"Next Steps for Decision Makers","text":"<ol> <li>Review the Security Compliance Analysis for detailed regulatory alignment</li> <li>Examine our NSA/CISA Kubernetes Hardening Guide implementation</li> <li>Explore the Enterprise Integration Analysis for adoption considerations</li> <li>Share the Approach Decision Matrix with your security and DevOps teams</li> <li>Direct implementation teams to the Quickstart Guide</li> </ol> <p>For security and compliance inquiries, see our detailed Risk Analysis and Compliance Documentation.</p>"},{"location":"overview/inventory/","title":"Overview Documentation","text":"<p>This directory contains documentation for the technical overview and architecture of the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"overview/inventory/#directory-contents","title":"Directory Contents","text":"<ul> <li><code>index.md</code> - Main technical architecture overview</li> <li><code>executive-summary.md</code> - Business-focused executive summary</li> <li><code>quickstart.md</code> - Implementation guide for technical users</li> <li><code>enterprise-integration-analysis.md</code> - Enterprise integration considerations</li> <li><code>ascii-diagrams.md</code> - ASCII-based workflow diagrams</li> </ul>"},{"location":"overview/inventory/#documentation-structure","title":"Documentation Structure","text":"<p>The overview section serves as the main technical introduction to the project architecture, scanning approaches, and implementation details.</p> <p>For the full documentation, visit the project documentation site.</p>"},{"location":"project/","title":"Project Documentation","text":"<p>This section contains project-level documentation that outlines the roadmap, changelog, and other administrative aspects of the Kube CINC Secure Scanner project.</p>"},{"location":"project/#overview","title":"Overview","text":"<p>The project documentation provides insight into the development history, planned features, and ongoing work for the Kube CINC Secure Scanner. This information is valuable for understanding the project's direction, tracking progress, and identifying opportunities for contribution.</p>"},{"location":"project/#project-status","title":"Project Status","text":"<p>The Kube CINC Secure Scanner is an actively developed project with regular updates and improvements. The Changelog provides a detailed history of changes, while the Roadmap outlines planned features and enhancements.</p>"},{"location":"project/#documentation-structure","title":"Documentation Structure","text":"<p>The project's documentation is organized according to a specific structure to ensure consistency and ease of navigation. The Documentation Entry Refactoring document explains the current structure and ongoing improvements.</p> <p>Progress on the documentation restructuring is tracked in the Documentation Structure Progress document, which provides a comprehensive matrix of the documentation's current state.</p>"},{"location":"project/#documentation-tools","title":"Documentation Tools","text":"<p>To maintain consistent cross-references as documentation evolves, we've developed specialized tools. The Documentation Tools guide provides comprehensive instructions for using these tools to manage links during reorganization.</p>"},{"location":"project/#terminology","title":"Terminology","text":"<p>To ensure clear and consistent communication, the project maintains a standardized Terminology guide that defines key terms and concepts used throughout the documentation.</p>"},{"location":"project/#documentation-gaps","title":"Documentation Gaps","text":"<p>Ongoing efforts to improve the documentation are tracked in the Documentation Gaps document, which identifies areas that need additional content or clarification.</p>"},{"location":"project/#content-organization","title":"Content Organization","text":"<p>The Content Map provides a high-level overview of the documentation's organization, helping users navigate the extensive documentation efficiently.</p>"},{"location":"project/#archived-content","title":"Archived Content","text":"<p>The Archive contains content that has been superseded by newer documentation but is maintained for historical reference.</p>"},{"location":"project/approaches-reorganization-summary/","title":"Approaches Section Reorganization - Summary","text":""},{"location":"project/approaches-reorganization-summary/#what-weve-accomplished","title":"What We've Accomplished","text":"<ol> <li>Created Dedicated Subdirectories for Each Approach</li> <li>kubernetes-api/ - For the Kubernetes API approach</li> <li>debug-container/ - For the Debug Container approach</li> <li>sidecar-container/ - For the Sidecar Container approach</li> <li> <p>helper-scripts/ - For the Helper Scripts documentation</p> </li> <li> <p>Created Comprehensive Index Files</p> </li> <li>Created index.md files for each approach subdirectory</li> <li> <p>Implemented a consistent structure with:</p> <ul> <li>Introduction section</li> <li>Key features</li> <li>Links to detailed documentation</li> <li>Related resources</li> </ul> </li> <li> <p>Created Inventory Files</p> </li> <li>Added inventory.md files for each approach subdirectory</li> <li>Listed all available files with descriptions</li> <li> <p>Added cross-references to related directories</p> </li> <li> <p>Extracted Focused Content Files</p> </li> <li>Created implementation.md for technical details</li> <li>Created rbac.md for RBAC configuration</li> <li>Created limitations.md for approach limitations</li> <li>Created distroless-basics.md for foundational understanding</li> <li> <p>Created scripts-vs-commands.md for implementation comparison</p> </li> <li> <p>Updated Main Index and Inventory Files</p> </li> <li>Updated approaches/index.md to serve as a redirect/overview</li> <li>Updated approaches/inventory.md to reflect the new structure</li> <li> <p>Maintained comparison.md and decision-matrix.md at the top level</p> </li> <li> <p>Updated the Navigation Structure</p> </li> <li>Created a new navigation structure in mkdocs.yml</li> <li>Organized navigation by approach with focused subtopics</li> <li> <p>Maintained top-level comparison and decision-making tools</p> </li> <li> <p>Updated Progress Tracking</p> </li> <li>Updated SESSION-RECOVERY.md to reflect our progress</li> <li>Updated content-organization-approach.md to mark Approaches as completed</li> <li>Added Approaches section to the implementation examples</li> </ol>"},{"location":"project/approaches-reorganization-summary/#next-steps","title":"Next Steps","text":"<ol> <li>Apply Similar Pattern to Security Section</li> <li>Create subdirectories for different security aspects</li> <li>Break down the security files into focused topics</li> <li> <p>Update navigation and cross-references</p> </li> <li> <p>Complete Other High-Priority Sections</p> </li> <li>Helm Charts - Organize by chart type and functionality</li> <li>Configuration - Separate by configuration target</li> <li> <p>Architecture - Split by architectural component</p> </li> <li> <p>Finish Creating Content Files for Approaches</p> </li> <li>Add security.md files for each approach</li> <li>Add future-work.md files for each approach</li> <li> <p>Add integration.md files for each approach</p> </li> <li> <p>Validate Documentation Flow</p> </li> <li>Ensure logical flow between approaches</li> <li>Verify all cross-references are working correctly</li> <li> <p>Update comparison files to reference new structure</p> </li> <li> <p>Update mkdocs.yml with Final Navigation</p> </li> <li>Replace current navigation with our proposed structure</li> <li>Ensure proper nesting and organization</li> <li>Test the documentation site with new navigation</li> </ol>"},{"location":"project/approaches-reorganization-summary/#implementation-status","title":"Implementation Status","text":"<p>The Approaches section reorganization is now well-structured with:</p> <ul> <li>Clear organization by approach type</li> <li>Consistent structure across all approach documentation</li> <li>Focused topic files for specific aspects</li> <li>Improved navigability and readability</li> <li>Better maintainability for future updates</li> </ul> <p>This implementation serves as a model for how other complex sections should be organized going forward.</p>"},{"location":"project/architecture-reorganization-summary/","title":"Architecture Section Reorganization Summary","text":"<p>This document summarizes the architecture section reorganization that was completed to improve documentation structure and maintainability.</p>"},{"location":"project/architecture-reorganization-summary/#reorganization-overview","title":"Reorganization Overview","text":"<p>The architecture section was reorganized following the established pattern of breaking down large monolithic documents into smaller, focused topics organized in logical subdirectories. This transformation significantly improves documentation usability, maintainability, and extensibility.</p>"},{"location":"project/architecture-reorganization-summary/#key-changes","title":"Key Changes","text":"<ol> <li>Created Comprehensive Subdirectory Structure:</li> <li><code>/components/</code> - Core architectural components</li> <li><code>/workflows/</code> - End-to-end workflow processes</li> <li><code>/diagrams/</code> - WCAG-compliant Mermaid diagrams</li> <li><code>/deployment/</code> - Deployment architectures</li> <li> <p><code>/integrations/</code> - CI/CD integration architectures</p> </li> <li> <p>Created 25 New Markdown Files:</p> </li> <li>Created standardized index.md and inventory.md files for each subdirectory</li> <li>Created focused content files in each subdirectory</li> <li> <p>Each file focuses on a specific aspect of the architecture</p> </li> <li> <p>Enhanced Documentation Quality:</p> </li> <li>Added WCAG-compliant Mermaid diagrams throughout</li> <li>Ensured consistent styling and formatting</li> <li>Implemented comprehensive cross-references between related topics</li> <li> <p>Used standardized terminology throughout</p> </li> <li> <p>Updated Navigation:</p> </li> <li>Updated mkdocs.yml to reflect the new structure</li> <li>Created logical grouping in the navigation menu</li> <li>Ensured proper hierarchy and relationships</li> </ol>"},{"location":"project/architecture-reorganization-summary/#new-directory-structure","title":"New Directory Structure","text":"<pre><code>docs/architecture/\n\u251c\u2500\u2500 index.md                  # Main entry point with overview and navigation\n\u251c\u2500\u2500 inventory.md              # Complete listing of all architecture documentation\n\u251c\u2500\u2500 components/               # Core component documentation\n\u2502   \u251c\u2500\u2500 index.md              # Components overview\n\u2502   \u251c\u2500\u2500 inventory.md          # Components documentation inventory\n\u2502   \u251c\u2500\u2500 core-components.md    # Details of main system components\n\u2502   \u251c\u2500\u2500 security-components.md # Security-focused components\n\u2502   \u2514\u2500\u2500 communication.md      # Component communication patterns\n\u251c\u2500\u2500 workflows/                # Workflow process documentation\n\u2502   \u251c\u2500\u2500 index.md              # Workflows overview\n\u2502   \u251c\u2500\u2500 inventory.md          # Workflows documentation inventory\n\u2502   \u251c\u2500\u2500 standard-container.md # Standard container workflow\n\u2502   \u251c\u2500\u2500 distroless-container.md # Distroless container workflow\n\u2502   \u251c\u2500\u2500 sidecar-container.md  # Sidecar container workflow\n\u2502   \u2514\u2500\u2500 security-workflows.md # Security-focused workflows\n\u251c\u2500\u2500 diagrams/                 # Architecture diagrams\n\u2502   \u251c\u2500\u2500 index.md              # Diagrams overview\n\u2502   \u251c\u2500\u2500 inventory.md          # Diagrams documentation inventory\n\u2502   \u251c\u2500\u2500 component-diagrams.md # Component visualization diagrams\n\u2502   \u251c\u2500\u2500 workflow-diagrams.md  # Workflow visualization diagrams\n\u2502   \u2514\u2500\u2500 deployment-diagrams.md # Deployment visualization diagrams\n\u251c\u2500\u2500 deployment/               # Deployment architectures\n\u2502   \u251c\u2500\u2500 index.md              # Deployment overview\n\u2502   \u251c\u2500\u2500 inventory.md          # Deployment documentation inventory\n\u2502   \u251c\u2500\u2500 script-deployment.md  # Script-based deployment architecture\n\u2502   \u251c\u2500\u2500 helm-deployment.md    # Helm chart deployment architecture\n\u2502   \u2514\u2500\u2500 ci-cd-deployment.md   # CI/CD integration deployment architecture\n\u2514\u2500\u2500 integrations/             # CI/CD integration architectures\n    \u251c\u2500\u2500 index.md              # Integrations overview\n    \u251c\u2500\u2500 inventory.md          # Integrations documentation inventory\n    \u251c\u2500\u2500 github-actions.md     # GitHub Actions integration architecture\n    \u251c\u2500\u2500 gitlab-ci.md          # GitLab CI integration architecture\n    \u251c\u2500\u2500 gitlab-services.md    # GitLab Services integration architecture\n    \u2514\u2500\u2500 custom-integrations.md # Custom integration architecture\n</code></pre>"},{"location":"project/architecture-reorganization-summary/#content-creation-details","title":"Content Creation Details","text":""},{"location":"project/architecture-reorganization-summary/#components-documentation","title":"Components Documentation","text":"<p>The components directory contains documentation about the core architectural components of the scanning system:</p> <ul> <li>core-components.md: Detailed information about the main system components</li> <li>security-components.md: Security-focused components and their roles</li> <li>communication.md: Component communication patterns</li> </ul>"},{"location":"project/architecture-reorganization-summary/#workflows-documentation","title":"Workflows Documentation","text":"<p>The workflows directory contains documentation about the end-to-end workflow processes:</p> <ul> <li>standard-container.md: Workflow for standard containers</li> <li>distroless-container.md: Workflow for distroless containers</li> <li>sidecar-container.md: Workflow using the sidecar approach</li> <li>security-workflows.md: Security-focused workflows</li> </ul>"},{"location":"project/architecture-reorganization-summary/#diagrams-documentation","title":"Diagrams Documentation","text":"<p>The diagrams directory contains WCAG-compliant Mermaid diagrams visualizing the architecture:</p> <ul> <li>component-diagrams.md: Visualization of system components</li> <li>workflow-diagrams.md: Visualization of workflow processes</li> <li>deployment-diagrams.md: Visualization of deployment architectures</li> </ul>"},{"location":"project/architecture-reorganization-summary/#deployment-documentation","title":"Deployment Documentation","text":"<p>The deployment directory contains documentation about different deployment architectures:</p> <ul> <li>script-deployment.md: Script-based deployment architecture</li> <li>helm-deployment.md: Helm chart deployment architecture</li> <li>ci-cd-deployment.md: CI/CD integration deployment architecture</li> </ul>"},{"location":"project/architecture-reorganization-summary/#integrations-documentation","title":"Integrations Documentation","text":"<p>The integrations directory contains documentation about CI/CD integration architectures:</p> <ul> <li>github-actions.md: GitHub Actions integration architecture</li> <li>gitlab-ci.md: GitLab CI integration architecture</li> <li>gitlab-services.md: GitLab Services integration architecture</li> <li>custom-integrations.md: Custom integration architecture</li> </ul>"},{"location":"project/architecture-reorganization-summary/#benefits-of-reorganization","title":"Benefits of Reorganization","text":"<p>The architecture section reorganization provides several key benefits:</p> <ol> <li>Improved Readability: Smaller, focused documents are easier to read and understand</li> <li>Enhanced Maintainability: Focused files are easier to update and maintain</li> <li>Better Navigation: Logical subdirectory structure makes information easier to find</li> <li>Consistent Structure: Follows the established pattern from other sections</li> <li>Comprehensive Coverage: Ensures all aspects of the architecture are documented</li> <li>Improved Visualization: WCAG-compliant diagrams throughout improve understanding</li> <li>Clear Relationships: Cross-references show relationships between components</li> </ol>"},{"location":"project/architecture-reorganization-summary/#next-steps","title":"Next Steps","text":"<p>After completing the architecture section reorganization, the next steps in the documentation refactoring process are:</p> <ol> <li>Proceed with Integration section reorganization</li> <li>Continue Phase 4 (review and refinement) of documentation refactoring</li> <li>Address remaining documentation gaps</li> <li>Implement documentation validation tools</li> </ol>"},{"location":"project/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"project/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"project/changelog/#performance","title":"Performance","text":"<ul> <li>Improved documentation build performance with optimized MkDocs configuration</li> <li>Enhanced diagram rendering efficiency with optimized Mermaid settings</li> <li>Added caching configuration for faster documentation site performance</li> <li>Optimized image assets for faster loading times</li> <li>Reduced CSS size with optimization techniques</li> </ul>"},{"location":"project/changelog/#added","title":"Added","text":"<ul> <li> <p>2025-03-20: Documentation infrastructure</p> <ul> <li>Added comprehensive MkDocs with Material theme configuration</li> <li>Implemented automated documentation validation tools</li> <li>Created docs-tools.sh script for documentation maintenance</li> <li>Added spell checking and markdown linting</li> <li>Created README files for all major documentation sections</li> <li>Added custom CSS for improved documentation styling</li> <li>Implemented mermaid-config.js for consistent diagram styling</li> <li>Created documentation link validation tools</li> </ul> </li> <li> <p>2025-03-19: CI/CD Integration</p> <ul> <li>Added GitLab CI pipeline examples for all scanning approaches</li> <li>Created GitHub Actions workflows for container scanning</li> <li>Added examples for dynamic RBAC configuration in pipelines</li> <li>Created examples for existing cluster integration</li> <li>Implemented GitLab CI with services configuration</li> <li>Added documentation on CI/CD integration patterns</li> </ul> </li> <li> <p>2025-03-18: Security and compliance documentation</p> <ul> <li>Created detailed security risk analysis for all approaches</li> <li>Added compliance documentation aligned with DoD 8500.01</li> <li>Created service account and token management documentation</li> <li>Added RBAC configuration guides with examples</li> <li>Created threshold validation documentation</li> </ul> </li> <li> <p>2025-03-17: Helm charts and deployment</p> <ul> <li>Created modular Helm chart architecture</li> <li>Implemented scanner infrastructure chart</li> <li>Added specialized charts for each scanning approach</li> <li>Created common components chart</li> <li>Added values files with examples</li> <li>Created comprehensive deployment documentation</li> </ul> </li> <li> <p>2025-03-15: Initial project structure and core functionality</p> <ul> <li>Three container scanning approaches:<ul> <li>Kubernetes API Approach (train-k8s-container plugin)</li> <li>Debug Container Approach (ephemeral containers)</li> <li>Sidecar Container Approach (shared process namespace)</li> </ul> </li> <li>Basic shell scripts for each scanning approach</li> <li>Example profiles and configurations</li> <li>Core documentation framework</li> </ul> </li> </ul>"},{"location":"project/changelog/#changed","title":"Changed","text":"<ul> <li> <p>2025-03-20: Documentation reorganization and structure improvement</p> <ul> <li>Complete reorganization of documentation into logical directory structure</li> <li>Created dedicated directories for approaches, architecture, security</li> <li>Reorganized navigation structure in mkdocs.yml</li> <li>Moved Helm Chart Architecture to Helm Charts section</li> <li>Created new \"Kubernetes Setup\" section for infrastructure-related docs</li> <li>Renamed \"Configuration\" to \"Scanner Configuration\" for clarity</li> <li>Added README files for all major documentation sections</li> <li>Fixed all internal links after reorganization</li> <li>Created automation script (fix-links.sh) for link maintenance</li> <li>Improved cross-references between related documentation</li> <li>Fixed Mermaid diagram display issues with proper containment</li> <li>Separated configuration documentation into kubeconfig and service accounts sections</li> <li>Improved RELEASE-NOTES.md with comprehensive feature list</li> <li>Enhanced GitHub workflow examples with clearer section organization</li> <li>Restructured GitLab pipeline examples for better discoverability</li> <li>Improved session recovery documentation with better headings and structure</li> </ul> </li> <li> <p>2025-03-19: Documentation consistency enhancement</p> <ul> <li>Added consistent strategic priority statements about Kubernetes API Approach in key files</li> <li>Standardized terminology from \"InSpec\" to \"CINC Auditor\" across all documents</li> <li>Fixed broken relative links to use absolute paths (e.g., <code>/docs/overview/workflows.md</code>)</li> <li>Updated path references to reflect current directory structure</li> <li>Added clear labeling of interim approaches vs enterprise-recommended solutions</li> <li>Standardized approach naming (Kubernetes API Approach, Debug Container Approach, Sidecar Container Approach)</li> <li>Added explicit strategic priority statements for train-k8s-container plugin enhancement</li> <li>Updated integration documentation to consistently recommend Kubernetes API Approach</li> <li>Fixed cross-references between GitHub Actions and GitLab CI documentation</li> <li>Corrected examples' directory paths and workflow references</li> <li>Updated TASKS.md to highlight highest priority implementation items</li> <li>Added consistent \"Strategic Priority\" banners to key technical documents</li> <li>Enhanced integration guides with consistent approach recommendations</li> <li>Fixed repository name references in quickstart documentation</li> <li>Updated index files for GitHub and GitLab examples with consistent messaging</li> <li>Added strategic implementation path to plugin-modifications.md</li> </ul> </li> <li> <p>2025-03-18: System architecture and workflow documentation</p> <ul> <li>Added comprehensive Helm chart architecture documentation</li> <li>Created workflow diagrams for all scanning approaches</li> <li>Added sequence diagrams for CI/CD integration workflows</li> <li>Improved documentation of component relationships</li> <li>Added GitLab CI integration with services documentation</li> <li>Enhanced diagram documentation with color guidelines</li> <li>Added ASCII to Mermaid conversion utilities</li> </ul> </li> </ul>"},{"location":"project/changelog/#fixed","title":"Fixed","text":"<ul> <li> <p>2025-03-20: Documentation structure and links</p> <ul> <li>Fixed broken internal links after directory reorganization</li> <li>Resolved MkDocs build warnings</li> <li>Fixed Mermaid diagram containment issues</li> <li>Corrected cross-references between documentation sections</li> <li>Fixed README references to moved files</li> <li>Corrected include paths for code examples</li> <li>Resolved dark/light mode issues with Mermaid diagrams</li> <li>Fixed inconsistent heading structure across documentation</li> <li>Corrected file and directory paths in example code</li> <li>Fixed navigation structure inconsistencies</li> <li>Resolved path issues after moving GitHub workflow examples</li> <li>Fixed GitLab pipeline examples directory references</li> </ul> </li> <li> <p>2025-03-19: Consistency and naming</p> <ul> <li>Fixed inconsistent terminology across documentation</li> <li>Resolved approach naming inconsistencies</li> <li>Fixed directory structure inconsistencies</li> <li>Corrected relative vs. absolute path issues</li> <li>Fixed navigation structure in mkdocs.yml</li> <li>Addressed MkDocs build warnings with proper exclude_docs configuration</li> </ul> </li> <li> <p>2025-03-18: Technical documentation</p> <ul> <li>Fixed workflow diagrams with proper styling</li> <li>Corrected security analysis documentation</li> <li>Fixed threshold examples in threshold.md</li> <li>Corrected Helm chart value examples</li> <li>Fixed GitLab CI pipeline configuration examples</li> </ul> </li> </ul>"},{"location":"project/changelog/#security","title":"Security","text":"<ul> <li>Enhanced documentation of security compliance considerations</li> <li>Clarified risk documentation requirements for alternative approaches</li> <li>Added detailed RBAC configuration guidelines with security best practices</li> <li>Improved token management documentation with enhanced security considerations</li> <li>Added service account configuration security recommendations</li> <li>Created dedicated security section for each scanning approach</li> <li>Enhanced security risk analysis documentation for enterprise environments</li> <li>Added DoD 8500.01 compliance considerations to security documentation</li> <li>Improved guidance for least privilege configuration in all scanning scenarios</li> </ul>"},{"location":"project/configuration-reorganization-summary/","title":"Configuration Section Reorganization Summary","text":"<p>This document summarizes the reorganization of the Configuration section in the documentation.</p>"},{"location":"project/configuration-reorganization-summary/#overview","title":"Overview","text":"<p>The Configuration section has been completely reorganized to improve usability, maintainability, and logical structure. The reorganization follows the established pattern used in other sections of breaking down large documents into focused subdirectories with dedicated content files.</p>"},{"location":"project/configuration-reorganization-summary/#previous-structure","title":"Previous Structure","text":"<p>The previous structure consisted of:</p> <ul> <li><code>configuration/index.md</code> - Focused on kubeconfig generation</li> <li><code>configuration/inventory.md</code> - Directory inventory</li> <li><code>configuration/advanced/</code> - Subdirectory for advanced configuration<ul> <li><code>advanced/index.md</code> - Overview of advanced configuration</li> <li><code>advanced/thresholds.md</code> - Threshold configuration documentation</li> <li><code>advanced/plugin-modifications.md</code> - Plugin modification documentation</li> <li><code>advanced/saf-cli-integration.md</code> - SAF CLI integration documentation</li> <li><code>advanced/inventory.md</code> - Advanced directory inventory</li> </ul> </li> </ul> <p>This structure had several limitations:</p> <ol> <li>Mixed different configuration concerns in single files</li> <li>Inconsistent organization with some topics at root level and others in subdirectories</li> <li>Limited scalability for adding new configuration topics</li> <li>No clear organization by functional area</li> </ol>"},{"location":"project/configuration-reorganization-summary/#new-structure","title":"New Structure","text":"<p>The new structure organizes content by functional area into focused subdirectories:</p> <ul> <li><code>configuration/</code> - Root directory<ul> <li><code>index.md</code> - Overview of configuration options</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>kubeconfig/</code> - Kubernetes authentication configuration<ul> <li><code>index.md</code> - Overview of kubeconfig configuration</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>generation.md</code> - Kubeconfig generation documentation</li> <li><code>management.md</code> - Kubeconfig management documentation</li> <li><code>security.md</code> - Kubeconfig security documentation</li> <li><code>dynamic.md</code> - Dynamic kubeconfig generation documentation</li> </ul> </li> <li><code>thresholds/</code> - Compliance threshold configuration<ul> <li><code>index.md</code> - Overview of threshold configuration</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>basic.md</code> - Basic threshold configuration</li> <li><code>advanced.md</code> - Advanced threshold configuration</li> <li><code>examples.md</code> - Example threshold configurations</li> <li><code>cicd.md</code> - CI/CD integration for thresholds</li> </ul> </li> <li><code>plugins/</code> - Plugin customization<ul> <li><code>index.md</code> - Overview of plugin customization</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>distroless.md</code> - Distroless container support</li> <li><code>implementation.md</code> - Implementation guide</li> <li><code>testing.md</code> - Testing guide</li> </ul> </li> <li><code>integration/</code> - Integration configuration<ul> <li><code>index.md</code> - Overview of integration configuration</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>saf-cli.md</code> - SAF CLI integration</li> <li><code>github.md</code> - GitHub Actions integration</li> <li><code>gitlab.md</code> - GitLab CI integration</li> </ul> </li> <li><code>security/</code> - Security configuration<ul> <li><code>index.md</code> - Overview of security configuration</li> <li><code>inventory.md</code> - Directory inventory</li> <li><code>hardening.md</code> - Security hardening</li> <li><code>credentials.md</code> - Credential management</li> <li><code>rbac.md</code> - RBAC configuration</li> </ul> </li> <li><code>advanced/</code> - Legacy directory (with redirects to new locations)<ul> <li><code>index.md</code> - Redirects to main configuration overview</li> <li><code>thresholds.md</code> - Redirects to thresholds section</li> <li><code>plugin-modifications.md</code> - Redirects to plugins section</li> <li><code>saf-cli-integration.md</code> - Redirects to integration section</li> <li><code>inventory.md</code> - Legacy directory inventory</li> </ul> </li> </ul> </li> </ul>"},{"location":"project/configuration-reorganization-summary/#content-extraction-and-enhancement","title":"Content Extraction and Enhancement","text":"<p>The reorganization involved:</p> <ol> <li>Content Extraction: Extracting content from existing files into focused topic files</li> <li>Content Enhancement: Adding new content to cover gaps and provide more detailed documentation</li> <li>Cross-referencing: Maintaining and enhancing cross-references between related topics</li> <li>Redirects: Adding redirects from legacy files to new locations to maintain backward compatibility</li> </ol>"},{"location":"project/configuration-reorganization-summary/#navigation-updates","title":"Navigation Updates","text":"<p>The navigation in <code>mkdocs.yml</code> has been updated to reflect the new structure:</p> <pre><code>- Configuration:\n  - Overview: configuration/index.md\n  - Directory Contents: configuration/inventory.md\n  - Kubeconfig:\n    - Overview: configuration/kubeconfig/index.md\n    - Directory Contents: configuration/kubeconfig/inventory.md\n    - Generation: configuration/kubeconfig/generation.md\n    - Management: configuration/kubeconfig/management.md\n    - Security: configuration/kubeconfig/security.md\n    - Dynamic Configuration: configuration/kubeconfig/dynamic.md\n  - Thresholds:\n    - Overview: configuration/thresholds/index.md\n    - Directory Contents: configuration/thresholds/inventory.md\n    - Basic Configuration: configuration/thresholds/basic.md\n    - Advanced Configuration: configuration/thresholds/advanced.md\n    - Example Configurations: configuration/thresholds/examples.md\n    - CI/CD Integration: configuration/thresholds/cicd.md\n  - Plugin Customization:\n    - Overview: configuration/plugins/index.md\n    - Directory Contents: configuration/plugins/inventory.md\n    - Distroless Support: configuration/plugins/distroless.md\n    - Implementation Guide: configuration/plugins/implementation.md\n    - Testing Guide: configuration/plugins/testing.md\n  - Integration:\n    - Overview: configuration/integration/index.md\n    - Directory Contents: configuration/integration/inventory.md\n    - SAF CLI Integration: configuration/integration/saf-cli.md\n    - GitHub Actions: configuration/integration/github.md\n    - GitLab CI: configuration/integration/gitlab.md\n  - Security:\n    - Overview: configuration/security/index.md\n    - Directory Contents: configuration/security/inventory.md\n    - Hardening: configuration/security/hardening.md\n    - Credential Management: configuration/security/credentials.md\n    - RBAC Configuration: configuration/security/rbac.md\n  - Legacy:\n    - Advanced Configuration: configuration/advanced/index.md\n    - Scanning Thresholds: configuration/advanced/thresholds.md\n    - Plugin Modifications: configuration/advanced/plugin-modifications.md\n    - SAF CLI Integration: configuration/advanced/saf-cli-integration.md\n    - Directory Contents: configuration/advanced/inventory.md\n</code></pre>"},{"location":"project/configuration-reorganization-summary/#benefits-of-the-new-structure","title":"Benefits of the New Structure","text":"<p>The reorganization provides several benefits:</p> <ol> <li>Logical Organization: Content is now organized by functional area</li> <li>Improved Discoverability: Users can more easily find related configuration topics</li> <li>Enhanced Maintainability: Focused files are easier to maintain and update</li> <li>Better Scalability: New configuration topics can be added to the appropriate subdirectory</li> <li>Consistent Structure: Follows the same pattern used in other sections (approaches, security)</li> <li>Progressive Disclosure: Users can start with high-level overview and drill down into details</li> <li>Enhanced Navigation: Clearer navigation structure in the sidebar</li> </ol>"},{"location":"project/configuration-reorganization-summary/#backward-compatibility","title":"Backward Compatibility","text":"<p>To ensure backward compatibility:</p> <ol> <li>Legacy files include redirects to their new locations</li> <li>Legacy files are still accessible in the navigation under the \"Legacy\" section</li> <li>Cross-references from other sections have been updated to point to the new locations</li> </ol>"},{"location":"project/configuration-reorganization-summary/#next-steps","title":"Next Steps","text":"<p>With the Configuration section reorganization complete, the focus will shift to:</p> <ol> <li>Reorganizing the Architecture section</li> <li>Reorganizing the Integration section</li> <li>Continuing Phase 4 (review and refinement) of documentation refactoring</li> <li>Addressing remaining documentation gaps</li> <li>Implementing documentation validation tools</li> </ol>"},{"location":"project/content-map/","title":"Documentation Structure and Content Map","text":"<p>This document provides a comprehensive overview of the documentation structure for the Kube CINC Secure Scanner project. It serves as a reference for the expected organization of our documentation.</p>"},{"location":"project/content-map/#top-level-sections","title":"Top-Level Sections","text":"<p>Our documentation is organized into the following top-level sections:</p> <ol> <li>Getting Started - Introduction and quickstart materials</li> <li>Core Concepts - Architecture, approaches, and security principles</li> <li>Deployment &amp; Configuration - Setup, RBAC, config, and Helm charts</li> <li>CI/CD Integration - Integrating with CI/CD systems</li> <li>Development - Developer guide and contributing information</li> <li>Project Information - Project management and meta-documentation</li> </ol>"},{"location":"project/content-map/#documentation-directory-structure","title":"Documentation Directory Structure","text":"<p>Below is the expected structure of our documentation with key files:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                     # Main landing page\n\u251c\u2500\u2500 quickstart-guide.md          # Quick start guide\n\u251c\u2500\u2500 approaches/                  # Scanning approaches\n\u2502   \u251c\u2500\u2500 index.md                 # Approaches overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 comparison.md            # Comparison of approaches\n\u2502   \u251c\u2500\u2500 decision-matrix.md       # Decision matrix for choosing approaches\n\u2502   \u251c\u2500\u2500 kubernetes-api/          # Kubernetes API approach\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 implementation.md    # Implementation details\n\u2502   \u2502   \u251c\u2500\u2500 rbac.md              # RBAC configuration\n\u2502   \u2502   \u2514\u2500\u2500 limitations.md       # Limitations\n\u2502   \u251c\u2500\u2500 debug-container/         # Debug container approach\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 distroless-basics.md # Distroless container basics\n\u2502   \u2502   \u2514\u2500\u2500 implementation.md    # Implementation details\n\u2502   \u251c\u2500\u2500 sidecar-container/       # Sidecar container approach\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u2514\u2500\u2500 implementation.md    # Implementation details\n\u2502   \u2514\u2500\u2500 helper-scripts/          # Helper scripts approach\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u2514\u2500\u2500 scripts-vs-commands.md # Scripts vs. Commands\n\u251c\u2500\u2500 architecture/                # Architecture documentation\n\u2502   \u251c\u2500\u2500 index.md                 # Architecture overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 components/              # System components\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 core-components.md   # Core components\n\u2502   \u2502   \u251c\u2500\u2500 communication.md     # Communication patterns\n\u2502   \u2502   \u2514\u2500\u2500 security-components.md # Security components\n\u2502   \u251c\u2500\u2500 diagrams/                # Architecture diagrams\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 component-diagrams.md # Component diagrams\n\u2502   \u2502   \u251c\u2500\u2500 deployment-diagrams.md # Deployment diagrams\n\u2502   \u2502   \u2514\u2500\u2500 workflow-diagrams.md # Workflow diagrams\n\u2502   \u251c\u2500\u2500 workflows/               # Workflow documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 standard-container.md # Standard container workflow\n\u2502   \u2502   \u251c\u2500\u2500 distroless-container.md # Distroless container workflow\n\u2502   \u2502   \u2514\u2500\u2500 sidecar-container.md # Sidecar container workflow\n\u2502   \u251c\u2500\u2500 deployment/              # Deployment architecture\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 script-deployment.md # Script deployment\n\u2502   \u2502   \u251c\u2500\u2500 helm-deployment.md   # Helm deployment\n\u2502   \u2502   \u2514\u2500\u2500 ci-cd-deployment.md  # CI/CD deployment\n\u2502   \u2514\u2500\u2500 integrations/            # External integrations\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u251c\u2500\u2500 gitlab-ci.md         # GitLab CI integration\n\u2502       \u251c\u2500\u2500 github-actions.md    # GitHub Actions integration\n\u2502       \u251c\u2500\u2500 gitlab-services.md   # GitLab Services integration\n\u2502       \u2514\u2500\u2500 custom-integrations.md # Custom integrations\n\u251c\u2500\u2500 configuration/               # Configuration documentation\n\u2502   \u251c\u2500\u2500 index.md                 # Configuration overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 kubeconfig/              # Kubeconfig management\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 generation.md        # Generation of kubeconfig\n\u2502   \u2502   \u251c\u2500\u2500 management.md        # Management of kubeconfig\n\u2502   \u2502   \u251c\u2500\u2500 security.md          # Security considerations\n\u2502   \u2502   \u2514\u2500\u2500 dynamic.md           # Dynamic configuration\n\u2502   \u251c\u2500\u2500 thresholds/              # Threshold configuration\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 basic.md             # Basic configuration\n\u2502   \u2502   \u251c\u2500\u2500 advanced.md          # Advanced configuration\n\u2502   \u2502   \u251c\u2500\u2500 examples.md          # Example configurations\n\u2502   \u2502   \u2514\u2500\u2500 cicd.md              # CI/CD thresholds\n\u2502   \u251c\u2500\u2500 plugins/                 # Plugin configuration\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 distroless.md        # Distroless support\n\u2502   \u2502   \u251c\u2500\u2500 implementation.md    # Implementation guide\n\u2502   \u2502   \u2514\u2500\u2500 testing.md           # Testing guide\n\u2502   \u251c\u2500\u2500 integration/             # Integration configuration\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 saf-cli.md           # SAF CLI integration\n\u2502   \u2502   \u251c\u2500\u2500 github.md            # GitHub Actions config\n\u2502   \u2502   \u2514\u2500\u2500 gitlab.md            # GitLab CI config\n\u2502   \u2514\u2500\u2500 security/                # Security configuration\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u251c\u2500\u2500 hardening.md         # Hardening guide\n\u2502       \u251c\u2500\u2500 credentials.md       # Credential management\n\u2502       \u2514\u2500\u2500 rbac.md              # RBAC configuration\n\u251c\u2500\u2500 security/                    # Security documentation\n\u2502   \u251c\u2500\u2500 index.md                 # Security overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 principles/              # Security principles\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 least-privilege.md   # Least privilege\n\u2502   \u2502   \u251c\u2500\u2500 ephemeral-creds.md   # Ephemeral credentials\n\u2502   \u2502   \u251c\u2500\u2500 resource-isolation.md # Resource isolation\n\u2502   \u2502   \u2514\u2500\u2500 secure-transport.md  # Secure transport\n\u2502   \u251c\u2500\u2500 risk/                    # Risk analysis\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 model.md             # Risk model\n\u2502   \u2502   \u251c\u2500\u2500 kubernetes-api.md    # K8s API approach risks\n\u2502   \u2502   \u251c\u2500\u2500 debug-container.md   # Debug container risks\n\u2502   \u2502   \u251c\u2500\u2500 sidecar-container.md # Sidecar container risks\n\u2502   \u2502   \u2514\u2500\u2500 mitigations.md       # Risk mitigations\n\u2502   \u251c\u2500\u2500 threat-model/            # Threat model\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 attack-vectors.md    # Attack vectors\n\u2502   \u2502   \u251c\u2500\u2500 lateral-movement.md  # Lateral movement\n\u2502   \u2502   \u251c\u2500\u2500 token-exposure.md    # Token exposure\n\u2502   \u2502   \u2514\u2500\u2500 threat-mitigations.md # Threat mitigations\n\u2502   \u251c\u2500\u2500 compliance/              # Compliance documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 approach-comparison.md # Approach comparison\n\u2502   \u2502   \u2514\u2500\u2500 risk-documentation.md # Risk documentation\n\u2502   \u2514\u2500\u2500 recommendations/         # Security recommendations\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u2514\u2500\u2500 inventory.md         # Directory listing\n\u251c\u2500\u2500 helm-charts/                 # Helm chart documentation\n\u2502   \u251c\u2500\u2500 index.md                 # Helm charts overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 overview/                # Overview documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # General overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u2514\u2500\u2500 architecture.md      # Architecture\n\u2502   \u251c\u2500\u2500 scanner-types/           # Scanner types\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 common-scanner.md    # Common scanner\n\u2502   \u2502   \u251c\u2500\u2500 standard-scanner.md  # Standard scanner\n\u2502   \u2502   \u251c\u2500\u2500 distroless-scanner.md # Distroless scanner\n\u2502   \u2502   \u2514\u2500\u2500 sidecar-scanner.md   # Sidecar scanner\n\u2502   \u251c\u2500\u2500 infrastructure/          # Infrastructure\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 rbac.md              # RBAC configuration\n\u2502   \u2502   \u251c\u2500\u2500 service-accounts.md  # Service accounts\n\u2502   \u2502   \u2514\u2500\u2500 namespaces.md        # Namespaces\n\u2502   \u251c\u2500\u2500 usage/                   # Usage documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 customization.md     # Customization guide\n\u2502   \u2502   \u251c\u2500\u2500 configuration.md     # Configuration reference\n\u2502   \u2502   \u2514\u2500\u2500 values.md            # Values files\n\u2502   \u251c\u2500\u2500 security/                # Security documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 best-practices.md    # Best practices\n\u2502   \u2502   \u251c\u2500\u2500 rbac-hardening.md    # RBAC hardening\n\u2502   \u2502   \u2514\u2500\u2500 risk-assessment.md   # Risk assessment\n\u2502   \u2514\u2500\u2500 operations/              # Operations documentation\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u251c\u2500\u2500 troubleshooting.md   # Troubleshooting\n\u2502       \u251c\u2500\u2500 performance.md       # Performance\n\u2502       \u2514\u2500\u2500 maintenance.md       # Maintenance\n\u251c\u2500\u2500 integration/                 # CI/CD integration\n\u2502   \u251c\u2500\u2500 index.md                 # Integration overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 overview.md              # Integration overview\n\u2502   \u251c\u2500\u2500 approach-mapping.md      # Approach mapping\n\u2502   \u251c\u2500\u2500 gitlab-services-analysis.md # GitLab services analysis\n\u2502   \u251c\u2500\u2500 platforms/               # CI/CD platforms\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 github-actions.md    # GitHub Actions\n\u2502   \u2502   \u251c\u2500\u2500 gitlab-ci.md         # GitLab CI\n\u2502   \u2502   \u2514\u2500\u2500 gitlab-services.md   # GitLab Services\n\u2502   \u251c\u2500\u2500 workflows/               # Integration workflows\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 standard-container.md # Standard container\n\u2502   \u2502   \u251c\u2500\u2500 distroless-container.md # Distroless container\n\u2502   \u2502   \u251c\u2500\u2500 sidecar-container.md # Sidecar container\n\u2502   \u2502   \u2514\u2500\u2500 security-workflows.md # Security workflows\n\u2502   \u251c\u2500\u2500 examples/                # Integration examples\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2502   \u251c\u2500\u2500 github-examples.md   # GitHub examples\n\u2502   \u2502   \u2514\u2500\u2500 gitlab-examples.md   # GitLab examples\n\u2502   \u2514\u2500\u2500 configuration/           # Integration configuration\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u251c\u2500\u2500 environment-variables.md # Environment variables\n\u2502       \u251c\u2500\u2500 secrets-management.md # Secrets management\n\u2502       \u251c\u2500\u2500 thresholds-integration.md # Thresholds\n\u2502       \u2514\u2500\u2500 reporting.md         # Reporting\n\u251c\u2500\u2500 developer-guide/             # Developer documentation\n\u2502   \u251c\u2500\u2500 index.md                 # Developer guide overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 testing/                 # Testing documentation\n\u2502   \u2502   \u251c\u2500\u2500 index.md             # Overview\n\u2502   \u2502   \u2514\u2500\u2500 inventory.md         # Directory listing\n\u2502   \u2514\u2500\u2500 deployment/              # Deployment guide\n\u2502       \u251c\u2500\u2500 index.md             # Overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u251c\u2500\u2500 script-deployment.md # Script deployment\n\u2502       \u251c\u2500\u2500 helm-deployment.md   # Helm deployment\n\u2502       \u251c\u2500\u2500 cicd-deployment.md   # CI/CD deployment\n\u2502       \u251c\u2500\u2500 scenarios/           # Deployment scenarios\n\u2502       \u2502   \u251c\u2500\u2500 index.md         # Overview\n\u2502       \u2502   \u251c\u2500\u2500 enterprise.md    # Enterprise environment\n\u2502       \u2502   \u251c\u2500\u2500 development.md   # Development environment\n\u2502       \u2502   \u251c\u2500\u2500 cicd.md          # CI/CD environment\n\u2502       \u2502   \u251c\u2500\u2500 multi-tenant.md  # Multi-tenant environment\n\u2502       \u2502   \u2514\u2500\u2500 air-gapped.md    # Air-gapped environment\n\u2502       \u2514\u2500\u2500 advanced-topics/     # Advanced deployment\n\u2502           \u251c\u2500\u2500 index.md         # Overview\n\u2502           \u251c\u2500\u2500 inventory.md     # Directory listing\n\u2502           \u251c\u2500\u2500 scaling.md       # Scaling and performance\n\u2502           \u251c\u2500\u2500 security.md      # Security enhancements\n\u2502           \u251c\u2500\u2500 monitoring.md    # Monitoring and maintenance\n\u2502           \u251c\u2500\u2500 specialized-environments.md # Specialized environments\n\u2502           \u251c\u2500\u2500 verification.md  # Deployment verification\n\u2502           \u2514\u2500\u2500 custom-development.md # Custom development\n\u251c\u2500\u2500 project/                     # Project information\n\u2502   \u251c\u2500\u2500 index.md                 # Project overview\n\u2502   \u251c\u2500\u2500 inventory.md             # Directory listing\n\u2502   \u251c\u2500\u2500 changelog.md             # Changelog\n\u2502   \u251c\u2500\u2500 roadmap.md               # Roadmap\n\u2502   \u251c\u2500\u2500 tasks.md                 # Tasks and issues\n\u2502   \u251c\u2500\u2500 documentation-gaps.md    # Documentation gaps\n\u2502   \u251c\u2500\u2500 content-map.md           # This file\n\u2502   \u251c\u2500\u2500 documentation-entry-refactoring.md # Refactoring plan\n\u2502   \u251c\u2500\u2500 documentation-review-plan.md # Review plan\n\u2502   \u251c\u2500\u2500 documentation-structure-progress.md # Structure progress\n\u2502   \u251c\u2500\u2500 terminology.md           # Terminology reference\n\u2502   \u2514\u2500\u2500 archive/                 # Archived documentation\n\u2502       \u251c\u2500\u2500 index.md             # Archive overview\n\u2502       \u251c\u2500\u2500 inventory.md         # Directory listing\n\u2502       \u2514\u2500\u2500 ascii-diagrams.md    # ASCII diagrams\n\u2514\u2500\u2500 contributing/                # Contributing documentation\n    \u251c\u2500\u2500 index.md                 # Contributing overview\n    \u251c\u2500\u2500 inventory.md             # Directory listing\n    \u251c\u2500\u2500 documentation-tools.md   # Documentation tools\n    \u251c\u2500\u2500 code-snippets.md         # Code snippets\n    \u251c\u2500\u2500 diagram-color-guide.md   # Diagram color guide\n    \u2514\u2500\u2500 testing/                 # Documentation testing\n        \u251c\u2500\u2500 index.md             # Testing overview\n        \u251c\u2500\u2500 inventory.md         # Directory listing\n        \u2514\u2500\u2500 dark-light-mode-test.md # Theme testing\n</code></pre>"},{"location":"project/content-map/#documentation-standards","title":"Documentation Standards","text":"<p>All directories should follow these standards:</p> <ol> <li>Each directory must have an <code>index.md</code> file serving as the entry point and overview</li> <li>Each directory should have an <code>inventory.md</code> file listing all files with descriptions</li> <li>Content should be organized in a logical, hierarchical manner</li> <li>Cross-references should use relative paths to other markdown files</li> <li>All files should use a consistent markdown style and formatting</li> </ol>"},{"location":"project/content-map/#redirects-and-backup","title":"Redirects and Backup","text":"<p>Original files from the older structure have been moved to the backup directory:</p> <pre><code>docs-backup/\n\u251c\u2500\u2500 approaches/            # Original approach files\n\u251c\u2500\u2500 architecture/          # Original architecture files\n\u251c\u2500\u2500 configuration/         # Original configuration files\n\u251c\u2500\u2500 helm-charts/           # Original helm-charts files\n\u251c\u2500\u2500 integration/           # Original integration files\n\u251c\u2500\u2500 security/              # Original security files\n\u2514\u2500\u2500 developer-guide/       # Original developer-guide files\n</code></pre>"},{"location":"project/content-map/#navigation-structure","title":"Navigation Structure","text":"<p>The navigation is organized in the <code>mkdocs.yml</code> file following this high-level structure:</p> <ol> <li>Getting Started</li> <li>Introduction</li> <li>Executive Summary</li> <li>Quickstart Guide</li> <li> <p>Technical Overview</p> </li> <li> <p>Core Concepts</p> </li> <li>Architecture</li> <li>Scanning Approaches</li> <li> <p>Security</p> </li> <li> <p>Deployment &amp; Configuration</p> </li> <li>Kubernetes Setup</li> <li>RBAC Configuration</li> <li>Configuration</li> <li>Authentication</li> <li> <p>Helm Charts</p> </li> <li> <p>CI/CD Integration</p> </li> <li>Overview</li> <li>CI/CD Platforms</li> <li>Integration Workflows</li> <li>Integration Examples</li> <li> <p>Example Resources</p> </li> <li> <p>Development &amp; Contributing</p> </li> <li>Developer Guide</li> <li>Testing</li> <li>Deployment</li> <li> <p>Contributing</p> </li> <li> <p>Project Information</p> </li> <li>Project Overview</li> <li>Documentation</li> <li>Tools &amp; Utilities</li> <li>Archive</li> </ol>"},{"location":"project/content-map/#maintenance-and-updates","title":"Maintenance and Updates","text":"<p>When updating documentation:</p> <ol> <li>Add new files to the appropriate directory</li> <li>Update the corresponding <code>inventory.md</code> file</li> <li>Update cross-references if needed</li> <li>Update this content map if there are structural changes</li> <li>Add the new files to the navigation in <code>mkdocs.yml</code> if appropriate</li> </ol>"},{"location":"project/content-map/#cross-reference-mappings","title":"Cross-Reference Mappings","text":"<p>These mappings help the cross-reference fixer script update links across the documentation. Each line shows an old file path and where its content has been moved in the new structure.</p>"},{"location":"project/content-map/#approach-specific-files-to-global-sections","title":"Approach-Specific Files to Global Sections","text":"<pre><code># Approaches to Security mappings\napproaches/kubernetes-api/security.md -&gt; security/risk/kubernetes-api.md\napproaches/debug-container/security.md -&gt; security/risk/debug-container.md\napproaches/sidecar-container/security.md -&gt; security/risk/sidecar-container.md\napproaches/helper-scripts/security.md -&gt; security/risk/model.md\n\n# Approaches to Integration mappings\napproaches/kubernetes-api/integration.md -&gt; integration/workflows/standard-container.md\napproaches/debug-container/integration.md -&gt; integration/workflows/distroless-container.md\napproaches/sidecar-container/integration.md -&gt; integration/workflows/sidecar-container.md\napproaches/helper-scripts/integration.md -&gt; integration/workflows/index.md\n\n# Approaches to Project mappings\napproaches/kubernetes-api/future-work.md -&gt; project/roadmap.md\napproaches/debug-container/future-work.md -&gt; project/roadmap.md\napproaches/sidecar-container/future-work.md -&gt; project/roadmap.md\napproaches/helper-scripts/future-work.md -&gt; project/roadmap.md\n\n# Approaches to RBAC mappings\napproaches/kubernetes-api/rbac.md -&gt; rbac/index.md\napproaches/debug-container/rbac.md -&gt; rbac/index.md\napproaches/sidecar-container/rbac.md -&gt; rbac/index.md\napproaches/helper-scripts/rbac.md -&gt; rbac/index.md\n\n# Approaches to Configuration mappings\napproaches/kubernetes-api/limitations.md -&gt; approaches/kubernetes-api/limitations.md\napproaches/debug-container/limitations.md -&gt; approaches/debug-container/implementation.md\napproaches/sidecar-container/limitations.md -&gt; approaches/sidecar-container/implementation.md\napproaches/helper-scripts/limitations.md -&gt; approaches/helper-scripts/scripts-vs-commands.md\n</code></pre>"},{"location":"project/content-map/#top-level-section-reorganizations","title":"Top-Level Section Reorganizations","text":"<pre><code># Security section reorganization\nsecurity/overview.md -&gt; security/index.md\nsecurity/analysis.md -&gt; security/threat-model/index.md\nsecurity/risk-analysis.md -&gt; security/risk/index.md\nsecurity/compliance.md -&gt; security/compliance/index.md\n\n# Integration section reorganization\nintegration/overview.md -&gt; integration/index.md\nintegration/github-actions.md -&gt; integration/platforms/github-actions.md\nintegration/gitlab.md -&gt; integration/platforms/gitlab-ci.md\nintegration/gitlab-services.md -&gt; integration/platforms/gitlab-services.md\n\n# Architecture section reorganization\narchitecture/workflows.md -&gt; architecture/workflows/index.md\narchitecture/diagrams.md -&gt; architecture/diagrams/index.md\n\n# Configuration section reorganization\nconfiguration/thresholds.md -&gt; configuration/thresholds/index.md\nconfiguration/plugins.md -&gt; configuration/plugins/index.md\nconfiguration/advanced/plugin-modifications.md -&gt; configuration/plugins/implementation.md\nconfiguration/advanced/saf-cli-integration.md -&gt; configuration/integration/saf-cli.md\nconfiguration/advanced/thresholds.md -&gt; configuration/thresholds/advanced.md\n\n# Helm Charts reorganization\nhelm-charts/overview.md -&gt; helm-charts/overview/index.md\nhelm-charts/architecture.md -&gt; helm-charts/overview/architecture.md\nhelm-charts/common-scanner.md -&gt; helm-charts/scanner-types/common-scanner.md\nhelm-charts/distroless-scanner.md -&gt; helm-charts/scanner-types/distroless-scanner.md\nhelm-charts/sidecar-scanner.md -&gt; helm-charts/scanner-types/sidecar-scanner.md\nhelm-charts/standard-scanner.md -&gt; helm-charts/scanner-types/standard-scanner.md\nhelm-charts/scanner-infrastructure.md -&gt; helm-charts/infrastructure/index.md\nhelm-charts/security.md -&gt; helm-charts/security/index.md\nhelm-charts/troubleshooting.md -&gt; helm-charts/operations/troubleshooting.md\nhelm-charts/customization.md -&gt; helm-charts/usage/customization.md\n\n# Developer Guide reorganization\ndeveloper-guide/deployment/scenarios.md -&gt; developer-guide/deployment/scenarios/index.md\ndeveloper-guide/deployment/advanced-topics.md -&gt; developer-guide/deployment/advanced-topics/index.md\n</code></pre>"},{"location":"project/content-map/#sidecar-specific-file-reorganization","title":"Sidecar-Specific File Reorganization","text":"<pre><code># Sidecar container specific files\napproaches/sidecar-container/pod-configuration.md -&gt; approaches/sidecar-container/implementation.md\napproaches/sidecar-container/retrieving-results.md -&gt; approaches/sidecar-container/implementation.md\n</code></pre>"},{"location":"project/content-organization-approach/","title":"Content Organization Approach","text":"<p>This document outlines the approach for organizing documentation content for optimal readability and navigation.</p>"},{"location":"project/content-organization-approach/#overview","title":"Overview","text":"<p>In addition to our basic directory structure pattern with index.md and inventory.md files, we've identified the need to break down large documentation pages into smaller, more focused subsections. This approach improves readability, makes navigation more intuitive, and allows users to find specific information more quickly.</p>"},{"location":"project/content-organization-approach/#content-organization-pattern","title":"Content Organization Pattern","text":"<p>For comprehensive documentation sections, we follow this organization pattern:</p> <ol> <li>Section Overview Page</li> <li>A high-level introduction to the topic area</li> <li>Summary of key concepts and subtopics</li> <li>Links to detailed subtopic pages</li> <li> <p>Serves as the entry point for the section</p> </li> <li> <p>Dedicated Subdirectory</p> </li> <li>Create a subdirectory named after the section</li> <li>Place all subtopic files in this directory</li> <li> <p>Include index.md and inventory.md in the subdirectory</p> </li> <li> <p>Individual Topic Pages</p> </li> <li>Create separate markdown files for each subtopic</li> <li>Focus each file on a specific aspect of the larger topic</li> <li>Keep files focused and concise (typically under 300 lines)</li> <li> <p>Use consistent naming conventions (e.g., <code>scaling.md</code>, <code>security.md</code>)</p> </li> <li> <p>Redirect Pattern</p> </li> <li>Keep the original section file as a redirect page</li> <li>Include a note about reorganization</li> <li>Provide links to all subtopic pages</li> <li>Ensures backward compatibility with existing links</li> </ol>"},{"location":"project/content-organization-approach/#navigation-structure","title":"Navigation Structure","text":"<p>In the MkDocs navigation:</p> <pre><code># Example navigation structure\n- Section Name:\n  - Overview: section/index.md\n  - Directory Contents: section/inventory.md\n  - Subtopic Group A:\n    - First Subtopic: section/subtopic1.md\n    - Second Subtopic: section/subtopic2.md\n  - Subtopic Group B:\n    - Third Subtopic: section/subtopic3.md\n    - Fourth Subtopic: section/subtopic4.md\n</code></pre>"},{"location":"project/content-organization-approach/#implementation-examples","title":"Implementation Examples","text":"<p>We have successfully applied this pattern to the following sections:</p> <ol> <li>Deployment Scenarios</li> <li>Created scenarios subdirectory</li> <li>Broke down into individual scenario files (enterprise.md, development.md, etc.)</li> <li>Added comprehensive index.md and inventory.md files</li> <li> <p>Updated navigation with logical grouping</p> </li> <li> <p>Advanced Deployment Topics</p> </li> <li>Created advanced-topics subdirectory</li> <li>Split into focused topic files (scaling.md, security.md, etc.)</li> <li>Created detailed cross-references between related topics</li> <li> <p>Maintained the original file as a redirect</p> </li> <li> <p>Scanning Approaches</p> </li> <li>Created dedicated subdirectories for each approach:<ul> <li>kubernetes-api/ - For the Kubernetes API approach</li> <li>debug-container/ - For the Debug Container approach</li> <li>sidecar-container/ - For the Sidecar Container approach</li> <li>helper-scripts/ - For the Helper Scripts documentation</li> </ul> </li> <li>Implemented focused topic files for each aspect (implementation, limitations, security, etc.)</li> <li>Created comprehensive index.md and inventory.md files for each approach</li> <li>Updated navigation with logical grouping by approach</li> <li>Improved cross-references between related approaches</li> </ol>"},{"location":"project/content-organization-approach/#when-to-apply-this-approach","title":"When to Apply This Approach","text":"<p>Consider breaking down content into subtopics when:</p> <ol> <li>The content exceeds 300 lines in a single file</li> <li>The section covers multiple distinct concepts or approaches</li> <li>Users would likely be interested in specific subsections rather than the entire content</li> <li>The content would benefit from a hierarchical organization</li> <li>Different user personas would be interested in different subsections</li> </ol>"},{"location":"project/content-organization-approach/#implementation-process","title":"Implementation Process","text":"<p>To implement this approach for a section:</p> <ol> <li>Analyze Content</li> <li>Review existing content and identify logical divisions</li> <li>Plan the subdirectory and file structure</li> <li> <p>Identify connections between subtopics</p> </li> <li> <p>Create Directory Structure</p> </li> <li>Create a subdirectory named after the section</li> <li> <p>Plan file names that reflect their content</p> </li> <li> <p>Create Content Files</p> </li> <li>Start with index.md for the section overview</li> <li>Create individual files for each subtopic</li> <li>Ensure each file is focused and comprehensive</li> <li> <p>Add cross-references between related subtopics</p> </li> <li> <p>Update Original File</p> </li> <li>Convert the original file to a redirect page</li> <li>Include a note about reorganization</li> <li> <p>List links to all new subtopic pages</p> </li> <li> <p>Update Navigation</p> </li> <li>Update mkdocs.yml to reflect the new structure</li> <li>Group related subtopics under appropriate headings</li> <li> <p>Ensure logical navigation flow</p> </li> <li> <p>Test and Validate</p> </li> <li>Verify all pages are accessible</li> <li>Check for proper rendering</li> <li>Test navigation flow and usability</li> </ol>"},{"location":"project/content-organization-approach/#sections-to-apply-this-pattern","title":"Sections to Apply This Pattern","text":"<p>Based on our analysis, the following sections should be considered for this reorganization approach:</p> Section Current Status Priority Notes Approaches \u2705 Completed High Split scanning approaches into individual directories with focused files Security \u2705 Completed High Created dedicated subdirectories for principles, risk, compliance, threat-model, and recommendations Helm Charts \u2705 Completed High Reorganized into overview/, scanner-types/, infrastructure/, usage/, security/, and operations/ subdirectories Configuration \ud83d\udcc5 Planned Medium Separate by configuration target Architecture \ud83d\udcc5 Planned Medium Split by architectural component Integration \ud83d\udcc5 Planned Medium Separate by integration platform"},{"location":"project/content-organization-approach/#expected-benefits","title":"Expected Benefits","text":"<p>Implementing this organization pattern will:</p> <ol> <li>Improve Readability: Smaller, focused files are easier to read and understand</li> <li>Enhance Navigation: Logical hierarchy makes information easier to find</li> <li>Facilitate Maintenance: Smaller files are easier to update and maintain</li> <li>Support Collaboration: Multiple contributors can work on different subtopics</li> <li>Reduce Cognitive Load: Users only need to focus on relevant subtopics</li> </ol>"},{"location":"project/content-organization-approach/#related-documents","title":"Related Documents","text":"<ul> <li>Documentation Structure Reorganization Progress</li> <li>Documentation Entry Point Refactoring</li> <li>Documentation Review Plan</li> </ul>"},{"location":"project/documentation-cleanup-plan/","title":"Documentation Cleanup and Stabilization Plan","text":"<p>This document outlines our systematic approach to stabilizing the documentation structure after the comprehensive reorganization. It serves as a reference for maintaining continuity in the cleanup process.</p>"},{"location":"project/documentation-cleanup-plan/#current-understanding","title":"Current Understanding","text":""},{"location":"project/documentation-cleanup-plan/#reorganization-process","title":"Reorganization Process","text":"<ul> <li>Large documentation files were broken into smaller, focused files organized in subdirectories</li> <li>Each section follows a consistent pattern: index.md (overview), inventory.md (listing), and specific topic files</li> <li>Original files and new reorganized structure currently coexist</li> <li>Reorganization documented in <code>/docs/project/*-reorganization-summary.md</code> files</li> </ul>"},{"location":"project/documentation-cleanup-plan/#current-state","title":"Current State","text":"<ul> <li>Navigation in mkdocs.yml mostly points to the new structure</li> <li>Cross-references in content still often point to old file paths</li> <li>Both old files (e.g., <code>kubernetes-api.md</code>) and new structure (e.g., <code>kubernetes-api/index.md</code>) exist</li> </ul>"},{"location":"project/documentation-cleanup-plan/#reorganized-sections","title":"Reorganized Sections","text":"<ul> <li>Approaches: kubernetes-api/, debug-container/, sidecar-container/, helper-scripts/</li> <li>Architecture: components/, deployment/, diagrams/, integrations/, workflows/</li> <li>Configuration: advanced/, integration/, kubeconfig/, plugins/, security/, thresholds/</li> <li>Contributing: testing/</li> <li>Developer Guide: deployment/ (including advanced-topics/, scenarios/), testing/</li> <li>Helm Charts: overview/, scanner-types/, infrastructure/, usage/, security/, operations/</li> <li>Integration: platforms/, workflows/, examples/, configuration/</li> <li>Security: principles/, risk/, compliance/, threat-model/, recommendations/</li> <li>Other Directories: examples/, github-workflow-examples/, gitlab-pipeline-examples/, gitlab-services-examples/, kubernetes-setup/, overview/, rbac/, service-accounts/, tokens/, utilities/</li> </ul>"},{"location":"project/documentation-cleanup-plan/#order-of-operations","title":"Order of Operations","text":""},{"location":"project/documentation-cleanup-plan/#phase-1-preparation","title":"Phase 1: Preparation","text":"<ol> <li>Create backup directory</li> </ol> <pre><code>mkdir -p /Users/alippold/github/mitre/kube-secure-scanner/docs-backup\n</code></pre> <ol> <li>Create TODO list document</li> <li>Document placeholder files that need to be created</li> <li>Track content gaps identified during reorganization</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-2-approaches-section-cleanup","title":"Phase 2: Approaches Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li>Find all references to old file paths (e.g., <code>kubernetes-api.md</code>)</li> <li> <p>Document the files that need updating</p> </li> <li> <p>Update cross-references</p> </li> <li>Update links to point to new structure</li> <li> <p>Follow established patterns:</p> <ul> <li><code>approaches/kubernetes-api.md</code> \u2192 <code>approaches/kubernetes-api/index.md</code></li> <li><code>approaches/debug-container.md</code> \u2192 <code>approaches/debug-container/index.md</code></li> <li><code>approaches/sidecar-container.md</code> \u2192 <code>approaches/sidecar-container/index.md</code></li> </ul> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to docs-backup directory at the project root</li> <li>Maintain directory structure for reference</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-3-integration-section-cleanup","title":"Phase 3: Integration Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old file paths</p> </li> <li> <p>Update cross-references</p> </li> <li>Update links to point to new structure</li> <li> <p>Follow established patterns:</p> <ul> <li><code>integration/github-actions.md</code> \u2192 <code>integration/platforms/github-actions.md</code></li> <li><code>integration/gitlab.md</code> \u2192 <code>integration/platforms/gitlab-ci.md</code></li> <li><code>integration/gitlab-services.md</code> \u2192 <code>integration/platforms/gitlab-services.md</code></li> <li><code>integration/overview.md</code> \u2192 <code>integration/index.md</code></li> </ul> </li> <li> <p>Move old files to backup</p> </li> <li>Move any remaining original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-4-architecture-section-cleanup","title":"Phase 4: Architecture Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old file paths (e.g., <code>architecture/workflows.md</code>)</p> </li> <li> <p>Update cross-references</p> </li> <li>Update links to point to new structure</li> <li> <p>Follow patterns:</p> <ul> <li><code>architecture/workflows.md</code> \u2192 <code>architecture/workflows/index.md</code></li> <li><code>architecture/diagrams.md</code> \u2192 <code>architecture/diagrams/index.md</code></li> </ul> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-5-configuration-section-cleanup","title":"Phase 5: Configuration Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old configuration files</p> </li> <li> <p>Update cross-references</p> </li> <li> <p>Update links to point to new subdirectory structure</p> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-6-security-section-cleanup","title":"Phase 6: Security Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old file paths</p> </li> <li> <p>Update cross-references</p> </li> <li>Update links to point to new structure</li> <li> <p>Follow established patterns</p> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-7-helm-charts-section-cleanup","title":"Phase 7: Helm Charts Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old file paths</p> </li> <li> <p>Update cross-references</p> </li> <li> <p>Update links to point to new structure</p> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-8-developer-guide-section-cleanup","title":"Phase 8: Developer Guide Section Cleanup","text":"<ol> <li>Identify cross-references</li> <li> <p>Find all references to old file paths (e.g., <code>developer-guide/deployment/scenarios.md</code>)</p> </li> <li> <p>Update cross-references</p> </li> <li> <p>Update links to point to appropriate subdirectory files</p> </li> <li> <p>Move old files to backup</p> </li> <li>Move original files to backup directory</li> </ol>"},{"location":"project/documentation-cleanup-plan/#phase-9-validation-and-finalization","title":"Phase 9: Validation and Finalization","text":"<ol> <li>Build documentation</li> </ol> <pre><code>./docs-tools.sh build\n</code></pre> <ol> <li>Check for warnings</li> <li>Review build output for warnings about missing files or broken links</li> <li> <p>Update any remaining issues</p> </li> <li> <p>Run link checker</p> </li> </ol> <pre><code>./docs-tools.sh links\n</code></pre> <ol> <li>Verify navigation</li> <li>Preview the documentation</li> <li> <p>Test navigation paths for key user journeys</p> </li> <li> <p>Review backup files</p> </li> <li>Confirm all content from old files exists in the new structure</li> <li>Document any content that still needs to be migrated</li> </ol>"},{"location":"project/documentation-cleanup-plan/#cross-reference-patterns","title":"Cross-Reference Patterns","text":""},{"location":"project/documentation-cleanup-plan/#approaches-section","title":"Approaches Section","text":"<ul> <li><code>approaches/kubernetes-api.md</code> \u2192 <code>approaches/kubernetes-api/index.md</code></li> <li><code>approaches/debug-container.md</code> \u2192 <code>approaches/debug-container/index.md</code></li> <li><code>approaches/sidecar-container.md</code> \u2192 <code>approaches/sidecar-container/index.md</code></li> <li><code>approaches/direct-commands.md</code> \u2192 <code>approaches/helper-scripts/scripts-vs-commands.md</code></li> </ul>"},{"location":"project/documentation-cleanup-plan/#architecture-section","title":"Architecture Section","text":"<ul> <li><code>architecture/workflows.md</code> \u2192 <code>architecture/workflows/index.md</code></li> <li><code>architecture/diagrams.md</code> \u2192 <code>architecture/diagrams/index.md</code></li> <li><code>architecture/components.md</code> \u2192 <code>architecture/components/index.md</code> (if exists)</li> </ul>"},{"location":"project/documentation-cleanup-plan/#configuration-section","title":"Configuration Section","text":"<ul> <li><code>configuration/kubeconfig.md</code> \u2192 <code>configuration/kubeconfig/index.md</code> (if exists)</li> <li><code>configuration/thresholds.md</code> \u2192 <code>configuration/thresholds/index.md</code></li> <li><code>configuration/plugins.md</code> \u2192 <code>configuration/plugins/index.md</code> (if exists)</li> <li><code>configuration/security.md</code> \u2192 <code>configuration/security/index.md</code> (if exists)</li> </ul>"},{"location":"project/documentation-cleanup-plan/#developer-guide-section","title":"Developer Guide Section","text":"<ul> <li><code>developer-guide/deployment/scenarios.md</code> \u2192 <code>developer-guide/deployment/scenarios/index.md</code></li> <li><code>developer-guide/deployment/advanced-topics.md</code> \u2192 <code>developer-guide/deployment/advanced-topics/index.md</code></li> </ul>"},{"location":"project/documentation-cleanup-plan/#integration-section","title":"Integration Section","text":"<ul> <li><code>integration/github-actions.md</code> \u2192 <code>integration/platforms/github-actions.md</code></li> <li><code>integration/gitlab.md</code> \u2192 <code>integration/platforms/gitlab-ci.md</code></li> <li><code>integration/gitlab-services.md</code> \u2192 <code>integration/platforms/gitlab-services.md</code></li> <li><code>integration/overview.md</code> \u2192 <code>integration/index.md</code></li> </ul>"},{"location":"project/documentation-cleanup-plan/#security-section","title":"Security Section","text":"<ul> <li><code>security/analysis.md</code> \u2192 Multiple files in subdirectories</li> <li><code>security/compliance.md</code> \u2192 <code>security/compliance/index.md</code></li> <li><code>security/risk-analysis.md</code> \u2192 <code>security/risk/index.md</code></li> <li><code>security/overview.md</code> \u2192 <code>security/index.md</code></li> <li><code>security/principles.md</code> \u2192 <code>security/principles/index.md</code> (if exists)</li> <li><code>security/threat-model.md</code> \u2192 <code>security/threat-model/index.md</code> (if exists)</li> </ul>"},{"location":"project/documentation-cleanup-plan/#helm-charts-section","title":"Helm Charts Section","text":"<ul> <li><code>helm-charts/architecture.md</code> \u2192 <code>helm-charts/overview/architecture.md</code></li> <li><code>helm-charts/common-scanner.md</code> \u2192 <code>helm-charts/scanner-types/common-scanner.md</code></li> <li><code>helm-charts/distroless-scanner.md</code> \u2192 <code>helm-charts/scanner-types/distroless-scanner.md</code></li> <li><code>helm-charts/sidecar-scanner.md</code> \u2192 <code>helm-charts/scanner-types/sidecar-scanner.md</code></li> <li><code>helm-charts/standard-scanner.md</code> \u2192 <code>helm-charts/scanner-types/standard-scanner.md</code></li> <li><code>helm-charts/scanner-infrastructure.md</code> \u2192 <code>helm-charts/infrastructure/index.md</code></li> <li><code>helm-charts/security.md</code> \u2192 <code>helm-charts/security/index.md</code></li> <li><code>helm-charts/troubleshooting.md</code> \u2192 <code>helm-charts/operations/troubleshooting.md</code></li> <li><code>helm-charts/overview.md</code> \u2192 <code>helm-charts/overview/index.md</code></li> <li><code>helm-charts/customization.md</code> \u2192 <code>helm-charts/usage/customization.md</code></li> </ul>"},{"location":"project/documentation-cleanup-plan/#other-directories","title":"Other Directories","text":"<ul> <li>From root paths to appropriate subdirectory paths based on reorganization pattern</li> </ul>"},{"location":"project/documentation-cleanup-plan/#useful-commands","title":"Useful Commands","text":""},{"location":"project/documentation-cleanup-plan/#finding-cross-references","title":"Finding Cross-References","text":"<pre><code># Find references to old file paths\ngrep -r \"kubernetes-api\\.md\" --include=\"*.md\" /Users/alippold/github/mitre/kube-secure-scanner/docs | grep -v node_modules\n\n# Find all markdown files in a directory\nfind /Users/alippold/github/mitre/kube-secure-scanner/docs/approaches -type f -name \"*.md\" | sort\n\n# List reorganization summary files\nls -la /Users/alippold/github/mitre/kube-secure-scanner/docs/project/*reorganization*\n</code></pre>"},{"location":"project/documentation-cleanup-plan/#viewing-directory-structure","title":"Viewing Directory Structure","text":"<pre><code># View directory structure with tree command\ntree -L 2 /Users/alippold/github/mitre/kube-secure-scanner/docs/approaches\n\n# View directory structure with limited depth\ntree -L 1 /Users/alippold/github/mitre/kube-secure-scanner/docs\ntree -L 3 /Users/alippold/github/mitre/kube-secure-scanner/docs/approaches\n</code></pre>"},{"location":"project/documentation-cleanup-plan/#backup-operations","title":"Backup Operations","text":"<pre><code># Create backup directory\nmkdir -p /Users/alippold/github/mitre/kube-secure-scanner/docs-backup\n\n# Move a file to backup (preserving directory structure)\nmkdir -p /Users/alippold/github/mitre/kube-secure-scanner/docs-backup/approaches\nmv /Users/alippold/github/mitre/kube-secure-scanner/docs/approaches/kubernetes-api.md /Users/alippold/github/mitre/kube-secure-scanner/docs-backup/approaches/\n</code></pre>"},{"location":"project/documentation-cleanup-plan/#documentation-tools","title":"Documentation Tools","text":"<pre><code># Build documentation\n./docs-tools.sh build\n\n# Check links\n./docs-tools.sh links\n\n# Preview documentation\n./docs-tools.sh preview\n</code></pre>"},{"location":"project/documentation-cleanup-plan/#note-on-context-restoration","title":"Note on Context Restoration","text":"<p>This document serves as a reference for restoring context when returning to the documentation cleanup task. Refer to this file to quickly understand the state of the reorganization and next steps in the process.</p>"},{"location":"project/documentation-cleanup-progress/","title":"Documentation Clean-up Progress Tracking","text":"<p>This document tracks the progress of fixing cross-references and link issues throughout the documentation.</p>"},{"location":"project/documentation-cleanup-progress/#processing-steps","title":"Processing Steps","text":"<p>For each section, we follow these comprehensive steps:</p> <ol> <li>Documentation Issue Detection: Run <code>extract-doc-warnings.sh --info</code> to identify all issue types</li> <li>Basic Link Fixing: Run <code>fix-links-simple.sh</code> to update file moves with comprehensive mappings</li> <li>Relative Path Fixing: Fix relative paths and convert absolute paths to relative</li> <li>INFO Message Handling: Fix directory links, add missing anchors, and analyze \"-new\" files</li> <li>Verification: Check results with MkDocs build to confirm fixed links</li> <li>Special Cases: Address any section-specific issues that require manual attention</li> </ol>"},{"location":"project/documentation-cleanup-progress/#progress-tracking-table","title":"Progress Tracking Table","text":"Section Basic Link Fixing Relative Path Fixing INFO Message Handling Verification Special Cases Notes <code>/approaches</code> Complete Complete Complete Complete Complete 100% compliance on links <code>/approaches/debug-container</code> Complete Complete Complete Complete Complete Fixed future-work.md links to project/roadmap.md <code>/approaches/kubernetes-api</code> Complete Complete Complete Complete Complete Fixed future-work.md links to project/roadmap.md <code>/approaches/sidecar-container</code> Complete Complete Complete Complete Complete Fixed absolute links to relative paths <code>/approaches/helper-scripts</code> Complete Complete Complete Complete Complete Fixed implementation.md and customization.md links <code>/architecture</code> Complete Complete Complete Complete Complete Added to mkdocs.yml navigation <code>/architecture/components</code> Complete Complete Complete Complete Complete Added to mkdocs.yml navigation <code>/architecture/workflows</code> Complete Complete Complete Complete Complete Fixed integration links <code>/architecture/diagrams</code> Complete Complete Complete Complete Complete Added to mkdocs.yml navigation <code>/architecture/deployment</code> Complete Complete Complete Complete Complete Added to mkdocs.yml navigation <code>/architecture/integrations</code> Complete Complete Complete Complete Complete Added to mkdocs.yml navigation <code>/configuration</code> Complete Complete Complete Complete Complete 100% compliant - no warnings <code>/configuration/advanced</code> Complete Complete Complete Complete Complete Verified with build <code>/configuration/kubeconfig</code> Complete Complete Complete Complete Complete Verified with build <code>/configuration/plugins</code> Complete Complete Complete Complete Complete Verified with build <code>/configuration/integration</code> Complete Complete Complete Complete Complete Verified with build <code>/configuration/thresholds</code> Complete Complete Complete Complete Complete Verified with build <code>/configuration/security</code> Complete Complete Complete Complete Complete Verified with build <code>/security</code> Complete Complete Complete Complete Complete Fixed directory links and index references <code>/security/principles</code> Complete Complete Complete Complete Complete Fixed directory references <code>/security/risk</code> Complete Complete Complete Complete Complete Fixed compliance links to proper locations <code>/security/compliance</code> Complete Complete Complete Complete Complete Fixed approach-comparison links <code>/security/threat-model</code> Complete Complete Complete Complete Complete Fixed directory references <code>/security/recommendations</code> Complete Complete Complete Complete Complete Fixed links to enterprise.md, ci-cd.md, and monitoring.md <code>/helm-charts</code> Complete Complete Complete Complete Complete 100% compliant - no warnings <code>/helm-charts/overview</code> Complete Complete Complete Complete Complete Verified with build <code>/helm-charts/scanner-types</code> Complete Complete Complete Complete Complete Verified with build <code>/helm-charts/infrastructure</code> Complete Complete Complete Complete Complete Verified with build <code>/helm-charts/usage</code> Complete Complete Complete Complete Complete Verified with build <code>/helm-charts/security</code> Complete Complete Complete Complete Complete Verified with build <code>/helm-charts/operations</code> Complete Complete Complete Complete Complete Verified with build <code>/integration</code> Complete Complete Complete Complete Complete Updated inventory links <code>/integration/platforms</code> Complete Complete Complete Complete Complete Fixed missing file links <code>/integration/workflows</code> Complete Complete Complete Complete Complete Added missing configuration anchors <code>/integration/examples</code> Complete Complete Complete Complete Complete Fixed missing file links <code>/integration/configuration</code> Complete Complete Complete Complete Complete Fixed missing anchor references <code>/rbac</code> Complete Complete Complete Complete Complete Verified with build <code>/service-accounts</code> Complete Complete Complete Complete Complete Verified with build <code>/tokens</code> Complete Complete Complete Complete Complete Verified with build <code>/kubernetes-setup</code> Complete Complete Complete Complete Complete Verified with build <code>/overview</code> Complete Complete Complete Complete Complete Verified with build <code>/developer-guide</code> Complete Complete Complete Complete Complete Fixed profile-development.md references"},{"location":"project/documentation-cleanup-progress/#overall-progress","title":"Overall Progress","text":"<ul> <li>Total Sections: 37</li> <li>Sections Completed: 37 (100%)<ul> <li>approaches</li> <li>approaches/debug-container</li> <li>approaches/kubernetes-api</li> <li>approaches/sidecar-container</li> <li>approaches/helper-scripts</li> <li>security</li> <li>security/principles</li> <li>security/risk</li> <li>security/compliance</li> <li>security/threat-model</li> <li>security/recommendations</li> <li>integration</li> <li>integration/platforms</li> <li>integration/workflows</li> <li>integration/examples</li> <li>integration/configuration</li> <li>test files</li> <li>developer-guide</li> <li>architecture</li> <li>architecture/components</li> <li>architecture/workflows</li> <li>architecture/diagrams</li> <li>architecture/deployment</li> <li>architecture/integrations</li> <li>configuration</li> <li>configuration/advanced</li> <li>configuration/kubeconfig</li> <li>configuration/plugins</li> <li>configuration/integration</li> <li>configuration/thresholds</li> <li>configuration/security</li> <li>helm-charts</li> <li>rbac</li> <li>service-accounts</li> <li>tokens</li> <li>kubernetes-setup</li> <li>overview</li> </ul> </li> <li>Sections In Progress: 0</li> <li>Sections Not Started: 0</li> </ul>"},{"location":"project/documentation-cleanup-progress/#mkdocs-build-warnings-tracking","title":"MkDocs Build Warnings Tracking","text":"<p>Initial warning count: ~125 link warnings</p> Date Warnings Count Notes March 26, 2025 125 Starting point March 26, 2025 44 After fixing integration/platforms and integration/examples March 26, 2025 23 After fixing approaches section links March 26, 2025 16 After fixing helper-scripts documentation March 26, 2025 7 After fixing security section links March 26, 2025 0 After fixing remaining links and addressing INFO messages March 26, 2025 0 Verified all sections: configuration, helm-charts, rbac, service-accounts, tokens, kubernetes-setup, and overview <p>The documentation is now 100% compliant with no warnings. We've also addressed INFO messages by:</p> <ol> <li>Converting directory links to index.md references</li> <li>Converting absolute links to relative paths</li> <li>Adding missing anchor points in target files</li> <li>Removing redundant \"-new\" files after comparison</li> </ol>"},{"location":"project/documentation-cleanup-progress/#project-cleanup-report","title":"Project Cleanup Report","text":"<p>We've created a comprehensive cleanup-script.sh for managing project maintenance:</p> File Type Count Action Backup files (.bak,.backup, etc.) 2 Identified for removal Test files (test-.md, test-.sh, etc.) 11 Identified for removal Warning tracking files (warning.txt) 8 Identified for removal Unused documentation files 37 Identified for review <p>The script identifies files into several categories:</p> <ol> <li>Backup files: Safe to remove after verification</li> <li>Test files: Created during testing, safe to remove if no longer needed</li> <li>Warning tracking files: Can be removed after warnings are fixed</li> <li>Unused documentation files: Require manual review to determine appropriate action</li> </ol>"},{"location":"project/documentation-cleanup-progress/#cleanup-procedure","title":"Cleanup Procedure","text":"<ol> <li>Review the cleanup report in the <code>cleanup-report/</code> directory</li> <li>For backup, test, and warning files:</li> <li>Run <code>./cleanup-script.sh --remove</code> to clean up</li> <li>For unused documentation files:</li> <li>Manually review each file in <code>cleanup-report/unused-files.txt</code></li> <li>Determine if each file should be:      a) Added to mkdocs.yml navigation      b) Kept as reference but not in navigation      c) Removed as no longer needed</li> <li>Create a documentation review checklist for unused files</li> </ol>"},{"location":"project/documentation-cleanup-progress/#final-verification","title":"Final Verification","text":"<p>We have completed verification for all processed sections:</p> <ol> <li>\u2705 MkDocs build - 0 warnings achieved</li> <li>\u2705 INFO message handling - Directory links, absolute paths fixed</li> <li>\u2705 Cross-reference verification - All links now resolve correctly</li> <li>\u2705 Navigation checks - Key documentation paths work correctly</li> <li>\u2705 Project maintenance - Created comprehensive cleanup-script.sh with:</li> <li>Cross-platform compatibility (Linux and macOS)</li> <li>Intelligent file categorization</li> <li>Safe operation with dry-run mode</li> <li>Detailed reporting capabilities</li> </ol> <p>For remaining sections, follow the enhanced process:</p> <ol> <li>Run <code>./scripts/extract-doc-warnings.sh --info</code> to identify issues</li> <li>Fix warnings and errors first (critical for build)</li> <li>Address INFO messages for optimal documentation</li> <li>Compare any \"-new\" files with originals</li> <li>Verify with <code>cd docs &amp;&amp; ./docs-tools.sh build</code></li> <li>Update documentation-cleanup-progress.md after each section</li> </ol>"},{"location":"project/documentation-cleanup-progress/#notes-and-special-cases","title":"Notes and Special Cases","text":"<ul> <li> <p>Approaches Section: \u2705 COMPLETED</p> <ul> <li>Fixed future-work.md links to point to project/roadmap.md</li> <li>Fixed absolute links to use relative paths</li> <li>Fixed implementation.md and customization.md links</li> <li>Fixed corrupted link formats with nested parentheses</li> </ul> </li> <li> <p>Integration Section: \u2705 COMPLETED</p> <ul> <li>Added missing configuration anchors in workflow files</li> <li>Fixed missing anchors for cross-references</li> <li>Updated all directory references to index.md files</li> </ul> </li> <li> <p>Security Section: \u2705 COMPLETED</p> <ul> <li>Fixed directory links to point to index.md files</li> <li>Fixed links to development/scenarios files</li> <li>Fixed compliance links to point to proper locations</li> <li>Fixed recommendations links to enterprise.md, ci-cd.md, and monitoring.md</li> </ul> </li> <li> <p>Developer Guide Section: \u2705 COMPLETED</p> <ul> <li>Fixed profile-development.md references to custom-development.md</li> <li>Updated security links to correct paths</li> </ul> </li> <li> <p>Architecture Section: \ud83d\udea9 NEEDS ATTENTION</p> <ul> <li>Has cross-references to integration section that need special handling</li> <li>Workflow diagrams need to reference both approaches and integration sections</li> </ul> </li> <li> <p>Configuration Section: \ud83d\udea9 NEEDS ATTENTION</p> <ul> <li>Contains references to multiple other sections</li> <li>Kubeconfig subdirectory has many technical references that need verification</li> </ul> </li> <li> <p>Helm Charts Section: \ud83d\udea9 NEEDS ATTENTION</p> <ul> <li>Heavily reorganized section with many cross-references</li> <li>References to security/recommendations need special attention</li> </ul> </li> <li> <p>Architecture Section: \u2705 COMPLETED</p> <ul> <li>Added all subdirectories to mkdocs.yml navigation</li> <li>Verified proper relative paths in workflow files</li> <li>Fixed references to integration workflows</li> <li>No warnings present in build</li> </ul> </li> <li> <p>Script Improvements: \u2705 COMPLETED</p> <ul> <li>Created comprehensive cleanup-script.sh with cross-platform support</li> <li>Fixed track-warning-progress.sh to handle integer parsing properly</li> <li>Enhanced documentation of processes in SESSION-RECOVERY.md</li> </ul> </li> </ul>"},{"location":"project/documentation-coming-soon/","title":"Documentation Coming Soon Tasks","text":"<p>This document lists the planned future documentation files that are currently referenced in the documentation as \"coming soon\". These should be created as part of the ongoing documentation improvement process.</p>"},{"location":"project/documentation-coming-soon/#integration-section","title":"Integration Section","text":""},{"location":"project/documentation-coming-soon/#platforms","title":"Platforms","text":"File Path Description <code>integration/platforms/jenkins.md</code> Jenkins integration guide <code>integration/platforms/azure-devops.md</code> Azure DevOps integration guide <code>integration/platforms/custom-platforms.md</code> Custom platform integration guide"},{"location":"project/documentation-coming-soon/#examples","title":"Examples","text":"File Path Description <code>integration/examples/gitlab-services-examples.md</code> GitLab Services examples <code>integration/examples/custom-examples.md</code> Custom integration examples"},{"location":"project/documentation-coming-soon/#approaches-section","title":"Approaches Section","text":""},{"location":"project/documentation-coming-soon/#debug-container-approach","title":"Debug Container Approach","text":"File Path Description <code>approaches/debug-container/future-work.md</code> Future work for debug container approach <code>approaches/debug-container/security.md</code> Security considerations for debug container approach"},{"location":"project/documentation-coming-soon/#sidecar-container-approach","title":"Sidecar Container Approach","text":"File Path Description <code>approaches/sidecar-container/future-work.md</code> Future work for sidecar container approach <code>approaches/sidecar-container/pod-configuration.md</code> Pod configuration details for sidecar approach <code>approaches/sidecar-container/retrieving-results.md</code> Results retrieval for sidecar approach"},{"location":"project/documentation-coming-soon/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"File Path Description <code>approaches/kubernetes-api/future-work.md</code> Future work for Kubernetes API approach"},{"location":"project/documentation-coming-soon/#implementation-notes","title":"Implementation Notes","text":"<p>When implementing these documents:</p> <ol> <li>Follow the established structure: Use the same structure as existing documents in the respective sections</li> <li>Update inventory files: Update relevant inventory.md files when adding new documents</li> <li>Update navigation: Ensure new documents are added to the MkDocs navigation in mkdocs.yml</li> <li>Fix cross-references: Update any links pointing to the \"coming soon\" placeholders</li> <li>Follow the process documentation: Use the scripts described in <code>docs/project/warning-resolution-scripts.md</code> to validate and fix any new issues</li> </ol>"},{"location":"project/documentation-coming-soon/#priority-order-suggested","title":"Priority Order (Suggested)","text":"<ol> <li>Approaches section documents - these are core functionality documents</li> <li>Integration platforms - these are important for CI/CD integrations</li> <li>Examples - these are useful reference materials but less critical</li> </ol> <p>The above priority order is a suggestion based on the likely user journey through the documentation, focusing on core concepts first, then integration, and finally examples.</p>"},{"location":"project/documentation-entry-refactoring/","title":"Documentation Entry Point Refactoring Plan","text":"<p>This document outlines a systematic plan for refactoring the main documentation entry points to create a more cohesive, user-friendly experience for different audiences.</p>"},{"location":"project/documentation-entry-refactoring/#goals","title":"Goals","text":"<ol> <li>Create clear, distinct purposes for each documentation entry point</li> <li>Eliminate redundancy across primary entry documents</li> <li>Establish consistent terminology and approach descriptions</li> <li>Create audience-specific navigation paths</li> <li>Enhance visual aids to improve understanding</li> <li>Streamline the information architecture</li> <li>Improve the overall documentation flow and user experience</li> </ol>"},{"location":"project/documentation-entry-refactoring/#order-of-operations","title":"Order of Operations","text":"<p>This plan follows a specific sequence to minimize disruption during refactoring:</p>"},{"location":"project/documentation-entry-refactoring/#phase-1-analysis-and-standardization-prep-work","title":"Phase 1: Analysis and Standardization (Prep Work) \u2705","text":"<ol> <li>Create standardized terminology and descriptions \u2705</li> <li>\u2705 Develop unified descriptions for all three approaches</li> <li>\u2705 Standardize feature descriptions and capabilities</li> <li>\u2705 Create consistent visual styling guidelines</li> <li> <p>\u2705 Finalize the recommended user journeys by role</p> </li> <li> <p>Define clear document purposes \u2705</p> </li> <li>\u2705 Finalize the specific audience and purpose for each entry point</li> <li>\u2705 Document content that should remain, move, or be removed</li> <li>\u2705 Map cross-reference relationships between documents</li> <li>\u2705 Prepare content templates for each entry point</li> </ol>"},{"location":"project/documentation-entry-refactoring/#phase-2-primary-document-refactoring","title":"Phase 2: Primary Document Refactoring \u2705","text":"<ol> <li>Update index.md (Main Entry Point) \u2705</li> <li>\u2705 Implement streamlined introduction</li> <li>\u2705 Create role-based user journey section</li> <li>\u2705 Add visual approach comparison and selection guide</li> <li>\u2705 Implement clean, focused navigation to key sections</li> <li> <p>\u2705 Remove duplicative content that belongs in other documents</p> </li> <li> <p>Refactor quickstart.md (Technical Implementers) \u2705</p> </li> <li>\u2705 Focus exclusively on implementation steps</li> <li>\u2705 Remove conceptual content (move to appropriate locations)</li> <li>\u2705 Add clear prerequisites and verification steps</li> <li>\u2705 Enhance with clear \"next steps\" guidance</li> <li> <p>\u2705 Update all links to reflect the new documentation structure</p> </li> <li> <p>Enhance executive-summary.md (Decision Makers) \u2705</p> </li> <li>\u2705 Refocus entirely on business value and strategic considerations</li> <li>\u2705 Remove technical implementation details</li> <li>\u2705 Add decision flow chart for approach selection</li> <li>\u2705 Include implementation roadmap visualization</li> <li> <p>\u2705 Update compliance information and migration paths</p> </li> <li> <p>Update overview/README.md (Technical Architecture) \u2705</p> </li> <li>\u2705 Refocus on technical components and interactions</li> <li>\u2705 Update directory structure to reflect current organization</li> <li>\u2705 Add enhanced workflow visualizations</li> <li>\u2705 Create clear links to technical implementation details</li> <li>\u2705 Remove duplicate value proposition content</li> </ol>"},{"location":"project/documentation-entry-refactoring/#phase-3-visual-and-navigation-enhancements","title":"Phase 3: Visual and Navigation Enhancements \u2705","text":"<ol> <li>Develop and implement visual aids \u2705</li> <li>\u2705 Create high-level architecture diagram for index.md</li> <li>\u2705 Develop approach comparison visualization</li> <li>\u2705 Add decision flow chart for executive summary</li> <li>\u2705 Implement workflow diagrams for quickstart.md</li> <li> <p>\u2705 Update document styling for consistency</p> </li> <li> <p>Enhance cross-document navigation \u2705</p> </li> <li>\u2705 Implement consistent \"related topics\" sections</li> <li>\u2705 Add \"next steps\" guidance at the end of each page</li> <li>\u2705 Create navigation breadcrumbs for context</li> <li>\u2705 Update all internal links to reflect the new structure</li> <li>\u2705 Add role-based navigation prompts</li> </ol>"},{"location":"project/documentation-entry-refactoring/#phase-4-review-and-refinement","title":"Phase 4: Review and Refinement","text":"<ol> <li>Conduct comprehensive review</li> <li>Verify all links are working correctly</li> <li>Ensure terminology consistency across all documents</li> <li>Check for remaining redundancy or duplication</li> <li>Validate user journey paths are complete and logical</li> <li> <p>Test documentation flow from different user perspectives</p> </li> <li> <p>Make final refinements</p> <ul> <li>Address any issues found during review</li> <li>Optimize for search and discoverability</li> <li>Implement feedback from potential users</li> <li>Finalize visual elements and styling</li> <li>Update any related documents affected by changes</li> </ul> </li> </ol>"},{"location":"project/documentation-entry-refactoring/#detailed-task-plan","title":"Detailed Task Plan","text":""},{"location":"project/documentation-entry-refactoring/#1-create-standardized-terminology-and-descriptions","title":"1. Create Standardized Terminology and Descriptions","text":"<p>Tasks:</p> <ul> <li> Create a terminology document with standard definitions</li> <li> Develop unified descriptions for all three approaches</li> <li> Standardize feature descriptions using consistent language</li> <li> Define visual styling guidelines for diagrams and tables</li> <li> Create a template for approach comparisons</li> </ul> <p>Key Deliverable: Standardized terminology and description document for reference during refactoring</p>"},{"location":"project/documentation-entry-refactoring/#2-define-clear-document-purposes","title":"2. Define Clear Document Purposes","text":"<p>Tasks:</p> <ul> <li> Create content map showing current vs. desired content for each document</li> <li> Define specific audience persona for each entry point</li> <li> List key questions each document should answer</li> <li> Document content that should be moved between documents</li> <li> Create content templates for each entry point</li> </ul> <p>Key Deliverable: Document purpose and content mapping guide</p>"},{"location":"project/documentation-entry-refactoring/#3-update-indexmd-main-entry-point","title":"3. Update index.md (Main Entry Point)","text":"<p>Tasks:</p> <ul> <li> Craft concise, compelling introduction</li> <li> Create role-based \"I am a...\" navigation section</li> <li> Develop visual approach comparison</li> <li> Implement streamlined feature highlights</li> <li> Add clear calls-to-action for different user types</li> <li> Remove content that belongs in other documents</li> </ul> <p>Key Deliverable: Completely refactored index.md serving as an effective project gateway</p>"},{"location":"project/documentation-entry-refactoring/#4-refactor-quickstartmd-technical-implementers","title":"4. Refactor quickstart.md (Technical Implementers)","text":"<p>Tasks:</p> <ul> <li> Reorganize into clear, sequential steps</li> <li> Create distinct sections for different installation methods</li> <li> Add explicit prerequisites section</li> <li> Create verification steps section</li> <li> Develop \"next steps\" section with relevant links</li> <li> Remove conceptual content</li> </ul> <p>Key Deliverable: Streamlined quickstart guide focused on implementation</p>"},{"location":"project/documentation-entry-refactoring/#5-enhance-executive-summarymd-decision-makers","title":"5. Enhance executive-summary.md (Decision Makers)","text":"<p>Tasks:</p> <ul> <li> Refocus on business value and ROI</li> <li> Enhance strategic considerations section</li> <li> Add implementation roadmap visualization</li> <li> Create compliance and security positioning section</li> <li> Develop approach selection guidance</li> <li> Remove technical implementation details</li> </ul> <p>Key Deliverable: Business-focused executive summary for decision makers</p>"},{"location":"project/documentation-entry-refactoring/#6-update-overviewreadmemd-technical-architecture","title":"6. Update overview/README.md (Technical Architecture)","text":"<p>Tasks:</p> <ul> <li> Focus on system components and architecture</li> <li> Update directory structure to match current organization</li> <li> Add component relationship explanations</li> <li> Create clear links to technical documentation</li> <li> Remove duplicate value proposition content</li> <li> Add technical workflow visualizations</li> </ul> <p>Key Deliverable: Technical architecture overview for implementers</p>"},{"location":"project/documentation-entry-refactoring/#7-develop-and-implement-visual-aids","title":"7. Develop and Implement Visual Aids","text":"<p>Tasks:</p> <ul> <li> Create high-level architecture diagram for index.md</li> <li> Develop approach comparison visualization</li> <li> Create decision flow chart for executive summary</li> <li> Implement workflow diagrams for quickstart.md</li> <li> Standardize diagram styling across all documents</li> </ul> <p>Key Deliverable: Suite of visual aids to enhance documentation understanding</p>"},{"location":"project/documentation-entry-refactoring/#8-enhance-cross-document-navigation","title":"8. Enhance Cross-Document Navigation","text":"<p>Tasks:</p> <ul> <li> Implement consistent \"related topics\" sections</li> <li> Add \"next steps\" guidance at the end of each page</li> <li> Create navigation breadcrumbs for context</li> <li> Update all internal links to reflect the new structure</li> <li> Add role-based navigation prompts throughout documents</li> </ul> <p>Key Deliverable: Enhanced navigation system across documentation</p>"},{"location":"project/documentation-entry-refactoring/#9-conduct-comprehensive-review","title":"9. Conduct Comprehensive Review","text":"<p>Tasks:</p> <ul> <li> Verify all links are working correctly</li> <li> Ensure terminology consistency across documents</li> <li> Check for remaining redundancy</li> <li> Validate user journey paths</li> <li> Test documentation flow from different perspectives</li> </ul> <p>Key Deliverable: Review report identifying any remaining issues</p>"},{"location":"project/documentation-entry-refactoring/#10-make-final-refinements","title":"10. Make Final Refinements","text":"<p>Tasks:</p> <ul> <li> Address issues found during review</li> <li> Optimize headings and content for search</li> <li> Implement user feedback</li> <li> Finalize visual elements and styling</li> <li> Update the MkDocs navigation if needed</li> </ul> <p>Key Deliverable: Finalized documentation entry points</p>"},{"location":"project/documentation-entry-refactoring/#success-criteria","title":"Success Criteria","text":"<p>The refactoring will be considered successful when:</p> <ol> <li>Each entry point has a clear, distinct purpose without significant overlap</li> <li>Users can easily find information relevant to their role</li> <li>Terminology is consistent across all documents</li> <li>Navigation between documents is intuitive and logical</li> <li>Visual aids enhance understanding of key concepts</li> <li>The documentation flow guides users from high-level concepts to implementation details</li> <li>Redundancy is minimized or eliminated</li> <li>All links and references are correct and working</li> </ol>"},{"location":"project/documentation-entry-refactoring/#tracking-and-implementation","title":"Tracking and Implementation","text":"<p>This refactoring plan should be tracked in the project task system, with each major phase and significant tasks assigned appropriately. Regular reviews should be conducted after each phase to ensure the refactoring is progressing as expected.</p> <p>After implementation, user feedback should be collected to validate the improvements and identify any additional refinements needed.</p>"},{"location":"project/documentation-gaps/","title":"Documentation Gaps Analysis","text":"<p>This document identifies remaining documentation gaps and opportunities for improvement in the Secure CINC Auditor Kubernetes Container Scanning project documentation.</p>"},{"location":"project/documentation-gaps/#current-status","title":"Current Status","text":"<p>As of March 2025, the documentation is approximately 95% complete. The documentation structure is comprehensive and well-organized, with a logical hierarchy that guides users from high-level concepts to specific implementation details.</p>"},{"location":"project/documentation-gaps/#strengths","title":"Strengths","text":"<ol> <li>Complete Coverage of Core Components:</li> <li>All three scanning approaches thoroughly documented</li> <li>Kubernetes infrastructure setup well-explained</li> <li>Security considerations addressed in detail</li> <li>Helm charts documented with examples</li> <li> <p>CI/CD integration covered for GitHub Actions and GitLab CI</p> </li> <li> <p>Project Documentation:</p> </li> <li>Comprehensive changelog with detailed entries by date</li> <li>Complete tasks tracker showing progress</li> <li>Detailed roadmap with timeline and status percentages</li> <li> <p>Clear project status overview</p> </li> <li> <p>Navigation Structure:</p> </li> <li>Logical organization in mkdocs.yml</li> <li>Proper section hierarchy</li> <li>README.md files for all major directories</li> </ol>"},{"location":"project/documentation-gaps/#documentation-gaps-to-address","title":"Documentation Gaps to Address","text":""},{"location":"project/documentation-gaps/#1-contributing-section-enhancements","title":"1. Contributing Section Enhancements","text":"<ul> <li> <p>Missing Top-level Contributing Guide:</p> <ul> <li>Create a comprehensive README.md for the contributing section</li> <li>Include contribution workflow, pull request process, and development guidelines</li> <li>Link to specialized guides (documentation tools, code snippets, diagram color guide)</li> </ul> </li> <li> <p>Code Contribution Guidelines:</p> <ul> <li>Add specific guidelines for code contributions</li> <li>Include coding standards, testing requirements, and review process</li> <li>Provide examples of good pull requests</li> </ul> </li> </ul>"},{"location":"project/documentation-gaps/#2-testing-documentation-improvements","title":"2. Testing Documentation Improvements","text":"<ul> <li> <p>Example Test Cases:</p> <ul> <li>Add concrete examples of test cases for each scanning approach</li> <li>Include expected outputs and validation criteria</li> <li>Provide troubleshooting guidelines for failed tests</li> </ul> </li> <li> <p>Test Coverage Requirements:</p> <ul> <li>Define minimum test coverage expectations</li> <li>Explain how to measure and report test coverage</li> <li>Integrate with CI/CD validation</li> </ul> </li> </ul>"},{"location":"project/documentation-gaps/#3-examples-directory-organization","title":"3. Examples Directory Organization","text":"<ul> <li> <p>README Files for Example Directories:</p> <ul> <li>Add README.md files to GitHub workflow examples directory</li> <li>Add README.md files to GitLab pipeline examples directory</li> <li>Create index pages that explain each example's purpose and usage</li> </ul> </li> <li> <p>Cross-references to Examples:</p> <ul> <li>Ensure all examples are properly referenced from main documentation</li> <li>Add links from integration guides to specific examples</li> <li>Create a matrix of examples showing which ones apply to different scenarios</li> </ul> </li> </ul>"},{"location":"project/documentation-gaps/#4-quick-reference-materials","title":"4. Quick Reference Materials","text":"<ul> <li> <p>Command Quick Reference:</p> <ul> <li>Create a cheat sheet for common commands</li> <li>Include syntax examples and parameter descriptions</li> <li>Format for easy printing or reference</li> </ul> </li> <li> <p>Workflow Quick Start Guides:</p> <ul> <li>Develop concise guides for common workflows</li> <li>Include step-by-step instructions without detailed explanations</li> <li>Focus on practical usage scenarios</li> </ul> </li> </ul>"},{"location":"project/documentation-gaps/#5-additional-sections-to-consider","title":"5. Additional Sections to Consider","text":"<ul> <li> <p>Troubleshooting Guide:</p> <ul> <li>Create a comprehensive troubleshooting section</li> <li>Include common errors and their resolutions</li> <li>Add diagnostic procedures for different environments</li> </ul> </li> <li> <p>Glossary:</p> <ul> <li>Develop a glossary of technical terms</li> <li>Include project-specific terminology</li> <li>Ensure consistent usage across documentation</li> </ul> </li> <li> <p>FAQ Section:</p> <ul> <li>Compile frequently asked questions</li> <li>Organize by topic area</li> <li>Link to detailed documentation where appropriate</li> </ul> </li> </ul>"},{"location":"project/documentation-gaps/#implementation-priorities","title":"Implementation Priorities","text":""},{"location":"project/documentation-gaps/#high-priority-before-v100-release","title":"High Priority (Before v1.0.0 Release)","text":"<ol> <li>Create top-level Contributing README.md</li> <li>Add README.md files to examples directories</li> <li>Develop troubleshooting guide for common issues</li> <li>Create command quick reference</li> </ol>"},{"location":"project/documentation-gaps/#medium-priority-post-v100","title":"Medium Priority (Post v1.0.0)","text":"<ol> <li>Enhance testing documentation with examples</li> <li>Develop workflow quick start guides</li> <li>Create cross-reference matrix for examples</li> <li>Add glossary of technical terms</li> </ol>"},{"location":"project/documentation-gaps/#low-priority-future-enhancement","title":"Low Priority (Future Enhancement)","text":"<ol> <li>Expand FAQ section based on user feedback</li> <li>Create additional example scenarios</li> <li>Develop video or animated tutorials</li> <li>Add internationalization support for documentation</li> </ol>"},{"location":"project/documentation-gaps/#conclusion","title":"Conclusion","text":"<p>While the documentation is comprehensive and well-structured, addressing these gaps will further enhance its usability and completeness. The high-priority items should be addressed before the v1.0.0 release to ensure users have a complete understanding of the project, while medium and low-priority items can be addressed in future iterations based on user feedback and needs.</p> <p>These documentation improvements will contribute to increased adoption, smoother onboarding for new users, and reduced support burden as users can more effectively self-serve information.</p>"},{"location":"project/documentation-review-plan/","title":"Documentation Review Plan (Phase 4)","text":"<p>This document outlines the systematic approach for implementing Phase 4 (Review and Refinement) of our documentation entry point refactoring plan.</p>"},{"location":"project/documentation-review-plan/#review-findings-summary","title":"Review Findings Summary","text":"<p>Based on our comprehensive analysis, we've identified several key areas requiring attention:</p> <ol> <li>Critical Content Mismatch</li> <li>kubernetes-api.md actually contains content about distroless container scanning</li> <li> <p>debug-container.md appears to focus only on debugging, not scanning</p> </li> <li> <p>Terminology Inconsistencies</p> </li> <li>Terms like \"Kubernetes API Approach\" vs \"Standard Container Scanning\"</li> <li>Inconsistent descriptions of approaches across documents</li> <li>Use of aliases marked \"to avoid\" in terminology.md</li> <li> <p>Non-standardized parenthetical descriptions</p> </li> <li> <p>Content Redundancy</p> </li> <li>Duplicated approach descriptions across multiple documents</li> <li>Implementation details appearing in executive-summary.md</li> <li>Business value statements in technical documents</li> <li> <p>Workflow descriptions repeated in multiple locations</p> </li> <li> <p>User Journey Gaps</p> </li> <li>Missing direct links between related documents in user journeys</li> <li>kubernetes-api.md content mismatch disrupts DevOps Engineer journey</li> <li>Lack of clear prerequisites specific to each approach</li> <li>Missing troubleshooting guidance for each approach</li> </ol>"},{"location":"project/documentation-review-plan/#implementation-plan","title":"Implementation Plan","text":""},{"location":"project/documentation-review-plan/#1-critical-content-fixes-priority-1","title":"1. Critical Content Fixes (Priority 1)","text":"<ol> <li>Fix kubernetes-api.md content mismatch:</li> <li>Create properly named file for distroless content</li> <li>Create new kubernetes-api.md with correct content about the Kubernetes API approach</li> <li> <p>Update all links to ensure proper references</p> </li> <li> <p>Fix debug-container.md content focus:</p> </li> <li>Expand debug-container.md to include scanning aspects, not just debugging</li> <li>Ensure consistent application of terminology</li> <li>Add proper links to relevant documentation</li> </ol>"},{"location":"project/documentation-review-plan/#2-terminology-standardization-priority-2","title":"2. Terminology Standardization (Priority 2)","text":"<ol> <li>Replace non-standard terms with official terminology:</li> <li>Search and replace \"Standard Container Scanning\" with \"Kubernetes API Approach\"</li> <li>Remove all parenthetical descriptions not part of official terms</li> <li> <p>Update all approach descriptions to match standardized descriptions in terminology.md</p> </li> <li> <p>Audit key files for consistent terminology:</p> </li> <li>index.md</li> <li>overview/README.md</li> <li>executive-summary.md</li> <li>quickstart.md</li> <li>approaches/* files</li> </ol>"},{"location":"project/documentation-review-plan/#3-content-redundancy-elimination-priority-3","title":"3. Content Redundancy Elimination (Priority 3)","text":"<ol> <li>Refactor duplicated approach descriptions:</li> <li>Move all approach technical details to approaches/* files</li> <li>Keep only brief overview in index.md</li> <li>Ensure executive-summary.md focuses solely on business value</li> <li> <p>Update quickstart.md to link to approaches/* files instead of duplicating</p> </li> <li> <p>Remove implementation details from non-implementation documents:</p> </li> <li>Remove technical implementation steps from executive-summary.md</li> <li>Move business value statements from overview/README.md to executive-summary.md</li> <li>Consolidate workflow descriptions in architecture/workflows.md</li> </ol>"},{"location":"project/documentation-review-plan/#4-user-journey-enhancement-priority-4","title":"4. User Journey Enhancement (Priority 4)","text":"<ol> <li>Fix DevOps Engineer journey:</li> <li>Ensure kubernetes-api.md contains correct content</li> <li>Add clear links between implementation steps</li> <li> <p>Improve approach selection guidance</p> </li> <li> <p>Enhance cross-document linking:</p> </li> <li>Add \"Next Steps\" sections at the end of each key document</li> <li>Implement \"Related Topics\" sections</li> <li> <p>Create clearer path between architecture/diagrams.md and approaches/decision-matrix.md</p> </li> <li> <p>Add journey-specific enhancements:</p> </li> <li>Create approach-specific prerequisites in quickstart.md</li> <li>Add troubleshooting matrix for each approach</li> <li>Ensure key questions from content-map.md are answered in each document</li> </ol>"},{"location":"project/documentation-review-plan/#validation-testing","title":"Validation Testing","text":"<p>After implementing changes, we will validate improvements through:</p> <ol> <li>Automated Link Testing:</li> <li>Run <code>./docs-tools.sh links</code> to verify all internal links</li> <li> <p>Check cross-references between related documents</p> </li> <li> <p>Terminology Consistency Test:</p> </li> <li>Search for known aliases to verify they've been eliminated</li> <li> <p>Validate all approach descriptions match standardized language</p> </li> <li> <p>User Journey Walk-throughs:</p> </li> <li>Test each user journey by following all links in sequence</li> <li>Verify all critical information is accessible along each path</li> <li> <p>Check that each journey presents a coherent narrative</p> </li> <li> <p>MkDocs Navigation Verification:</p> </li> <li>Build the site with <code>./docs-tools.sh build</code></li> <li>Test navigation structure and breadcrumbs</li> <li>Verify no 404 errors or navigation dead-ends</li> </ol>"},{"location":"project/documentation-review-plan/#action-items","title":"Action Items","text":"<ol> <li>Critical Fixes:</li> <li>\u2705 Normalized README.md vs index.md usage across documentation</li> <li>\u2705 Created index.md files for key sections (overview, approaches, architecture, security, etc.)</li> <li>\u2705 Updated mkdocs.yml navigation to use index.md files consistently</li> <li>\u2705 Created proper kubernetes-api.md content with correct Kubernetes API approach information</li> <li>\u2705 Moved distroless content to debug-container.md where it belongs</li> <li>\u2705 Expanded debug-container.md with proper scanning aspects</li> <li>\u2705 Created kubernetes-setup/index.md for documentation consistency</li> <li> <p>\ud83d\udd04 Update all links to reflect reorganized content (partially complete)</p> <ul> <li>\u2705 Fixed links in quickstart/index.md</li> <li>\u2705 Fixed links in security/overview.md</li> <li>\u2705 Fixed links in kubernetes-setup directory</li> <li>\ud83d\udd04 Still working on remaining links in other files</li> </ul> </li> <li> <p>Terminology Updates:</p> </li> <li> Update index.md with standardized terminology</li> <li> Update overview/index.md with consistent descriptions</li> <li> Fix executive-summary.md terminology</li> <li> Update quickstart.md methods with proper naming</li> <li> <p> Review all approaches/* files for consistent terminology</p> </li> <li> <p>Content Refinement:</p> </li> <li> Remove duplicated approach descriptions</li> <li> Move implementation details to appropriate locations</li> <li> Consolidate workflows in architecture/workflows.md</li> <li> <p> Move business value content to executive-summary.md</p> </li> <li> <p>User Journey Enhancement:</p> </li> <li> Add \"Next Steps\" sections to key documents</li> <li> Implement \"Related Topics\" sections</li> <li> Create approach-specific prerequisites</li> <li> Add troubleshooting matrix for each approach</li> </ol>"},{"location":"project/documentation-review-plan/#timeline","title":"Timeline","text":"<ol> <li>March 24, 2025: Complete critical content fixes</li> <li>March 25, 2025: Implement terminology standardization</li> <li>March 26, 2025: Address content redundancy</li> <li>March 27, 2025: Enhance user journeys</li> <li>March 28, 2025: Conduct final validation and make additional refinements</li> </ol>"},{"location":"project/documentation-review-plan/#success-criteria","title":"Success Criteria","text":"<p>The Phase 4 implementation will be considered successful when:</p> <ol> <li>All critical content mismatches are resolved</li> <li>Terminology is consistent across all documents</li> <li>Redundancy is eliminated with content in appropriate locations</li> <li>User journeys flow smoothly without gaps or obstacles</li> <li>All validation tests pass without errors</li> <li>The documentation effectively serves the needs of all target audiences</li> </ol>"},{"location":"project/documentation-structure-progress/","title":"Documentation Structure Progress","text":"<p>This document tracks the progress of the documentation reorganization and structure improvements.</p>"},{"location":"project/documentation-structure-progress/#overall-progress","title":"Overall Progress","text":"Phase Status Description Completion Phase 1: Restructuring and Security Prioritization \u2705 Completed Restructured navigation, elevated security content 100% Phase 2: Learning Path Content Development \u2705 Completed Created learning paths with security focus 100% Phase 3: Task-Oriented Content Development \u2705 Completed Created task-based documentation pages 100% Phase 4: Navigation Aids and Cross-Links \ud83d\udd04 In Progress Created site index and initial cross-references 65% Phase 5: Testing and Refinement \ud83d\udccb Not Started User testing and documentation refinement 0%"},{"location":"project/documentation-structure-progress/#phase-4-progress","title":"Phase 4 Progress","text":"Task Status Description Completion Site Index Creation \u2705 Completed Created comprehensive site index with visual enhancements 100% Combined UI Enhancement and Cross-Referencing \ud83d\udd04 In Progress Enhancing pages with UI elements and adding cross-references 20% Security Standards Integration \u2705 Completed Added comprehensive NSA/CISA Kubernetes Hardening Guide documentation with detailed mappings 100% Common Abbreviations Centralization \u2705 Completed Created common abbreviations page and removed inline info boxes 100% Repository Organization \u2705 Completed Updated README, .gitignore, and improved git tracking 100% Navigation Structure Improvements \ud83d\udccb Pending Implementing navigation aids 0% Content Discovery Enhancements \ud83d\udccb Pending Adding content discovery features 0%"},{"location":"project/documentation-structure-progress/#learning-paths-ui-and-cross-reference-progress","title":"Learning Paths UI and Cross-Reference Progress","text":"Learning Path UI Enhancement Cross-References Added Status new-users.md \u2705 Complete \u2705 Complete Done implementation.md \u2705 Partial \u2705 Complete In Progress security-first.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started core-concepts.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started advanced-features.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started"},{"location":"project/documentation-structure-progress/#tasks-ui-and-cross-reference-progress","title":"Tasks UI and Cross-Reference Progress","text":"Task UI Enhancement Cross-References Added Status standard-container-scan.md \u2705 Complete \ud83d\udccb Pending In Progress script-deployment.md \ud83d\udccb Pending \u2705 Complete In Progress distroless-container-scan.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started sidecar-container-scan.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started github-integration.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started gitlab-integration.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started kubernetes-setup.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started rbac-setup.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started token-management.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started thresholds-configuration.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started helm-deployment.md \ud83d\udccb Pending \ud83d\udccb Pending Not Started"},{"location":"project/documentation-structure-progress/#phase-3-progress","title":"Phase 3 Progress","text":"Task Status Description Completion Task Template \u2705 Completed Created standard task page template 100% Container Scanning Tasks \u2705 Completed Created standard, distroless, and sidecar scanning task pages 100% CI/CD Integration Tasks \u2705 Completed Created GitHub and GitLab integration task pages 100% Infrastructure Tasks \u2705 Completed Created RBAC, token, and Kubernetes setup tasks 100% Deployment Tasks \u2705 Completed Created Helm chart and script deployment task pages 100% Configuration Tasks \u2705 Completed Created threshold configuration task page 100%"},{"location":"project/documentation-structure-progress/#phase-2-progress","title":"Phase 2 Progress","text":"Task Status Description Completion Learning Path Template \u2705 Completed Created standard learning path template 100% New Users Path \u2705 Completed Created learning path for new users 100% Security-First Path \u2705 Completed Created security-focused learning path 100% Implementation Path \u2705 Completed Created implementation learning path 100% Core Concepts Path \u2705 Completed Created core concepts learning path 100% Advanced Features Path \u2705 Completed Created advanced features learning path 100%"},{"location":"project/documentation-structure-progress/#documentation-enhancements","title":"Documentation Enhancements","text":"Enhancement Status Description Security Architecture Sections \u2705 Completed Added standardized security architecture sections to all tasks Permission Layer Documentation \u2705 Completed Implemented collapsible admonitions for permission layers Security Risk Indicators \u2705 Completed Added color-coded risk indicators to all tasks Approach Risk Comparison \u2705 Completed Added visual risk level comparison with cards and color-coded indicators in security overview Material Design UI Elements \ud83d\udd04 In Progress Implementing enhanced UI elements using Material for MkDocs Cross-References \ud83d\udd04 In Progress Adding comprehensive cross-references across documentation Compliance-Approach Connections \u2705 Completed Connected scanning approaches to specific compliance requirements with visual indicators Risk Documentation Requirements \u2705 Completed Added clear documentation requirements based on compliance impact Visual Navigation Aids \ud83d\udccb Pending Creating visual navigation aids for improved user experience"},{"location":"project/documentation-structure-progress/#next-actions","title":"Next Actions","text":"<ol> <li>Continue combined UI enhancement and cross-referencing across all files:</li> <li>Complete enhancement of learning paths (security-first.md, core-concepts.md, advanced-features.md)</li> <li>Complete enhancement of task pages (starting with remaining container scan tasks)</li> <li>Follow established patterns from new-users.md and standard-container-scan.md</li> <li>Ensure bidirectional links between all related content</li> <li>Implement breadcrumb navigation and additional navigation aids</li> <li>Add content discovery enhancements (tags, \"You might also be interested in\" sections)</li> <li>Continue centralizing commonly used content:</li> <li>Consider creating dedicated glossary page for project-specific terminology</li> <li>Identify other common sections that could be centralized for consistency</li> <li>Review all documentation for proper integration of NSA/CISA Kubernetes Hardening Guide references</li> <li>Prepare for Phase 5 testing and refinement</li> </ol>"},{"location":"project/documentation-structure-progress/#documentation-structure","title":"Documentation Structure","text":"<p>The current structure follows a multi-layered approach:</p> <ol> <li>User Personas and Entry Points</li> <li>Getting Started section with security content elevated</li> <li> <p>Learning Paths section for guided implementation</p> </li> <li> <p>Task-Oriented Documentation</p> </li> <li>Common Tasks section for frequently performed operations</li> <li> <p>Deployment Scenarios section for specific environments</p> </li> <li> <p>Technical Reference Documentation</p> </li> <li>Technical Documentation section with comprehensive references</li> <li> <p>Reference section with consolidated configuration details</p> </li> <li> <p>Project Information</p> </li> <li>Project section with project management and meta-documentation</li> </ol>"},{"location":"project/documentation-tools/","title":"Documentation Maintenance Tools","text":"<p>This project includes several specialized tools to help maintain cross-references and links within the documentation, especially when reorganizing or restructuring content.</p>"},{"location":"project/documentation-tools/#quick-start-workflow-for-new-users","title":"Quick Start Workflow for New Users","text":"<p>If you're new to these documentation tools, here's the typical workflow for fixing cross-references after a documentation reorganization:</p> <ol> <li>Generate initial mappings file based on your documentation structure:</li> </ol> <pre><code>./scripts/generate-doc-mappings.sh --output-file docs/my_mappings.txt\n</code></pre> <ol> <li>Review the generated mappings to ensure they reflect your desired document organization:</li> </ol> <pre><code>less docs/my_mappings.txt\n</code></pre> <ol> <li>Run the cross-reference fixer in dry-run mode to see what changes would be made:</li> </ol> <pre><code>./fix-links-simple.sh --mappings docs/my_mappings.txt --verify-files --dry-run\n</code></pre> <ol> <li>Apply the changes after reviewing the expected updates:</li> </ol> <pre><code>./fix-links-simple.sh --mappings docs/my_mappings.txt --verify-files\n</code></pre> <ol> <li>Test the documentation by building and previewing:</li> </ol> <pre><code>./docs-tools.sh build\n./docs-tools.sh preview\n</code></pre> <ol> <li>Process any warnings to fix remaining broken links:</li> </ol> <pre><code>./docs-tools.sh build 2&gt; mkdocs-warnings.txt\n./scripts/generate-doc-mappings.sh --process-warnings mkdocs-warnings.txt --output-file docs/additional_mappings.txt\n./fix-links-simple.sh --mappings docs/additional_mappings.txt --verify-files\n</code></pre> <ol> <li>Update navigation if needed:</li> </ol> <pre><code>./scripts/update-mkdocs-nav.sh --update\n</code></pre>"},{"location":"project/documentation-tools/#available-tools","title":"Available Tools","text":""},{"location":"project/documentation-tools/#1-generate-doc-mappingssh","title":"1. <code>generate-doc-mappings.sh</code>","text":"<p>Automatically generates path mappings for documentation cross-references by scanning the filesystem structure and analyzing the MkDocs navigation.</p> <p>Usage:</p> <pre><code>./scripts/generate-doc-mappings.sh [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--process-warnings FILE</code>: Process MkDocs warning file to add specific broken links</li> <li><code>--output-file FILE</code>: Specify output mapping file (default: docs/auto_mappings.txt)</li> <li><code>--append</code>: Append to existing mapping file instead of overwriting</li> <li><code>--verbose</code>: Show detailed information about mappings being created</li> <li><code>--dry-run</code>: Show what would be done without writing any files</li> <li><code>--keep-history</code>: Keep a history of mapping files (default: true)</li> <li><code>--history-dir DIR</code>: Specify directory for mapping history</li> <li><code>--help</code>: Show help message</li> </ul> <p>Example:</p> <pre><code>./scripts/generate-doc-mappings.sh --output-file docs/mappings.txt --verbose\n</code></pre> <p>Key Features:</p> <ul> <li>Automatically scans filesystem to detect index.md files and directory structure</li> <li>Parses mkdocs.yml to understand the official navigation structure</li> <li>Generates mappings for common path patterns (dir.md \u2192 dir/index.md)</li> <li>Can process MkDocs warnings to identify specific broken links</li> <li>Handles relative paths including multi-level parent directory references</li> <li>Maintains mapping history for tracking changes over time</li> </ul>"},{"location":"project/documentation-tools/#2-fix-links-simplesh","title":"2. <code>fix-links-simple.sh</code>","text":"<p>Fixes cross-references in Markdown files using a mapping file after a documentation reorganization.</p> <p>Usage:</p> <pre><code>./fix-links-simple.sh [options]\n</code></pre> <p>Options:</p> <ul> <li><code>-h, --help</code>: Show help message</li> <li><code>-d, --dry-run</code>: Check for issues without making changes</li> <li><code>-q, --quiet</code>: Minimize output</li> <li><code>-v, --verbose</code>: Show detailed progress information</li> <li><code>-p, --path DIR</code>: Limit processing to a specific subdirectory</li> <li><code>-f, --verify-files</code>: Verify that destination files actually exist (slower)</li> <li><code>-m, --mappings FILE</code>: Use custom mappings file (default: docs/path_mappings.txt)</li> <li><code>--docsdir DIR</code>: Use custom docs directory (default: ./docs)</li> </ul> <p>Example:</p> <pre><code>./fix-links-simple.sh --mappings docs/mappings.txt --verify-files --path architecture\n</code></pre> <p>Key Features:</p> <ul> <li>Handles both standard Markdown links and directory-style links</li> <li>Tracks and reports on links that are already correctly formatted</li> <li>Provides detailed metrics on link formats and compliance</li> <li>Generates detailed reports of changes</li> <li>Supports dry-run mode for previewing changes</li> <li>Can target specific subdirectories or process the entire documentation</li> </ul>"},{"location":"project/documentation-tools/#3-fix-relative-linkssh","title":"3. <code>fix-relative-links.sh</code>","text":"<p>Specialized script for fixing relative path issues in Markdown links, ensuring links work correctly regardless of file location in the directory hierarchy.</p> <p>Usage:</p> <pre><code>./scripts/fix-relative-links.sh [options]\n</code></pre> <p>Options:</p> <ul> <li><code>-h, --help</code>: Show help message</li> <li><code>-d, --dry-run</code>: Check for issues without making changes</li> <li><code>-q, --quiet</code>: Minimize output</li> <li><code>-v, --verbose</code>: Show detailed progress information</li> <li><code>-p, --path DIR</code>: Limit processing to a specific subdirectory or file</li> <li><code>-o, --output-dir DIR</code>: Specify output directory (default: same as input)</li> <li><code>-r, --report FILE</code>: Specify report file</li> </ul> <p>Example:</p> <pre><code>./scripts/fix-relative-links.sh --path approaches/debug-container --verbose\n</code></pre> <p>Key Features:</p> <ul> <li>Automatically calculates correct relative paths between files</li> <li>Fixes links that MkDocs would interpret incorrectly</li> <li>Maintains link anchors and other components</li> <li>Intelligently identifies and resolves common patterns</li> <li>Works with both files and directories</li> <li>Provides detailed reporting on fixed links</li> <li>Supports dry-run mode for previewing changes</li> </ul>"},{"location":"project/documentation-tools/#4-update-mkdocs-navsh","title":"4. <code>update-mkdocs-nav.sh</code>","text":"<p>Updates the navigation section in mkdocs.yml based on the filesystem structure or a combination of auto-generation and manual structure.</p> <p>Usage:</p> <pre><code>./scripts/update-mkdocs-nav.sh [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--auto</code>: Generate navigation automatically based on filesystem</li> <li><code>--update</code>: Update existing navigation with new files</li> <li><code>--hybrid</code>: Use hybrid approach (maintain structure, add new files)</li> <li><code>--backup</code>: Create backup of mkdocs.yml before modifying</li> <li><code>--dry-run</code>: Show what would be done without changing files</li> <li><code>--verbose</code>: Show detailed progress information</li> <li><code>--output FILE</code>: Write to specified file instead of updating mkdocs.yml</li> <li><code>--help</code>: Show help message</li> </ul> <p>Example:</p> <pre><code>./scripts/update-mkdocs-nav.sh --update --backup\n</code></pre> <p>Key Features:</p> <ul> <li>Multiple navigation generation modes to suit different needs</li> <li>Preserves existing structure while adding new files when using hybrid or update modes</li> <li>Includes new directories and files in appropriate locations</li> <li>Keeps custom ordering and organization when using update mode</li> <li>Detects renamed sections and provides suggestions</li> <li>Provides detailed reports on changes made</li> </ul>"},{"location":"project/documentation-tools/#common-workflows","title":"Common Workflows","text":"<p>This section provides step-by-step instructions for common documentation maintenance tasks, with proper ordering of operations for each scenario.</p>"},{"location":"project/documentation-tools/#reorganizing-a-documentation-section","title":"Reorganizing a Documentation Section","text":"<p>When moving files to new locations or changing directory structure:</p> <ol> <li>First, move the files to their new locations using git or filesystem operations:</li> </ol> <pre><code># Example: Moving a file to a new directory\nmkdir -p docs/new/directory\ngit mv docs/old-location/file.md docs/new/directory/\n\n# Example: Converting a file to a directory with index.md\nmkdir -p docs/section/subsection\ngit mv docs/section/subsection.md docs/section/subsection/index.md\n</code></pre> <ol> <li>Generate mappings for the moved files to track the changes:</li> </ol> <pre><code>./scripts/generate-doc-mappings.sh --output-file docs/section_mappings.txt --verbose\n</code></pre> <ol> <li>Fix cross-references in specific sections using the mappings:</li> </ol> <pre><code>./fix-links-simple.sh --mappings docs/section_mappings.txt --path path/to/section --verify-files\n</code></pre> <ol> <li>Fix relative path issues caused by directory depth changes:</li> </ol> <pre><code>./scripts/fix-relative-links.sh --path path/to/section\n</code></pre> <ol> <li>Update the navigation structure to reflect the new organization:</li> </ol> <pre><code>./scripts/update-mkdocs-nav.sh --update\n</code></pre> <ol> <li>Build and test the documentation to verify changes:</li> </ol> <pre><code>./docs-tools.sh build\n./docs-tools.sh preview\n</code></pre>"},{"location":"project/documentation-tools/#converting-files-to-directory-structure","title":"Converting Files to Directory Structure","text":"<p>When converting single files to directory-based organization with index.md:</p> <ol> <li>Create the directory structure and move files:</li> </ol> <pre><code># For each file to convert:\nmkdir -p docs/section/file-name\ngit mv docs/section/file-name.md docs/section/file-name/index.md\n</code></pre> <ol> <li>Generate mappings specifically for the conversion pattern:</li> </ol> <pre><code>./scripts/generate-doc-mappings.sh --output-file docs/conversion_mappings.txt\n</code></pre> <ol> <li>Update cross-references throughout the documentation:</li> </ol> <pre><code>./fix-links-simple.sh --mappings docs/conversion_mappings.txt --verify-files\n</code></pre> <ol> <li>Fix any remaining relative path issues:</li> </ol> <pre><code>./scripts/fix-relative-links.sh\n</code></pre> <ol> <li>Update navigation to include new structure:</li> </ol> <pre><code>./scripts/update-mkdocs-nav.sh --update\n</code></pre> <ol> <li>Verify changes:</li> </ol> <pre><code>./docs-tools.sh build\n./docs-tools.sh preview\n</code></pre>"},{"location":"project/documentation-tools/#fixing-link-issues-after-detecting-broken-links","title":"Fixing Link Issues After Detecting Broken Links","text":"<p>When MkDocs build reports broken links:</p> <ol> <li>Build documentation and capture warnings:</li> </ol> <pre><code>./docs-tools.sh build 2&gt; mkdocs-warnings.txt\n</code></pre> <ol> <li>Process warnings to generate mappings:</li> </ol> <pre><code>./scripts/generate-doc-mappings.sh --process-warnings mkdocs-warnings.txt --output-file docs/warning_mappings.txt\n</code></pre> <ol> <li>Fix broken links using the generated mappings:</li> </ol> <pre><code>./fix-links-simple.sh --mappings docs/warning_mappings.txt --verify-files\n</code></pre> <ol> <li>Fix any remaining relative path issues:</li> </ol> <pre><code>./scripts/fix-relative-links.sh --path problematic/section\n</code></pre> <ol> <li>Verify fixes with another build:</li> </ol> <pre><code>./docs-tools.sh build\n</code></pre>"},{"location":"project/documentation-tools/#adding-new-documentation-files","title":"Adding New Documentation Files","text":"<p>When adding new content to the documentation:</p> <ol> <li>Create the new files in the appropriate location:</li> </ol> <pre><code># For a regular file:\ntouch docs/section/new-file.md\n\n# For a directory-based structure:\nmkdir -p docs/section/new-topic\ntouch docs/section/new-topic/index.md\n</code></pre> <ol> <li>Update navigation to include new files:</li> </ol> <pre><code>./scripts/update-mkdocs-nav.sh --update\n</code></pre> <ol> <li>Build and test to verify integration:</li> </ol> <pre><code>./docs-tools.sh build\n./docs-tools.sh preview\n</code></pre>"},{"location":"project/documentation-tools/#monitoring-overall-documentation-health","title":"Monitoring Overall Documentation Health","text":"<p>To regularly check the health of documentation cross-references:</p> <ol> <li>Verify links without making changes:</li> </ol> <pre><code>./fix-links-simple.sh --verify-files --dry-run\n</code></pre> <ol> <li>Check for relative path issues:</li> </ol> <pre><code>./scripts/fix-relative-links.sh --dry-run\n</code></pre> <ol> <li>Review detailed link reports:</li> </ol> <pre><code>less docs/.cross-reference-fixes.log\nless docs/.relative-links-fixes.log\n</code></pre> <ol> <li>Run comprehensive link checks:</li> </ol> <pre><code>./docs-tools.sh links\n</code></pre> <ol> <li>Build documentation to catch any remaining issues:</li> </ol> <pre><code>./docs-tools.sh build\n</code></pre>"},{"location":"project/documentation-tools/#setting-up-continuous-integration-checks","title":"Setting Up Continuous Integration Checks","text":"<p>To include documentation verification in CI/CD pipelines:</p> <ol> <li>Add a documentation check step to your CI configuration:</li> </ol> <pre><code># Example GitHub Actions step\n- name: Check documentation health\n  run: |\n    ./docs-tools.sh links\n    ./docs-tools.sh build\n    ./fix-links-simple.sh --verify-files --dry-run\n</code></pre> <ol> <li>Create a reporting step to summarize findings:</li> </ol> <pre><code>- name: Generate documentation health report\n  if: always()\n  run: |\n    echo \"## Documentation Health Report\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    grep \"Total links\" docs/.cross-reference-fixes.log &gt;&gt; $GITHUB_STEP_SUMMARY\n    grep \"Broken links\" docs/.cross-reference-fixes.log &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>"},{"location":"project/documentation-tools/#integration-with-docs-toolssh","title":"Integration with docs-tools.sh","text":"<p>The <code>docs-tools.sh</code> script provides a comprehensive wrapper for documentation tasks, including building, previewing, linting, and checking links.</p> <p>Examples:</p> <pre><code># Build and check for warnings\n./docs-tools.sh build\n\n# Serve docs with automatic reload\n./docs-tools.sh preview\n\n# Check links\n./docs-tools.sh links\n\n# Run all checks\n./docs-tools.sh check-all\n</code></pre>"},{"location":"project/documentation-tools/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use the --verify-files flag with fix-links-simple.sh to ensure you're not creating links to non-existent files.</p> </li> <li> <p>Run in dry-run mode first to preview changes before applying them.</p> </li> <li> <p>Keep mapping files for reference as they document the reorganization and can be used again if needed.</p> </li> <li> <p>Process MkDocs warnings to catch any missed cross-references.</p> </li> <li> <p>Use the hybrid approach for navigation updates to maintain your custom organization while incorporating new files.</p> </li> <li> <p>Commit changes in logical groups:</p> </li> <li>Filesystem reorganization</li> <li>Cross-reference fixes</li> <li> <p>Navigation updates</p> </li> <li> <p>Create backups before major reorganizations:</p> </li> </ol> <pre><code>cp -r docs docs-backup\n</code></pre> <ol> <li> <p>Test builds frequently to catch issues early.</p> </li> <li> <p>Keep test files in script-tests directory:    All test files for documentation tools (like test-links, test-warnings.md, test-cross-ref.md) should be kept in the <code>scripts/script-tests/</code> directory rather than in the main documentation. This prevents these files from appearing in the documentation build and generating warnings.</p> </li> </ol>"},{"location":"project/helm-charts-reorganization-summary/","title":"Helm Charts Documentation Reorganization Summary","text":""},{"location":"project/helm-charts-reorganization-summary/#overview","title":"Overview","text":"<p>This document summarizes the reorganization of the Helm Charts documentation section, which was completed on March 25, 2025. The reorganization follows the content organization pattern established in our Content Organization Approach document.</p>"},{"location":"project/helm-charts-reorganization-summary/#reorganization-structure","title":"Reorganization Structure","text":"<p>The Helm Charts documentation has been reorganized from a flat structure into a logical hierarchy of subdirectories, each with focused content files. The new structure is as follows:</p> <pre><code>docs/helm-charts/\n\u251c\u2500\u2500 index.md                # Main overview with redirects\n\u251c\u2500\u2500 inventory.md            # Directory listing \n\u251c\u2500\u2500 overview/               # Overview subdirectory\n\u2502   \u251c\u2500\u2500 index.md            # High-level overview\n\u2502   \u251c\u2500\u2500 inventory.md        # Directory listing\n\u2502   \u2514\u2500\u2500 architecture.md     # Architecture diagrams and explanations\n\u251c\u2500\u2500 scanner-types/          # Scanner types subdirectory\n\u2502   \u251c\u2500\u2500 index.md            # Introduction to scanner types\n\u2502   \u251c\u2500\u2500 inventory.md        # Directory listing\n\u2502   \u251c\u2500\u2500 common-scanner.md   # Common scanner documentation\n\u2502   \u251c\u2500\u2500 standard-scanner.md # Standard scanner (Kubernetes API)\n\u2502   \u251c\u2500\u2500 distroless-scanner.md # Distroless scanner (Debug Container)\n\u2502   \u2514\u2500\u2500 sidecar-scanner.md  # Sidecar scanner documentation\n\u251c\u2500\u2500 infrastructure/         # Infrastructure subdirectory\n\u2502   \u251c\u2500\u2500 index.md            # Infrastructure overview\n\u2502   \u251c\u2500\u2500 inventory.md        # Directory listing\n\u2502   \u251c\u2500\u2500 rbac.md             # RBAC configurations\n\u2502   \u251c\u2500\u2500 service-accounts.md # Service account setup\n\u2502   \u2514\u2500\u2500 namespaces.md       # Namespace configuration\n\u251c\u2500\u2500 usage/                  # Usage and customization subdirectory\n\u2502   \u251c\u2500\u2500 index.md            # Usage overview\n\u2502   \u251c\u2500\u2500 inventory.md        # Directory listing\n\u2502   \u251c\u2500\u2500 customization.md    # Customization guide\n\u2502   \u251c\u2500\u2500 configuration.md    # Configuration reference\n\u2502   \u2514\u2500\u2500 values.md           # Values file documentation\n\u251c\u2500\u2500 security/               # Security subdirectory\n\u2502   \u251c\u2500\u2500 index.md            # Security overview\n\u2502   \u251c\u2500\u2500 inventory.md        # Directory listing\n\u2502   \u251c\u2500\u2500 best-practices.md   # Security best practices\n\u2502   \u251c\u2500\u2500 rbac-hardening.md   # RBAC hardening guide\n\u2502   \u2514\u2500\u2500 risk-assessment.md  # Risk assessment by chart\n\u2514\u2500\u2500 operations/             # Operations subdirectory\n    \u251c\u2500\u2500 index.md            # Operations overview\n    \u251c\u2500\u2500 inventory.md        # Directory listing\n    \u251c\u2500\u2500 troubleshooting.md  # Troubleshooting guide\n    \u251c\u2500\u2500 performance.md      # Performance optimization\n    \u2514\u2500\u2500 maintenance.md      # Maintenance procedures\n</code></pre>"},{"location":"project/helm-charts-reorganization-summary/#content-transformation","title":"Content Transformation","text":"<p>The content from the original files was extracted and distributed into focused files within the new structure. Key transformations include:</p> <ol> <li>overview.md \u2192 Split into overview/index.md and overview/architecture.md</li> <li>architecture.md \u2192 Moved to overview/architecture.md with component details extracted to scanner-types/* files</li> <li>scanner-infrastructure.md \u2192 Split across infrastructure/* files</li> <li>common-scanner.md, standard-scanner.md, distroless-scanner.md, sidecar-scanner.md \u2192 Moved to scanner-types/* with additional content extracted to usage/configuration.md</li> <li>customization.md \u2192 Moved to usage/customization.md with configuration details extracted to usage/configuration.md</li> <li>security.md \u2192 Split across security/* files</li> <li>troubleshooting.md \u2192 Moved to operations/troubleshooting.md with additional performance and maintenance content extracted to operations/performance.md and operations/maintenance.md</li> </ol>"},{"location":"project/helm-charts-reorganization-summary/#navigation-updates","title":"Navigation Updates","text":"<p>The navigation in mkdocs.yml was updated to reflect the new structure, with logical grouping of related topics:</p> <pre><code>- Helm Charts:\n  - Introduction: helm-charts/index.md\n  - Directory Contents: helm-charts/inventory.md\n  - Overview:\n    - Introduction: helm-charts/overview/index.md\n    - Directory Contents: helm-charts/overview/inventory.md\n    - Architecture: helm-charts/overview/architecture.md\n  - Scanner Types:\n    - Introduction: helm-charts/scanner-types/index.md\n    - Directory Contents: helm-charts/scanner-types/inventory.md\n    - Common Scanner: helm-charts/scanner-types/common-scanner.md\n    - Kubernetes API Scanner: helm-charts/scanner-types/standard-scanner.md\n    - Debug Container Scanner: helm-charts/scanner-types/distroless-scanner.md\n    - Sidecar Container Scanner: helm-charts/scanner-types/sidecar-scanner.md\n  - Infrastructure:\n    - Overview: helm-charts/infrastructure/index.md\n    - Directory Contents: helm-charts/infrastructure/inventory.md\n    - RBAC Configuration: helm-charts/infrastructure/rbac.md\n    - Service Accounts: helm-charts/infrastructure/service-accounts.md\n    - Namespaces: helm-charts/infrastructure/namespaces.md\n  - Usage &amp; Customization:\n    - Overview: helm-charts/usage/index.md\n    - Directory Contents: helm-charts/usage/inventory.md\n    - Customization Guide: helm-charts/usage/customization.md\n    - Configuration Reference: helm-charts/usage/configuration.md\n    - Values Files: helm-charts/usage/values.md\n  - Security:\n    - Overview: helm-charts/security/index.md\n    - Directory Contents: helm-charts/security/inventory.md\n    - Best Practices: helm-charts/security/best-practices.md\n    - RBAC Hardening: helm-charts/security/rbac-hardening.md\n    - Risk Assessment: helm-charts/security/risk-assessment.md\n  - Operations:\n    - Overview: helm-charts/operations/index.md\n    - Directory Contents: helm-charts/operations/inventory.md\n    - Troubleshooting: helm-charts/operations/troubleshooting.md\n    - Performance: helm-charts/operations/performance.md\n    - Maintenance: helm-charts/operations/maintenance.md\n</code></pre>"},{"location":"project/helm-charts-reorganization-summary/#benefits-of-reorganization","title":"Benefits of Reorganization","text":"<p>The Helm Charts documentation reorganization provides several benefits:</p> <ol> <li>Improved Readability: Smaller, focused files are easier to read and understand</li> <li>Enhanced Navigation: Logical hierarchy makes information easier to find</li> <li>Topic Separation: Clear separation of concerns between different aspects of Helm chart documentation</li> <li>Consistent Structure: Follows the same pattern as other reorganized sections</li> <li>Maintainability: Smaller files are easier to update and maintain</li> <li>Comprehensive Coverage: New structure ensures all aspects of Helm charts are documented</li> </ol>"},{"location":"project/helm-charts-reorganization-summary/#next-steps","title":"Next Steps","text":"<p>With the completion of the Helm Charts reorganization, we can now focus on:</p> <ol> <li>Reorganizing the Configuration section</li> <li>Reorganizing the Architecture section</li> <li>Reorganizing the Integration section</li> <li>Continuing the Phase 4 (review and refinement) of documentation refactoring</li> </ol>"},{"location":"project/helm-charts-reorganization-summary/#related-documents","title":"Related Documents","text":"<ul> <li>Content Organization Approach</li> <li>Documentation Entry Refactoring</li> <li>Session Recovery Document (in repository root)</li> <li>Helm Charts Index</li> </ul>"},{"location":"project/integration-reorganization-summary/","title":"Integration Section Reorganization Summary","text":"<p>This document summarizes the reorganization of the integration section in the Kube CINC Secure Scanner documentation.</p>"},{"location":"project/integration-reorganization-summary/#reorganization-overview","title":"Reorganization Overview","text":"<p>The integration section has been reorganized to provide a more structured and focused approach to documentation. The reorganization follows the established pattern used for other sections, breaking down large documentation files into focused files organized in a logical directory structure.</p>"},{"location":"project/integration-reorganization-summary/#directory-structure","title":"Directory Structure","text":"<p>The reorganized integration section now has the following structure:</p> <ol> <li><code>/docs/integration/</code> (Main directory)</li> <li>index.md (Overview and navigation guide)</li> <li>inventory.md (Complete listing of all files)</li> <li>approach-mapping.md (Mapping of scanning approaches to CI/CD platforms)</li> <li>overview.md (General overview of integration capabilities)</li> <li> <p>gitlab-services-analysis.md (Analysis of GitLab Services integration approach)</p> </li> <li> <p><code>/docs/integration/platforms/</code> (CI/CD Platforms)</p> </li> <li>index.md (Overview of platform integrations)</li> <li>inventory.md (Listing of platform files)</li> <li>github-actions.md (GitHub Actions integration)</li> <li>gitlab-ci.md (GitLab CI integration)</li> <li>gitlab-services.md (GitLab Services integration)</li> <li>jenkins.md (Jenkins integration)</li> <li>azure-devops.md (Azure DevOps integration)</li> <li> <p>custom-platforms.md (Custom CI/CD platform integration)</p> </li> <li> <p><code>/docs/integration/workflows/</code> (Integration Workflows)</p> </li> <li>index.md (Overview of integration workflows)</li> <li>inventory.md (Listing of workflow files)</li> <li>standard-container.md (Standard container workflow integration)</li> <li>distroless-container.md (Distroless container workflow integration)</li> <li>sidecar-container.md (Sidecar container workflow integration)</li> <li> <p>security-workflows.md (Security-focused integration workflows)</p> </li> <li> <p><code>/docs/integration/examples/</code> (Practical Examples)</p> </li> <li>index.md (Overview of integration examples)</li> <li>inventory.md (Listing of example files)</li> <li>github-examples.md (GitHub Actions examples)</li> <li>gitlab-examples.md (GitLab CI examples)</li> <li>gitlab-services-examples.md (GitLab Services examples)</li> <li> <p>custom-examples.md (Custom integration examples)</p> </li> <li> <p><code>/docs/integration/configuration/</code> (Integration Configuration)</p> </li> <li>index.md (Overview of integration configuration)</li> <li>inventory.md (Listing of configuration files)</li> <li>environment-variables.md (Environment variable configuration)</li> <li>secrets-management.md (Secrets and token management)</li> <li>thresholds-integration.md (Integration with threshold configuration)</li> <li>reporting.md (Results reporting configuration)</li> </ol>"},{"location":"project/integration-reorganization-summary/#content-organization","title":"Content Organization","text":"<p>The content has been organized according to the following principles:</p> <ol> <li>Platform-Specific Content: Documentation specific to CI/CD platforms is placed in the platforms/ directory.</li> <li>Workflow-Specific Content: Documentation focused on integration workflows is placed in the workflows/ directory.</li> <li>Example Content: Practical implementation examples are placed in the examples/ directory.</li> <li>Configuration Content: Integration configuration guidance is placed in the configuration/ directory.</li> </ol>"},{"location":"project/integration-reorganization-summary/#implementation-details","title":"Implementation Details","text":"<p>The reorganization was implemented using the following steps:</p> <ol> <li>Directory Structure Creation: Created the necessary subdirectories for the reorganized content.</li> <li>Index Files Creation: Created comprehensive index.md and inventory.md files for each subdirectory.</li> <li>Content Migration: Moved and adapted content from existing files to the new structure:</li> <li>Moved github-actions.md to platforms/github-actions.md</li> <li>Moved gitlab.md to platforms/gitlab-ci.md</li> <li>Moved gitlab-services.md to platforms/gitlab-services.md</li> <li>Created other placeholder files for future content</li> <li>Cross-References Update: Updated cross-references between files to reflect the new structure.</li> <li>Main Navigation Update: Updated the main integration/index.md and integration/inventory.md files to reflect the new structure.</li> </ol>"},{"location":"project/integration-reorganization-summary/#content-improvements","title":"Content Improvements","text":"<p>During the reorganization, the following content improvements were made:</p> <ol> <li>Enhanced Navigation: Improved navigation structure with logical grouping of related topics.</li> <li>Clear Entry Points: Created clear entry points for different types of integration information.</li> <li>Focused Content: Broke down large topics into focused files for improved readability.</li> <li>Cross-References: Added comprehensive cross-references between related topics.</li> <li>Consistent Structure: Applied a consistent structure across all subdirectories.</li> </ol>"},{"location":"project/integration-reorganization-summary/#implementation-summary","title":"Implementation Summary","text":"<p>The reorganization has been implemented with the following actions:</p> <ol> <li>Directory Structure Creation: Created a comprehensive directory structure for the reorganized content.</li> <li>Index Files Creation: Created index.md and inventory.md files for each subdirectory.</li> <li>Content Extraction and Creation:</li> <li>Moved github-actions.md to platforms/github-actions.md</li> <li>Moved gitlab.md to platforms/gitlab-ci.md</li> <li>Moved gitlab-services.md to platforms/gitlab-services.md</li> <li>Created comprehensive workflow files (standard-container.md, distroless-container.md, sidecar-container.md, security-workflows.md)</li> <li>Created practical examples file (github-examples.md) with detailed GitHub Actions workflows</li> <li>Cross-References Update: Updated cross-references between files to reflect the new structure.</li> <li>Main Navigation Update: Updated the mkdocs.yml file to reflect the new directory structure in the navigation.</li> <li>Content Enhancement: Added detailed code examples for all workflows and platforms.</li> </ol>"},{"location":"project/integration-reorganization-summary/#completed-enhancements","title":"Completed Enhancements","text":"<p>During the reorganization, the following content was created:</p> <ol> <li>Workflow Documentation: Created comprehensive documentation files for each scanning workflow:</li> <li>standard-container.md - For standard container scanning</li> <li>distroless-container.md - For distroless container scanning</li> <li>sidecar-container.md - For sidecar container scanning</li> <li> <p>security-workflows.md - For security-focused workflows</p> </li> <li> <p>Example Documentation: Created GitHub Actions examples documentation:</p> </li> <li> <p>github-examples.md - With detailed GitHub Actions workflow examples</p> </li> <li> <p>Enhanced Navigation: Updated mkdocs.yml to provide a logical navigation structure:</p> </li> <li>Organized by platforms, workflows, examples, and configuration</li> <li>Grouped example resources together</li> <li>Improved cross-linking between related topics</li> </ol>"},{"location":"project/integration-reorganization-summary/#next-steps","title":"Next Steps","text":"<p>The following steps are recommended to complete the integration section:</p> <ol> <li>Additional Platform Examples: Create additional platform example files (gitlab-examples.md).</li> <li>Configuration Files: Create the environment-variables.md, secrets-management.md, thresholds-integration.md, and reporting.md configuration files.</li> <li>Cross-References Validation: Validate all cross-references between files to ensure proper navigation.</li> <li>Content Review: Conduct a comprehensive review of the content for accuracy and consistency.</li> <li>User Journey Testing: Test typical user journeys through the documentation to ensure a smooth experience.</li> </ol>"},{"location":"project/inventory/","title":"Project Directory Contents","text":"<p>This page provides an inventory of all files in the project documentation section.</p>"},{"location":"project/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of project documentation changelog.md Detailed history of project changes and updates roadmap.md Planned features and development timeline tasks.md Current development tasks and priorities terminology.md Standardized definitions of key terms and concepts content-map.md Map of documentation organization and structure documentation-gaps.md Identified areas needing additional documentation documentation-entry-refactoring.md Plan for restructuring documentation entry points documentation-structure-progress.md Tracking matrix for documentation structure updates documentation-review-plan.md Plan for reviewing and improving documentation documentation-tools.md Guide for using the documentation link management tools mkdocs-material-features-guide.md Comprehensive guide to Material for MkDocs features for enhancing documentation"},{"location":"project/inventory/#subdirectories","title":"Subdirectories","text":""},{"location":"project/inventory/#archive","title":"Archive","text":"File Description ascii-diagrams.md Archived ASCII diagram documentation (replaced by Mermaid diagrams)"},{"location":"project/inventory/#related-links","title":"Related Links","text":"<ul> <li>Contributing Guide</li> <li>Developer Guide</li> <li>Utilities</li> </ul>"},{"location":"project/mkdocs-material-features-guide/","title":"Material for MkDocs Features Guide","text":"<p>This document provides a comprehensive guide to Material for MkDocs features that can enhance our documentation during the restructuring process. It focuses on features that will improve visual presentation, organization, and user experience.</p>"},{"location":"project/mkdocs-material-features-guide/#navigation-and-structure-features","title":"Navigation and Structure Features","text":""},{"location":"project/mkdocs-material-features-guide/#primary-navigation","title":"Primary Navigation","text":"<ul> <li>Navigation Tabs: Top-level navigation using tabs for main sections</li> <li>Navigation Sections: Collapsible sections for sub-navigation</li> <li>Expandable Navigation: Allow expanding all navigation items</li> <li>Instant Loading: Fast page transitions without full page reload</li> <li>Navigation Breadcrumbs: Clear path indication for current location</li> <li>Sticky Navigation: Persistent navigation as user scrolls</li> <li>Section Indexes: Automatically generated index pages for sections</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Auto-generated TOC: Based on page headings</li> <li>Configurable Depth: Control how many heading levels to include</li> <li>Custom Title: Change the default \"Table of contents\" title</li> <li>Sticky TOC: Keep TOC visible while scrolling</li> <li>Back-to-top Button: Quick navigation to page top</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#visual-content-elements","title":"Visual Content Elements","text":""},{"location":"project/mkdocs-material-features-guide/#icons-and-emojis","title":"Icons and Emojis","text":"<ul> <li>Material Design Icons: 10,000+ icons available</li> <li>Custom Icons: Add project-specific icons</li> <li>Icon Colors: Apply colors to icons (use for security level indicators)</li> <li>Icon Animations: Animate icons for interactive elements</li> <li>Emoji Support: Use in text and headings for visual cues</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#images-and-diagrams","title":"Images and Diagrams","text":"<ul> <li>Image Lazy Loading: Improve page load performance</li> <li>Light/Dark Mode Images: Different images based on theme</li> <li>Image Captions: Add descriptive text below images</li> <li>Image Alignment: Left, center, right alignment options</li> <li>Lightbox Integration: Click to enlarge images</li> <li>Responsive Images: Adapt to different screen sizes</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#lists-and-organization","title":"Lists and Organization","text":"<ul> <li>Unordered Lists: Bullet points for general items</li> <li>Ordered Lists: Numbered steps for procedures</li> <li>Definition Lists: Term-definition pairs for glossaries</li> <li>Task Lists: Checkboxes for procedures and requirements</li> <li>Custom List Markers: Change the appearance of list bullets</li> <li>Collapsible Lists: Show/hide details when needed</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#interactive-elements","title":"Interactive Elements","text":""},{"location":"project/mkdocs-material-features-guide/#admonitions-call-outs","title":"Admonitions (Call-outs)","text":"<ul> <li>Standard Types: Note, Tip, Warning, Danger, Info, etc.</li> <li>Custom Admonitions: Create project-specific admonition types</li> <li>Collapsible Admonitions: Toggle visibility of detailed content</li> <li>Nested Admonitions: Place admonitions inside other admonitions</li> <li>Icon Customization: Change icons for different admonition types</li> </ul> <p>Example:</p> <pre><code>!!! security \"Security Consideration\"\n    This configuration requires additional security controls.\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#content-tabs","title":"Content Tabs","text":"<ul> <li>Content Comparison: Compare different approaches</li> <li>Environment-specific Content: Show content for different environments</li> <li>Code Examples: Show examples in different languages</li> <li>Role-based Content: Show content appropriate for different user roles</li> <li>Linked Content Tabs: Link tabs across multiple blocks</li> </ul> <p>Example:</p> <pre><code>=== \"Kubernetes API Approach\"\n    Configure the Kubernetes API scanner...\n\n=== \"Debug Container Approach\"\n    Configure the Debug Container scanner...\n\n=== \"Sidecar Container Approach\"\n    Configure the Sidecar Container scanner...\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#buttons","title":"Buttons","text":"<ul> <li>Call-to-action Buttons: Highlight important links</li> <li>Primary/Secondary Styles: Visual hierarchy for actions</li> <li>Icon Buttons: Buttons with icons for visual emphasis</li> <li>Button Sizing: Control button sizes</li> <li>Custom Colors: Match buttons to documentation theme</li> </ul> <p>Example:</p> <pre><code>[Start Scanning](#){ .md-button .md-button--primary }\n[Learn More](#){ .md-button }\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#code-blocks","title":"Code Blocks","text":"<ul> <li>Syntax Highlighting: Language-specific highlighting</li> <li>Line Numbers: Show line numbers for reference</li> <li>Code Annotations: Add explanatory comments to specific lines</li> <li>Code Highlighting: Highlight specific lines or sections</li> <li>Copy Button: One-click copy of code examples</li> <li>Code Links: Link to source code repositories</li> </ul> <p>Example with annotations:</p> <pre><code>```yaml\napiVersion: v1 # (1)\nkind: Pod\nmetadata:\n  name: security-scanner # (2)\n```\n\n1. Kubernetes API version\n2. Name of the scanner pod\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#layout-and-organization","title":"Layout and Organization","text":""},{"location":"project/mkdocs-material-features-guide/#grids","title":"Grids","text":"<ul> <li>Card Grids: Visual grids of content cards</li> <li>Feature Comparison: Compare approaches or features</li> <li>Responsive Layouts: Adapt to different screen sizes</li> <li>Custom Spacing: Control grid spacing and alignment</li> </ul> <p>Example:</p> <pre><code>&lt;div class=\"grid cards\" markdown&gt;\n\n- :material-kubernetes: **Kubernetes API Approach**\n\n    Standard container scanning using train-k8s-container transport.\n\n- :material-docker: **Debug Container Approach**\n\n    Distroless container scanning using ephemeral debug containers.\n\n- :material-server: **Sidecar Container Approach**\n\n    Shared process namespace for both container types.\n\n&lt;/div&gt;\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#data-tables","title":"Data Tables","text":"<ul> <li>Column Alignment: Left, center, right alignment</li> <li>Sortable Tables: Allow sorting table data</li> <li>Responsive Tables: Adapt to different screen sizes</li> <li>Custom Styling: Apply special styles to tables</li> </ul> <p>Example:</p> <pre><code>| Approach | Container Types | Security Level |\n|:---------|:---------------:|---------------:|\n| Kubernetes API | Standard | Low |\n| Debug Container | Distroless | Medium |\n| Sidecar | Both | High |\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#social-cards","title":"Social Cards","text":"<ul> <li>Automatic Generation: Create preview cards for social media sharing</li> <li>Custom Designs: Brand-specific card templates</li> <li>Per-page Cards: Different cards for different sections</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#search-and-discovery","title":"Search and Discovery","text":""},{"location":"project/mkdocs-material-features-guide/#search-features","title":"Search Features","text":"<ul> <li>Full-text Search: Search across all documentation</li> <li>Search Highlighting: Highlight search terms in results</li> <li>Search Suggestions: Show suggestions as user types</li> <li>Search Exclusion: Exclude certain content from search</li> <li>Result Ranking: Prioritize important content in results</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#tooltips-and-glossary","title":"Tooltips and Glossary","text":"<ul> <li>Inline Tooltips: Hover explanations for technical terms</li> <li>Abbreviation Support: Auto-explain abbreviations across the site</li> <li>Glossary Integration: Central glossary with site-wide tooltips</li> <li>Custom Tooltip Styling: Control appearance of tooltips</li> <li>Term Highlighting: Visual indication of terms with definitions</li> </ul> <p>Example:</p> <pre><code>[RBAC](../security/principles/least-privilege.md \"Role-Based Access Control: A security approach that restricts system access to authorized users\")\n\n*[RBAC]: Role-Based Access Control\n</code></pre>"},{"location":"project/mkdocs-material-features-guide/#projects-plugin-insiders-edition","title":"Projects Plugin (Insiders Edition)","text":"<p>The Projects plugin is an Insiders-only feature that offers powerful capabilities for larger documentation sites:</p> <ul> <li>Split documentation into multiple projects while maintaining a unified experience</li> <li>Build concurrently for faster generation times</li> <li>Preview individual projects during development</li> <li>Selective rebuilding when files change</li> </ul> <p>This plugin would be particularly valuable for our documentation as we could:</p> <ol> <li>Create separate project sections for different user roles (developers, security teams, operators)</li> <li>Build specialized documentation sections independently</li> <li>Maintain a unified navigation and search experience</li> <li>Improve build performance for large documentation sets</li> </ol> <p>Note that this plugin is only available to sponsors of the Material for MkDocs project.</p>"},{"location":"project/mkdocs-material-features-guide/#implementation-strategy","title":"Implementation Strategy","text":"<p>When implementing the restructuring, we should follow these principles:</p> <ol> <li>Progressive Enhancement: Start with basic content and enhance with interactive elements</li> <li>Consistent Patterns: Use the same patterns for similar content across the documentation</li> <li>Purposeful Use: Only use visual enhancements when they improve understanding</li> <li>Performance Awareness: Consider page load time impact of features</li> <li>Accessibility: Ensure all enhancements work with screen readers and keyboard navigation</li> </ol>"},{"location":"project/mkdocs-material-features-guide/#feature-integration-plan","title":"Feature Integration Plan","text":""},{"location":"project/mkdocs-material-features-guide/#phase-1-basic-enhancement","title":"Phase 1: Basic Enhancement","text":"<ul> <li>Add admonitions for security warnings and notes</li> <li>Implement content tabs for approach comparisons</li> <li>Add icons to main navigation sections</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#phase-2-visual-improvements","title":"Phase 2: Visual Improvements","text":"<ul> <li>Create card grids for landing pages</li> <li>Implement code annotations for script examples</li> <li>Add task lists for compliance requirements</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#phase-3-interactive-elements","title":"Phase 3: Interactive Elements","text":"<ul> <li>Add buttons for key user paths</li> <li>Implement collapsible sections for detailed content</li> <li>Create custom admonitions for security levels</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#phase-4-advanced-features","title":"Phase 4: Advanced Features","text":"<ul> <li>Add social cards for key documentation sections</li> <li>Implement diagrams for workflows and architectures</li> <li>Create custom stylesheets for security-specific highlighting</li> <li>Add tooltips for technical terms and abbreviations</li> </ul>"},{"location":"project/mkdocs-material-features-guide/#reference-documentation","title":"Reference Documentation","text":"<ul> <li>Material for MkDocs Documentation</li> <li>Material for MkDocs Reference</li> <li>Material for MkDocs Setup</li> <li>Material for MkDocs Plugins</li> </ul>"},{"location":"project/project-target-organization-plan/","title":"Documentation Restructuring Plan: Security-First Learning Journeys","text":"<p>This document outlines the implementation plan for restructuring our documentation with enhanced security focus and clear learning paths.</p>"},{"location":"project/project-target-organization-plan/#overview","title":"Overview","text":"Project Documentation Restructuring Start Date March 26, 2025 Target Completion 8 weeks Priority High Focus Security-first learning journeys"},{"location":"project/project-target-organization-plan/#progress-tracking","title":"Progress Tracking","text":"Phase Status Progress Expected Completion Phase 1: Restructuring and Security Prioritization Not Started 0% Weeks 1-2 Phase 2: Learning Path Content Development Not Started 0% Weeks 3-4 Phase 3: Task-Oriented Content Development Not Started 0% Weeks 5-6 Phase 4: Navigation Aids and Cross-Links Not Started 0% Week 7 Phase 5: Testing and Refinement Not Started 0% Week 8"},{"location":"project/project-target-organization-plan/#proposed-target-final-structure-and-organization","title":"Proposed Target Final Structure and Organization","text":"<p>nav:     # Quick entry points - focused on immediate value     - Getting Started:       - Introduction: index.md       - Executive Summary: overview/executive-summary.md       - Security Overview: security/index.md  # Elevated security content       - Approach Security Comparison: security/compliance/approach-comparison.md  # Elevated security comparison       - Risk Considerations: security/risk/index.md  # Elevated risk analysis       - Quickstart Guide: quickstart-guide.md       - Learning Paths:         - For New Users: learning-paths/new-users.md         - Security-First Implementation: learning-paths/security-first.md  # New security-focused path         - Understanding Core Concepts: learning-paths/core-concepts.md         - Implementation Path: learning-paths/implementation.md         - Advanced Features Path: learning-paths/advanced-features.md</p> <pre><code># Task-oriented section from Option 2\n- Common Tasks:\n  - Scanning Containers:\n    - Standard Container Scan: tasks/standard-container-scan.md  # New task-based page\n    - Distroless Container Scan: tasks/distroless-container-scan.md  # New task-based page\n    - Sidecar Container Scan: tasks/sidecar-container-scan.md  # New task-based page\n  - CI/CD Integration:\n    - GitHub Actions Setup: tasks/github-integration.md  # New task-based page\n    - GitLab CI Setup: tasks/gitlab-integration.md  # New task-based page\n    - Configuring Thresholds: configuration/thresholds/basic.md\n  - Security Setup:\n    - RBAC Configuration: tasks/rbac-setup.md  # New task-based page\n    - Token Management: tasks/token-management.md  # New task-based page\n  - Deployment:\n    - Helm Chart Deployment: tasks/helm-deployment.md  # New task-based page\n    - Script-Based Deployment: tasks/script-deployment.md  # New task-based page\n\n# Role-based guides from Option 1\n- Role-Based Guides:\n  - For DevOps Engineers:\n    - Overview &amp; Getting Started: guides/devops/index.md  # New role-based page\n    - Workflow Examples: guides/devops/workflows.md  # New role-based page\n    - Troubleshooting: helm-charts/operations/troubleshooting.md\n  - For Security Engineers:\n    - Overview &amp; Getting Started: guides/security/index.md  # New role-based page\n    - Risk Assessment Guide: guides/security/risk-assessment.md  # New role-based page\n    - Compliance Integration: guides/security/compliance.md  # New role-based page\n  - For CI/CD Engineers:\n    - Overview &amp; Getting Started: guides/cicd/index.md  # New role-based page\n    - Pipeline Integration: guides/cicd/pipeline-integration.md  # New role-based page\n    - Example Configurations: integration/examples/index.md\n\n# Solution-based section for special cases\n- Deployment Scenarios:\n  - Enterprise Environment: developer-guide/deployment/scenarios/enterprise.md\n  - Development Environment: developer-guide/deployment/scenarios/development.md\n  - CI/CD Environment: developer-guide/deployment/scenarios/cicd.md\n  - Multi-Tenant Environment: developer-guide/deployment/scenarios/multi-tenant.md\n  - Air-Gapped Environment: developer-guide/deployment/scenarios/air-gapped.md\n\n# The layered approach from Option 3 for technical content\n- Technical Documentation:\n  - Approaches:\n    - Overview: approaches/index.md\n    - Comparison: approaches/comparison.md\n    - Decision Matrix: approaches/decision-matrix.md\n    - Kubernetes API Approach:\n      - Overview: approaches/kubernetes-api/index.md\n      - Implementation: approaches/kubernetes-api/implementation.md\n      - RBAC Configuration: approaches/kubernetes-api/rbac.md\n      - Limitations: approaches/kubernetes-api/limitations.md\n    - Debug Container Approach:\n      - Overview: approaches/debug-container/index.md\n      - Distroless Basics: approaches/debug-container/distroless-basics.md\n      - Implementation: approaches/debug-container/implementation.md\n    - Sidecar Container Approach:\n      - Overview: approaches/sidecar-container/index.md\n      - Implementation: approaches/sidecar-container/implementation.md\n      - Pod Configuration: approaches/sidecar-container/pod-configuration.md\n      - Retrieving Results: approaches/sidecar-container/retrieving-results.md\n    - Helper Scripts:\n      - Overview: approaches/helper-scripts/index.md\n      - Available Scripts: approaches/helper-scripts/available-scripts.md\n      - Scripts vs. Commands: approaches/helper-scripts/scripts-vs-commands.md\n  - Architecture:\n    - Overview: architecture/index.md\n    - Components: architecture/components/index.md\n    - Workflows: architecture/workflows/index.md\n    - Diagrams: architecture/diagrams/index.md\n    - Deployment: architecture/deployment/index.md\n    - Integrations: architecture/integrations/index.md\n  - Security:\n    - Overview: security/index.md\n    - Principles: security/principles/index.md\n    - Risk Analysis: security/risk/index.md\n    - Threat Model: security/threat-model/index.md\n    - Compliance: security/compliance/index.md\n    - Recommendations: security/recommendations/index.md\n\n# Consolidated references\n- Reference:\n  - Configuration:\n    - Overview: configuration/index.md\n    - Kubeconfig: configuration/kubeconfig/index.md\n    - Thresholds: configuration/thresholds/index.md\n    - Plugins: configuration/plugins/index.md\n    - Integration: configuration/integration/index.md\n    - Security: configuration/security/index.md\n    - Advanced: configuration/advanced/index.md\n  - Integration:\n    - Overview: integration/index.md\n    - Platforms: integration/platforms/index.md\n    - Workflows: integration/workflows/index.md\n    - Configuration: integration/configuration/index.md\n    - Examples: integration/examples/index.md\n  - Helm Charts:\n    - Overview: helm-charts/index.md\n    - Scanner Types: helm-charts/scanner-types/index.md\n    - Infrastructure: helm-charts/infrastructure/index.md\n    - Usage: helm-charts/usage/index.md\n    - Security: helm-charts/security/index.md\n    - Operations: helm-charts/operations/index.md\n  - Authentication:\n    - RBAC: rbac/index.md\n    - Tokens: tokens/index.md\n    - Service Accounts: service-accounts/index.md\n  - Example Resources:\n    - GitHub Workflows: github-workflow-examples/index.md\n    - GitLab Pipelines: gitlab-pipeline-examples/index.md\n    - GitLab Services: gitlab-services-examples/index.md\n    - Code Examples: examples/index.md\n\n# Development and project information\n- Project:\n  - Developer Guide: developer-guide/index.md\n  - Contributing: contributing/index.md\n  - Roadmap: project/roadmap.md\n  - Changelog: project/changelog.md\n  - Documentation Tools: utilities/index.md\n\n# Complete index for discoverability\n- Documentation Index:\n  - Full Site Index: site-index.md  # New page with links to all content\n  - Documentation Structure: project/documentation-structure-progress.md\n</code></pre> <p>Key Features of this Hybrid Approach:</p> <ol> <li>Multiple Entry Points: Users can access content through tasks, roles, or technical structure depending on their needs</li> <li>Progressive Detail: Simple tasks are easily accessible at the top level, while detailed technical documentation is organized systematically in deeper levels</li> <li>Role-based Guides: New section to help users based on their specific role in the organization</li> <li>Task-oriented Section: Front-loads the most common tasks to help users get started quickly</li> <li>Deployment Scenarios: Brings special deployment cases to the top level for visibility</li> <li>Consolidated References: All reference documentation is organized in one place</li> <li>Complete Documentation Index: Ensures all content remains discoverable</li> </ol> <p>Implementation Strategy:</p> <ol> <li>Create new landing pages for each of the task-based and role-based sections</li> <li>Generate a comprehensive site index that includes links to all content</li> <li>Implement this navigation structure while preserving all existing content</li> <li>Add cross-linking between related content to help users navigate</li> <li>Add \"Related Resources\" sections at the bottom of new pages to point to the detailed documentation</li> </ol> <p>This hybrid approach offers:</p> <ul> <li>Quick access to common tasks</li> <li>Role-specific guidance</li> <li>Structured technical documentation</li> <li>Clear deployment scenarios</li> <li>Comprehensive references</li> <li>Complete discoverability of all content</li> </ul> <p>It combines the best elements of task-based, role-based, and layered approaches while ensuring no content becomes inaccessible.</p>"},{"location":"project/project-target-organization-plan/#possible-improvement-on-the-first-section-higher-secruity-focus","title":"Possible improvement on the first section (higher secruity focus )","text":"<pre><code>- Getting Started:\n  - Introduction: index.md\n  - Executive Summary: overview/executive-summary.md\n  - Security Overview: security/index.md  # Elevated security content\n  - Approach Security Comparison: security/compliance/approach-comparison.md  # Elevated security comparison\n  - Risk Considerations: security/risk/index.md  # Elevated risk analysis\n  - Quickstart Guide: quickstart-guide.md\n  - Learning Paths:\n    - For New Users: learning-paths/new-users.md\n    - Security-First Implementation: learning-paths/security-first.md  # New security-focused path\n    - Understanding Core Concepts: learning-paths/core-concepts.md\n    - Implementation Path: learning-paths/implementation.md\n    - Advanced Features Path: learning-paths/advanced-features.md\n</code></pre>"},{"location":"project/project-target-organization-plan/#detailed-task-list","title":"Detailed Task List","text":""},{"location":"project/project-target-organization-plan/#phase-1-restructuring-and-security-prioritization-weeks-1-2","title":"Phase 1: Restructuring and Security Prioritization (Weeks 1-2)","text":"<ul> <li> <p> Update Navigation Structure [REORGANIZATION]</p> <ul> <li> Create backup of current mkdocs.yml [REORGANIZATION]</li> <li> Implement new navigation structure in mkdocs.yml [REORGANIZATION]</li> <li> Test build with new structure [REORGANIZATION]</li> <li> Verify no broken links or orphaned content [REORGANIZATION]</li> </ul> </li> <li> <p> Elevate Security Content [REORGANIZATION]</p> <ul> <li> Move security overview to getting started section [REORGANIZATION]</li> <li> Elevate approach security comparison [REORGANIZATION]</li> <li> Add risk considerations to introductory content [ENHANCEMENT]</li> <li> Ensure security is prominently featured on landing pages [ENHANCEMENT]</li> </ul> </li> <li> <p> Create Security-Focused Landing Pages [NEW CONTENT]</p> <ul> <li> <code>security-first.md</code>: Security-focused learning path [NEW CONTENT]</li> <li> <code>approach-security-guide.md</code>: Security-based approach selection [NEW CONTENT]</li> <li> <code>compliance-quickstart.md</code>: Fast path to compliance [NEW CONTENT]</li> <li> Add security decision tree for approach selection [NEW CONTENT]</li> </ul> </li> <li> <p> Update Introduction Pages [ENHANCEMENT]</p> <ul> <li> Revise <code>index.md</code> to highlight security [ENHANCEMENT]</li> <li> Enhance executive summary with security emphasis [ENHANCEMENT]</li> <li> Add security callouts to quickstart guide [ENHANCEMENT]</li> <li> Create \"why security matters\" section for new users [NEW CONTENT]</li> </ul> </li> </ul>"},{"location":"project/project-target-organization-plan/#phase-2-create-learning-path-content-weeks-3-4","title":"Phase 2: Create Learning Path Content (Weeks 3-4)","text":"<ul> <li> <p> Develop Learning Path Framework [NEW CONTENT]</p> <ul> <li> Create learning path template with: [NEW CONTENT]<ul> <li> Progression indicators [NEW CONTENT]</li> <li> Prerequisites section [NEW CONTENT]</li> <li> Expected outcomes [NEW CONTENT]</li> <li> Time requirements [NEW CONTENT]</li> <li> Security considerations [NEW CONTENT]</li> </ul> </li> </ul> </li> <li> <p> Build Core Learning Paths [NEW CONTENT]</p> <ul> <li> <code>learning-paths/new-users.md</code> [NEW CONTENT]<ul> <li> Introduction to project with security focus [NEW CONTENT]</li> <li> First steps guide with security practices [NEW CONTENT]</li> <li> Prerequisites for secure implementation [NEW CONTENT]</li> </ul> </li> <li> <code>learning-paths/security-first.md</code> [NEW CONTENT]<ul> <li> Security-optimized implementation path [NEW CONTENT]</li> <li> Compliance integration steps [NEW CONTENT]</li> <li> Security verification points [NEW CONTENT]</li> </ul> </li> <li> <code>learning-paths/core-concepts.md</code> [NEW CONTENT]<ul> <li> Security principles foundation [ADAPTATION - using security/principles/index.md]</li> <li> Authentication and authorization model [ADAPTATION - using security/principles/least-privilege.md]</li> <li> Security architecture overview [ADAPTATION - using security/index.md]</li> </ul> </li> <li> <code>learning-paths/implementation.md</code> [NEW CONTENT]<ul> <li> Step-by-step implementation with security checks [NEW CONTENT]</li> <li> Secure configuration guidelines [ADAPTATION - using configuration/security/index.md]</li> <li> Testing and validation procedures [ADAPTATION - using developer-guide/testing/index.md]</li> </ul> </li> <li> <code>learning-paths/advanced-features.md</code> [NEW CONTENT]<ul> <li> Advanced security features [NEW CONTENT]</li> <li> Custom security configurations [ADAPTATION - using security/recommendations/index.md]</li> <li> Enterprise security patterns [ADAPTATION - using security/principles/index.md]</li> </ul> </li> </ul> </li> <li> <p> Create Role-Based Learning Journeys [NEW CONTENT]</p> <ul> <li> For DevOps Engineers: [NEW CONTENT]<ul> <li> <code>guides/devops/index.md</code>: Overview with security emphasis [NEW CONTENT]</li> <li> <code>guides/devops/basic-setup.md</code>: Secure setup procedures [NEW CONTENT]</li> <li> <code>guides/devops/integration.md</code>: Security in integration [NEW CONTENT]</li> <li> <code>guides/devops/automation.md</code>: Secure automation practices [NEW CONTENT]</li> <li> <code>guides/devops/monitoring.md</code>: Security monitoring [NEW CONTENT]</li> </ul> </li> <li> For Security Engineers: [NEW CONTENT]<ul> <li> <code>guides/security/index.md</code>: Security-specific overview [NEW CONTENT]</li> <li> <code>guides/security/security-model.md</code>: Detailed security model [ADAPTATION - using security/index.md]</li> <li> <code>guides/security/risk-assessment.md</code>: Risk assessment guide [ADAPTATION - using security/risk/index.md]</li> <li> <code>guides/security/compliance.md</code>: Compliance implementation [ADAPTATION - using security/compliance/index.md]</li> <li> <code>guides/security/advanced.md</code>: Advanced security topics [NEW CONTENT]</li> </ul> </li> <li> For CI/CD Engineers: [NEW CONTENT]<ul> <li> <code>guides/cicd/index.md</code>: Security in CI/CD overview [NEW CONTENT]</li> <li> <code>guides/cicd/basic-integration.md</code>: Secure integration basics [ADAPTATION - using integration/index.md]</li> <li> <code>guides/cicd/custom-pipelines.md</code>: Security in custom pipelines [ADAPTATION - using integration/platforms/index.md]</li> <li> <code>guides/cicd/optimization.md</code>: Security optimization strategies [NEW CONTENT]</li> </ul> </li> </ul> </li> </ul>"},{"location":"project/project-target-organization-plan/#phase-3-task-oriented-content-development-weeks-5-6","title":"Phase 3: Task-Oriented Content Development (Weeks 5-6)","text":"<ul> <li> <p> Create Standard Task Page Template [NEW CONTENT]</p> <ul> <li> Design template with: [NEW CONTENT]<ul> <li> Security prerequisites section [NEW CONTENT]</li> <li> Step-by-step instructions with security notes [NEW CONTENT]</li> <li> Security best practices callouts [NEW CONTENT]</li> <li> Verification steps for security [NEW CONTENT]</li> <li> \"Next Steps\" recommendations [NEW CONTENT]</li> <li> Related security considerations [NEW CONTENT]</li> </ul> </li> </ul> </li> <li> <p> Develop Security-Focused Task Pages [NEW CONTENT]</p> <ul> <li> <code>tasks/secure-rbac-setup.md</code> [NEW CONTENT]<ul> <li> Least privilege setup guide [ADAPTATION - using rbac/index.md]</li> <li> Role-based access control configuration [ADAPTATION - using rbac/label-based.md]</li> <li> Security verification steps [NEW CONTENT]</li> </ul> </li> <li> <code>tasks/compliance-verification.md</code> [NEW CONTENT]<ul> <li> Compliance scanning configuration [ADAPTATION - using security/compliance/index.md]</li> <li> Report generation and interpretation [ADAPTATION - using integration/configuration/reporting.md]</li> <li> Remediation procedures [NEW CONTENT]</li> </ul> </li> <li> <code>tasks/security-scanning.md</code> [NEW CONTENT]<ul> <li> Security scanning setup [ADAPTATION - using approaches/comparison.md]</li> <li> Scan result interpretation [NEW CONTENT]</li> <li> Remediation workflow [NEW CONTENT]</li> </ul> </li> <li> <code>tasks/secure-deployment.md</code> [NEW CONTENT]<ul> <li> Secure deployment procedures [ADAPTATION - using architecture/deployment/index.md]</li> <li> Security verification steps [NEW CONTENT]</li> <li> Post-deployment security checks [NEW CONTENT]</li> </ul> </li> </ul> </li> <li> <p> Develop Core Task Pages [NEW CONTENT]</p> <ul> <li> Container Scanning Tasks: [NEW CONTENT]<ul> <li> <code>tasks/standard-container-scan.md</code> [ADAPTATION - using approaches/kubernetes-api/implementation.md]</li> <li> <code>tasks/distroless-container-scan.md</code> [ADAPTATION - using approaches/debug-container/implementation.md]</li> <li> <code>tasks/sidecar-container-scan.md</code> [ADAPTATION - using approaches/sidecar-container/implementation.md]</li> </ul> </li> <li> CI/CD Integration Tasks: [NEW CONTENT]<ul> <li> <code>tasks/github-integration.md</code> [ADAPTATION - using integration/platforms/github-actions.md]</li> <li> <code>tasks/gitlab-integration.md</code> [ADAPTATION - using integration/platforms/gitlab-ci.md]</li> <li> <code>tasks/thresholds-configuration.md</code> [ADAPTATION - using configuration/thresholds/basic.md]</li> </ul> </li> <li> Deployment Tasks: [NEW CONTENT]<ul> <li> <code>tasks/helm-deployment.md</code> [ADAPTATION - using architecture/deployment/helm-deployment.md]</li> <li> <code>tasks/script-deployment.md</code> [ADAPTATION - using architecture/deployment/script-deployment.md]</li> <li> <code>tasks/kubernetes-setup.md</code> [ADAPTATION - using kubernetes-setup/index.md]</li> </ul> </li> </ul> </li> <li> <p> Add Security Notes to All Tasks [ENHANCEMENT]</p> <ul> <li> Review all task pages [ENHANCEMENT]</li> <li> Add standardized \"Security Considerations\" section [ENHANCEMENT]</li> <li> Highlight security warnings [ENHANCEMENT]</li> <li> Add compliance requirement references [ENHANCEMENT]</li> </ul> </li> </ul>"},{"location":"project/project-target-organization-plan/#phase-4-navigation-aids-and-cross-links-week-7","title":"Phase 4: Navigation Aids and Cross-Links (Week 7)","text":"<ul> <li> <p> Develop Site Index [NEW CONTENT]</p> <ul> <li> Create comprehensive <code>site-index.md</code> [NEW CONTENT]</li> <li> Organize with security-focused sections at top [NEW CONTENT]</li> <li> Add tags for security-critical content [NEW CONTENT]</li> <li> Create alphabetical index for reference [NEW CONTENT]</li> </ul> </li> <li> <p> Implement Progress Indicators [NEW CONTENT]</p> <ul> <li> Add \"You Are Here\" indicators to multi-step guides [NEW CONTENT]</li> <li> Create breadcrumb navigation for learning paths [NEW CONTENT]</li> <li> Develop progress visualizations for complex guides [NEW CONTENT]</li> </ul> </li> <li> <p> Generate Cross-Links [ENHANCEMENT]</p> <ul> <li> Add \"Related Security Topics\" to all pages [ENHANCEMENT]</li> <li> Link implementation guides to security content [ENHANCEMENT]</li> <li> Create bidirectional links between related content [ENHANCEMENT]</li> <li> Ensure no critical content is more than 2 clicks away [REORGANIZATION]</li> </ul> </li> <li> <p> Create Quick Reference Resources [NEW CONTENT]</p> <ul> <li> Security checklist reference [NEW CONTENT]</li> <li> Approach comparison summary [ADAPTATION - using approaches/comparison.md]</li> <li> Risk mitigation quick reference [ADAPTATION - using security/risk/mitigations.md]</li> <li> Compliance requirement summary [ADAPTATION - using security/compliance/index.md]</li> </ul> </li> </ul>"},{"location":"project/project-target-organization-plan/#phase-5-testing-and-refinement-week-8","title":"Phase 5: Testing and Refinement (Week 8)","text":"<ul> <li> <p> User Testing Plan [NEW CONTENT]</p> <ul> <li> Develop testing scenarios focused on security paths [NEW CONTENT]</li> <li> Create task-completion tests for learning journeys [NEW CONTENT]</li> <li> Design feedback collection mechanism [NEW CONTENT]</li> <li> Identify test user groups [NEW CONTENT]</li> </ul> </li> <li> <p> Conduct User Testing [NEW CONTENT]</p> <ul> <li> Test finding security information [NEW CONTENT]</li> <li> Test understanding security implications [NEW CONTENT]</li> <li> Test following learning paths [NEW CONTENT]</li> <li> Test completing security-focused tasks [NEW CONTENT]</li> </ul> </li> <li> <p> Gather Feedback [NEW CONTENT]</p> <ul> <li> Collect feedback on navigation clarity [NEW CONTENT]</li> <li> Assess security content prominence [NEW CONTENT]</li> <li> Evaluate learning path effectiveness [NEW CONTENT]</li> <li> Measure task completion success [NEW CONTENT]</li> </ul> </li> <li> <p> Documentation Refinement [ENHANCEMENT]</p> <ul> <li> Adjust navigation based on feedback [REORGANIZATION]</li> <li> Enhance security content where gaps identified [ENHANCEMENT]</li> <li> Improve learning paths that tested poorly [ENHANCEMENT]</li> <li> Add additional security cross-links where needed [ENHANCEMENT]</li> </ul> </li> </ul>"},{"location":"project/project-target-organization-plan/#success-criteria","title":"Success Criteria","text":"Metric Target Measurement Method User journey completion 90%+ Analytics tracking through paths Security content discoverability &lt; 30 seconds Timed user tests Task completion rates 95%+ User testing success rates Learning path progression 80%+ Completion tracking Documentation feedback 4.5/5 User surveys"},{"location":"project/project-target-organization-plan/#content-templates","title":"Content Templates","text":""},{"location":"project/project-target-organization-plan/#learning-path-template-structure","title":"Learning Path Template Structure","text":"<pre><code># [Title] Learning Path\n\n## Overview\n[Brief description with security emphasis]\n\n## Prerequisites\n- [Required knowledge]\n- [Required access]\n- [Required tools]\n\n## Learning Path Steps\n1. [Step 1 title]\n   - Expected time: [time]\n   - Security focus: [security aspects]\n   - Link: [Step 1 page]\n\n2. [Step 2 title]\n   - Expected time: [time]\n   - Security focus: [security aspects]\n   - Link: [Step 2 page]\n\n[...additional steps...]\n\n## Security Considerations\n[Important security notes relevant to this path]\n\n## Compliance Relevance\n[How this path relates to compliance requirements]\n\n## Next Steps After Completion\n[Where to go after completing this path]\n\n## Related Resources\n- [Related security documentation]\n- [Related implementation guides]\n- [Related reference materials]\n</code></pre>"},{"location":"project/project-target-organization-plan/#task-page-template-structure","title":"Task Page Template Structure","text":"<pre><code># [Task Title]\n\n## Overview\n[Brief description with security context]\n\n## Security Prerequisites\n- [Required permissions]\n- [Security configurations]\n- [Risk considerations]\n\n## Step-by-Step Instructions\n1. [Step 1]\n   - [Security note if applicable]\n\n2. [Step 2]\n   - [Security note if applicable]\n\n[...additional steps...]\n\n## Security Best Practices\n- [Security recommendation 1]\n- [Security recommendation 2]\n- [Security recommendation 3]\n\n## Verification Steps\n1. [Verification step 1]\n2. [Verification step 2]\n[...additional verification steps...]\n\n## Troubleshooting\n[Common issues and security-aware solutions]\n\n## Next Steps\n[Logical next tasks to perform]\n\n## Related Security Considerations\n[Links to related security documentation]\n</code></pre>"},{"location":"project/project-target-organization-plan/#maintenance-guidelines","title":"Maintenance Guidelines","text":"<ol> <li>Adding New Content</li> <li>Always include security considerations</li> <li>Place in appropriate learning path context</li> <li>Add to site index</li> <li> <p>Create necessary cross-links</p> </li> <li> <p>Updating Existing Content</p> </li> <li>Maintain security emphasis</li> <li>Update cross-links if needed</li> <li>Verify learning path integrity</li> <li> <p>Check for security accuracy</p> </li> <li> <p>Periodic Review</p> </li> <li>Review security content quarterly</li> <li>Update compliance information as needed</li> <li>Refresh learning paths with new content</li> <li>Verify cross-links remain valid</li> </ol>"},{"location":"project/project-target-organization-plan/#progress-reporting","title":"Progress Reporting","text":"<p>Weekly progress updates will track:</p> <ul> <li>Tasks completed vs. planned</li> <li>Blockers and issues</li> <li>Documentation quality metrics</li> <li>User feedback summary</li> <li>Next week priorities</li> </ul> <p>This plan was created on March 26, 2025 and is subject to revision as implementation progresses.</p> <p>\ud83e\udd16 Generated with Claude Code Co-Authored-By: Claude noreply@anthropic.com</p>"},{"location":"project/roadmap/","title":"Container Security Scanning Roadmap","text":"<p>This document outlines the completed components and future development plans for our Kubernetes container security scanning solution.</p>"},{"location":"project/roadmap/#completed-components","title":"Completed Components","text":""},{"location":"project/roadmap/#core-infrastructure","title":"Core Infrastructure","text":"<ul> <li> <p> RBAC Configuration</p> <ul> <li> Least-privilege role-based access</li> <li> Service account setup</li> <li> Token management</li> <li> Both resource-name and label-based access</li> </ul> </li> <li> <p> Scanning Scripts</p> <ul> <li> <code>scan-container.sh</code> for standard containers</li> <li> <code>scan-distroless-container.sh</code> for distroless containers (with placeholders)</li> <li> <code>generate-kubeconfig.sh</code> for credential management</li> <li> <code>setup-minikube.sh</code> for local testing</li> </ul> </li> <li> <p> Initial Distroless Container Support</p> <ul> <li> Proof of concept for distroless scanning with ephemeral containers</li> <li> Documentation of distroless container challenges and approaches</li> <li> Support in setup-minikube.sh with --with-distroless flag</li> <li> Distroless Helm chart with ephemeral container configuration</li> </ul> </li> <li> <p> Kubernetes Resources</p> <ul> <li> Namespace configuration</li> <li> Test pods for demonstration</li> <li> ServiceAccount and Role templates</li> <li> RoleBinding templates</li> </ul> </li> </ul>"},{"location":"project/roadmap/#helm-chart-implementation","title":"Helm Chart Implementation","text":"<ul> <li> <p> Modular Chart Structure</p> <ul> <li> scanner-infrastructure: Core RBAC, service accounts, tokens</li> <li> common-scanner: Common scanning components and utilities</li> <li> standard-scanner: Standard container scanning</li> <li> distroless-scanner: Distroless container scanning with ephemeral containers</li> </ul> </li> <li> <p> Chart Features</p> <ul> <li> Proper dependencies between charts</li> <li> ConfigMaps for scripts and utilities</li> <li> Well-documented values.yaml</li> <li> README files for each chart</li> </ul> </li> <li> <p> Helper Utilities</p> <ul> <li> install-all.sh for easy deployment</li> <li> Example values for different environments</li> <li> SAF CLI integration in charts</li> </ul> </li> </ul>"},{"location":"project/roadmap/#documentation","title":"Documentation","text":"<ul> <li> <p> Core Documentation</p> <ul> <li> Project overview and architecture</li> <li> RBAC and service account setup</li> <li> Token management</li> <li> SAF CLI integration guide</li> </ul> </li> <li> <p> Integration Guides</p> <ul> <li> GitHub Actions workflows</li> <li> GitLab CI pipelines</li> <li> SAF CLI threshold configuration</li> <li> Helper scripts vs. direct commands</li> </ul> </li> </ul>"},{"location":"project/roadmap/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li> <p> GitHub Actions</p> <ul> <li> Basic setup and scan workflow</li> <li> Dynamic RBAC scanning workflow</li> <li> CI/CD pipeline workflow</li> </ul> </li> <li> <p> GitLab CI</p> <ul> <li> Complete pipeline example</li> <li> Multi-stage process with cleanup</li> </ul> </li> </ul>"},{"location":"project/roadmap/#planned-components","title":"Planned Components","text":""},{"location":"project/roadmap/#distroless-container-scanning-dual-approach-demonstration","title":"Distroless Container Scanning (Dual Approach Demonstration)","text":"<ul> <li> <p> Approach 1: Modified Train-k8s-container Plugin (Enterprise Solution)</p> <ul> <li> Fork and modify the train-k8s-container plugin for native distroless support</li> <li> Add ephemeral container detection and fallback</li> <li> Implement direct filesystem access through debug container</li> <li> Modify connection and exec client classes</li> <li> Create streamlined user experience with consistent commands</li> </ul> </li> <li> <p> Approach 2: CINC Auditor in Debug Container (Working Prototype)</p> <ul> <li> Create initial script with placeholder code (scan-distroless-container.sh)</li> <li> Document the approach for ephemeral container usage</li> <li> Create specialized debug container with CINC Auditor pre-installed</li> <li> Implement chroot-based filesystem access to target container</li> <li> Bridge results back to host system</li> <li> Fully document the approach's tradeoffs and use cases</li> </ul> </li> <li> <p> Approach 3: Sidecar Container with Shared Process Namespace (Working Solution)</p> <ul> <li> Create script for sidecar deployment and scanning</li> <li> Implement process detection and filesystem access</li> <li> Create Helm chart for sidecar container approach</li> <li> Document the sidecar approach thoroughly</li> <li> Create CI/CD integration examples</li> </ul> </li> <li> <p> Comparative Analysis</p> <ul> <li> Benchmark performance of all approaches</li> <li> Document security implications of each approach</li> <li> Create decision matrix for solution selection</li> <li> Develop recommendation for enterprise environments</li> </ul> </li> </ul>"},{"location":"project/roadmap/#enhanced-architecture-documentation","title":"Enhanced Architecture Documentation","text":"<ul> <li> <p> System Architecture Documentation</p> <ul> <li> Container interaction flow diagrams</li> <li> Security model diagrams</li> <li> Sequence diagrams for each approach</li> <li> Component diagrams showing interactions</li> </ul> </li> <li> <p> Security Analysis Documentation</p> <ul> <li> Risk analysis of container scanning approaches</li> <li> Threat modeling for all distroless approaches</li> <li> Security controls and mitigations</li> <li> Privilege minimization techniques</li> </ul> </li> <li> <p> Decision Support Documentation</p> <ul> <li> Pros and cons analysis of all approaches</li> <li> Total cost of ownership considerations</li> <li> Maintenance and support implications</li> <li> Formal recommendation document for stakeholders</li> </ul> </li> <li> <p> Additional Guides</p> <ul> <li> Advanced RBAC configurations</li> <li> Custom profile development</li> <li> Integrating with vulnerability scanners</li> </ul> </li> <li> <p> Tutorials</p> <ul> <li> End-to-end scanning tutorial</li> <li> Custom profile development tutorial</li> <li> Integrating results with security dashboards</li> </ul> </li> </ul>"},{"location":"project/roadmap/#testing-and-validation","title":"Testing and Validation","text":"<ul> <li> <p> Container Type Testing</p> <ul> <li> Test with Google's distroless images</li> <li> Test with custom minimalist containers</li> <li> Test with different language runtimes (Go, Java, Python)</li> </ul> </li> <li> <p> Performance Optimization</p> <ul> <li> Measure and optimize scan times</li> <li> Reduce resource usage during scans</li> <li> Optimize startup time</li> <li> Compare performance metrics between approaches</li> </ul> </li> </ul>"},{"location":"project/roadmap/#extended-cicd-examples","title":"Extended CI/CD Examples","text":"<ul> <li> <p> Distroless Container CI/CD Integration</p> <ul> <li> GitHub Actions workflow for Approach 1 (modified plugin)</li> <li> GitHub Actions workflow for Approach 2 (debug container method)</li> <li> GitHub Actions workflow for Approach 3 (sidecar method)</li> <li> GitLab CI pipeline for Approach 2 and Approach 3</li> <li> Jenkins pipeline example</li> </ul> </li> <li> <p> CI/CD Enhancements</p> <ul> <li> Dedicated distroless scanning GitHub Actions workflow</li> <li> Dedicated distroless scanning GitLab CI pipeline</li> <li> Integration with vulnerability scanning tools</li> <li> End-to-end security pipeline examples</li> </ul> </li> </ul>"},{"location":"project/roadmap/#roadmap-timeline","title":"Roadmap Timeline","text":""},{"location":"project/roadmap/#phase-1-core-functionality-100-complete","title":"Phase 1: Core Functionality (100% Complete)","text":"<ul> <li>Basic container scanning with RBAC</li> <li>Helper scripts for standard workflows</li> <li>GitHub and GitLab integration</li> </ul>"},{"location":"project/roadmap/#phase-2-enhanced-capabilities-100-complete","title":"Phase 2: Enhanced Capabilities (100% Complete)","text":"<ul> <li>Modular Helm chart implementation</li> <li>SAF CLI integration</li> <li>Threshold configuration</li> <li>Documentation improvements</li> </ul>"},{"location":"project/roadmap/#phase-3-distroless-container-support-90-complete","title":"Phase 3: Distroless Container Support (90% Complete)","text":"<ul> <li>Implemented multiple demonstration approaches:<ul> <li>Approach 1: Modified train-k8s-container plugin (20% complete)</li> <li>Approach 2: CINC Auditor in debug container with chroot (100% complete)</li> <li>Approach 3: Sidecar container with shared process namespace (100% complete)</li> </ul> </li> <li>Enhanced documentation with architectural diagrams</li> <li>Created security risk analysis for all approaches</li> <li>Provided clear recommendations for decision makers</li> <li>Developed comprehensive documentation and comparison resources</li> </ul>"},{"location":"project/roadmap/#phase-4-documentation-and-integration-enhancement-95-complete","title":"Phase 4: Documentation and Integration Enhancement (95% Complete)","text":"<ul> <li>Comprehensive documentation reorganization</li> <li>MkDocs with Material theme implementation</li> <li>Enhanced navigation and cross-references</li> <li>Complete guide for all scanning approaches</li> <li>Improved integration examples and CI/CD workflows</li> </ul>"},{"location":"project/roadmap/#phase-5-advanced-features-planned-for-q3-2025","title":"Phase 5: Advanced Features (Planned for Q3 2025)","text":"<ul> <li>Automated remediation suggestions</li> <li>Integration with security dashboards</li> <li>Enterprise-grade customization options</li> <li>Additional CI/CD platform support</li> <li>Integration with vulnerability scanning tools</li> </ul>"},{"location":"project/roadmap/#project-status","title":"Project Status","text":"<ul> <li>Overall Project Completion: ~90%</li> <li>Documentation Completion: 95%</li> <li>Core Functionality: 100%</li> <li>Testing Coverage: 70%</li> <li>Next Major Milestone: Complete Approach 1 implementation and v1.0.0 release</li> <li>Target Release Date: May 2025</li> </ul>"},{"location":"project/security-nav-update/","title":"Security Navigation Updates","text":"<p>This document outlines the changes needed to update the mkdocs.yml navigation to reflect the reorganized security section structure.</p>"},{"location":"project/security-nav-update/#current-navigation-before","title":"Current Navigation (Before)","text":"<pre><code>- Security:\n  - Overview: security/overview.md\n  - Risk Analysis: security/risk-analysis.md\n  - Security Analysis: security/analysis.md\n  - Compliance Analysis: security/compliance.md\n</code></pre>"},{"location":"project/security-nav-update/#updated-navigation-after","title":"Updated Navigation (After)","text":"<pre><code>- Security:\n  - Overview: security/index.md\n  - Directory: security/inventory.md\n  - Security Principles:\n    - Overview: security/principles/index.md\n    - Directory: security/principles/inventory.md\n    - Least Privilege: security/principles/least-privilege.md\n    - Ephemeral Credentials: security/principles/ephemeral-creds.md\n    - Resource Isolation: security/principles/resource-isolation.md\n    - Secure Transport: security/principles/secure-transport.md\n  - Risk Analysis:\n    - Overview: security/risk/index.md\n    - Directory: security/risk/inventory.md\n    - Risk Model: security/risk/model.md\n    - Kubernetes API Approach: security/risk/kubernetes-api.md\n    - Debug Container Approach: security/risk/debug-container.md\n    - Sidecar Container Approach: security/risk/sidecar-container.md\n    - Risk Mitigations: security/risk/mitigations.md\n  - Threat Model:\n    - Overview: security/threat-model/index.md\n    - Directory: security/threat-model/inventory.md\n    - Attack Vectors: security/threat-model/attack-vectors.md\n    - Lateral Movement: security/threat-model/lateral-movement.md\n    - Token Exposure: security/threat-model/token-exposure.md\n    - Threat Mitigations: security/threat-model/threat-mitigations.md\n  - Compliance:\n    - Overview: security/compliance/index.md\n    - Directory: security/compliance/inventory.md\n    - Approach Comparison: security/compliance/approach-comparison.md\n    - Risk Documentation: security/compliance/risk-documentation.md\n  - Recommendations:\n    - Overview: security/recommendations/index.md\n    - Directory: security/recommendations/inventory.md\n</code></pre>"},{"location":"project/security-nav-update/#changes-summary","title":"Changes Summary","text":"<ol> <li>Main Navigation</li> <li>Changed security overview link from <code>security/overview.md</code> to <code>security/index.md</code></li> <li> <p>Added <code>security/inventory.md</code> as \"Directory\"</p> </li> <li> <p>New Subdirectory Navigation</p> </li> <li> <p>Added five new subdirectory sections:</p> <ul> <li>Security Principles</li> <li>Risk Analysis</li> <li>Threat Model</li> <li>Compliance</li> <li>Recommendations</li> </ul> </li> <li> <p>Entry Points and Content</p> </li> <li> <p>Each subdirectory has:</p> <ul> <li>Overview (index.md)</li> <li>Directory (inventory.md)</li> <li>Topic-specific content files</li> </ul> </li> <li> <p>Removed Obsolete Entries</p> </li> <li>Removed direct links to old files:<ul> <li><code>security/risk-analysis.md</code></li> <li><code>security/analysis.md</code></li> <li><code>security/compliance.md</code></li> <li><code>security/overview.md</code></li> </ul> </li> </ol>"},{"location":"project/security-nav-update/#implementation-notes","title":"Implementation Notes","text":"<p>When implementing this navigation update:</p> <ol> <li>Ensure all file paths are correct (especially watch for typos in directory names)</li> <li>Verify that all referenced files exist in the correct locations</li> <li>Maintain proper indentation in the YAML structure</li> <li>Test navigation after changes to ensure all links work correctly</li> <li>The old files can be retained in the repository as redirects to their new locations if needed</li> </ol>"},{"location":"project/security-nav-update/#benefits","title":"Benefits","text":"<ol> <li>Logical Organization</li> <li>Clear, hierarchical structure for security documentation</li> <li> <p>Improved content discoverability</p> </li> <li> <p>Progressive Disclosure</p> </li> <li>Top-level navigation shows major security categories</li> <li> <p>Drill-down for detailed information</p> </li> <li> <p>Consistency</p> </li> <li>Follows the same pattern used in the approaches section</li> <li>Standardized structure across documentation</li> </ol> <p>This navigation update should be applied to the mkdocs.yml file as part of completing the security section reorganization.</p>"},{"location":"project/security-reorganization-plan/","title":"Security Documentation Reorganization Plan","text":""},{"location":"project/security-reorganization-plan/#current-structure-analysis","title":"Current Structure Analysis","text":"<p>The current security section contains several large, comprehensive files:</p> <ol> <li>index.md: Overview of security aspects and principles</li> <li>overview.md: Security design principles and threat mitigation</li> <li>analysis.md: Detailed security analysis of the different approaches</li> <li>risk-analysis.md: Comprehensive risk assessment for each approach</li> <li>compliance.md: Detailed compliance analysis against security frameworks</li> </ol> <p>The content is well-organized but includes large, complex documents that cover multiple aspects of security. This makes it challenging for users to find specific information about individual security topics.</p>"},{"location":"project/security-reorganization-plan/#proposed-directory-structure","title":"Proposed Directory Structure","text":"<p>I propose reorganizing the security section as follows:</p> <pre><code>/docs/security/\n\u251c\u2500\u2500 index.md                  # Overview and introduction to security documentation\n\u251c\u2500\u2500 inventory.md              # Directory listing of all security documentation\n\u251c\u2500\u2500 principles/               # Security principles subdirectory\n\u2502   \u251c\u2500\u2500 index.md              # Overview of security principles \n\u2502   \u251c\u2500\u2500 least-privilege.md    # Details on least privilege implementation\n\u2502   \u251c\u2500\u2500 ephemeral-creds.md    # Details on ephemeral credentials\n\u2502   \u251c\u2500\u2500 resource-isolation.md # Details on resource isolation\n\u2502   \u251c\u2500\u2500 secure-transport.md   # Details on secure transport\n\u2502   \u2514\u2500\u2500 inventory.md          # Directory listing\n\u251c\u2500\u2500 risk/                     # Risk analysis subdirectory\n\u2502   \u251c\u2500\u2500 index.md              # Overview of risk analysis\n\u2502   \u251c\u2500\u2500 model.md              # Risk model and methodology\n\u2502   \u251c\u2500\u2500 kubernetes-api.md     # Risks for Kubernetes API approach\n\u2502   \u251c\u2500\u2500 debug-container.md    # Risks for Debug Container approach\n\u2502   \u251c\u2500\u2500 sidecar-container.md  # Risks for Sidecar Container approach\n\u2502   \u251c\u2500\u2500 mitigations.md        # Risk mitigation strategies\n\u2502   \u2514\u2500\u2500 inventory.md          # Directory listing\n\u251c\u2500\u2500 compliance/               # Compliance subdirectory \n\u2502   \u251c\u2500\u2500 index.md              # Overview of compliance documentation\n\u2502   \u251c\u2500\u2500 dod-8500-01.md        # DoD Instruction 8500.01 alignment\n\u2502   \u251c\u2500\u2500 disa-srg.md           # DISA Container Platform SRG alignment\n\u2502   \u251c\u2500\u2500 kubernetes-stig.md    # Kubernetes STIG alignment\n\u2502   \u251c\u2500\u2500 cis-benchmarks.md     # CIS Kubernetes Benchmarks alignment\n\u2502   \u251c\u2500\u2500 approach-comparison.md # Compliance comparison of approaches\n\u2502   \u251c\u2500\u2500 risk-documentation.md # Requirements for risk documentation\n\u2502   \u2514\u2500\u2500 inventory.md          # Directory listing\n\u251c\u2500\u2500 threat-model/             # Threat model subdirectory\n\u2502   \u251c\u2500\u2500 index.md              # Overview of threat modeling\n\u2502   \u251c\u2500\u2500 attack-vectors.md     # Potential attack vectors\n\u2502   \u251c\u2500\u2500 threat-mitigations.md # Threat mitigation strategies\n\u2502   \u251c\u2500\u2500 token-exposure.md     # Token exposure threats and mitigations\n\u2502   \u251c\u2500\u2500 lateral-movement.md   # Preventing lateral movement\n\u2502   \u2514\u2500\u2500 inventory.md          # Directory listing\n\u2514\u2500\u2500 recommendations/          # Security recommendations subdirectory\n    \u251c\u2500\u2500 index.md              # Overview of security recommendations\n    \u251c\u2500\u2500 enterprise.md         # Enterprise security recommendations\n    \u251c\u2500\u2500 ci-cd.md              # CI/CD security recommendations\n    \u251c\u2500\u2500 monitoring.md         # Security monitoring recommendations\n    \u251c\u2500\u2500 network.md            # Network security recommendations\n    \u2514\u2500\u2500 inventory.md          # Directory listing\n</code></pre>"},{"location":"project/security-reorganization-plan/#content-distribution-plan","title":"Content Distribution Plan","text":""},{"location":"project/security-reorganization-plan/#1-principles-section","title":"1. Principles Section","text":"<p>Extract from overview.md:</p> <ul> <li>Core Security Principles</li> <li>Principle of Least Privilege</li> <li>Ephemeral Credentials</li> <li>Resource Isolation</li> <li>Secure Transport</li> </ul>"},{"location":"project/security-reorganization-plan/#2-risk-section","title":"2. Risk Section","text":"<p>Extract from risk-analysis.md:</p> <ul> <li>Security Risk Overview</li> <li>Detailed Risk Assessment (split by approach)</li> <li>Risk Mitigation Strategies</li> <li>Enterprise Security Recommendations</li> </ul>"},{"location":"project/security-reorganization-plan/#3-compliance-section","title":"3. Compliance Section","text":"<p>Extract from compliance.md:</p> <ul> <li>Compliance Overview</li> <li>DoD Instruction 8500.01 Alignment</li> <li>DISA Container Platform SRG Alignment</li> <li>Kubernetes STIG Alignment</li> <li>CIS Kubernetes Benchmark Alignment</li> <li>Compliance Analysis of All Approaches</li> <li>Compliance Comparison Table</li> <li>Risk Documentation Requirements</li> </ul>"},{"location":"project/security-reorganization-plan/#4-threat-model-section","title":"4. Threat Model Section","text":"<p>Extract from overview.md and analysis.md:</p> <ul> <li>Threat Mitigation section from overview.md</li> <li>Preventing Lateral Movement</li> <li>Key Threats Addressed from analysis.md</li> <li>Security Best Practices Implementation</li> </ul>"},{"location":"project/security-reorganization-plan/#5-recommendations-section","title":"5. Recommendations Section","text":"<p>Extract from risk-analysis.md and compliance.md:</p> <ul> <li>Enterprise Security Recommendations</li> <li>Implementation Guidelines for Compliance</li> <li>Security Best Practices Implementation</li> </ul>"},{"location":"project/security-reorganization-plan/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Create Directory Structure: Set up all the subdirectories</li> <li>Create Index Files: Create overview index.md for each subdirectory</li> <li>Create Inventory Files: Create inventory.md for each subdirectory</li> <li>Extract Content: Move content from existing files to new focused files</li> <li>Update Main Index: Convert main index.md to serve as a unified entry point</li> <li>Update Navigation: Update mkdocs.yml with new navigation structure</li> </ol>"},{"location":"project/security-reorganization-plan/#navigation-structure-in-mkdocsyml","title":"Navigation Structure in mkdocs.yml","text":"<pre><code>- Security:\n  - Overview: security/index.md\n  - Directory Contents: security/inventory.md\n  - Security Principles:\n    - Overview: security/principles/index.md\n    - Least Privilege: security/principles/least-privilege.md\n    - Ephemeral Credentials: security/principles/ephemeral-creds.md\n    - Resource Isolation: security/principles/resource-isolation.md\n    - Secure Transport: security/principles/secure-transport.md\n  - Risk Analysis:\n    - Overview: security/risk/index.md\n    - Risk Model: security/risk/model.md\n    - Kubernetes API Approach: security/risk/kubernetes-api.md\n    - Debug Container Approach: security/risk/debug-container.md\n    - Sidecar Container Approach: security/risk/sidecar-container.md\n    - Risk Mitigations: security/risk/mitigations.md\n  - Compliance:\n    - Overview: security/compliance/index.md\n    - DoD 8500.01: security/compliance/dod-8500-01.md\n    - DISA Container SRG: security/compliance/disa-srg.md\n    - Kubernetes STIG: security/compliance/kubernetes-stig.md\n    - CIS Benchmarks: security/compliance/cis-benchmarks.md\n    - Approach Comparison: security/compliance/approach-comparison.md\n    - Risk Documentation: security/compliance/risk-documentation.md\n  - Threat Model:\n    - Overview: security/threat-model/index.md\n    - Attack Vectors: security/threat-model/attack-vectors.md\n    - Threat Mitigations: security/threat-model/threat-mitigations.md\n    - Token Exposure: security/threat-model/token-exposure.md\n    - Lateral Movement: security/threat-model/lateral-movement.md\n  - Recommendations:\n    - Overview: security/recommendations/index.md\n    - Enterprise: security/recommendations/enterprise.md\n    - CI/CD Security: security/recommendations/ci-cd.md\n    - Monitoring: security/recommendations/monitoring.md\n    - Network Security: security/recommendations/network.md\n</code></pre>"},{"location":"project/security-reorganization-plan/#expected-benefits","title":"Expected Benefits","text":"<ol> <li>Improved Readability: Smaller, focused files will be easier to read and understand</li> <li>Better Navigation: Logical hierarchy makes information easier to find</li> <li>Focused Topics: Users can quickly find specific security information</li> <li>Reduced Cognitive Load: Users only need to focus on relevant security aspects</li> <li>Easier Maintenance: Smaller files are easier to update and maintain</li> <li>Comprehensive Coverage: All security aspects properly documented in dedicated files</li> </ol>"},{"location":"project/security-reorganization-plan/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>Create directory structure and base files</li> <li>Implement principles section</li> <li>Implement risk section</li> <li>Implement compliance section</li> <li>Implement threat model section</li> <li>Implement recommendations section</li> <li>Update main index.md and inventory.md</li> <li>Update navigation in mkdocs.yml</li> <li>Review and validate all cross-references</li> <li>Test navigation and readability</li> </ol>"},{"location":"project/security-reorganization-plan/#next-steps","title":"Next Steps","text":"<ol> <li>Get approval for this restructuring plan</li> <li>Begin implementation with directory creation</li> <li>Start extracting and reorganizing content</li> <li>Update navigation and cross-references</li> </ol>"},{"location":"project/security-reorganization-summary/","title":"Security Section Reorganization Summary","text":""},{"location":"project/security-reorganization-summary/#overview","title":"Overview","text":"<p>The security section has been completely reorganized to improve usability, navigation, and content discoverability. This reorganization follows the same pattern established in the approaches section reorganization, creating logical subdirectories with focused content files.</p>"},{"location":"project/security-reorganization-summary/#restructuring-approach","title":"Restructuring Approach","text":"<ol> <li>Directory Structure Creation</li> <li> <p>Created five dedicated subdirectories:</p> <ul> <li><code>/principles/</code> - Core security principles</li> <li><code>/risk/</code> - Risk analysis by approach</li> <li><code>/compliance/</code> - Compliance framework alignment</li> <li><code>/threat-model/</code> - Threat modeling and attack vectors</li> <li><code>/recommendations/</code> - Security best practices</li> </ul> </li> <li> <p>Content Extraction</p> </li> <li> <p>Extracted content from original files:</p> <ul> <li><code>overview.md</code> \u2192 principles/ files</li> <li><code>risk-analysis.md</code> \u2192 risk/ files</li> <li><code>analysis.md</code> \u2192 threat-model/ files</li> <li><code>compliance.md</code> \u2192 compliance/ files</li> </ul> </li> <li> <p>Directory Standardization</p> </li> <li> <p>Each subdirectory includes:</p> <ul> <li><code>index.md</code> - Overview and introduction to the topic</li> <li><code>inventory.md</code> - Directory listing with short descriptions</li> <li>Topic-specific content files</li> </ul> </li> <li> <p>Navigation Enhancement</p> </li> <li>Updated the main security/index.md to serve as a guide to the new structure</li> <li>Created comprehensive inventory.md with links to all content</li> <li>Implemented consistent cross-referencing between related topics</li> </ol>"},{"location":"project/security-reorganization-summary/#content-organization","title":"Content Organization","text":""},{"location":"project/security-reorganization-summary/#security-principles-directory","title":"Security Principles Directory","text":"<ul> <li><code>index.md</code> - Security principles overview</li> <li><code>least-privilege.md</code> - Least privilege implementation</li> <li><code>ephemeral-creds.md</code> - Ephemeral credentials implementation</li> <li><code>resource-isolation.md</code> - Resource isolation implementation</li> <li><code>secure-transport.md</code> - Secure transport implementation</li> <li><code>inventory.md</code> - Directory listing</li> </ul>"},{"location":"project/security-reorganization-summary/#risk-analysis-directory","title":"Risk Analysis Directory","text":"<ul> <li><code>index.md</code> - Risk analysis overview</li> <li><code>model.md</code> - Risk assessment methodology</li> <li><code>kubernetes-api.md</code> - Kubernetes API approach risk analysis</li> <li><code>debug-container.md</code> - Debug container approach risk analysis</li> <li><code>sidecar-container.md</code> - Sidecar container approach risk analysis</li> <li><code>mitigations.md</code> - Risk mitigation strategies</li> <li><code>inventory.md</code> - Directory listing</li> </ul>"},{"location":"project/security-reorganization-summary/#compliance-directory","title":"Compliance Directory","text":"<ul> <li><code>index.md</code> - Compliance overview</li> <li><code>approach-comparison.md</code> - Compliance comparison by approach</li> <li><code>risk-documentation.md</code> - Risk documentation requirements</li> <li>Placeholder files for framework-specific documentation</li> <li><code>inventory.md</code> - Directory listing</li> </ul>"},{"location":"project/security-reorganization-summary/#threat-model-directory","title":"Threat Model Directory","text":"<ul> <li><code>index.md</code> - Threat model overview</li> <li><code>attack-vectors.md</code> - Attack vector analysis</li> <li><code>lateral-movement.md</code> - Lateral movement risk analysis</li> <li><code>token-exposure.md</code> - Token exposure risk analysis</li> <li><code>threat-mitigations.md</code> - Threat mitigation strategies</li> <li><code>inventory.md</code> - Directory listing</li> </ul>"},{"location":"project/security-reorganization-summary/#recommendations-directory","title":"Recommendations Directory","text":"<ul> <li><code>index.md</code> - Recommendations overview</li> <li><code>inventory.md</code> - Directory listing</li> <li>Placeholder structure for future content</li> </ul>"},{"location":"project/security-reorganization-summary/#main-security-documentation","title":"Main Security Documentation","text":"<ul> <li>Updated <code>security/index.md</code> to provide clear navigation to all subdirectories</li> <li>Updated <code>security/inventory.md</code> with comprehensive listings of all content</li> </ul>"},{"location":"project/security-reorganization-summary/#content-enhancement","title":"Content Enhancement","text":"<ol> <li>Comprehensive Coverage</li> <li>Added detailed content for each security aspect</li> <li>Created consistent structure across all documentation files</li> <li> <p>Enhanced tables, code examples, and formatting</p> </li> <li> <p>Cross-Referencing</p> </li> <li>Implemented thorough cross-references between related topics</li> <li>Created clear navigation paths for different user journeys</li> <li> <p>Maintained links to external documentation</p> </li> <li> <p>Visual Enhancements</p> </li> <li>Used consistent formatting for tables, lists, and code blocks</li> <li>Applied proper heading hierarchy for better navigation</li> <li>Added admonitions for important information</li> </ol>"},{"location":"project/security-reorganization-summary/#benefits-of-the-new-structure","title":"Benefits of the New Structure","text":"<ol> <li>Improved Discoverability</li> <li>Logical grouping of related content</li> <li>Clear entry points for different security aspects</li> <li> <p>Consistent navigation structure</p> </li> <li> <p>Maintainability</p> </li> <li>Smaller, focused files are easier to update</li> <li>Clear separation of concerns</li> <li> <p>Reduced duplication of content</p> </li> <li> <p>User Experience</p> </li> <li>Better navigation for different user personas</li> <li>Progressive disclosure of complex information</li> <li>Clearer information architecture</li> </ol>"},{"location":"project/security-reorganization-summary/#next-steps","title":"Next Steps","text":"<ol> <li>Navigation Update</li> <li> <p>Update mkdocs.yml to reflect the new security structure</p> </li> <li> <p>Link Validation</p> </li> <li> <p>Verify all internal and external links are working</p> </li> <li> <p>Content Review</p> </li> <li>Final review for consistency and completeness</li> <li> <p>Check for any remaining content gaps</p> </li> <li> <p>Documentation Standards Application</p> </li> <li>Ensure all files follow project documentation standards</li> <li>Apply consistent formatting and structure</li> </ol>"},{"location":"project/security-reorganization-summary/#previous-content-location-reference","title":"Previous Content Location Reference","text":"<p>For reference, the original content was located in:</p> <ul> <li><code>/docs/security/overview.md</code></li> <li><code>/docs/security/analysis.md</code></li> <li><code>/docs/security/risk-analysis.md</code></li> <li><code>/docs/security/compliance.md</code></li> </ul>"},{"location":"project/tasks/","title":"Project Tasks Tracker","text":""},{"location":"project/tasks/#core-development-tasks","title":"Core Development Tasks","text":"<ul> <li> <p> Implement three distroless container scanning approaches</p> <ul> <li> HIGHEST PRIORITY: Approach 1 (Kubernetes API Approach): Modify the train-k8s-container plugin (Enterprise Recommended)<ul> <li> Add ephemeral container detection and fallback</li> <li> Implement direct filesystem access through debug container</li> <li> Modify connection and exec client classes</li> </ul> </li> <li> Approach 2 (Debug Container Approach): CINC Auditor in debug container with chroot (Interim solution)<ul> <li> Create specialized debug container with CINC Auditor pre-installed</li> <li> Implement chroot-based filesystem access to target container</li> <li> Bridge results back to host system</li> </ul> </li> <li> Approach 3 (Sidecar Container Approach): Sidecar container with shared process namespace (Interim solution)<ul> <li> Create script for sidecar deployment and scanning</li> <li> Implement process detection and filesystem access</li> <li> Integration with CI/CD pipelines</li> </ul> </li> </ul> </li> <li> <p> Complete Helm chart templates</p> <ul> <li> Finish configmap templates for remaining components</li> <li> Create helpers and utilities</li> <li> Ensure proper chart dependencies</li> <li> Create Helm chart for sidecar container approach</li> </ul> </li> <li> <p> Testing with container types</p> <ul> <li> Test with Google's distroless images</li> <li> Test with custom minimalist containers</li> <li> Test with different language runtimes (Go, Java, Python)</li> </ul> </li> </ul>"},{"location":"project/tasks/#documentation-tasks","title":"Documentation Tasks","text":"<ul> <li> <p> Create detailed documentation showing script/command equivalence</p> <ul> <li> Document what <code>setup-minikube.sh</code> does vs. direct minikube/kubectl commands</li> <li> Document what <code>scan-container.sh</code> does vs. direct kubectl/inspec commands</li> <li> Document what <code>scan-distroless-container.sh</code> does vs. direct ephemeral container commands</li> <li> Create a <code>/docs/direct-commands.md</code> file with examples</li> </ul> </li> <li> <p> Update main README.md</p> <ul> <li> Clarify the two approaches (shell scripts vs. Helm)</li> <li> Add installation requirements</li> <li> Improve usage examples</li> </ul> </li> <li> <p> Create comprehensive documentation</p> <ul> <li> Design architecture and flow diagrams showing container interactions</li> <li> Create ASCII text-based versions of all diagrams for terminal viewing</li> <li> Develop Executive Summary for stakeholders and decision makers</li> <li> Create detailed security risk analysis for all three approaches</li> <li> Document risk mitigation strategies and security considerations</li> <li> Create Enterprise Integration Analysis (scalability, maintenance, UX)</li> <li> Develop comprehensive decision matrix for approach selection</li> </ul> </li> </ul>"},{"location":"project/tasks/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li> <p> Create CI/CD pipeline examples</p> <ul> <li> GitHub Actions workflows for container scanning<ul> <li> Dynamic RBAC scanning workflow</li> <li> Existing cluster scanning workflow</li> </ul> </li> <li> GitLab CI pipelines for container scanning<ul> <li> Dynamic RBAC scanning pipeline</li> <li> Existing cluster scanning pipeline</li> </ul> </li> <li> Jenkins pipeline example (optional)</li> </ul> </li> <li> <p> Create CI/CD examples for all distroless approaches</p> <ul> <li> HIGHEST PRIORITY: GitHub Actions workflow for Approach 1 (Kubernetes API Approach)</li> <li> GitHub Actions workflow for Approach 2 (Debug Container Approach) - interim solution</li> <li> GitHub Actions workflow for Approach 3 (Sidecar Container Approach) - interim solution</li> <li> HIGHEST PRIORITY: GitLab CI configuration for Approach 1 (Kubernetes API Approach)</li> <li> GitLab CI configuration for Approach 2 (Debug Container Approach) - interim solution</li> <li> GitLab CI configuration for Approach 3 (Sidecar Container Approach) - interim solution</li> <li> GitLab CI with Services for Approach 3 (Sidecar Container Approach) - interim solution</li> </ul> </li> <li> <p> Additional Security Scanning Integration Examples</p> <ul> <li> OWASP ZAP integration for web application security scanning<ul> <li> Create GitHub Actions example for ZAP scanning integration</li> <li> Create GitLab CI pipeline examples for ZAP integration</li> <li> Create GitLab Services configuration for ZAP scanning</li> <li> Document integration points between container and application scanning</li> </ul> </li> <li> Create examples showing combined container/application security reporting</li> </ul> </li> </ul>"},{"location":"project/tasks/#saf-cli-integration","title":"SAF CLI Integration","text":"<ul> <li> <p> Implement threshold configuration files</p> <ul> <li> Create sample threshold YAML files</li> <li> Document threshold configuration options</li> <li> Add examples for pass/fail criteria</li> </ul> </li> <li> <p> Add SAF CLI integration examples</p> <ul> <li> Show how to process scan results with SAF CLI</li> <li> Demonstrate compliance reporting</li> <li> Document threshold checks</li> </ul> </li> </ul>"},{"location":"project/tasks/#validation-and-refinement","title":"Validation and Refinement","text":"<ul> <li> <p> Security review</p> <ul> <li> Audit RBAC permissions for least privilege</li> <li> Review token generation and management</li> <li> Assess network security model</li> <li> Compare security implications of both distroless approaches</li> </ul> </li> <li> <p> Performance optimization</p> <ul> <li> Measure and optimize scan times for both approaches</li> <li> Reduce resource usage during scans</li> <li> Improve startup time</li> <li> Benchmark and compare performance between approaches</li> </ul> </li> <li> <p> Comparative analysis</p> <ul> <li> Document pros and cons of each distroless approach</li> <li> Create decision matrix for approach selection</li> <li> Provide usage recommendations based on different scenarios</li> </ul> </li> </ul>"},{"location":"project/tasks/#documentation-system","title":"Documentation System","text":"<ul> <li> <p> Implement MkDocs with Material theme</p> <ul> <li> Create mkdocs.yml configuration</li> <li> Set up GitHub Actions for documentation deployment</li> <li> Create enhanced navigation hierarchy</li> <li> Add requirements.txt for Python dependencies</li> <li> Update README.md with documentation usage instructions</li> <li> Update terminology for consistent naming of approaches</li> <li> Optimize documentation build performance</li> <li> Add custom CSS for improved styling</li> <li> Configure Mermaid diagram settings</li> </ul> </li> <li> <p> Documentation Refinement</p> <ul> <li> Standardize approach naming across all documents</li> <li> Create Helm Chart documentation section</li> <li> Integrate ASCII diagram approach comparison into main documentation</li> <li> Fix approach-mapping.md links to workflow YAML files</li> <li> Ensure consistent messaging about the Kubernetes API Approach as enterprise-recommended solution</li> <li> Add clear strategic priority statements across all key documentation</li> <li> Add development and testing documentation section</li> <li> Conduct comprehensive documentation review for coherence and flow</li> <li> Reorganize documentation into logical directory structure</li> <li> Fix broken internal links after reorganization<ul> <li> Fix paths in approaches/ directory files</li> <li> Fix paths in security/ directory files</li> <li> Fix paths in architecture/ directory files</li> <li> Fix paths in integration/ directory files</li> <li> Fix paths in helm-charts/ directory files</li> <li> Fix paths in developer-guide/ directory files</li> <li> Fix paths in overview/ directory files</li> </ul> </li> <li> Create script to automate link path fixes for common patterns</li> </ul> </li> </ul>"},{"location":"project/tasks/#administrative","title":"Administrative","text":"<ul> <li> Project release preparation<ul> <li> Version tagging (v1.0.0)</li> <li> Release notes with key features and capabilities</li> <li> Comprehensive documentation website with MkDocs</li> <li> Final review of all example code and scripts</li> <li> Create project logo and branding assets</li> <li> Prepare demonstration of all three scanning approaches</li> <li> Create comprehensive changelog</li> </ul> </li> </ul>"},{"location":"project/terminology/","title":"Standardized Terminology","text":"<p>This document establishes consistent terminology for the Secure CINC Auditor Kubernetes Container Scanning project to ensure clarity and cohesion across all documentation.</p>"},{"location":"project/terminology/#scanning-approaches","title":"Scanning Approaches","text":"Official Term Description Status Aliases to Avoid Kubernetes API Approach Direct API-based scanning through the Kubernetes API using the train-k8s-container plugin Enterprise Recommended Standard Scanning, Modified Plugin Debug Container Approach Ephemeral debug container with chroot-based scanning for distroless containers Interim Solution Ephemeral Container Approach Sidecar Container Approach CINC Auditor sidecar container with shared process namespace Interim Solution Process Namespace Approach"},{"location":"project/terminology/#container-types","title":"Container Types","text":"Term Description Standard Container Container with a shell and basic utilities (e.g., busybox, alpine, ubuntu) Distroless Container Minimal container without shell or package manager (e.g., Google's distroless images)"},{"location":"project/terminology/#security-components","title":"Security Components","text":"Term Description Least Privilege RBAC Role-based access control configured to provide only the minimal permissions needed Dynamic Access Control Time-limited, targeted access granted only for the duration of a scan Label-based RBAC RBAC permissions scoped to pods with specific labels Name-based RBAC RBAC permissions scoped to specific named resources"},{"location":"project/terminology/#deployment-methods","title":"Deployment Methods","text":"Term Description Shell Script Approach Using the provided shell scripts for direct deployment and scanning Helm Chart Approach Using the modular Helm charts for declarative deployment CI/CD Integration Integration with GitHub Actions or GitLab CI for automated scanning"},{"location":"project/terminology/#technical-terms","title":"Technical Terms","text":"Term Description Preferred Over CINC Auditor Open source distribution of Chef InSpec InSpec train-k8s-container Transport plugin for CINC Auditor to scan Kubernetes containers SAF CLI MITRE Security Automation Framework Command Line Interface Threshold Configuration YAML or JSON configuration for defining compliance requirements"},{"location":"project/terminology/#strategic-descriptions","title":"Strategic Descriptions","text":"<p>When describing the approaches, use these consistent formulations:</p>"},{"location":"project/terminology/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>\"The Kubernetes API Approach is our recommended enterprise solution, using the train-k8s-container plugin for direct API-based scanning. This approach will provide universal container scanning capability once distroless support is fully implemented.\"</p>"},{"location":"project/terminology/#debug-container-approach","title":"Debug Container Approach","text":"<p>\"The Debug Container Approach is an interim solution for scanning distroless containers, using ephemeral debug containers with chroot-based filesystem access. This approach requires Kubernetes clusters with ephemeral container support enabled.\"</p>"},{"location":"project/terminology/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>\"The Sidecar Container Approach is an interim solution that works universally across Kubernetes versions, deploying a scanner container alongside the target container with shared process namespace. This approach requires deploying containers specifically with the sidecar configuration.\"</p>"},{"location":"project/warning-resolution-scripts/","title":"Warning Resolution Scripts Proposal","text":"<p>This document outlines a set of scripts to implement a \"fail fast\" approach to fixing documentation warnings in our project.</p>"},{"location":"project/warning-resolution-scripts/#goals","title":"Goals","text":"<ul> <li>Target specific files with warnings rather than entire directories</li> <li>Process files individually to avoid timeouts</li> <li>Track progress by reduction in warnings rather than by sections</li> <li>Provide actionable tasks for remaining issues</li> </ul>"},{"location":"project/warning-resolution-scripts/#proposed-scripts","title":"Proposed Scripts","text":""},{"location":"project/warning-resolution-scripts/#1-extract-doc-warningssh","title":"1. <code>extract-doc-warnings.sh</code>","text":"<p>Extracts specific file paths from MkDocs warnings and creates an actionable task list.</p> <pre><code>#!/bin/bash\n# extract-doc-warnings.sh - Extract and categorize documentation warnings\n\n# Build docs and capture warnings\n./docs-tools.sh build 2&gt; docs/current-warnings.txt\n\n# Extract files with link warnings\necho \"# Files with link warnings\" &gt; docs/warning-tasks.md\necho \"Generated: $(date)\" &gt;&gt; docs/warning-tasks.md\necho \"\" &gt;&gt; docs/warning-tasks.md\n\n# Process different warning types\necho \"## Missing file links\" &gt;&gt; docs/warning-tasks.md\ngrep \"WARNING\" docs/current-warnings.txt | grep \"contains a link\" | grep \"not found among documentation files\" | \n  sort | uniq | sed -E \"s/.*Doc file '([^']+)'.*contains a link '([^']+)'.*/| \\1 | \\2 | Fix missing target |/\" &gt;&gt; docs/warning-tasks.md\n\necho \"\" &gt;&gt; docs/warning-tasks.md\necho \"## Relative path issues\" &gt;&gt; docs/warning-tasks.md\ngrep \"WARNING\" docs/current-warnings.txt | grep \"contains a link\" | grep \"but the target\" | grep -v \"not found among documentation files\" |\n  sort | uniq | sed -E \"s/.*Doc file '([^']+)'.*contains a link '([^']+)'.*target '([^']+)'.*/| \\1 | \\2 \u2192 \\3 | Fix relative path |/\" &gt;&gt; docs/warning-tasks.md\n\n# Create action list for each file\necho \"\" &gt;&gt; docs/warning-tasks.md\necho \"## Files to process\" &gt;&gt; docs/warning-tasks.md\necho \"\" &gt;&gt; docs/warning-tasks.md\ngrep \"WARNING\" docs/current-warnings.txt | grep \"contains a link\" | cut -d\"'\" -f2 | sort | uniq |\n  while read -r file; do\n    echo \"### $file\" &gt;&gt; docs/warning-tasks.md\n    echo \"\\`\\`\\`bash\" &gt;&gt; docs/warning-tasks.md\n    echo \"./fix-links-simple.sh --path \\\"$file\\\" --mappings docs/comprehensive_mappings.txt --verify-files\" &gt;&gt; docs/warning-tasks.md\n    echo \"./scripts/fix-relative-links.sh --path \\\"$file\\\"\" &gt;&gt; docs/warning-tasks.md\n    echo \"\\`\\`\\`\" &gt;&gt; docs/warning-tasks.md\n    echo \"\" &gt;&gt; docs/warning-tasks.md\n  done\n\necho \"Generated actionable tasks for $(grep -c \"###\" docs/warning-tasks.md) files with warnings\"\n</code></pre>"},{"location":"project/warning-resolution-scripts/#2-fix-warning-filesh","title":"2. <code>fix-warning-file.sh</code>","text":"<p>Processes and fixes warnings in a specific file:</p> <pre><code>#!/bin/bash\n# fix-warning-file.sh - Fix warnings in a specific file\n\nfile=\"$1\"\n\nif [ -z \"$file\" ]; then\n  echo \"Usage: ./fix-warning-file.sh &lt;file_path&gt;\"\n  echo \"Example: ./fix-warning-file.sh approaches/debug-container/index.md\"\n  exit 1\nfi\n\necho \"Processing file: $file\"\n\n# First run fix-links-simple.sh\necho \"Running fix-links-simple.sh...\"\n./fix-links-simple.sh --path \"$file\" --mappings docs/comprehensive_mappings.txt --verify-files\n\n# Then run fix-relative-links.sh\necho \"Running fix-relative-links.sh...\"\n./scripts/fix-relative-links.sh --path \"$file\"\n\n# Check if warnings were fixed\necho \"Verifying fix...\"\n./docs-tools.sh build 2&gt; /tmp/verify-warnings.txt\nif grep -q \"$file\" /tmp/verify-warnings.txt; then\n  echo \"\u26a0\ufe0f File still has warnings:\"\n  grep \"$file\" /tmp/verify-warnings.txt\nelse\n  echo \"\u2705 All warnings in $file have been fixed!\"\nfi\n</code></pre>"},{"location":"project/warning-resolution-scripts/#3-track-warning-progresssh","title":"3. <code>track-warning-progress.sh</code>","text":"<p>Tracks progress on fixing warnings:</p> <pre><code>#!/bin/bash\n# track-warning-progress.sh - Track progress on fixing warnings\n\n# Count initial warnings\ninitial_count=$(grep -c \"WARNING\" docs/current-warnings.txt 2&gt;/dev/null || echo \"Unknown\")\n\n# Run a new build to get current warnings\n./docs-tools.sh build 2&gt; docs/latest-warnings.txt\ncurrent_count=$(grep -c \"WARNING\" docs/latest-warnings.txt)\n\n# Calculate progress\nif [[ \"$initial_count\" =~ ^[0-9]+$ ]]; then\n  fixed_count=$((initial_count - current_count))\n  percentage=$((fixed_count * 100 / initial_count))\n\n  echo \"=== Warning Resolution Progress ===\"\n  echo \"Initial warnings: $initial_count\"\n  echo \"Current warnings: $current_count\"\n  echo \"Warnings fixed: $fixed_count ($percentage%)\"\n\n  # Update the progress file\n  echo \"# Warning Resolution Progress\" &gt; docs/warning-progress.md\n  echo \"Updated: $(date)\" &gt;&gt; docs/warning-progress.md\n  echo \"\" &gt;&gt; docs/warning-progress.md\n  echo \"- Initial warnings: $initial_count\" &gt;&gt; docs/warning-progress.md\n  echo \"- Current warnings: $current_count\" &gt;&gt; docs/warning-progress.md\n  echo \"- Warnings fixed: $fixed_count ($percentage%)\" &gt;&gt; docs/warning-progress.md\n\n  # Add remaining files with warnings\n  echo \"\" &gt;&gt; docs/warning-progress.md\n  echo \"## Remaining files with warnings\" &gt;&gt; docs/warning-progress.md\n  grep \"WARNING\" docs/latest-warnings.txt | grep \"contains a link\" | cut -d\"'\" -f2 | sort | uniq |\n    while read -r file; do\n      count=$(grep \"$file\" docs/latest-warnings.txt | wc -l)\n      echo \"- $file ($count warnings)\" &gt;&gt; docs/warning-progress.md\n    done\nelse\n  echo \"No initial warning count available. Run this script after extracting warnings.\"\nfi\n</code></pre>"},{"location":"project/warning-resolution-scripts/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>Create the scripts:</li> <li>Add them to the scripts directory</li> <li>Make them executable</li> <li> <p>Document their usage</p> </li> <li> <p>Initial extraction:</p> </li> <li>Run <code>extract-doc-warnings.sh</code> to create the initial task list</li> <li> <p>Capture baseline warning count</p> </li> <li> <p>Iterative fixing:</p> </li> <li>Process files with warnings one at a time using <code>fix-warning-file.sh</code></li> <li>Track progress with <code>track-warning-progress.sh</code></li> <li> <p>Focus on high-warning files first</p> </li> <li> <p>Final verification:</p> </li> <li>Ensure no remaining warnings exist</li> <li>Update documentation with the new maintenance approach</li> </ol>"},{"location":"project/warning-resolution-scripts/#integration-with-existing-tools","title":"Integration with Existing Tools","text":"<p>These new scripts complement our existing tools by:</p> <ol> <li>Providing targeted fixing of specific files with warnings</li> <li>Tracking progress on warning resolution</li> <li>Creating actionable tasks for remaining issues</li> </ol>"},{"location":"project/warning-resolution-scripts/#updates-to-documentation","title":"Updates to Documentation","text":"<p>We should add this approach to our documentation-tools.md document, specifically for the \"Fixing Link Issues After Detecting Broken Links\" workflow.</p> <p>Example documentation addition:</p> <pre><code>### Efficient Warning Resolution Workflow\n\nWhen you need to fix a large number of warnings:\n\n1. **Extract and categorize warnings**:\n   ```bash\n   ./scripts/extract-doc-warnings.sh\n   ```\n\n   This creates a task list in `docs/warning-tasks.md`\n\n2. **Fix warnings one file at a time**:\n\n   ```bash\n   ./scripts/fix-warning-file.sh path/to/file.md\n   ```\n\n3. **Track progress**:\n\n   ```bash\n   ./scripts/track-warning-progress.sh\n   ```\n\n   This updates progress in `docs/warning-progress.md`\n\nThis targeted approach is more efficient than processing entire sections at once,\nespecially for large documentation structures.\n</code></pre>"},{"location":"project/archive/","title":"Archived Documentation","text":"<p>This section contains documentation that has been archived but is maintained for historical reference.</p>"},{"location":"project/archive/#overview","title":"Overview","text":"<p>As the Kube CINC Secure Scanner project evolves, some documentation becomes outdated or is replaced by newer content. Rather than deleting this content, we maintain it in the archive for reference purposes.</p>"},{"location":"project/archive/#archived-content","title":"Archived Content","text":"<p>The archive currently contains:</p> <ul> <li>ASCII Diagrams - Original ASCII diagram documentation that has been replaced by Mermaid diagrams</li> </ul>"},{"location":"project/archive/#usage-notes","title":"Usage Notes","text":"<p>Archived content is maintained for:</p> <ul> <li>Historical reference</li> <li>Understanding the evolution of the project</li> <li>Providing context for older references or discussions</li> </ul> <p>Please note that archived content may not reflect the current state of the project, and newer documentation should be consulted for up-to-date information.</p>"},{"location":"project/archive/ascii-diagrams/","title":"ASCII Text-Based Workflow and Architecture Diagrams","text":"<p>This document provides ASCII text-based diagrams for the key workflows and architectures in our project. These diagrams are intended to complement the Mermaid diagrams and provide a more accessible alternative that can be viewed directly in a terminal or without rendering.</p>"},{"location":"project/archive/ascii-diagrams/#minikube-architecture","title":"Minikube Architecture","text":"<pre><code>+-----------------------------------------------------------------------+\n|                                                                       |\n|                          MINIKUBE CLUSTER                             |\n|                                                                       |\n|  +-------------------------+        +-------------------------+        |\n|  |                         |        |                         |        |\n|  |      CONTROL NODE       |        |      WORKER NODE 1      |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |  kube-apiserver   |  |        |  | Target Containers |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  |       etcd        |  |        |  |   Scanner Pods    |  |        |\n|  |  |                   |  |        |  |                   |  |        |\n|  |  +-------------------+  |        |  +-------------------+  |        |\n|  |                         |        |                         |        |\n|  +-------------------------+        +-------------------------+        |\n|                                                                       |\n|                                                                       |\n|                           +-------------------------+                  |\n|                           |                         |                  |\n|                           |      WORKER NODE 2      |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |  Debug Containers |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           |  +-------------------+  |                  |\n|                           |  |                   |  |                  |\n|                           |  |   Sidecar Pods    |  |                  |\n|                           |  |                   |  |                  |\n|                           |  +-------------------+  |                  |\n|                           |                         |                  |\n|                           +-------------------------+                  |\n|                                                                       |\n+-----------------------------------------------------------------------+\n                        |                |                |\n                        |                |                |\n                        v                v                v\n          +------------------+  +------------------+  +------------------+\n          |                  |  |                  |  |                  |\n          |   CINC Profiles  |  | Service Accounts |  |     SAF CLI      |\n          |   (Compliance    |  |    and RBAC      |  |  (Reporting &amp;    |\n          |    Controls)     |  |  (Access Control)|  |  Thresholds)     |\n          |                  |  |                  |  |                  |\n          +------------------+  +------------------+  +------------------+\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#standard-container-scanning-workflow-approach-1","title":"Standard Container Scanning Workflow (Approach 1)","text":"<pre><code>              START STANDARD CONTAINER SCANNING\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|              STEP 1: SETUP &amp; PREPARATION                 |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |     Identify     |---------&gt;|  Create RBAC and   |    |\n|  |     Target       |          |  Service Account   |    |\n|  |     Container    |          |                    |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Generate Short-lived         |\n|                      |       Security Token               |\n|                      |                                    |\n|                      +------------------------------------+\n|                                          |               |\n|                                          v               |\n|                      +------------------------------------+\n|                      |                                    |\n|                      |       Create Restricted            |\n|                      |       Kubeconfig File              |\n|                      |                                    |\n|                      +------------------------------------+\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n+----------------------------------------------------------+\n|                                                          |\n|                STEP 2: SCANNING EXECUTION                |\n|                                                          |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Run CINC      |          |    Process with    |    |\n|  |    Auditor with  |&lt;---------|    SAF CLI &amp;       |    |\n|  |    k8s-container |          |    Check Threshold |    |\n|  |    Transport     |          |                    |    |\n|  +------------------+          +--------------------+    |\n|          |                                              |\n|          v                                              |\n|  +------------------+          +--------------------+    |\n|  |                  |          |                    |    |\n|  |    Generate      |---------&gt;|    Clean up RBAC   |    |\n|  |    Reports and   |          |    &amp; Service       |    |\n|  |    Validations   |          |    Account         |    |\n|  |                  |          |                    |    |\n|  +------------------+          +--------------------+    |\n|                                                          |\n+----------------------------------------------------------+\n                           |\n                           v\n                       SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#distroless-container-debug-container-approach-approach-2","title":"Distroless Container - Debug Container Approach (Approach 2)","text":"<pre><code>         START DEBUG CONTAINER APPROACH FOR DISTROLESS CONTAINERS\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 1: ATTACH DEBUG CONTAINER                    |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Identify        |-------&gt;|  Create Ephemeral       |     |\n|  |    Distroless      |        |  Debug Container with   |     |\n|  |    Target Container|        |  kubectl debug command  |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Deploy CINC Auditor in       |     |\n|                       |     Ephemeral Debug Container    |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|              STEP 2: PERFORM SCANNING THROUGH DEBUG CONTAINER  |\n|                                                                |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Chroot to       |-------&gt;|  Run CINC Auditor       |     |\n|  |    Target Container|        |  Against Target         |     |\n|  |    Filesystem      |        |  Container Root         |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|                       +----------------------------------+     |\n|                       |                                  |     |\n|                       |     Export Scan Results to       |     |\n|                       |     Host System                  |     |\n|                       |                                  |     |\n|                       +----------------------------------+     |\n|                                           |                    |\n|                                           v                    |\n|  +--------------------+        +-------------------------+     |\n|  |                    |        |                         |     |\n|  |    Process Results |-------&gt;|  Terminate Debug        |     |\n|  |    with SAF CLI    |        |  Container &amp; Clean Up   |     |\n|  |    Threshold Check |        |  Resources              |     |\n|  |                    |        |                         |     |\n|  +--------------------+        +-------------------------+     |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#sidecar-container-approach-approach-3","title":"Sidecar Container Approach (Approach 3)","text":""},{"location":"project/archive/ascii-diagrams/#ascii-diagram-legacy","title":"ASCII Diagram (Legacy)","text":"<pre><code>            START SIDECAR CONTAINER APPROACH FOR SCANNING\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 1: DEPLOY POD WITH SIDECAR                  |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Deploy Target    |------&gt;|   Deploy Scanner       |       |\n|  |   Container in     |       |   Sidecar Container    |       |\n|  |   Kubernetes Pod   |       |   in Same Pod          |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Enable Shared Process Namespace      ||\n|                      |   Between Containers in Pod            ||\n|                      |   (shareProcessNamespace: true)        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|               STEP 2: PERFORM SCAN USING SIDECAR               |\n|                                                                |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Sidecar Finds    |------&gt;|   Access Target        |       |\n|  |   Target Process   |       |   Filesystem via       |       |\n|  |   Using 'ps'       |       |   /proc/PID/root       |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Run CINC Auditor Against             ||\n|                      |   Target Container's Filesystem        ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                          |                     |\n|                                          v                     |\n|  +--------------------+       +------------------------+       |\n|  |                    |       |                        |       |\n|  |   Store Results    |------&gt;|   Process Results with |       |\n|  |   in Shared        |       |   SAF CLI &amp; Validate   |       |\n|  |   Volume           |       |   Against Threshold    |       |\n|  |                    |       |                        |       |\n|  +--------------------+       +------------------------+       |\n|                                          |                     |\n|                                          v                     |\n|                      +----------------------------------------+|\n|                      |                                        ||\n|                      |   Retrieve Results from Sidecar        ||\n|                      |   via kubectl cp or Volume Mount       ||\n|                      |                                        ||\n|                      +----------------------------------------+|\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                           SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#mermaid-diagram-wcag-compliant","title":"Mermaid Diagram (WCAG Compliant)","text":"<pre><code>flowchart TD\n    start([Start]) --&gt; step1\n\n    subgraph step1[\"STEP 1: DEPLOY POD WITH SIDECAR\"]\n        deploy_target[\"Deploy Target Container in Kubernetes Pod\"] --&gt; deploy_sidecar[\"Deploy Scanner Sidecar Container in Same Pod\"]\n        deploy_sidecar --&gt; shared_namespace[\"Enable Shared Process Namespace Between Containers\"]\n    end\n\n    step1 --&gt; step2\n\n    subgraph step2[\"STEP 2: PERFORM SCAN USING SIDECAR\"]\n        find_process[\"Sidecar Finds Target Process Using 'ps'\"] --&gt; access_fs[\"Access Target Filesystem via /proc/PID/root\"]\n        access_fs --&gt; run_cinc[\"Run CINC Auditor Against Target Container's Filesystem\"]\n        run_cinc --&gt; store_results[\"Store Results in Shared Volume\"]\n        store_results --&gt; process_results[\"Process Results with SAF CLI &amp; Validate Against Threshold\"]\n        process_results --&gt; retrieve_results[\"Retrieve Results from Sidecar via kubectl cp or Volume Mount\"]\n    end\n\n    step2 --&gt; complete([Scan Complete])\n\n    %% Applying WCAG-compliant styling\n    style start fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n    style complete fill:#0066CC,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF,font-weight:bold\n\n    %% Process styling\n    style deploy_target fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style deploy_sidecar fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style shared_namespace fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style find_process fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style access_fs fill:#505050,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style run_cinc fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style store_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style process_results fill:#217645,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n    style retrieve_results fill:#4C366B,stroke:#FFFFFF,stroke-width:2px,color:#FFFFFF\n\n    %% Step grouping styling\n    style step1 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000\n    style step2 fill:none,stroke:#DD6100,stroke-width:2px,color:#000000</code></pre>"},{"location":"project/archive/ascii-diagrams/#modified-transport-plugin-approach-approach-1-enterprise","title":"Modified Transport Plugin Approach (Approach 1 - Enterprise)","text":"<pre><code>            START MODIFIED TRANSPORT PLUGIN APPROACH\n                            |\n                            v\n+------------------------------------------------------------+\n|                                                            |\n|          STEP 1: CONTAINER DETECTION AND SETUP             |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Target         |-------&gt;|  Modified            |       |\n|  |  Container      |        |  train-k8s-container |       |\n|  |  Identification |        |  Plugin (Enhanced)   |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                       |                    |\n|                                       v                    |\n|                    +----------------------------------+    |\n|                    |                                  |    |\n|                    |  Auto-Detect if Container        |    |\n|                    |  is Distroless (No Shell)        |    |\n|                    |                                  |    |\n|                    +----------------------------------+    |\n|                             /           \\                  |\n|                            /             \\                 |\n|                           v               v                |\n| +-------------------------+   +---------------------------+|\n| |                         |   |                           ||\n| |  If Regular Container:  |   |  If Distroless Container: ||\n| |  Use Standard Direct    |   |  Automatically Use Debug  ||\n| |  Exec Connection        |   |  Container Fallback       ||\n| |                         |   |                           ||\n| +-------------------------+   +---------------------------+|\n|          |                                   |             |\n|          |                                   v             |\n|          |                    +---------------------------+|\n|          |                    |                           ||\n|          |                    |  Create Temporary Debug   ||\n|          |                    |  Container Automatically  ||\n|          |                    |                           ||\n|          |                    +---------------------------+|\n|          |                                   |             |\n+------------------------------------------------------------+\n                   |                          |\n                   v                          v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 2: SCANNING EXECUTION                    |\n|                                                            |\n|  +-----------------+        +----------------------+       |\n|  |                 |        |                      |       |\n|  |  Run CINC       |        |  Process Results     |       |\n|  |  Auditor Scan   |-------&gt;|  with SAF CLI &amp;      |       |\n|  |  Transparently  |        |  Check Thresholds    |       |\n|  |                 |        |                      |       |\n|  +-----------------+        +----------------------+       |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n+------------------------------------------------------------+\n|                                                            |\n|              STEP 3: CLEANUP (FOR DISTROLESS)              |\n|                                                            |\n|                    +---------------------------+           |\n|                    |                           |           |\n|                    |  If Debug Container Used: |           |\n|                    |  Terminate and Clean Up   |           |\n|                    |  Resources                |           |\n|                    |                           |           |\n|                    +---------------------------+           |\n|                                                            |\n+------------------------------------------------------------+\n                                |\n                                v\n                          SCAN COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#gitlab-ci-pipeline-with-services","title":"GitLab CI Pipeline with Services","text":"<pre><code>                    GITLAB CI PIPELINE WITH SERVICES\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: PIPELINE SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Start CINC Auditor  |        |\n|  |  Pipeline Begins  |         |  Scanner as a        |        |\n|  |                   |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Deploy Target Container in        |    |\n|                      |  Kubernetes Cluster                |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SECURITY SETUP                     |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Create RBAC &amp;    |--------&gt;|  Generate Short-lived|        |\n|  |  Service Account  |         |  Security Token      |        |\n|  |  in Cluster       |         |                      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Create Restricted kubeconfig      |    |\n|                      |  with Minimal Permissions          |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: SCANNING &amp; REPORTING               |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Execute Scan     |--------&gt;|  Process Results     |        |\n|  |  in Service       |         |  with SAF CLI in     |        |\n|  |  Container        |         |  Service Container   |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Copy Results from Service         |    |\n|                      |  to Pipeline &amp; Generate Reports    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Clean Up Resources in Kubernetes  |    |\n|                      |  (Pods, Service Accounts, RBAC)    |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#gitlab-ci-sidecar-approach","title":"GitLab CI Sidecar Approach","text":"<pre><code>                    GITLAB CI SIDECAR APPROACH\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 1: DEPLOYMENT                         |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  GitLab CI        |--------&gt;|  Deploy Pod with    |        |\n|  |  Pipeline Begins  |         |  Target Container   |        |\n|  |                   |         |  and Scanner Sidecar|        |\n|  |                   |         |  in Same Pod        |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Enable Shared Process Namespace   |    |\n|                      |  Between Target and Scanner        |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 2: SCANNING                           |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Sidecar Scanner  |--------&gt;|  Scan Target via    |        |\n|  |  Container Starts |         |  /proc Filesystem   |        |\n|  |                   |         |  Access Method      |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Store Results in Shared Volume   |    |\n|                      |  and Process with SAF CLI         |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n+----------------------------------------------------------------+\n|                                                                |\n|                    STAGE 3: RESULTS PROCESSING                 |\n|                                                                |\n|  +-------------------+         +----------------------+        |\n|  |                   |         |                      |        |\n|  |  Retrieve Scan    |--------&gt;|  Process Results    |        |\n|  |  Results from     |         |  and Generate       |        |\n|  |  Sidecar Container|         |  Reports            |        |\n|  |                   |         |                      |        |\n|  +-------------------+         +----------------------+        |\n|                                           |                    |\n|                                           v                    |\n|                      +------------------------------------+    |\n|                      |                                    |    |\n|                      |  Upload Results as Pipeline       |    |\n|                      |  Artifacts &amp; Clean Up Resources   |    |\n|                      |                                    |    |\n|                      +------------------------------------+    |\n|                                                                |\n+----------------------------------------------------------------+\n                                |\n                                v\n                         PIPELINE COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>                   GITHUB ACTIONS WORKFLOW\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster (Kind)         |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Install CINC Auditor &amp;              |    |\n|                    | train-k8s-container Plugin          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: TARGET DEPLOYMENT                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Target    |-------&gt;| Create RBAC &amp;          |        |\n| | Container in     |        | Service Account        |        |\n| | Kubernetes       |        | for Scanner            |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Short-lived Token &amp;        |    |\n|                    | Create Restricted kubeconfig       |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: SCAN &amp; REPORT                       |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Run CINC Auditor |-------&gt;| Process Results with   |        |\n| | Against Target   |        | SAF CLI &amp; Threshold    |        |\n| | Container        |        | Validation             |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Generate Reports, Upload as         |    |\n|                    | GitHub Artifacts &amp; Clean Up         |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#github-actions-sidecar-approach","title":"GitHub Actions Sidecar Approach","text":"<pre><code>                GITHUB ACTIONS SIDECAR APPROACH\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 1: ENVIRONMENT SETUP                   |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | GitHub Actions   |-------&gt;| Setup Kubernetes       |        |\n| | Workflow Start   |        | Cluster using Kind     |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Build Scanner Container Image      |    |\n|                    | with CINC Auditor &amp; SAF CLI        |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 2: DEPLOYMENT &amp; SCANNING               |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Deploy Pod with  |-------&gt;| Configure Shared       |        |\n| | Target Container |        | Process Namespace      |        |\n| | and Scanner      |        | Between Containers     |        |\n| | Sidecar          |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n|                    +-------------------------------------+    |\n|                    |                                     |    |\n|                    | Scanner Sidecar Automatically       |    |\n|                    | Finds &amp; Scans Target Container     |    |\n|                    | via /proc/PID/root Access          |    |\n|                    |                                     |    |\n|                    +-------------------------------------+    |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n+---------------------------------------------------------------+\n|                                                               |\n|                   STEP 3: RESULTS PROCESSING                  |\n|                                                               |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Wait for Scan    |-------&gt;| Retrieve Results       |        |\n| | Completion       |        | from Sidecar Container |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                         |                     |\n|                                         v                     |\n| +------------------+        +------------------------+        |\n| |                  |        |                        |        |\n| | Process Results  |-------&gt;| Upload Results         |        |\n| | with SAF CLI &amp;   |        | as GitHub Artifacts    |        |\n| | Generate Reports |        | &amp; Clean Up Resources   |        |\n| |                  |        |                        |        |\n| +------------------+        +------------------------+        |\n|                                                               |\n+---------------------------------------------------------------+\n                               |\n                               v\n                       WORKFLOW COMPLETE\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#end-to-end-security-architecture","title":"End-to-End Security Architecture","text":"<pre><code>                   SECURITY ARCHITECTURE\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                SECURITY PRINCIPLES                   |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Principle of   |-----&gt;|   Short-lived    |      |\n|  |   Least          |      |   Token          |      |\n|  |   Privilege      |      |   Generation     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Namespace      |&lt;----&gt;|   No Permanent   |      |\n|  |   Isolation      |      |   Elevated       |      |\n|  |                  |      |   Privileges     |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|               IMPLEMENTATION CONTROLS                |\n|                                                      |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  | Resource-specific|&lt;----&gt;|   Security       |      |\n|  | RBAC Controls    |      |   First Design   |      |\n|  | (Pod-specific)   |      |                  |      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|           |                        |                 |\n|           v                        v                 |\n|  +------------------+      +------------------+      |\n|  |                  |      |                  |      |\n|  |   Audit Trail    |&lt;----&gt;|   Automatic      |      |\n|  |   of Scan        |      |   Cleanup After  |      |\n|  |   Access         |      |   Scan Completion|      |\n|  |                  |      |                  |      |\n|  +------------------+      +------------------+      |\n|                                                      |\n+------------------------------------------------------+\n                            |\n                            v\n+------------------------------------------------------+\n|                                                      |\n|                COMPLIANCE VALIDATION                 |\n|                                                      |\n|  +--------------------------------------------------+|\n|  |                                                  ||\n|  |            Threshold-based Compliance            ||\n|  |            Validation with SAF CLI               ||\n|  |                                                  ||\n|  |       * Minimum compliance percentage            ||\n|  |       * Maximum critical/high failures           ||\n|  |       * Enforced in CI/CD pipelines              ||\n|  |                                                  ||\n|  +--------------------------------------------------+|\n|                                                      |\n+------------------------------------------------------+\n</code></pre>"},{"location":"project/archive/ascii-diagrams/#comparison-of-approaches","title":"Comparison of Approaches","text":"<pre><code>+---------------------------------------------------------------------+\n|                                                                     |\n|                        APPROACH COMPARISON                          |\n|                                                                     |\n+---------------------------------------------------------------------+\n|                                                                     |\n|                        KEY CHARACTERISTICS                          |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Works with all      |                |             |                |\n| Kubernetes versions |      No        |     No      |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| Works with          |                |             |                |\n| existing pods       |      Yes       |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| User experience     |    Seamless    |   Complex   |    Medium      |\n| complexity          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Implementation      |    Complex     |   Medium    |    Simple      |\n| difficulty          |                |             |                |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                      TECHNICAL REQUIREMENTS                         |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Special K8s         |                |             |                |\n| features needed     |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Ephemeral container |                |             |                |\n| support required    |      No        |     Yes     |      No        |\n+---------------------+----------------+-------------+----------------+\n| Can scan distroless |                |             |                |\n| containers          |      Yes       |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| CI/CD               |                |             |                |\n| integration ease    |    Simple      |   Complex   |    Medium      |\n+---------------------+----------------+-------------+----------------+\n\n+---------------------------------------------------------------------+\n|                                                                     |\n|                           IMPLEMENTATION STATUS                     |\n|                                                                     |\n+---------------------+----------------+-------------+----------------+\n| FEATURE             | APPROACH 1     | APPROACH 2  | APPROACH 3     |\n|                     | (Modified      | (Debug      | (Sidecar       |\n|                     |  Plugin)       | Container)  | Container)     |\n+---------------------+----------------+-------------+----------------+\n| Development         | In Progress    | Complete    | Complete       |\n| status              |                |             |                |\n+---------------------+----------------+-------------+----------------+\n| Security            |                |             |                |\n| footprint           |    Medium      |   High      |    Medium      |\n+---------------------+----------------+-------------+----------------+\n| Recommended         | Enterprise     | Advanced    | Universal      |\n| usage               | environments   | users       | compatibility  |\n+---------------------+----------------+-------------+----------------+\n| GitHub Actions      |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n| GitLab CI           |                |             |                |\n| example available   |      No        |     Yes     |      Yes       |\n+---------------------+----------------+-------------+----------------+\n</code></pre>"},{"location":"project/archive/inventory/","title":"Archive Directory Contents","text":"<p>This page provides an inventory of all archived documentation files.</p>"},{"location":"project/archive/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of archived documentation ascii-diagrams.md Original ASCII diagram documentation (replaced by Mermaid diagrams)"},{"location":"project/archive/inventory/#related-links","title":"Related Links","text":"<ul> <li>Project Documentation</li> <li>Current Diagrams</li> </ul>"},{"location":"rbac/","title":"RBAC Configuration Guide","text":"<p>This guide explains the Role-Based Access Control (RBAC) configuration used for secure container scanning with InSpec.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the RBAC Documentation Inventory.</p>"},{"location":"rbac/#overview","title":"Overview","text":"<p>The RBAC configuration consists of three key components:</p> <ol> <li>Role: Defines the permissions allowed for scanning containers</li> <li>ServiceAccount: The identity used to access the Kubernetes API</li> <li>RoleBinding: Links the Role to the ServiceAccount</li> </ol>"},{"location":"rbac/#basic-rbac-configuration","title":"Basic RBAC Configuration","text":""},{"location":"rbac/#role","title":"Role","text":"<p>The basic Role grants minimal permissions required for container scanning:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"inspec-target\"]  # Only allows exec into this pod\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"inspec-target\"]  # Only allows logs from this pod\n</code></pre> <p>Key security aspects:</p> <ul> <li><code>pods</code> access is limited to <code>get</code> and <code>list</code> (no create/modify/delete)</li> <li><code>pods/exec</code> is limited to <code>create</code> only for specific pods by name</li> <li><code>pods/log</code> is limited to <code>get</code> only for specific pods by name</li> </ul>"},{"location":"rbac/#rolebinding","title":"RoleBinding","text":"<p>The RoleBinding links the Role to the ServiceAccount:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-user\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"rbac/#dynamic-rbac-configurations","title":"Dynamic RBAC Configurations","text":"<p>For CI/CD environments, you can create dynamic RBAC configurations:</p>"},{"location":"rbac/#label-based-roles","title":"Label-Based Roles","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-dynamic-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n</code></pre> <p>Combined with a RoleBinding that includes a label selector in the subjects section.</p>"},{"location":"rbac/#temporary-roles","title":"Temporary Roles","text":"<p>For single-use scans, create temporary roles with a unique identifier:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-scan-role-${RUN_ID}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre>"},{"location":"rbac/#additional-rbac-strategies","title":"Additional RBAC Strategies","text":"<p>See the following documentation for more specialized RBAC configurations:</p> <ul> <li>Namespace-Isolated RBAC: Configure RBAC permissions isolated to specific namespaces</li> <li>Label-Based Access Control: Secures pods using label selectors</li> <li>CI/CD Dynamic Configuration: Demonstrated in the CI/CD examples</li> </ul>"},{"location":"rbac/#references","title":"References","text":"<ul> <li>Kubernetes RBAC Documentation</li> <li>RBAC Good Practices</li> </ul>"},{"location":"rbac/inventory/","title":"RBAC Configuration Guide","text":"<p>This guide explains the Role-Based Access Control (RBAC) configuration used for secure container scanning with InSpec.</p>"},{"location":"rbac/inventory/#overview","title":"Overview","text":"<p>The RBAC configuration consists of three key components:</p> <ol> <li>Role: Defines the permissions allowed for scanning containers</li> <li>ServiceAccount: The identity used to access the Kubernetes API</li> <li>RoleBinding: Links the Role to the ServiceAccount</li> </ol>"},{"location":"rbac/inventory/#basic-rbac-configuration","title":"Basic RBAC Configuration","text":""},{"location":"rbac/inventory/#role","title":"Role","text":"<p>The basic Role grants minimal permissions required for container scanning:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-container-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"inspec-target\"]  # Only allows exec into this pod\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"inspec-target\"]  # Only allows logs from this pod\n</code></pre> <p>Key security aspects:</p> <ul> <li><code>pods</code> access is limited to <code>get</code> and <code>list</code> (no create/modify/delete)</li> <li><code>pods/exec</code> is limited to <code>create</code> only for specific pods by name</li> <li><code>pods/log</code> is limited to <code>get</code> only for specific pods by name</li> </ul>"},{"location":"rbac/inventory/#rolebinding","title":"RoleBinding","text":"<p>The RoleBinding links the Role to the ServiceAccount:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: inspec-container-rolebinding\n  namespace: inspec-test\nsubjects:\n- kind: ServiceAccount\n  name: inspec-user\n  namespace: inspec-test\nroleRef:\n  kind: Role\n  name: inspec-container-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"rbac/inventory/#dynamic-rbac-configurations","title":"Dynamic RBAC Configurations","text":"<p>For CI/CD environments, you can create dynamic RBAC configurations:</p>"},{"location":"rbac/inventory/#label-based-roles","title":"Label-Based Roles","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-dynamic-role\n  namespace: inspec-test\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"create\"]\n  # No resourceNames - access controlled by label selector\n</code></pre> <p>Combined with a RoleBinding that includes a label selector in the subjects section.</p>"},{"location":"rbac/inventory/#temporary-roles","title":"Temporary Roles","text":"<p>For single-use scans, create temporary roles with a unique identifier:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-scan-role-${RUN_ID}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]\n</code></pre>"},{"location":"rbac/inventory/#additional-rbac-strategies","title":"Additional RBAC Strategies","text":"<p>See the following documentation for more specialized RBAC configurations:</p> <ul> <li>Namespace-Isolated RBAC: Configure RBAC permissions isolated to specific namespaces</li> <li>Label-Based Access Control: Secures pods using label selectors</li> <li>CI/CD Dynamic Configuration: Demonstrated in the CI/CD examples</li> </ul>"},{"location":"rbac/inventory/#references","title":"References","text":"<ul> <li>Kubernetes RBAC Documentation</li> <li>RBAC Good Practices</li> </ul>"},{"location":"rbac/label-based/","title":"Label-Based RBAC Configuration","text":"<p>This document describes how to implement label-based RBAC for more flexible container scanning access.</p>"},{"location":"rbac/label-based/#overview","title":"Overview","text":"<p>Label-based RBAC allows you to grant access to containers based on their labels rather than their names. This approach is more flexible in dynamic environments where pod names change frequently.</p>"},{"location":"rbac/label-based/#implementation","title":"Implementation","text":""},{"location":"rbac/label-based/#1-pod-labeling","title":"1. Pod Labeling","text":"<p>Label your target pods with a designated label:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\n  namespace: production\n  labels:\n    security-scan: \"enabled\"  # Label for scan selection\n</code></pre>"},{"location":"rbac/label-based/#2-role-configuration","title":"2. Role Configuration","text":"<p>Create a role that doesn't specify resourceNames, but instead relies on the label selector:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: inspec-label-role\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n</code></pre> <p>Note: This role allows access to all pods in the namespace. The limitation will come from how we use this role.</p>"},{"location":"rbac/label-based/#3-script-based-access-control","title":"3. Script-Based Access Control","text":"<p>Use a script to:</p> <ol> <li>Find pods with the target label</li> <li>Generate a temporary kubeconfig</li> <li>Run InSpec only against those pods</li> </ol> <pre><code>#!/bin/bash\nNAMESPACE=\"production\"\nLABEL_SELECTOR=\"security-scan=enabled\"\n\n# Find pods with the label\nPODS=$(kubectl get pods -n ${NAMESPACE} -l ${LABEL_SELECTOR} -o jsonpath='{.items[*].metadata.name}')\n\nif [ -z \"$PODS\" ]; then\n  echo \"No pods found with label ${LABEL_SELECTOR} in namespace ${NAMESPACE}\"\n  exit 1\nfi\n\n# Generate token for service account\nTOKEN=$(kubectl create token scanner-sa -n ${NAMESPACE})\n\n# Create kubeconfig\n# [... kubeconfig generation code ...]\n\n# For each pod, run the scan\nfor POD in $PODS; do\n  CONTAINER=$(kubectl get pod ${POD} -n ${NAMESPACE} -o jsonpath='{.spec.containers[0].name}')\n  echo \"Scanning ${NAMESPACE}/${POD}/${CONTAINER}\"\n  KUBECONFIG=./kubeconfig.yaml inspec exec ./profiles/container \\\n    -t k8s-container://${NAMESPACE}/${POD}/${CONTAINER}\ndone\n</code></pre>"},{"location":"rbac/label-based/#advanced-labelselector-with-subjectaccessreview","title":"Advanced: LabelSelector with SubjectAccessReview","text":"<p>For more robust access control, you can use a Kubernetes ValidatingWebhook to perform SubjectAccessReview based on pod labels. This approach requires additional components:</p> <ol> <li>A ValidatingWebhookConfiguration</li> <li>A webhook server that performs label checks</li> <li>Integration with your authentication system</li> </ol> <p>For a full implementation, see the advanced label RBAC section below.</p>"},{"location":"rbac/label-based/#security-considerations","title":"Security Considerations","text":"<p>Label-based RBAC is more permissive than name-based RBAC:</p> <ol> <li>If a pod is mislabeled, it becomes accessible</li> <li>Users can potentially scan any pod with the target label</li> <li>More complex to audit and trace</li> </ol> <p>Mitigations:</p> <ol> <li>Strict control over who can apply labels to pods</li> <li>Regular auditing of pod labels</li> <li>Isolated namespaces for different sensitivity levels</li> <li>Time-bound access tokens</li> </ol>"},{"location":"rbac/label-based/#example-yaml","title":"Example YAML","text":"<p>A complete example configuration is available in the repository under <code>kubernetes/templates/label-rbac.yaml</code>.</p>"},{"location":"security/","title":"Security Documentation","text":"<p>This document provides an overview of the security aspects of the Secure CINC Auditor Kubernetes Container Scanning platform.</p> <p>Directory Contents</p> <p>For a complete listing of all files in this section, see the Security Documentation Inventory.</p>"},{"location":"security/#security-framework","title":"Security Framework","text":"<p>The platform is built on a comprehensive security framework that covers:</p> <ol> <li>Security Principles: Core principles guiding our security design</li> <li>Risk Analysis: Assessment of security risks and mitigations</li> <li>Compliance: Alignment with security standards and frameworks</li> <li>Threat Model: Analysis of threats and mitigation strategies</li> <li>Recommendations: Best practices and implementation guidance</li> </ol>"},{"location":"security/#key-security-features","title":"Key Security Features","text":"Feature Description Benefit Temporary Tokens Service account tokens with 15-minute default lifespan Reduces risk of credential compromise Targeted RBAC Role-based access control scoped to specific pods Minimizes potential attack surface Label-based Restrictions RBAC rules that can target pods by labels Provides flexible, precise access control Time-limited Access Credentials valid only for the duration of a scan Prevents persistence of unnecessary access Non-privileged Scanning Scanning without requiring privileged containers Maintains container security boundaries"},{"location":"security/#security-approach-by-scanning-method","title":"Security Approach by Scanning Method","text":"<p>Each scanning approach implements security controls appropriate for its method, with varying risk profiles:</p> <ul> <li> <p> Kubernetes API Approach</p> <p>Risk Level: \ud83d\udfe2 Low</p> <ul> <li>Uses least-privilege RBAC with temporary service account tokens</li> <li>Requires access only to specific pods in target namespaces</li> <li>Creates time-limited credentials for each scan</li> <li>Most secure approach from a compliance perspective</li> <li>Uses standard vendor-supported interfaces</li> </ul> <p>Details</p> </li> <li> <p> Debug Container Approach</p> <p>Risk Level: \ud83d\udfe1 Medium</p> <ul> <li>Creates temporary debug containers for scanning</li> <li>Requires ephemeral container permissions</li> <li>Removes debug containers after scanning</li> <li>Implements appropriate RBAC controls for ephemeral container creation</li> <li>Temporarily breaks container isolation</li> </ul> <p>Details</p> </li> <li> <p> Sidecar Container Approach</p> <p>Risk Level: \ud83d\udd34 High</p> <ul> <li>Uses pod-level isolation with shared process namespace</li> <li>Requires no cluster-wide permissions</li> <li>Scans directly from within the pod</li> <li>Implements appropriate container security contexts</li> <li>Permanently breaks container isolation within pod</li> </ul> <p>Details</p> </li> </ul>"},{"location":"security/#risk-level-comparison","title":"Risk Level Comparison","text":"Approach Overall Risk Required Privileges Attack Surface Isolation Impact Compliance Burden NSA/CISA Alignment Kubernetes API \ud83d\udfe2 Low \ud83d\udfe2 Minimal \ud83d\udfe2 Small \ud83d\udfe2 None \ud83d\udfe2 Low \ud83d\udfe2 Strong (90%) Debug Container \ud83d\udfe1 Medium \ud83d\udfe1 Moderate \ud83d\udfe1 Medium \ud83d\udfe1 Temporary \ud83d\udfe1 Medium \ud83d\udfe1 Moderate (70%) Sidecar Container \ud83d\udd34 High \ud83d\udfe1 Moderate \ud83d\udd34 Larger \ud83d\udd34 Permanent \ud83d\udd34 High \ud83d\udfe0 Limited (50%) <p>See our NSA/CISA Hardening Guide Compliance documentation for detailed mappings.</p>"},{"location":"security/#security-documentation-structure","title":"Security Documentation Structure","text":"<p>Our security documentation is organized into focused sections:</p>"},{"location":"security/#security-principles","title":"Security Principles","text":"<p>Core security design principles including:</p> <ul> <li>Least Privilege</li> <li>Ephemeral Credentials</li> <li>Resource Isolation</li> <li>Secure Transport</li> </ul>"},{"location":"security/#risk-analysis","title":"Risk Analysis","text":"<p>Comprehensive risk assessment including:</p> <ul> <li>Risk Model</li> <li>Kubernetes API Approach Risks</li> <li>Debug Container Approach Risks</li> <li>Sidecar Container Approach Risks</li> <li>Risk Mitigations</li> </ul>"},{"location":"security/#compliance","title":"Compliance","text":"<p>Alignment with security frameworks including:</p> <ul> <li>DoD Instruction 8500.01</li> <li>DISA Container Platform SRG</li> <li>Kubernetes STIG</li> <li>CIS Kubernetes Benchmarks</li> <li>NSA/CISA Kubernetes Hardening Guide</li> <li>Approach Comparison</li> <li>Risk Documentation Requirements</li> </ul>"},{"location":"security/#threat-model","title":"Threat Model","text":"<p>Analysis of security threats including:</p> <ul> <li>Attack Vectors</li> <li>Threat Mitigations</li> <li>Token Exposure</li> <li>Lateral Movement</li> </ul>"},{"location":"security/#recommendations","title":"Recommendations","text":"<p>Best practices and guidance including:</p> <ul> <li>Enterprise Recommendations</li> <li>CI/CD Security</li> <li>Monitoring</li> <li>Network Security</li> </ul>"},{"location":"security/#related-topics","title":"Related Topics","text":"<ul> <li>RBAC Configuration - Role-Based Access Control configuration</li> <li>Service Accounts - Service account management</li> <li>Token Management - Secure token handling</li> </ul>"},{"location":"security/inventory/","title":"Security Documentation Directory Contents","text":"<p>Directory Purpose</p> <p>This directory contains comprehensive documentation about security aspects of the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"security/inventory/#overview-files","title":"Overview Files","text":"File Description index.md Overview of security documentation inventory.md Directory listing of all security documentation"},{"location":"security/inventory/#security-subdirectories","title":"Security Subdirectories","text":"Directory Description principles/ Core security principles documentation risk/ Security risk analysis documentation compliance/ Compliance frameworks alignment documentation threat-model/ Threat modeling and mitigation documentation recommendations/ Security best practices and recommendations"},{"location":"security/inventory/#security-principles-section","title":"Security Principles Section","text":"<p>The principles/ directory contains:</p> File Description index.md Overview of security principles least-privilege.md Details on least privilege implementation ephemeral-creds.md Details on ephemeral credentials resource-isolation.md Details on resource isolation secure-transport.md Details on secure transport inventory.md Directory listing"},{"location":"security/inventory/#risk-analysis-section","title":"Risk Analysis Section","text":"<p>The risk/ directory contains:</p> File Description index.md Overview of risk analysis model.md Risk model and methodology kubernetes-api.md Risks for Kubernetes API approach debug-container.md Risks for Debug Container approach sidecar-container.md Risks for Sidecar Container approach mitigations.md Risk mitigation strategies inventory.md Directory listing"},{"location":"security/inventory/#compliance-section","title":"Compliance Section","text":"<p>The compliance/ directory contains:</p> File Description index.md Overview of compliance documentation dod-8500-01.md DoD Instruction 8500.01 alignment disa-srg.md DISA Container Platform SRG alignment kubernetes-stig.md Kubernetes STIG alignment cis-benchmarks.md CIS Kubernetes Benchmarks alignment approach-comparison.md Compliance comparison of approaches risk-documentation.md Requirements for risk documentation inventory.md Directory listing"},{"location":"security/inventory/#threat-model-section","title":"Threat Model Section","text":"<p>The threat-model/ directory contains:</p> File Description index.md Overview of threat modeling attack-vectors.md Potential attack vectors threat-mitigations.md Threat mitigation strategies token-exposure.md Token exposure threats and mitigations lateral-movement.md Preventing lateral movement inventory.md Directory listing"},{"location":"security/inventory/#recommendations-section","title":"Recommendations Section","text":"<p>The recommendations/ directory contains:</p> File Description index.md Overview of security recommendations enterprise.md Enterprise security recommendations ci-cd.md CI/CD security recommendations monitoring.md Security monitoring recommendations network.md Network security recommendations inventory.md Directory listing"},{"location":"security/inventory/#related-topics","title":"Related Topics","text":"<ul> <li>RBAC Configuration - Role-Based Access Control configuration</li> <li>Service Accounts - Service account management</li> <li>Token Management - Secure token handling</li> <li>Kubernetes API Approach - Standard approach security details</li> <li>Debug Container Approach - Debug container approach security details</li> <li>Sidecar Container Approach - Sidecar approach security details</li> </ul>"},{"location":"security/compliance/","title":"Security Compliance Documentation","text":"<p>This document provides an overview of how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with key security standards and compliance frameworks.</p>"},{"location":"security/compliance/#compliance-framework-alignment","title":"Compliance Framework Alignment","text":"<p>Our container scanning approach has been designed to meet rigorous security requirements defined in several frameworks:</p> <ul> <li>DoD Instruction 8500.01 - \"Cybersecurity\"</li> <li>DISA Container Platform SRG - Security Requirements Guide</li> <li>Kubernetes STIG - Security Technical Implementation Guide</li> <li>CIS Kubernetes Benchmarks - Center for Internet Security</li> <li>NSA/CISA Kubernetes Hardening Guide - National Security Agency &amp; Cybersecurity and Infrastructure Security Agency</li> </ul>"},{"location":"security/compliance/#compliance-approach-comparison","title":"Compliance Approach Comparison","text":"<p>The Approach Comparison document provides a comprehensive analysis of how each scanning approach aligns with compliance requirements:</p> Compliance Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach DoD 8500.01 - Standard Interfaces \u2705 Uses standard K8s API \u26a0\ufe0f Uses debug features \u26a0\ufe0f Uses process namespace sharing SRG-APP-000142 - Least Privilege \u2705 Minimal permissions \u26a0\ufe0f Additional privileges \u26a0\ufe0f Process namespace privileges STIG V-242423 - RBAC Authorization \u2705 Clear RBAC implementation \u2705 RBAC with broader scope \u2705 RBAC with broader scope CIS 5.2.4 - Process Namespace Sharing \u2705 No process sharing needed \u2705 No process sharing with host \u274c Requires process namespace sharing NSA/CISA - Non-Root Containers \u2705 Supports non-root scanning \u2705 Supports non-root scanning \u2705 Supports non-root scanning NSA/CISA - Container-Specific OS \u26a0\ufe0f Limited distroless support \u2705 Full distroless support \u2705 Full distroless support NSA/CISA - Default Deny Network \u2705 Compatible with network isolation \u2705 Compatible with network isolation \u26a0\ufe0f Requires additional network controls"},{"location":"security/compliance/#risk-documentation-requirements","title":"Risk Documentation Requirements","text":"<p>For environments with strict compliance requirements, proper risk documentation is essential when using alternative approaches:</p> <ul> <li>Risk Documentation - Requirements and templates for:<ul> <li>Security control deviations</li> <li>Risk assessments</li> <li>Authorization requirements</li> <li>Enhanced monitoring</li> <li>Migration planning</li> </ul> </li> </ul> <p>NSA/CISA Compliance Note</p> <p>Organizations implementing container scanning in NSA/CISA-compliant environments should carefully consider the approach used:</p> <ul> <li>Kubernetes API Approach: Provides strongest alignment with NSA/CISA guidance (90%)</li> <li>Limited only by current distroless container support</li> <li>Will reach near 100% compliance when planned distroless support is completed</li> <li>Debug Container Approach: Moderate alignment (70%) - requires documenting debug container risks</li> <li>Sidecar Container Approach: Limited alignment (50%) - process namespace sharing explicitly contradicts NSA/CISA isolation requirements</li> </ul> <p>See our detailed NSA/CISA compliance mapping for specific control implementation details.</p>"},{"location":"security/compliance/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>To ensure compliance with security standards:</p> <ol> <li>RBAC Implementation:</li> <li>Implement minimal, pod-specific permissions</li> <li>Use time-bound tokens (15-30 minutes maximum)</li> <li> <p>Implement proper audit logging</p> </li> <li> <p>Authentication and Authorization:</p> </li> <li>Use service accounts rather than user credentials</li> <li>Implement proper token management</li> <li> <p>Validate all access through Kubernetes RBAC</p> </li> <li> <p>Monitoring and Auditing:</p> </li> <li>Enable comprehensive audit logging</li> <li>Monitor scanner activity</li> <li>Maintain records of scan results for compliance reporting</li> </ol>"},{"location":"security/compliance/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Principles - Core security principles</li> <li>Risk Analysis - Analysis of security risks and mitigations</li> <li>Threat Model - Analysis of threats and mitigations</li> <li>Security Recommendations - Best practices and guidelines</li> </ul>"},{"location":"security/compliance/approach-comparison/","title":"Compliance Approach Comparison","text":"<p>This document provides a comprehensive comparison of how each container scanning approach aligns with key compliance requirements and security frameworks.</p>"},{"location":"security/compliance/approach-comparison/#compliance-framework-comparison-matrix","title":"Compliance Framework Comparison Matrix","text":"<p>The following matrix compares the three scanning approaches against major compliance frameworks:</p> Compliance Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach DoD 8500.01 - Standard Interfaces \u2705 Uses standard K8s API \u26a0\ufe0f Uses debug features which may be considered non-standard \u26a0\ufe0f Uses process namespace sharing (non-standard access) SRG-APP-000142 - Least Privilege \u2705 Minimal, well-defined permissions \u26a0\ufe0f Requires additional privileges \u26a0\ufe0f Requires process namespace privileges STIG V-242423 - RBAC Authorization \u2705 Clear RBAC implementation \u2705 Can use RBAC, but with broader scope \u2705 Can use RBAC, but with broader scope STIG V-242432 - Namespace Isolation \u2705 Maintains isolation \u2705 Maintains namespace isolation \u26a0\ufe0f Breaks process isolation within pod STIG V-242433 - Restrict Privilege \u2705 Minimal privileges \u26a0\ufe0f Requires debug privileges \u26a0\ufe0f Requires process sharing privileges CIS 5.1.6 - Service Account Tokens \u2705 Tokens only used when needed \u2705 Tokens can be limited \u2705 Tokens can be limited CIS 5.2.1 - Privileged Containers \u2705 No privileged access needed \u26a0\ufe0f May need elevated privileges \u26a0\ufe0f Requires elevated privileges for process sharing CIS 5.2.4 - Process Namespace Sharing \u2705 No process sharing needed \u2705 No process sharing with host \u274c Explicitly requires process namespace sharing NSA/CISA - Non-Root Containers \u2705 Supports non-root scanning \u2705 Supports non-root scanning \u2705 Supports non-root scanning NSA/CISA - Container-Specific OS \u26a0\ufe0f Limited distroless support \u2705 Full distroless support \u2705 Full distroless support NSA/CISA - Default Deny Network \u2705 Compatible with network isolation \u2705 Compatible with network isolation \u26a0\ufe0f Requires additional network controls NSA/CISA - Short-lived Credentials \u2705 Uses ephemeral tokens \u2705 Uses ephemeral tokens \u2705 Uses ephemeral tokens Audit Trail Clarity \u2705 Clear, direct access audit \u26a0\ufe0f More complex audit trail \u26a0\ufe0f Complicated by shared process context Pod Modification Required \u2705 No modification needed \u26a0\ufe0f Temporary modification (ephemeral) \u274c Requires pod definition changes Compliance Documentation Burden \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udd34 High Enterprise Production Readiness \ud83d\udfe2 High \ud83d\udfe0 Medium \ud83d\udfe0 Medium"},{"location":"security/compliance/approach-comparison/#applicable-compliance-frameworks","title":"Applicable Compliance Frameworks","text":"<p>Our scanning approaches have been evaluated against the following compliance frameworks:</p> <ul> <li>DoD Instruction 8500.01 - Cybersecurity</li> <li>DISA Container Platform SRG - Security Requirements Guide</li> <li>Kubernetes STIG - Security Technical Implementation Guide</li> <li>CIS Kubernetes Benchmarks - Center for Internet Security</li> <li>NSA/CISA Kubernetes Hardening Guide - NSA &amp; CISA guidance</li> </ul>"},{"location":"security/compliance/approach-comparison/#nsacisa-kubernetes-hardening-guide-alignment","title":"NSA/CISA Kubernetes Hardening Guide Alignment","text":"<p>The NSA/CISA Kubernetes Hardening Guide (v1.2) provides specific recommendations for securing Kubernetes environments. Our scanning approaches have different levels of alignment with these recommendations:</p> Approach NSA/CISA Alignment Key Considerations Kubernetes API \ud83d\udfe2 Strong (90%) \u2022 Uses standard Kubernetes APIs\u2022 Follows least privilege principle\u2022 Requires minimal permissions\u2022 Limited distroless support (planned enhancement)\u2022 Note: Will achieve near 100% compliance when distroless support is completed Debug Container \ud83d\udfe0 Moderate (70%) \u2022 Excellent for distroless containers (NSA recommended)\u2022 Uses debug features (potential risk)\u2022 Ephemeral access reduces risk\u2022 Compatible with all security contexts Sidecar Container \ud83d\udfe0 Limited (50%) \u2022 Process namespace sharing contradicts isolation recommendations\u2022 Works with any Kubernetes version\u2022 Supports distroless containers\u2022 Requires pod definition changes\u2022 Warning: Explicitly violates NSA/CISA container isolation requirements <p>For detailed analysis of NSA/CISA alignment, see our comprehensive mapping.</p>"},{"location":"security/compliance/approach-comparison/#dod-850001-alignment","title":"DoD 8500.01 Alignment","text":"<p>DoD Instruction 8500.01 establishes the cybersecurity program to protect and defend DoD information and information technology.</p>"},{"location":"security/compliance/approach-comparison/#standard-interface-requirements","title":"Standard Interface Requirements","text":"<p>Section 4.b.(1)(b) of DoD 8500.01 emphasizes the need for standardized, managed interfaces:</p> Approach DoD 8500.01 Alignment Notes Kubernetes API \u2705 Full Alignment Uses standard, vendor-supported Kubernetes API interfaces Debug Container \u26a0\ufe0f Partial Alignment Uses debug features which may be considered non-standard Sidecar Container \u26a0\ufe0f Partial Alignment Process namespace sharing considered a non-standard access pattern"},{"location":"security/compliance/approach-comparison/#disa-container-platform-srg-alignment","title":"DISA Container Platform SRG Alignment","text":"<p>The DISA Container Platform SRG provides security requirements for container technologies deployed in DoD environments.</p>"},{"location":"security/compliance/approach-comparison/#srg-app-000142-least-privilege","title":"SRG-APP-000142 - Least Privilege","text":"<p>This control requires applications to implement least privilege:</p> Approach SRG-APP-000142 Alignment Notes Kubernetes API \u2705 Full Alignment Minimal, well-defined permissions Debug Container \u26a0\ufe0f Partial Alignment Requires additional privileges for ephemeral container creation Sidecar Container \u26a0\ufe0f Partial Alignment Requires process namespace sharing privileges"},{"location":"security/compliance/approach-comparison/#srg-app-000133-vendor-supported-interfaces","title":"SRG-APP-000133 - Vendor-supported Interfaces","text":"<p>This control requires applications to use vendor-supported interfaces for accessing resources:</p> Approach SRG-APP-000133 Alignment Notes Kubernetes API \u2705 Full Alignment Uses standard Kubernetes API interfaces Debug Container \u26a0\ufe0f Partial Alignment Uses ephemeral container feature which is beta in some K8s versions Sidecar Container \u26a0\ufe0f Partial Alignment Uses process namespace sharing which is not intended for cross-container access"},{"location":"security/compliance/approach-comparison/#kubernetes-stig-alignment","title":"Kubernetes STIG Alignment","text":"<p>The Kubernetes STIG provides detailed security requirements for Kubernetes deployments in DoD environments.</p>"},{"location":"security/compliance/approach-comparison/#v-242423-rbac-authorization","title":"V-242423 - RBAC Authorization","text":"<p>This control requires Role-Based Access Control (RBAC) for authorization:</p> Approach V-242423 Alignment Notes Kubernetes API \u2705 Full Alignment Clear RBAC implementation with minimal scope Debug Container \u2705 Full Alignment Can use RBAC, though with broader scope Sidecar Container \u2705 Full Alignment Can use RBAC, though with broader scope"},{"location":"security/compliance/approach-comparison/#v-242432-namespace-isolation","title":"V-242432 - Namespace Isolation","text":"<p>This control requires namespaces to isolate resources:</p> Approach V-242432 Alignment Notes Kubernetes API \u2705 Full Alignment Maintains complete namespace isolation Debug Container \u2705 Full Alignment Maintains namespace isolation Sidecar Container \u26a0\ufe0f Partial Alignment Breaks process isolation within pod"},{"location":"security/compliance/approach-comparison/#v-242433-restrict-privilege-escalation","title":"V-242433 - Restrict Privilege Escalation","text":"<p>This control requires Pod Security Policies to restrict privilege escalation:</p> Approach V-242433 Alignment Notes Kubernetes API \u2705 Full Alignment Minimal privileges required Debug Container \u26a0\ufe0f Partial Alignment Requires debug privileges Sidecar Container \u26a0\ufe0f Partial Alignment Requires process sharing privileges"},{"location":"security/compliance/approach-comparison/#cis-kubernetes-benchmark-alignment","title":"CIS Kubernetes Benchmark Alignment","text":"<p>The CIS Kubernetes Benchmark provides industry-standard best practices for securing Kubernetes deployments.</p>"},{"location":"security/compliance/approach-comparison/#cis-524-process-namespace-sharing","title":"CIS 5.2.4 - Process Namespace Sharing","text":"<p>This control minimizes the admission of containers wishing to share the host process ID namespace:</p> Approach CIS 5.2.4 Alignment Notes Kubernetes API \u2705 Full Alignment No process namespace sharing Debug Container \u2705 Full Alignment No sharing with host namespace Sidecar Container \u274c Non-Alignment Explicitly requires process namespace sharing"},{"location":"security/compliance/approach-comparison/#cis-521-privileged-containers","title":"CIS 5.2.1 - Privileged Containers","text":"<p>This control minimizes the admission of privileged containers:</p> Approach CIS 5.2.1 Alignment Notes Kubernetes API \u2705 Full Alignment No privileged access needed Debug Container \u26a0\ufe0f Partial Alignment May need elevated privileges Sidecar Container \u26a0\ufe0f Partial Alignment Requires elevated privileges for process sharing"},{"location":"security/compliance/approach-comparison/#compliance-documentation-requirements","title":"Compliance Documentation Requirements","text":"<p>The compliance documentation burden varies significantly between approaches:</p> Approach Documentation Burden Requirements Kubernetes API \ud83d\udfe2 Low Standard RBAC and security documentation Debug Container \ud83d\udfe0 Medium Additional documentation for ephemeral container usage, RBAC, and security implications Sidecar Container \ud83d\udd34 High Extensive documentation for process namespace sharing, RBAC exceptions, container security, and formal risk acceptance"},{"location":"security/compliance/approach-comparison/#compliance-based-selection-framework","title":"Compliance-Based Selection Framework","text":"<p>Based on this compliance analysis, the following selection framework is recommended:</p>"},{"location":"security/compliance/approach-comparison/#for-dod-and-high-security-environments","title":"For DoD and High-Security Environments","text":"<p>Primary Recommendation: Kubernetes API Approach</p> <p>Rationale:</p> <ul> <li>Uses standard, vendor-supported interfaces (DoD 8500.01 requirement)</li> <li>Implements least privilege access (SRG-APP-000142, V-242433)</li> <li>Utilizes proper RBAC (V-242423)</li> <li>Avoids unnecessary pod modifications</li> <li>Generates appropriate audit trails (V-242377)</li> <li>Lowest compliance documentation burden</li> </ul> <p>Interim Solution for Distroless Containers:</p> <ul> <li>If on Kubernetes 1.16+: Debug Container Approach (with documented risk acceptance)</li> <li>If universal compatibility needed: Sidecar Container Approach with strict controls (with formal risk acceptance documentation)</li> </ul>"},{"location":"security/compliance/approach-comparison/#for-environments-with-specific-requirements","title":"For Environments with Specific Requirements","text":"Environment Compliance Focus Recommended Approach DoD Production DoD 8500.01, STIG Kubernetes API Approach Government NIST, FISMA Kubernetes API Approach Financial PCI DSS Kubernetes API Approach (preferred) or Sidecar with risk documentation Healthcare HIPAA Kubernetes API Approach (preferred) or Sidecar with risk documentation"},{"location":"security/compliance/approach-comparison/#risk-acceptance-requirements","title":"Risk Acceptance Requirements","text":"<p>When compliance gaps exist, formal risk acceptance may be required:</p> Approach Risk Acceptance Requirements Kubernetes API Generally no formal risk acceptance required Debug Container Document deviation from standard interface requirements, temporary isolation breaking Sidecar Container Formal security risk acceptance document required, signed by security authority"},{"location":"security/compliance/approach-comparison/#related-documentation","title":"Related Documentation","text":"<ul> <li>DoD 8500.01 Alignment - Detailed alignment with DoD requirements</li> <li>DISA SRG Alignment - Detailed alignment with DISA SRG</li> <li>Kubernetes STIG Alignment - Detailed alignment with Kubernetes STIG</li> <li>CIS Benchmarks Alignment - Detailed alignment with CIS Benchmarks</li> <li>Risk Documentation - Requirements for documenting compliance risks</li> </ul>"},{"location":"security/compliance/cis-benchmarks/","title":"CIS Kubernetes Benchmarks Alignment","text":"<p>This document describes how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with the Center for Internet Security (CIS) Kubernetes Benchmarks.</p>"},{"location":"security/compliance/cis-benchmarks/#overview","title":"Overview","text":"<p>The CIS Kubernetes Benchmarks provide prescriptive guidance for establishing a secure configuration posture for Kubernetes. This document outlines how our container scanning approaches align with these benchmarks.</p>"},{"location":"security/compliance/cis-benchmarks/#benchmark-alignment","title":"Benchmark Alignment","text":"Benchmark Section Title Requirement Summary Alignment Notes 1.2 API Server Configure secure API server settings \u2705 High Our scanning approaches respect secure API configurations 4.2 Authentication Implement strong authentication \u2705 High Service account tokens use short-lived credentials 5.1 RBAC Configure proper authorization \u2705 High Implementations use least-privilege RBAC 5.2 Service Accounts Manage service accounts securely \u2705 High Limited service account permissions 5.7 Network Policies Restrict pod communications \u2705 High Communications use TLS encryption"},{"location":"security/compliance/cis-benchmarks/#scanning-approach-compliance","title":"Scanning Approach Compliance","text":""},{"location":"security/compliance/cis-benchmarks/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach provides the highest level of alignment with CIS Kubernetes Benchmarks:</p> <ul> <li>Uses Kubernetes native service accounts with tight RBAC controls</li> <li>Prevents privilege escalation within containers</li> <li>Establishes proper network security with TLS encryption</li> <li>Implements proper logging and monitoring</li> </ul>"},{"location":"security/compliance/cis-benchmarks/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach has moderate alignment with CIS Kubernetes Benchmarks:</p> <ul> <li>Uses ephemeral debug containers with limited lifespans</li> <li>Implements proper RBAC controls for debug container creation</li> <li>Respects container security contexts</li> </ul>"},{"location":"security/compliance/cis-benchmarks/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach has moderate alignment with CIS Kubernetes Benchmarks:</p> <ul> <li>Uses shared process namespace with proper isolation</li> <li>Implements appropriate container security contexts</li> <li>Avoids privileged operations when possible</li> </ul>"},{"location":"security/compliance/cis-benchmarks/#implementation-recommendations","title":"Implementation Recommendations","text":"<p>For optimal alignment with CIS Kubernetes Benchmarks, we recommend:</p> <ol> <li>Using the Kubernetes API Approach when possible</li> <li>Implementing the least-privilege RBAC controls provided</li> <li>Ensuring proper audit logging is enabled</li> <li>Following the security recommendations in our Enterprise Recommendations guide</li> </ol>"},{"location":"security/compliance/cis-benchmarks/#related-documentation","title":"Related Documentation","text":"<ul> <li>Approach Comparison - Security framework comparison</li> <li>Risk Documentation - Documentation requirements</li> <li>Kubernetes STIG - DISA STIG alignment information</li> </ul>"},{"location":"security/compliance/disa-srg/","title":"DISA Container Platform Security Requirements Guide (SRG) Alignment","text":"<p>This document describes how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with the Defense Information Systems Agency (DISA) Container Platform Security Requirements Guide (SRG).</p>"},{"location":"security/compliance/disa-srg/#overview","title":"Overview","text":"<p>The DISA Container Platform SRG provides security requirements for container platforms used in DoD environments. This document outlines how our container scanning approaches align with these requirements.</p>"},{"location":"security/compliance/disa-srg/#srg-requirement-alignment","title":"SRG Requirement Alignment","text":"Vulnerability ID Title Requirement Summary Alignment Notes V-233246 Authentication Container platforms must use DoD PKI established certificate authorities \u2705 High Service account tokens with short lifespans V-233253 Authorization Container platforms must enforce least privilege access \u2705 High Least-privilege RBAC implementation V-233262 Isolation Container platforms must implement resource isolation \u2705 High Proper container isolation and boundaries V-233273 Encryption Container platforms must protect data-in-transit \u2705 High TLS encryption for all communications V-233240 Audit Logging Container platforms must implement DoD-required audit logging \u2705 High All scanning operations are logged"},{"location":"security/compliance/disa-srg/#scanning-approach-compliance","title":"Scanning Approach Compliance","text":""},{"location":"security/compliance/disa-srg/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach provides the highest level of alignment with DISA Container Platform SRG requirements:</p> <ul> <li>Implements DoD-compliant authentication and authorization</li> <li>Uses Kubernetes native security controls</li> <li>Maintains proper isolation and least privilege</li> <li>Provides comprehensive audit logging</li> </ul>"},{"location":"security/compliance/disa-srg/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach has moderate alignment with DISA Container Platform SRG requirements:</p> <ul> <li>Uses time-limited debug containers</li> <li>Implements appropriate RBAC controls</li> <li>Maintains isolation through container boundaries</li> </ul>"},{"location":"security/compliance/disa-srg/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach has moderate alignment with DISA Container Platform SRG requirements:</p> <ul> <li>Uses pod-level isolation with shared process namespace</li> <li>Implements appropriate container security contexts</li> <li>Provides limited audit logging capabilities</li> </ul>"},{"location":"security/compliance/disa-srg/#implementation-recommendations","title":"Implementation Recommendations","text":"<p>For optimal alignment with DISA Container Platform SRG requirements in DoD environments, we recommend:</p> <ol> <li>Using the Kubernetes API Approach when possible</li> <li>Implementing the least-privilege RBAC controls provided</li> <li>Ensuring comprehensive audit logging</li> <li>Following the security hardening recommendations in our Enterprise Recommendations guide</li> </ol>"},{"location":"security/compliance/disa-srg/#related-documentation","title":"Related Documentation","text":"<ul> <li>DoD Instruction 8500.01 - Alignment with DoD Instructions</li> <li>Kubernetes STIG - STIG alignment information</li> <li>Approach Comparison - Security framework comparison</li> </ul>"},{"location":"security/compliance/dod-8500-01/","title":"DoD Instruction 8500.01 Alignment","text":"<p>This document describes how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with the Department of Defense Instruction 8500.01 - Cybersecurity.</p>"},{"location":"security/compliance/dod-8500-01/#overview","title":"Overview","text":"<p>DoD Instruction 8500.01 establishes the cybersecurity policy for protecting DoD information and systems. This document outlines how our container scanning approaches align with these policies.</p>"},{"location":"security/compliance/dod-8500-01/#policy-alignment","title":"Policy Alignment","text":"Policy Section Title Requirement Summary Alignment Notes 4.1 Risk Management Implement risk management processes \u2705 High Comprehensive risk assessment and documentation 4.2 Identity Management Implement identity management \u2705 High Service account tokens with proper authentication 4.3 Access Control Implement least privilege \u2705 High Least-privilege RBAC implementation 4.4 Information Protection Protect data at rest and in transit \u2705 High Secure handling of scan results and findings 4.5 Configuration Management Manage secure configurations \u2705 High Secure default configurations"},{"location":"security/compliance/dod-8500-01/#cybersecurity-controls-implementation","title":"Cybersecurity Controls Implementation","text":""},{"location":"security/compliance/dod-8500-01/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach provides the highest level of alignment with DoD 8500.01:</p> <ul> <li>Uses DoD-compliant authentication and authorization</li> <li>Implements proper separation of duties</li> <li>Maintains least privilege access controls</li> <li>Provides comprehensive audit logging</li> <li>Supports secure configurations by default</li> </ul>"},{"location":"security/compliance/dod-8500-01/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach has moderate alignment with DoD 8500.01:</p> <ul> <li>Uses ephemeral debug containers with limited lifespans</li> <li>Implements appropriate RBAC controls</li> <li>Provides limited audit logging capabilities</li> </ul>"},{"location":"security/compliance/dod-8500-01/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach has moderate alignment with DoD 8500.01:</p> <ul> <li>Uses pod-level isolation with shared process namespace</li> <li>Implements appropriate container security contexts</li> <li>Supports deployment-time security controls</li> </ul>"},{"location":"security/compliance/dod-8500-01/#implementation-recommendations-for-dod-environments","title":"Implementation Recommendations for DoD Environments","text":"<p>For optimal alignment with DoD 8500.01 in DoD environments, we recommend:</p> <ol> <li>Using the Kubernetes API Approach as the primary scanning method</li> <li>Implementing the comprehensive RBAC controls provided</li> <li>Following the security hardening recommendations</li> <li>Implementing all audit logging capabilities</li> <li>Following the security guidelines in our Enterprise Recommendations guide</li> </ol>"},{"location":"security/compliance/dod-8500-01/#related-documentation","title":"Related Documentation","text":"<ul> <li>DISA Container Platform SRG - DISA SRG alignment</li> <li>Kubernetes STIG - STIG alignment information</li> <li>Approach Comparison - Security framework comparison</li> <li>Risk Documentation - Documentation requirements</li> </ul>"},{"location":"security/compliance/inventory/","title":"Security Compliance Directory","text":"<p>This directory contains documentation on the compliance framework alignment for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/compliance/inventory/#available-documents","title":"Available Documents","text":"Document Description Index Overview of compliance framework alignment Approach Comparison Comparison of scanning approaches against compliance frameworks Risk Documentation Requirements for documenting compliance risks DoD 8500.01 Alignment Alignment with DoD Instruction 8500.01 DISA SRG Alignment Alignment with DISA Container Platform SRG Kubernetes STIG Alignment Alignment with Kubernetes STIG CIS Benchmarks Alignment Alignment with CIS Kubernetes Benchmarks NSA/CISA Hardening Guide Alignment with NSA/CISA Kubernetes Hardening Guide"},{"location":"security/compliance/inventory/#related-directories","title":"Related Directories","text":"Directory Description Security Principles Core security principles Risk Analysis Security risk assessment Threat Model Security threat modeling Recommendations Security best practices and recommendations"},{"location":"security/compliance/kubernetes-stig/","title":"DISA Kubernetes Security Technical Implementation Guide (STIG) Alignment","text":"<p>This document describes how the Secure CINC Auditor Kubernetes Container Scanning solution aligns with the Defense Information Systems Agency (DISA) Kubernetes Security Technical Implementation Guide (STIG).</p>"},{"location":"security/compliance/kubernetes-stig/#overview","title":"Overview","text":"<p>The DISA Kubernetes STIG provides security requirements for Kubernetes deployments in DoD environments. This document outlines how our container scanning approaches align with these requirements.</p>"},{"location":"security/compliance/kubernetes-stig/#stig-alignment","title":"STIG Alignment","text":"Vulnerability ID Title Requirement Summary Alignment Notes V-242407 Authentication The Kubernetes API Server must disable anonymous authentication \u2705 High Service account tokens with proper authentication V-242446 Authorization The Kubernetes API Server must enable Node,RBAC as the authorization mode \u2705 High Least-privilege RBAC implementation V-242420 Pod Security User-managed resources must be created in dedicated namespaces \u2705 High Proper namespace and container isolation V-242408 Encryption The Kubernetes etcd must use TLS to protect data-in-transit \u2705 High TLS encryption for all communications V-242435 Audit Logging Kubernetes API Server must generate audit records \u2705 High Comprehensive logging of operations"},{"location":"security/compliance/kubernetes-stig/#scanning-approach-compliance","title":"Scanning Approach Compliance","text":""},{"location":"security/compliance/kubernetes-stig/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>The Kubernetes API Approach provides the highest level of alignment with Kubernetes STIG requirements:</p> <ul> <li>Uses Kubernetes native authentication and authorization</li> <li>Implements proper RBAC controls with least privilege</li> <li>Maintains container security boundaries</li> <li>Provides comprehensive audit logging</li> </ul>"},{"location":"security/compliance/kubernetes-stig/#debug-container-approach","title":"Debug Container Approach","text":"<p>The Debug Container Approach has moderate alignment with Kubernetes STIG requirements:</p> <ul> <li>Uses ephemeral debug containers with limited lifespans</li> <li>Implements appropriate RBAC controls</li> <li>Provides container isolation</li> </ul>"},{"location":"security/compliance/kubernetes-stig/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>The Sidecar Container Approach has moderate alignment with Kubernetes STIG requirements:</p> <ul> <li>Uses pod-level isolation with shared process namespace</li> <li>Implements appropriate container security contexts</li> <li>Supports deployment-time security controls</li> </ul>"},{"location":"security/compliance/kubernetes-stig/#implementation-recommendations-for-stig-compliance","title":"Implementation Recommendations for STIG Compliance","text":"<p>For optimal alignment with Kubernetes STIG requirements, we recommend:</p> <ol> <li>Using the Kubernetes API Approach as the primary scanning method</li> <li>Implementing the comprehensive RBAC controls provided</li> <li>Following the security hardening recommendations</li> <li>Implementing all audit logging capabilities</li> <li>Following the security guidelines in our Enterprise Recommendations guide</li> </ol>"},{"location":"security/compliance/kubernetes-stig/#testing-for-stig-compliance","title":"Testing for STIG Compliance","text":"<p>Our platform includes testing tools to validate STIG compliance:</p> <ol> <li>RBAC validation tools to ensure proper permissions</li> <li>Security context validation</li> <li>Network security validation</li> </ol>"},{"location":"security/compliance/kubernetes-stig/#related-documentation","title":"Related Documentation","text":"<ul> <li>DoD Instruction 8500.01 - DoD policy alignment</li> <li>DISA Container Platform SRG - DISA SRG alignment</li> <li>Approach Comparison - Security framework comparison</li> <li>Risk Documentation - Documentation requirements</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/","title":"NSA/CISA Kubernetes Hardening Guide","text":"<p>This document outlines how our Secure CINC Auditor Kubernetes Container Scanning solution aligns with the guidance provided in the NSA and CISA Kubernetes Hardening Guide.</p>"},{"location":"security/compliance/nsa-cisa-hardening/#overview-of-the-nsacisa-kubernetes-hardening-guide","title":"Overview of the NSA/CISA Kubernetes Hardening Guide","text":"<p>The NSA/CISA Kubernetes Hardening Guide (v1.2, August 2022) provides recommendations to enhance the security posture of Kubernetes clusters. The guide offers critical actions that administrators should take to secure container environments, focusing on areas such as:</p> <ul> <li>Kubernetes pod security</li> <li>Network separation and hardening</li> <li>Authentication and authorization</li> <li>Audit logging and threat detection</li> <li>Upgrading and application security</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/#guide-details","title":"Guide Details","text":"<ul> <li>Official PDF Guide: Kubernetes Hardening Guide v1.2</li> <li>Release Date: August 29, 2022 (v1.2)</li> <li>Issuing Agencies: National Security Agency (NSA) and Cybersecurity and Infrastructure Security Agency (CISA)</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/#implementation-status","title":"Implementation Status","text":"<p>The following table provides a high-level overview of our alignment with the key recommendations from the NSA/CISA Kubernetes Hardening Guide:</p> Category Recommendation Status Implementation Pod Security Use Pod Security Standards \ud83d\udfe1 In Progress Our scanner identifies pod security violations Pod Security Use container-specific OS \u2705 Implemented We support scanning of distroless containers Network Separation Network segmentation \u2705 Implemented Our scanner uses namespace-specific RBAC Authentication Strong authentication \u2705 Implemented We use ephemeral, time-limited tokens Authorization RBAC implementation \u2705 Implemented We implement least privilege access via RBAC Logging &amp; Monitoring Enable audit logging \ud83d\udfe1 In Progress We provide scanning but lack comprehensive monitoring Threat Detection Scan for vulnerabilities \ud83d\udfe1 In Progress CINC scanning with planned Anchore Grype integration"},{"location":"security/compliance/nsa-cisa-hardening/#reference-implementation","title":"Reference Implementation","text":"<p>For a practical implementation of NSA/CISA hardening guidance, we reference the KubeArmor implementation as a complementary solution.</p>"},{"location":"security/compliance/nsa-cisa-hardening/#detailed-guidance-mapping","title":"Detailed Guidance Mapping","text":""},{"location":"security/compliance/nsa-cisa-hardening/#1-pod-security-controls","title":"1. Pod Security Controls","text":"<p>Our implementation aligns with these NSA/CISA requirements through:</p> NSA/CISA Recommendation Implementation Approach Support Use non-root users in containers \u2022 Security context settings enforce non-root execution\u2022 Example in <code>sidecar-scanner-pod.yaml</code> sets <code>runAsNonRoot: true</code> and <code>runAsUser: 1000</code>\u2022 InSpec control <code>container-3.1</code> verifies containers aren't running as root \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Implement immutable filesystems \u2022 ReadOnlyRootFilesystem enforcement with <code>readOnlyRootFilesystem: true</code>\u2022 Limited write access to specific volumes only\u2022 InSpec checks for unauthorized filesystem modifications \u2705 K8s API\u26a0\ufe0f Debug Container\u26a0\ufe0f Sidecar Use container-specific OS (distroless) \u2022 Support for distroless containers through our Debug Container approach\u2022 Minimal attack surface with purpose-built containers\u2022 Native scanning capability for distroless environments \u26a0\ufe0f K8s API (Planned)\u2705 Debug Container\u2705 Sidecar Use trusted, digitally signed images \u2022 CINC scanner container images are digitally signed\u2022 InSpec profiles can verify image signatures\u2022 Plans to integrate with Anchore for signature verification \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Minimize container privileges \u2022 Capability dropping in security contexts with <code>capabilities.drop: [\"ALL\"]</code>\u2022 No privileged containers used in scanning\u2022 Custom security profiles to limit syscalls \u2705 K8s API\u26a0\ufe0f Debug Container\u274c Sidecar <p>Example configuration from our security documentation:</p> <pre><code>securityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop: [\"ALL\"]\n</code></pre>"},{"location":"security/compliance/nsa-cisa-hardening/#2-network-separation-and-hardening","title":"2. Network Separation and Hardening","text":"<p>Our implementation aligns with these NSA/CISA requirements through:</p> NSA/CISA Recommendation Implementation Approach Support Default deny network policy \u2022 NetworkPolicy examples for scanner isolation\u2022 Default-deny templates with specific allowances\u2022 Namespace isolation for scanning components \u2705 K8s API\u2705 Debug Container\u26a0\ufe0f Sidecar Namespace isolation \u2022 Dedicated namespaces for scanning operations\u2022 Network segmentation between scanning and target namespaces\u2022 Cross-namespace RBAC controls \u2705 K8s API\u2705 Debug Container\u26a0\ufe0f Sidecar Use TLS for communications \u2022 TLS enforcement for all API server communications\u2022 Certificate validation in Kubernetes connections\u2022 Secure transport for scanning results \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Restrict external service access \u2022 Egress filtering to restrict scanner outbound connections\u2022 No external dependencies during scanning operations\u2022 Controlled access to Kubernetes API only \u2705 K8s API\u26a0\ufe0f Debug Container\u26a0\ufe0f Sidecar <p>Example NetworkPolicy from our documentation:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-isolation\nspec:\n  podSelector:\n    matchLabels:\n      app: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: scanning-operator\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n    ports:\n    - protocol: TCP\n      port: 443  # Kubernetes API\n</code></pre>"},{"location":"security/compliance/nsa-cisa-hardening/#3-authentication-and-authorization","title":"3. Authentication and Authorization","text":"<p>Our implementation aligns with these NSA/CISA requirements through:</p> NSA/CISA Recommendation Implementation Approach Support Use RBAC for access control \u2022 Fine-grained RBAC with minimal permissions\u2022 Resource name restrictions to limit pod access\u2022 Pod-specific RBAC in <code>inspec-rbac.yaml</code> \u2705 K8s API\u26a0\ufe0f Debug Container\u26a0\ufe0f Sidecar Restrict anonymous access \u2022 No anonymous authentication allowed\u2022 Explicit service account for each scanner\u2022 Authentication required for all operations \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Use short-lived credentials \u2022 15-minute token lifetimes (default)\u2022 Automatic token expiration\u2022 Just-in-time credential issuance \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Implement least privilege \u2022 Minimal set of permissions for scanning\u2022 Label-based RBAC for targeted access\u2022 No cluster-wide permissions \u2705 K8s API\u26a0\ufe0f Debug Container\u274c Sidecar <p>Example RBAC configuration from our system:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-specific-scanner\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/exec\"]\n  verbs: [\"get\", \"list\", \"create\"]\n  resourceNames: [\"pod-to-scan\"]  # Restricted to specific pod\n</code></pre>"},{"location":"security/compliance/nsa-cisa-hardening/#4-logging-and-monitoring","title":"4. Logging and Monitoring","text":"<p>Our implementation aligns with these NSA/CISA requirements through:</p> NSA/CISA Recommendation Implementation Approach Support Enable audit logging \u2022 Comprehensive scan result logging\u2022 Integration with SAF CLI for result analysis\u2022 Compliance report generation \u2705 K8s API\u26a0\ufe0f Debug Container\u26a0\ufe0f Sidecar Monitor sensitive operations \u2022 Detailed logging of scanner operations\u2022 Tracking of pod access and modifications\u2022 Scan activity audit trail \u2705 K8s API\u26a0\ufe0f Debug Container\u274c Sidecar Alert on suspicious activity \u2022 Threshold-based compliance alerting\u2022 Integration with CI/CD pipelines for automated response\u2022 Failure alerting for security violations \u2705 K8s API\u26a0\ufe0f Debug Container\u26a0\ufe0f Sidecar"},{"location":"security/compliance/nsa-cisa-hardening/#5-vulnerability-management","title":"5. Vulnerability Management","text":"<p>Our implementation aligns with these NSA/CISA requirements through:</p> NSA/CISA Recommendation Implementation Approach Support Scan container images \u2022 InSpec profiles for container scanning\u2022 Integration with CI/CD for pre-deployment checks\u2022 Planned Anchore Grype integration \u2705 K8s API\u2705 Debug Container\u2705 Sidecar Implement pod security standards \u2022 Enforcement of pod security best practices\u2022 Security context validation\u2022 Pod configuration assessment \u2705 K8s API\u26a0\ufe0f Debug Container\u274c Sidecar Use trusted image sources \u2022 Verification of image provenance\u2022 Validation of container signatures\u2022 Source repository verification \ud83d\udfe1 In Progress(all approaches)"},{"location":"security/compliance/nsa-cisa-hardening/#approach-alignment-with-nsacisa-guide","title":"Approach Alignment with NSA/CISA Guide","text":"<p>The three scanning approaches have different levels of alignment with NSA/CISA hardening recommendations:</p>"},{"location":"security/compliance/nsa-cisa-hardening/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Strong Alignment (90%): Most closely follows NSA/CISA guidance</li> <li>Key Strengths:</li> <li>Maintains strict pod isolation</li> <li>Uses standard Kubernetes APIs (no non-standard features)</li> <li>Requires minimal, well-defined permissions</li> <li>Creates clear audit trail</li> <li>No pod modification required</li> <li>Excellent network boundary preservation</li> <li>Key Weaknesses:</li> <li>Limited distroless container support (planned enhancement)</li> <li>Configuration Example:   <pre><code># train-k8s-container transport configuration\ntransport:\n  name: train-k8s-container\n  connection_timeout: 15 # seconds\n  pod_name: target-pod\n  container_name: target-container\n  namespace: target-namespace\n</code></pre></li> <li>NSA/CISA Advantages: Follows least privilege principle, maintains namespace boundaries, uses standard interfaces</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Moderate Alignment (70%): Mixed compliance with NSA/CISA guidance</li> <li>Key Strengths:</li> <li>Works with distroless containers (NSA recommended)</li> <li>Provides temporary access only</li> <li>Ephemeral containers reduce attack surface</li> <li>Maintains namespace isolation</li> <li>Key Concerns:</li> <li>Uses debug features (NSA recommends standard interfaces)</li> <li>Requires additional privileges beyond minimum necessary</li> <li>Limited auditing capabilities for debug container operations</li> <li>More complex RBAC configuration</li> <li>Configuration Example:   <pre><code># Debug container configuration for distroless targets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: debug-container\n  annotations:\n    debug.container/target: distroless-pod\nspec:\n  ephemeralContainers:\n  - name: cinc-scanner\n    image: registry/cinc-scanner:latest\n    securityContext:\n      runAsNonRoot: true\n      capabilities:\n        drop: [\"ALL\"]\n</code></pre></li> <li>NSA/CISA Analysis: While this approach supports distroless containers (a recommended practice), it uses debug features which may introduce security risks that require additional controls and documentation.</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Limited Alignment (50%): Most significant deviations from NSA/CISA guidance</li> <li>Key Strengths:</li> <li>Works with distroless containers</li> <li>Compatible with all Kubernetes versions</li> <li>Supports non-root execution</li> <li>Key Concerns:</li> <li>Explicitly violates NSA/CISA recommendation against process namespace sharing</li> <li>Breaks pod isolation boundaries</li> <li>Requires significantly more privileges</li> <li>Complicates audit trails and monitoring</li> <li>Requires pod definition changes</li> <li>Weakens container isolation model</li> <li>Configuration Example:   <pre><code># Sidecar container configuration\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-sidecar\nspec:\n  shareProcessNamespace: true # Required for this approach - VIOLATES NSA/CISA GUIDANCE\n  containers:\n  - name: app-container\n    image: app-image\n  - name: cinc-scanner\n    image: registry/cinc-scanner:latest\n    securityContext:\n      runAsNonRoot: true\n      readOnlyRootFilesystem: true\n</code></pre></li> <li>NSA/CISA Analysis: The NSA/CISA guide specifically recommends maintaining strong isolation boundaries between containers. This approach's reliance on process namespace sharing fundamentally contradicts this guidance and would require formal risk acceptance and documentation in compliant environments.</li> </ul>"},{"location":"security/compliance/nsa-cisa-hardening/#approach-selection-considerations","title":"Approach Selection Considerations","text":"<p>The NSA/CISA guidance presents an interesting compliance tradeoff for our scanning approaches:</p> <p>Balancing Distroless Support with Other Security Controls</p> <p>The NSA/CISA guidance specifically recommends using container-specific operating systems like distroless containers, which have minimal attack surfaces. This is one area where our Debug Container and Sidecar approaches currently have an advantage over the Kubernetes API approach.</p> <p>The Kubernetes API approach (using train-k8s-container transport) works well with standard containers but has limited support for distroless containers right now. That's why it's marked with \u26a0\ufe0f and \"(Planned)\" - indicating this is a planned enhancement.</p> <p>This creates an interesting compliance tradeoff:</p> <ol> <li>The Kubernetes API approach has better overall security posture and alignment with most NSA/CISA controls (namespace isolation, minimal privileges, clear audit trail)</li> <li>The Debug Container and Sidecar approaches have better alignment with the specific NSA/CISA recommendation for supporting distroless containers</li> </ol> <p>This highlights why having multiple approaches is valuable - they have different strengths. For environments using distroless containers, using the Debug Container approach might be justified despite other shortcomings, specifically because it addresses this important NSA/CISA recommendation.</p> <p>When we complete the planned enhancement to the train-k8s-container plugin to support distroless containers, the Kubernetes API approach will become the clear leader across all categories, achieving near 100% alignment with NSA/CISA guidance.</p> <p>Organizations should evaluate their specific requirements and container technologies when selecting a scanning approach, considering both the NSA/CISA alignment and their specific operational needs.</p>"},{"location":"security/compliance/nsa-cisa-hardening/#gap-analysis-and-remediation","title":"Gap Analysis and Remediation","text":"<p>Areas where our implementation needs improvement to fully align with NSA/CISA guidance:</p> <ol> <li>Complete Vulnerability Scanning Integration</li> <li>Gap: Limited to CINC Auditor compliance scanning</li> <li>Remediation: Planned integration with Anchore Grype for CVE detection</li> <li> <p>NSA/CISA Requirement: \"Scan container images for vulnerabilities regularly\"</p> </li> <li> <p>Comprehensive Audit Logging</p> </li> <li>Gap: Scanner-focused logging without broader cluster context</li> <li>Remediation: Enhanced integration with Kubernetes audit logs</li> <li> <p>NSA/CISA Requirement: \"Enable auditing for sensitive actions\"</p> </li> <li> <p>Pod Security Admission Enforcement</p> </li> <li>Gap: Scanning without enforcement</li> <li>Remediation: Planned integration with Pod Security Admission webhook</li> <li> <p>NSA/CISA Requirement: \"Implement Pod Security Standards\"</p> </li> <li> <p>Process Namespace Isolation (Sidecar Approach)</p> </li> <li>Gap: Sidecar approach requires process namespace sharing</li> <li>Remediation: Document risk and provide risk acceptance templates for environments that must use this approach</li> <li>NSA/CISA Requirement: \"Maintain isolation between containers\"</li> <li> <p>Documentation: Environments using the Sidecar approach in NSA/CISA-compliant environments should document the risk acceptance and justification</p> </li> <li> <p>Advanced RBAC Implementation</p> </li> <li>Gap: Debug Container and Sidecar approaches require broader permissions</li> <li>Remediation: Enhanced RBAC templates with more restrictive controls</li> <li> <p>NSA/CISA Requirement: \"Use RBAC with least privilege\"</p> </li> <li> <p>Distroless Container Support in Kubernetes API Approach</p> </li> <li>Gap: Limited support for distroless containers in the Kubernetes API approach</li> <li>Remediation: Complete the planned enhancement to the train-k8s-container plugin for native distroless support</li> <li>NSA/CISA Requirement: \"Use container-specific OS\"</li> <li>Impact: Once completed, the Kubernetes API approach would achieve near 100% alignment with NSA/CISA recommendations, becoming fully compliant while maintaining its superior security properties compared to other approaches</li> </ol>"},{"location":"security/compliance/nsa-cisa-hardening/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Principles</li> <li>RBAC Implementation</li> <li>Risk Analysis</li> <li>Security Recommendations</li> </ul>"},{"location":"security/compliance/risk-documentation/","title":"Risk Documentation Requirements","text":"<p>This document outlines the requirements for documenting security risks and compliance deviations when using alternative container scanning approaches in environments with strict compliance requirements.</p>"},{"location":"security/compliance/risk-documentation/#risk-documentation-purpose","title":"Risk Documentation Purpose","text":"<p>When using approaches that deviate from compliance frameworks or security best practices, proper risk documentation serves several purposes:</p> <ol> <li>Transparency: Clearly acknowledges known deviations from requirements</li> <li>Risk Management: Demonstrates understanding and management of security implications</li> <li>Authorization: Documents formal approval for the deviation</li> <li>Mitigation: Outlines additional controls implemented to address risks</li> <li>Traceability: Provides an audit trail for compliance assessments</li> </ol>"},{"location":"security/compliance/risk-documentation/#debug-container-approach-risk-documentation","title":"Debug Container Approach Risk Documentation","text":"<p>If using the Debug Container Approach as an interim solution, document the following:</p>"},{"location":"security/compliance/risk-documentation/#1-security-control-deviation","title":"1. Security Control Deviation","text":"<p>Document that this approach deviates from standard access interfaces:</p> <pre><code>## Security Control Deviation\n\nThis implementation deviates from the following security controls:\n\n1. **DoD 8500.01 Section 4.b.(1)(b)** - Standard, vendor-supported interfaces\n   - **Deviation**: Uses ephemeral debug containers which may be considered non-standard\n   - **Justification**: Required for scanning distroless containers without shell access\n\n2. **SRG-APP-000142** - Least privilege implementation\n   - **Deviation**: Requires permissions to create ephemeral containers\n   - **Justification**: Necessary for accessing distroless container filesystem\n</code></pre>"},{"location":"security/compliance/risk-documentation/#2-risk-assessment","title":"2. Risk Assessment","text":"<p>Document the additional attack surface introduced:</p> <pre><code>## Risk Assessment\n\nThe Debug Container Approach introduces the following risks:\n\n1. **Temporary Container Isolation Breaking**\n   - **Risk Level**: Medium\n   - **Description**: Ephemeral debug container has access to target container filesystem\n   - **Mitigation**: Debug container is temporary and automatically removed after scanning\n\n2. **Elevated Permission Requirements**\n   - **Risk Level**: Medium\n   - **Description**: Requires permissions to create ephemeral containers\n   - **Mitigation**: Strict RBAC limiting which pods can have debug containers attached\n</code></pre>"},{"location":"security/compliance/risk-documentation/#3-authorization","title":"3. Authorization","text":"<p>Obtain formal approval:</p> <pre><code>## Authorization\n\nThis implementation has been reviewed and approved as an interim solution until the Kubernetes API Approach supports distroless containers.\n\n| Role | Name | Signature | Date |\n|------|------|-----------|------|\n| Information System Security Officer | [Name] | [Signature] | [Date] |\n| System Owner | [Name] | [Signature] | [Date] |\n\nThis approval expires on [Date] or when the Kubernetes API Approach is enhanced to support distroless containers, whichever comes first.\n</code></pre>"},{"location":"security/compliance/risk-documentation/#4-enhanced-monitoring","title":"4. Enhanced Monitoring","text":"<p>Document additional monitoring:</p> <pre><code>## Enhanced Monitoring\n\nThe following additional monitoring has been implemented:\n\n1. **Debug Container Creation Alerting**\n   - Alert on any ephemeral debug container creation\n   - Daily review of all debug container activity logs\n\n2. **Debug Container Duration Monitoring**\n   - Alert on debug containers lasting longer than 15 minutes\n   - Automatic termination of containers exceeding 30 minutes\n</code></pre>"},{"location":"security/compliance/risk-documentation/#sidecar-container-approach-risk-documentation","title":"Sidecar Container Approach Risk Documentation","text":"<p>If using the Sidecar Container Approach, more extensive risk documentation is required:</p>"},{"location":"security/compliance/risk-documentation/#1-security-control-deviation_1","title":"1. Security Control Deviation","text":"<p>Document explicit deviations:</p> <pre><code>## Security Control Deviation\n\nThis implementation deviates from the following security controls:\n\n1. **CIS Benchmark 5.2.4** - Minimize the admission of containers sharing process namespaces\n   - **Deviation**: Explicitly requires shared process namespaces\n   - **Justification**: Required to access distroless container filesystem\n\n2. **DoD 8500.01 Section 4.b.(1)(b)** - Standard, vendor-supported interfaces\n   - **Deviation**: Uses process namespace sharing for cross-container access\n   - **Justification**: Necessary for accessing distroless container filesystem\n\n3. **STIG V-242432** - Namespace isolation\n   - **Deviation**: Breaks process isolation within pod\n   - **Justification**: Required technical approach for distroless containers\n</code></pre>"},{"location":"security/compliance/risk-documentation/#2-technical-risk-assessment","title":"2. Technical Risk Assessment","text":"<p>Document shared process namespace security implications:</p> <pre><code>## Technical Risk Assessment\n\nThe Sidecar Container Approach introduces the following risks:\n\n1. **Process Namespace Sharing**\n   - **Risk Level**: High\n   - **Description**: Sidecar container has complete visibility into target container processes\n   - **Mitigation**: Strict security context, non-privileged execution, read-only filesystem\n\n2. **Container Isolation Breaking**\n   - **Risk Level**: High\n   - **Description**: Violates \"one process per container\" principle\n   - **Mitigation**: Enhanced container hardening, network isolation, minimal sidecar container\n\n3. **Persistent Access**\n   - **Risk Level**: Medium-High\n   - **Description**: Sidecar exists for pod lifetime, not just scanning duration\n   - **Mitigation**: Consider dedicated short-lived scanning pods instead of persistent sidecars\n</code></pre>"},{"location":"security/compliance/risk-documentation/#3-implementation-controls","title":"3. Implementation Controls","text":"<p>Document strict limitations:</p> <pre><code>## Implementation Controls\n\nThe following additional security measures have been implemented:\n\n1. **Strict Sidecar Container Hardening**\n   - Minimal base image with only required tools\n   - No shell access where possible\n   - Read-only filesystem\n   - Non-root user execution\n   - No additional capabilities\n\n2. **Enhanced Network Isolation**\n   - Egress filtering limited to Kubernetes API only\n   - No ingress traffic allowed\n   - Pod-specific network policies\n\n3. **Container Security Policies**\n   - SecComp profile: RuntimeDefault\n   - No privileged operation\n   - No host resource access\n   - CPU and memory limits\n</code></pre>"},{"location":"security/compliance/risk-documentation/#4-formal-approval-chain","title":"4. Formal Approval Chain","text":"<p>Document a more extensive approval chain:</p> <pre><code>## Formal Approval\n\nThis implementation has been reviewed by the security review board and approved with the understanding that it represents a temporary deviation from security best practices.\n\n| Role | Name | Signature | Date |\n|------|------|-----------|------|\n| Chief Information Security Officer | [Name] | [Signature] | [Date] |\n| Information System Security Officer | [Name] | [Signature] | [Date] |\n| System Owner | [Name] | [Signature] | [Date] |\n| Security Review Board Chair | [Name] | [Signature] | [Date] |\n\nThis approval is valid until [Date] and requires quarterly review and reauthorization.\n</code></pre>"},{"location":"security/compliance/risk-documentation/#5-migration-plan","title":"5. Migration Plan","text":"<p>Document timeline for migration:</p> <pre><code>## Migration Plan\n\nThe organization will migrate from the Sidecar Container Approach to the Kubernetes API Approach according to the following timeline:\n\n| Milestone | Target Date | Responsible Party | Status |\n|-----------|-------------|-------------------|--------|\n| Kubernetes API Approach Enhancement Design | [Date] | [Team] | [Status] |\n| Implementation and Testing | [Date] | [Team] | [Status] |\n| Pilot Deployment | [Date] | [Team] | [Status] |\n| Full Migration | [Date] | [Team] | [Status] |\n\nProgress will be reviewed monthly and reported to the security review board.\n</code></pre>"},{"location":"security/compliance/risk-documentation/#risk-documentation-template","title":"Risk Documentation Template","text":"<p>Below is a general template for risk documentation that can be adapted for either approach:</p> <pre><code># Security Risk Documentation for [Approach Name]\n\n## 1. Implementation Overview\n[Brief description of the implementation]\n\n## 2. Security Control Deviations\n[List all security controls or best practices that this implementation deviates from]\n\n## 3. Risk Assessment\n[Detailed assessment of security risks introduced]\n\n## 4. Mitigation Strategy\n[Controls implemented to mitigate identified risks]\n\n## 5. Residual Risk\n[Assessment of remaining risk after mitigations]\n\n## 6. Monitoring and Detection\n[Additional monitoring implemented for this approach]\n\n## 7. Authorization\n[Formal approval documentation]\n\n## 8. Expiration and Review\n[Expiration date and review schedule]\n\n## 9. Migration Plan\n[Plan to transition to a more compliant solution]\n</code></pre>"},{"location":"security/compliance/risk-documentation/#updating-risk-documentation","title":"Updating Risk Documentation","text":"<p>Risk documentation should be reviewed and updated:</p> <ol> <li>Quarterly, or according to organizational policy</li> <li>When changes are made to the implementation</li> <li>When new vulnerabilities or attack vectors are discovered</li> <li>When compliance requirements change</li> <li>When the risk assessment changes</li> </ol>"},{"location":"security/compliance/risk-documentation/#risk-documentation-storage","title":"Risk Documentation Storage","text":"<p>Risk documentation should be:</p> <ol> <li>Stored in a secure, version-controlled repository</li> <li>Accessible to security assessors and auditors</li> <li>Protected from unauthorized modification</li> <li>Referenced in system security documentation</li> <li>Included in authorization packages</li> </ol>"},{"location":"security/compliance/risk-documentation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Approach Comparison - Comparison of approaches against compliance frameworks</li> <li>DoD 8500.01 Alignment - Alignment with DoD requirements</li> <li>DISA SRG Alignment - Alignment with DISA SRG</li> <li>Risk Analysis - Detailed risk assessment</li> </ul>"},{"location":"security/principles/","title":"Security Principles","text":"<p>This document outlines the core security principles implemented in the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"security/principles/#overview","title":"Overview","text":"<p>Our solution is built on several fundamental security principles that ensure a strong security posture for container scanning operations:</p> <ul> <li>Least Privilege Access: Using minimal permissions needed for container scanning</li> <li>Ephemeral Credentials: Employing short-lived tokens (default 15-minute lifespan)</li> <li>Resource Isolation: Restricting access to specific namespaces and resources</li> <li>Secure Transport: Ensuring all communications are encrypted</li> <li>Defense in Depth: Implementing multiple layers of security controls</li> </ul>"},{"location":"security/principles/#core-security-principles","title":"Core Security Principles","text":"<p>Each security principle is documented in detail:</p> <ul> <li>Least Privilege - Implementation of minimal permissions</li> <li>Ephemeral Credentials - Using temporary, short-lived tokens</li> <li>Resource Isolation - Separating scanning resources</li> <li>Secure Transport - Ensuring all communications are encrypted</li> </ul>"},{"location":"security/principles/#security-by-design","title":"Security by Design","text":"<p>These principles are integrated into the design of all components and approaches:</p> <ol> <li>Service accounts have minimal permissions</li> <li>Roles are scoped to specific containers, not entire namespaces</li> <li>Access is limited to only required verbs (\"get\", \"list\", \"create\" for exec)</li> <li>Tokens are short-lived and automatically expire</li> <li>Namespaces isolate scanning operations</li> </ol>"},{"location":"security/principles/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis - Analysis of security risks and mitigations</li> <li>Compliance Documentation - Compliance frameworks alignment</li> <li>Threat Model - Analysis of threats and mitigations</li> <li>Security Recommendations - Best practices and guidelines</li> </ul>"},{"location":"security/principles/ephemeral-creds/","title":"Ephemeral Credentials","text":"<p>Ephemeral credentials are short-lived authentication tokens that provide temporary access to Kubernetes resources. This approach significantly reduces the security risks associated with long-lived credentials.</p>"},{"location":"security/principles/ephemeral-creds/#implementation-details","title":"Implementation Details","text":"<p>The Secure CINC Auditor Kubernetes Container Scanning solution implements ephemeral credentials through:</p> <ul> <li>Short-lived tokens are generated for each scan</li> <li>Token expiration can be configured (default: 1 hour)</li> <li>No long-lived tokens stored in CI/CD variables or config files</li> </ul>"},{"location":"security/principles/ephemeral-creds/#token-generation-process","title":"Token Generation Process","text":"<p>Tokens are generated using the Kubernetes TokenRequest API, which creates temporary credentials with a specified expiration time:</p> <pre><code>kubectl create token scanner-service-account \\\n  --bound-object-kind=Pod \\\n  --bound-object-name=scanner-pod \\\n  --audience=kubernetes \\\n  --validity-duration=1h\n</code></pre> <p>This token is automatically invalidated after the specified duration (1 hour in this example).</p>"},{"location":"security/principles/ephemeral-creds/#security-benefits","title":"Security Benefits","text":"<p>Ephemeral credentials provide several security advantages:</p> <ol> <li>Limited Exposure Window: Even if credentials are leaked, they have a short validity period</li> <li>No Persistent Storage: Tokens are generated on-demand and not persistently stored</li> <li>Audience Binding: Tokens can be bound to specific target systems</li> <li>Automatic Invalidation: No manual revocation required when access is no longer needed</li> <li>CI/CD Security: Reduces risk of credential leakage in CI/CD pipelines</li> </ol>"},{"location":"security/principles/ephemeral-creds/#implementation-considerations","title":"Implementation Considerations","text":"<p>When implementing ephemeral credentials:</p> <ul> <li>Set an appropriate token validity period based on scan duration requirements</li> <li>Implement proper error handling for token expiration during long-running scans</li> <li>Consider regenerating tokens for batch operations rather than using a single token</li> <li>Integrate token generation within automated workflows</li> </ul>"},{"location":"security/principles/ephemeral-creds/#recommended-token-lifetimes","title":"Recommended Token Lifetimes","text":"Scanning Scenario Recommended Token Lifetime Interactive Debugging 15-30 minutes CI/CD Pipeline Scan Duration of pipeline + 5 minutes Scheduled Batch Scans Maximum duration of batch + 15 minutes Production Monitoring 1 hour maximum"},{"location":"security/principles/ephemeral-creds/#integration-with-cicd-systems","title":"Integration with CI/CD Systems","text":"<p>For CI/CD integrations:</p> <ol> <li>Generate token at the beginning of the pipeline</li> <li>Use token for all scanning operations</li> <li>Token automatically expires after pipeline completion</li> <li>No token storage between pipeline runs</li> </ol>"},{"location":"security/principles/ephemeral-creds/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis - Security risks mitigated by ephemeral credentials</li> <li>Compliance Documentation - Compliance requirements for temporary credentials</li> <li>Service Accounts - Service account configuration</li> <li>Tokens - Token generation and management</li> </ul>"},{"location":"security/principles/inventory/","title":"Security Principles Directory","text":"<p>This directory contains documentation on the core security principles implemented in the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/principles/inventory/#available-documents","title":"Available Documents","text":"Document Description Index Overview of security principles Least Privilege Implementation of least privilege principle Ephemeral Credentials Usage of short-lived authentication tokens Resource Isolation Isolation of scanning resources Secure Transport Secure communication implementation"},{"location":"security/principles/inventory/#related-directories","title":"Related Directories","text":"Directory Description Risk Analysis Analysis of security risks and mitigations Compliance Compliance framework alignment Threat Model Security threat modeling Recommendations Security best practices and recommendations"},{"location":"security/principles/least-privilege/","title":"Least Privilege Principle","text":"<p>The Principle of Least Privilege is a core security concept implemented throughout the Secure CINC Auditor Kubernetes Container Scanning solution. This principle ensures that components are granted only the minimum permissions necessary to perform their required functions.</p>"},{"location":"security/principles/least-privilege/#implementation-details","title":"Implementation Details","text":""},{"location":"security/principles/least-privilege/#rbac-configuration","title":"RBAC Configuration","text":"<p>All components follow the principle of least privilege through careful RBAC configuration:</p> <ul> <li>Service accounts have minimal permissions</li> <li>Roles are scoped to specific containers, not entire namespaces</li> <li>Only required verbs (\"get\", \"list\", \"create\" for exec) are granted</li> <li>No cluster-wide permissions are used</li> </ul>"},{"location":"security/principles/least-privilege/#scope-limitation","title":"Scope Limitation","text":"<p>Permissions are limited in scope through several mechanisms:</p> <ol> <li>Namespace Restriction: Each role is limited to a specific namespace</li> <li>Resource Type Limitation: Only <code>pods</code> resources are accessible</li> <li>Verb Restriction: Only specific verbs are permitted</li> <li>Resource Name Constraints: When possible, specific pod names are specified</li> </ol>"},{"location":"security/principles/least-privilege/#example-rbac-configuration","title":"Example RBAC Configuration","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: cinc-scanner-role\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # Optional resource name constraint for specific pods\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre>"},{"location":"security/principles/least-privilege/#security-benefits","title":"Security Benefits","text":"<p>The least privilege principle provides several security benefits:</p> <ol> <li>Reduced Attack Surface: Limiting permissions reduces potential attack vectors</li> <li>Damage Limitation: If credentials are compromised, the scope of potential damage is minimal</li> <li>Compliance Alignment: Many compliance frameworks require least privilege implementation</li> <li>Auditability: Clear, minimal permissions are easier to audit and verify</li> </ol>"},{"location":"security/principles/least-privilege/#mitigation-of-token-exposure","title":"Mitigation of Token Exposure","text":"<p>If a token is exposed, the attacker can only:</p> <ol> <li>List pods in the target namespace</li> <li>Execute commands in specifically allowed containers</li> <li>View logs of specifically allowed containers</li> </ol> <p>The token cannot be used to:</p> <ol> <li>Create, modify, or delete any resources</li> <li>Access any other containers</li> <li>Access any cluster-wide information</li> <li>Escalate privileges</li> </ol>"},{"location":"security/principles/least-privilege/#implementation-across-scanning-approaches","title":"Implementation Across Scanning Approaches","text":"Scanning Approach Least Privilege Implementation Kubernetes API Minimal RBAC permissions for pod exec Debug Container Minimal RBAC for ephemeral container creation Sidecar Container Minimal RBAC for sidecar deployment"},{"location":"security/principles/least-privilege/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis - How least privilege mitigates security risks</li> <li>Compliance Documentation - Compliance framework requirements for least privilege</li> <li>RBAC Configuration - Detailed RBAC setup instructions</li> </ul>"},{"location":"security/principles/resource-isolation/","title":"Resource Isolation","text":"<p>Resource isolation is a fundamental security principle in the Secure CINC Auditor Kubernetes Container Scanning solution. This principle ensures that scanning operations are properly isolated and controlled.</p>"},{"location":"security/principles/resource-isolation/#implementation-details","title":"Implementation Details","text":"<p>The resource isolation principle is implemented through:</p> <ul> <li>Each scan operates within a specific namespace</li> <li>Only specifically named pods can be accessed</li> <li>No access to other cluster resources</li> <li>Option for dedicated namespaces per CI/CD pipeline</li> </ul>"},{"location":"security/principles/resource-isolation/#namespace-isolation","title":"Namespace Isolation","text":"<p>Namespace isolation is a key aspect of Kubernetes security:</p> <ol> <li>Dedicated Namespaces: Scanner components are deployed in dedicated namespaces</li> <li>Role Scoping: RBAC roles are scoped to specific namespaces</li> <li>Target Limitation: Scanner only accesses resources in target namespaces</li> <li>Network Segmentation: Optional network policies can further restrict communication</li> </ol>"},{"location":"security/principles/resource-isolation/#resource-level-controls","title":"Resource-Level Controls","text":"<p>Beyond namespace isolation, resource-level controls include:</p> <ul> <li>Access limited to pod resources only (no secrets, configmaps, etc.)</li> <li>ResourceName constraints to limit access to specific pods</li> <li>Label selectors to filter accessible resources</li> <li>No access to cluster-level resources</li> </ul>"},{"location":"security/principles/resource-isolation/#example-configuration","title":"Example Configuration","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  # Use resourceNames or labelSelector to limit scope further\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre>"},{"location":"security/principles/resource-isolation/#security-benefits","title":"Security Benefits","text":"<p>Resource isolation provides several security benefits:</p> <ol> <li>Attack Surface Reduction: Limiting accessible resources reduces potential attack vectors</li> <li>Multi-tenant Safety: Different teams/pipelines can operate without interference</li> <li>Blast Radius Limitation: Security incidents are contained within isolated boundaries</li> <li>Simplified Auditing: Clear boundaries make access auditing more straightforward</li> <li>Compliance Alignment: Supports separation of duties and least privilege requirements</li> </ol>"},{"location":"security/principles/resource-isolation/#preventing-lateral-movement","title":"Preventing Lateral Movement","text":"<p>The resource isolation implementation prevents lateral movement:</p> <ul> <li>No access to secrets</li> <li>No access to configmaps</li> <li>No ability to create new resources</li> <li>No ability to modify service accounts</li> </ul>"},{"location":"security/principles/resource-isolation/#implementation-across-scanning-approaches","title":"Implementation Across Scanning Approaches","text":"Scanning Approach Resource Isolation Implementation Kubernetes API Namespace and pod-specific RBAC Debug Container Namespace-scoped ephemeral container permissions Sidecar Container Namespace-scoped deployment permissions"},{"location":"security/principles/resource-isolation/#isolation-recommendations","title":"Isolation Recommendations","text":"<ol> <li>Namespace Strategy: Use dedicated namespaces for your scanning infrastructure</li> <li>Label-Based Access: Consider using pod labels and label selectors for more dynamic access control</li> <li>Network Policies: Implement Kubernetes network policies to further restrict scanner communication</li> <li>Resource Quotas: Apply resource quotas to scanning namespaces to prevent resource abuse</li> </ol>"},{"location":"security/principles/resource-isolation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis - Security risks mitigated by resource isolation</li> <li>Compliance Documentation - Compliance requirements for resource isolation</li> <li>Kubernetes Setup - Namespace and RBAC configuration</li> <li>RBAC - Role-based access control implementation</li> </ul>"},{"location":"security/principles/secure-transport/","title":"Secure Transport","text":"<p>Secure transport is a critical security principle in the Secure CINC Auditor Kubernetes Container Scanning solution. This principle ensures that all communications between components are encrypted and protected against eavesdropping and tampering.</p>"},{"location":"security/principles/secure-transport/#implementation-details","title":"Implementation Details","text":"<p>The secure transport principle is implemented through:</p> <ul> <li>All API communication uses TLS</li> <li>Kubeconfig files include the cluster's certificate authority data</li> <li>No insecure TLS options are enabled</li> </ul>"},{"location":"security/principles/secure-transport/#tls-communication","title":"TLS Communication","text":"<p>All communication with the Kubernetes API server is secured through TLS:</p> <ol> <li>Certificate Validation: The Kubernetes API server's certificate is validated against trusted certificate authorities</li> <li>Encryption in Transit: All data exchanged with the API server is encrypted</li> <li>No Insecure Fallback: The solution does not permit insecure connections if TLS fails</li> <li>Modern TLS Versions: Only secure TLS versions (TLS 1.2+) are used</li> </ol>"},{"location":"security/principles/secure-transport/#kubeconfig-security","title":"Kubeconfig Security","text":"<p>Kubeconfig files are configured securely:</p> <pre><code>apiVersion: v1\nkind: Config\nclusters:\n- name: kubernetes\n  cluster:\n    server: https://kubernetes.default.svc\n    certificate-authority-data: &lt;BASE64_ENCODED_CA_CERT&gt;\nusers:\n- name: scanner\n  user:\n    token: &lt;EPHEMERAL_TOKEN&gt;\ncontexts:\n- name: scanner-context\n  context:\n    cluster: kubernetes\n    user: scanner\ncurrent-context: scanner-context\n</code></pre> <p>Key security features:</p> <ul> <li>Certificate authority data is embedded (no insecure <code>insecure-skip-tls-verify: true</code>)</li> <li>TLS verification is always enabled</li> <li>Ephemeral tokens are used for authentication</li> </ul>"},{"location":"security/principles/secure-transport/#network-security-considerations","title":"Network Security Considerations","text":"<p>Beyond TLS, additional network security measures include:</p> <ol> <li>Network Policies: Optional Kubernetes NetworkPolicy resources to restrict pod communication</li> <li>Internal Service Communication: Using internal Kubernetes service names to avoid external network traversal</li> <li>API Server Access Control: Leveraging Kubernetes API server authentication and authorization</li> </ol>"},{"location":"security/principles/secure-transport/#security-benefits","title":"Security Benefits","text":"<p>Secure transport provides several security benefits:</p> <ol> <li>Confidentiality: Prevents eavesdropping on sensitive scanning data</li> <li>Integrity: Ensures data cannot be tampered with during transmission</li> <li>Authentication: Verifies the identity of the Kubernetes API server</li> <li>Man-in-the-Middle Protection: Prevents interception attacks</li> <li>Regulatory Compliance: Supports requirements for encrypted communications</li> </ol>"},{"location":"security/principles/secure-transport/#implementation-across-scanning-approaches","title":"Implementation Across Scanning Approaches","text":"<p>All scanning approaches use the same secure transport mechanisms to communicate with the Kubernetes API server:</p> Scanning Approach Secure Transport Implementation Kubernetes API TLS-secured API server communication Debug Container TLS-secured API server communication Sidecar Container TLS-secured API server communication"},{"location":"security/principles/secure-transport/#best-practices","title":"Best Practices","text":"<ol> <li>Certificate Rotation: Ensure cluster certificates are rotated according to security policies</li> <li>TLS Version: Configure minimum TLS version to 1.2 or higher</li> <li>Cipher Suites: Use only strong cipher suites</li> <li>Kubeconfig Security: Protect kubeconfig files with appropriate file permissions</li> <li>Network Segmentation: Consider network segmentation for scanner components</li> </ol>"},{"location":"security/principles/secure-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis - Security risks mitigated by secure transport</li> <li>Compliance Documentation - Compliance requirements for transport security</li> <li>Kubernetes Setup - Kubeconfig configuration</li> <li>Tokens - Token generation and security</li> </ul>"},{"location":"security/recommendations/","title":"Security Recommendations","text":"<p>This document provides security recommendations and best practices for implementing the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"security/recommendations/#overview","title":"Overview","text":"<p>To ensure a secure implementation of container scanning, we provide comprehensive recommendations across different operational areas. These recommendations are derived from industry best practices, our detailed risk analysis, and compliance framework requirements.</p>"},{"location":"security/recommendations/#enterprise-security-recommendations","title":"Enterprise Security Recommendations","text":"<p>Our Enterprise Recommendations provides guidance for enterprise-scale deployments:</p> <ol> <li>Scanning Governance</li> <li>Implement approval processes for scanning operations</li> <li>Log all scanning activities with detailed attribution</li> <li> <p>Setup alerts for unauthorized scanning attempts</p> </li> <li> <p>Resource Management</p> </li> <li>Implement quotas to prevent DoS conditions</li> <li>Configure sandbox environments for scanning</li> <li> <p>Ensure proper resource allocation</p> </li> <li> <p>Access Control</p> </li> <li>Implement strong RBAC governance</li> <li>Use centralized identity management</li> <li>Implement just-in-time access for scanning</li> </ol>"},{"location":"security/recommendations/#cicd-security-recommendations","title":"CI/CD Security Recommendations","text":"<p>Our CI/CD Security provides specific recommendations for CI/CD integrations:</p> <ol> <li>Pipeline Credentials</li> <li>Ensure pipeline credentials are properly secured</li> <li>Implement secret management solutions</li> <li> <p>Rotate credentials regularly</p> </li> <li> <p>Scanner Validation</p> </li> <li>Validate scanner configuration before deployment</li> <li>Scan the scanner images themselves for vulnerabilities</li> <li> <p>Verify integrity of scanner components</p> </li> <li> <p>Pipeline Integration</p> </li> <li>Implement secure scanning workflows</li> <li>Validate scanning results</li> <li>Apply proper threshold controls</li> </ol>"},{"location":"security/recommendations/#monitoring-recommendations","title":"Monitoring Recommendations","text":"<p>Our Monitoring outlines best practices for security monitoring:</p> <ol> <li>Audit and Monitoring</li> <li>Monitor for abnormal scanning patterns</li> <li>Audit scanner configuration changes</li> <li> <p>Review scanner logs for suspicious activities</p> </li> <li> <p>Alerting and Response</p> </li> <li>Implement alerts for security policy violations</li> <li>Create incident response procedures</li> <li>Set up escalation paths for security events</li> </ol>"},{"location":"security/recommendations/#network-security-recommendations","title":"Network Security Recommendations","text":"<p>Our Network Security document provides guidance for network controls:</p> <ol> <li>Network Policies</li> <li>Implement network policies to restrict scanner communication</li> <li>Consider running scanning operations in dedicated namespaces</li> <li> <p>Implement egress filtering for scanning components</p> </li> <li> <p>Segmentation</p> </li> <li>Separate scanning infrastructure</li> <li>Implement proper namespace isolation</li> <li>Apply zero-trust principles</li> </ol>"},{"location":"security/recommendations/#implementation-best-practices","title":"Implementation Best Practices","text":"<p>Across all areas, these general best practices apply:</p> <ol> <li>Defense in Depth</li> <li>Implement multiple security controls at different layers</li> <li>Don't rely on a single security mechanism</li> <li> <p>Apply layered security controls</p> </li> <li> <p>Least Privilege</p> </li> <li>Implement minimal permissions for scanning operations</li> <li>Regularly review and audit permissions</li> <li> <p>Remove unnecessary access</p> </li> <li> <p>Secure Defaults</p> </li> <li>Configure conservative default settings for all components</li> <li>Disable unnecessary features</li> <li> <p>Apply secure baseline configurations</p> </li> <li> <p>Regular Updates</p> </li> <li>Keep scanner components updated with security patches</li> <li>Monitor for security advisories</li> <li>Implement a patch management process</li> </ol>"},{"location":"security/recommendations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Principles - Core security principles</li> <li>Risk Analysis - Analysis of security risks and mitigations</li> <li>Compliance - Compliance frameworks alignment</li> <li>Threat Model - Analysis of threats and mitigations</li> </ul>"},{"location":"security/recommendations/inventory/","title":"Security Recommendations Directory","text":"<p>This directory contains security recommendations and best practices for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/recommendations/inventory/#available-documents","title":"Available Documents","text":"Document Description Index Overview of security recommendations Enterprise Recommendations Guidance for enterprise-scale deployments CI/CD Security Recommendations for CI/CD integrations Monitoring Best practices for security monitoring Network Security Guidance for network security controls"},{"location":"security/recommendations/inventory/#related-directories","title":"Related Directories","text":"Directory Description Security Principles Core security principles Risk Analysis Security risk assessment Compliance Compliance framework alignment Threat Model Security threat modeling"},{"location":"security/recommendations/network/","title":"Network Security Recommendations","text":"<p>This document provides network security recommendations for deploying and operating the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/recommendations/network/#overview","title":"Overview","text":"<p>Network security is a critical aspect of container scanning, ensuring that communications remain secure and that scan results and credentials are protected during transit.</p>"},{"location":"security/recommendations/network/#network-security-controls","title":"Network Security Controls","text":""},{"location":"security/recommendations/network/#transport-layer-security","title":"Transport Layer Security","text":"<ul> <li>TLS Encryption: All communications between components should use TLS 1.2 or higher</li> <li>Certificate Validation: Properly validate certificates for all components</li> <li>Certificate Rotation: Implement regular certificate rotation procedures</li> </ul>"},{"location":"security/recommendations/network/#network-policies","title":"Network Policies","text":"<ul> <li>Restrict Pod Communication: Implement Kubernetes Network Policies to limit pod-to-pod communication</li> <li>Egress Filtering: Control outbound connections from scanning components</li> <li>Ingress Protection: Limit inbound connections to only required endpoints</li> </ul>"},{"location":"security/recommendations/network/#scanning-approach-considerations","title":"Scanning Approach Considerations","text":""},{"location":"security/recommendations/network/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Configure proper TLS for all API communications</li> <li>Implement Network Policies to restrict scanner pods</li> <li>Use internal Kubernetes DNS for service discovery</li> </ul> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: scanner-namespace\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: scan-target-namespace\n</code></pre>"},{"location":"security/recommendations/network/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Ensure debug containers have limited network access</li> <li>Apply Network Policies to restrict debug container communications</li> <li>Limit egress to required services only</li> </ul>"},{"location":"security/recommendations/network/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Configure proper TLS for sidecar communications</li> <li>Implement pod-level network restrictions</li> <li>Isolate scanner network traffic from application traffic</li> </ul>"},{"location":"security/recommendations/network/#air-gapped-environments","title":"Air-Gapped Environments","text":"<p>For air-gapped or high-security environments:</p> <ol> <li>Pre-package all required container images</li> <li>Implement proper image transfer procedures</li> <li>Configure scanning without external dependencies</li> <li>Use internal artifact repositories for profiles and dependencies</li> </ol>"},{"location":"security/recommendations/network/#implementation-recommendations","title":"Implementation Recommendations","text":"<ol> <li>Default Deny Network Policies: Start with default deny policies and add specific allowances</li> <li>Separate Control Plane Traffic: Isolate scanner control communications from data traffic</li> <li>Encrypt All Communications: Ensure all network traffic is encrypted, even within the cluster</li> <li>Monitor Network Traffic: Implement network monitoring to detect unusual patterns</li> </ol>"},{"location":"security/recommendations/network/#related-documentation","title":"Related Documentation","text":"<ul> <li>Enterprise Recommendations - Enterprise deployment security</li> <li>CI/CD Security - CI/CD integration security</li> <li>Kubernetes Setup - Kubernetes configuration guidelines</li> </ul>"},{"location":"security/risk/","title":"Security Risk Analysis","text":"<p>This document provides an overview of the security risk analysis for the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"security/risk/#introduction","title":"Introduction","text":"<p>Understanding the security risks associated with container scanning is essential for implementing effective controls and selecting the most appropriate approach for your environment. This section provides a comprehensive security risk analysis for all scanning approaches.</p>"},{"location":"security/risk/#risk-analysis-by-approach","title":"Risk Analysis by Approach","text":"<p>Each container scanning approach has different security characteristics, risks, and mitigations:</p> <ul> <li>Kubernetes API Approach - Analysis of the standard scanning approach</li> <li>Debug Container Approach - Analysis of the debug container approach</li> <li>Sidecar Container Approach - Analysis of the sidecar container approach</li> </ul>"},{"location":"security/risk/#risk-model-and-framework","title":"Risk Model and Framework","text":"<p>Our Risk Model provides the framework and methodology used to assess security risks across all scanning approaches. It includes:</p> <ul> <li>Risk assessment methodology</li> <li>Risk classification criteria</li> <li>Impact and likelihood ratings</li> <li>Risk acceptance thresholds</li> </ul>"},{"location":"security/risk/#comprehensive-mitigations","title":"Comprehensive Mitigations","text":"<p>Risk Mitigations documents the strategies and controls implemented to address identified risks, including:</p> <ul> <li>Universal mitigations applied to all approaches</li> <li>Approach-specific mitigations</li> <li>Enterprise security recommendations</li> <li>Operational best practices</li> </ul>"},{"location":"security/risk/#security-risk-overview","title":"Security Risk Overview","text":"Security Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Required Privileges Container access Ephemeral container creation Process namespace sharing Attack Surface Minimal Moderate Moderate Credential Exposure Minimal Minimal Minimal Isolation Level High Moderate Lower Persistence Risk None (stateless) None (ephemeral) Container lifetime"},{"location":"security/risk/#risk-based-selection","title":"Risk-Based Selection","text":"<p>For a detailed comparison of risks to guide approach selection, see:</p> <ul> <li>Risk-Based Approach Selection</li> <li>Enterprise Security Recommendations</li> <li>Compliance Analysis</li> </ul>"},{"location":"security/risk/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Principles - Core security principles</li> <li>Compliance - Compliance frameworks alignment</li> <li>Threat Model - Analysis of threats and mitigations</li> <li>Security Recommendations - Best practices and guidelines</li> </ul>"},{"location":"security/risk/debug-container/","title":"Debug Container Approach Security Risk Analysis","text":"<p>This document provides a detailed security risk analysis of the Debug Container approach to container scanning, which uses ephemeral debug containers to access distroless containers.</p>"},{"location":"security/risk/debug-container/#security-model","title":"Security Model","text":"<p>The Debug Container approach creates an ephemeral debug container attached to the target pod's process namespace to access the filesystem of distroless containers.</p>"},{"location":"security/risk/debug-container/#security-characteristics","title":"Security Characteristics","text":"Security Factor Rating Description Required Privileges \ud83d\udfe0 Moderate Requires permissions to create ephemeral containers Attack Surface \ud83d\udfe0 Moderate Temporarily increased during debug container lifetime Credential Exposure \ud83d\udfe2 Minimal Uses short-lived service account tokens Isolation Level \ud83d\udfe0 Moderate Temporarily breaks container isolation Persistence Risk \ud83d\udfe2 None Debug container is ephemeral and deleted after scan"},{"location":"security/risk/debug-container/#detailed-risk-assessment","title":"Detailed Risk Assessment","text":""},{"location":"security/risk/debug-container/#authentication-and-authorization-risks","title":"Authentication and Authorization Risks","text":"Risk Likelihood Impact Mitigation Token leakage Low Medium Short-lived tokens, minimal permissions Excessive permissions Medium Medium Careful RBAC implementation Authentication bypass Very Low High Standard Kubernetes authentication mechanisms"},{"location":"security/risk/debug-container/#operational-risks","title":"Operational Risks","text":"Risk Likelihood Impact Mitigation Debug container persistence Low Medium Automatic removal after scan completion Resource exhaustion Low Medium Resource limits on debug containers Container interference Medium Medium Read-only access to container filesystem"},{"location":"security/risk/debug-container/#container-risks","title":"Container Risks","text":"Risk Likelihood Impact Mitigation Container isolation breach Medium Medium Temporary and controlled access Debug container compromise Low Medium Minimal tools in debug container Data exfiltration Low Medium Limited network access, short-lived containers"},{"location":"security/risk/debug-container/#risk-comparison","title":"Risk Comparison","text":"<p>When compared to other scanning approaches, the Debug Container approach presents:</p> <ul> <li>Higher risk than the Kubernetes API approach in terms of required privileges and container isolation</li> <li>Lower risk than the Sidecar Container approach in terms of persistence and isolation duration</li> </ul>"},{"location":"security/risk/debug-container/#risk-scenarios-and-mitigations","title":"Risk Scenarios and Mitigations","text":""},{"location":"security/risk/debug-container/#scenario-1-debug-container-persistence","title":"Scenario 1: Debug Container Persistence","text":"<p>Risk: A debug container fails to terminate and remains attached to the target pod.</p> <p>Mitigations:</p> <ol> <li>Timeout mechanism forces container termination</li> <li>Kubernetes garbage collection for terminated pods</li> <li>Monitoring for long-running debug containers</li> <li>Debug container has minimal capabilities</li> </ol> <p>Residual Risk: Low - Even if a debug container persists, its capabilities are limited and it will be removed when the pod terminates.</p>"},{"location":"security/risk/debug-container/#scenario-2-excessive-debug-container-access","title":"Scenario 2: Excessive Debug Container Access","text":"<p>Risk: Debug container gains unintended access to target container resources.</p> <p>Mitigations:</p> <ol> <li>Debug container runs with minimal privileges</li> <li>Read-only filesystem access</li> <li>No host mount access</li> <li>Network access restrictions</li> </ol> <p>Residual Risk: Medium - The debug container has access to the target container's filesystem but with controlled capabilities.</p>"},{"location":"security/risk/debug-container/#scenario-3-debug-container-compromise","title":"Scenario 3: Debug Container Compromise","text":"<p>Risk: The debug container itself is compromised during operation.</p> <p>Mitigations:</p> <ol> <li>Minimal tools and packages in debug container</li> <li>Short-lived container existence</li> <li>Limited network access</li> <li>Non-privileged execution</li> </ol> <p>Residual Risk: Medium - A compromised debug container has limited opportunity to cause harm due to its ephemeral nature.</p>"},{"location":"security/risk/debug-container/#enterprise-security-considerations","title":"Enterprise Security Considerations","text":"<p>For enterprise deployments:</p> <ol> <li>Debug Container Monitoring: Implement monitoring for unexpected debug containers</li> <li>Strict RBAC: Restrict ephemeral container creation to specific service accounts</li> <li>Container Hardening: Use minimal, hardened images for debug containers</li> <li>Network Policies: Restrict debug container network access</li> <li>Audit Logging: Enable comprehensive logging of debug container creation and termination</li> </ol>"},{"location":"security/risk/debug-container/#conclusion","title":"Conclusion","text":"<p>The Debug Container approach presents a moderate security risk profile. Its primary advantages are:</p> <ol> <li>It provides a solution for scanning distroless containers</li> <li>Debug containers are ephemeral and automatically removed</li> <li>It requires fewer modifications to pod definitions than the Sidecar approach</li> </ol> <p>However, it does temporarily break container isolation principles and requires elevated permissions for ephemeral container creation. This makes it an acceptable interim solution for environments where the Kubernetes API approach cannot be used for distroless containers, but with higher security risks than the standard approach.</p> <p>For security-sensitive environments, the Debug Container approach should be implemented with enhanced monitoring, strong RBAC controls, and clear documentation of the security implications.</p>"},{"location":"security/risk/debug-container/#related-documentation","title":"Related Documentation","text":"<ul> <li>Kubernetes API Approach - Comparison with standard container scanning</li> <li>Sidecar Container Approach - Comparison with sidecar container scanning</li> <li>Risk Mitigations - Comprehensive mitigation strategies</li> <li>Compliance Alignment - Compliance framework alignment</li> </ul>"},{"location":"security/risk/inventory/","title":"Security Risk Analysis Directory","text":"<p>This directory contains documentation on the security risk analysis for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/risk/inventory/#available-documents","title":"Available Documents","text":"Document Description Index Overview of security risk analysis Risk Model Risk assessment methodology and framework Kubernetes API Approach Risk analysis of the standard scanning approach Debug Container Approach Risk analysis of the debug container approach Sidecar Container Approach Risk analysis of the sidecar container approach Risk Mitigations Comprehensive mitigation strategies"},{"location":"security/risk/inventory/#related-directories","title":"Related Directories","text":"Directory Description Security Principles Core security principles Compliance Compliance framework alignment Threat Model Security threat modeling Recommendations Security best practices and recommendations"},{"location":"security/risk/kubernetes-api/","title":"Kubernetes API Approach Security Risk Analysis","text":"<p>This document provides a detailed security risk analysis of the Kubernetes API approach to container scanning, which uses the train-k8s-container transport plugin.</p>"},{"location":"security/risk/kubernetes-api/#security-model","title":"Security Model","text":"<p>The Kubernetes API approach uses the Kubernetes API server to execute commands within target containers.</p>"},{"location":"security/risk/kubernetes-api/#security-characteristics","title":"Security Characteristics","text":"Security Factor Rating Description Required Privileges \ud83d\udfe2 Low Only requires pod \"get\", \"list\", and \"exec\" permissions Attack Surface \ud83d\udfe2 Minimal Uses standard Kubernetes API only Credential Exposure \ud83d\udfe2 Minimal Uses short-lived service account tokens Isolation Level \ud83d\udfe2 High Preserves container isolation Persistence Risk \ud83d\udfe2 None Stateless operation with no persistent components"},{"location":"security/risk/kubernetes-api/#detailed-risk-assessment","title":"Detailed Risk Assessment","text":""},{"location":"security/risk/kubernetes-api/#authentication-and-authorization-risks","title":"Authentication and Authorization Risks","text":"Risk Likelihood Impact Mitigation Token leakage Low Medium Short-lived tokens, minimal permissions Excessive permissions Low Medium Least privilege RBAC implementation Authentication bypass Very Low High Standard Kubernetes authentication mechanisms"},{"location":"security/risk/kubernetes-api/#operational-risks","title":"Operational Risks","text":"Risk Likelihood Impact Mitigation Command injection Low Medium Input validation, limited command execution Resource exhaustion Low Low Resource limits on scanner activities Scan disruption Medium Low Retry mechanisms, graceful error handling"},{"location":"security/risk/kubernetes-api/#container-risks","title":"Container Risks","text":"Risk Likelihood Impact Mitigation Container compromise Very Low Medium Restricted command execution, minimal privileges Container interference Low Medium No modification of container state Data exfiltration Low Medium Limited access to container contents"},{"location":"security/risk/kubernetes-api/#risk-comparison","title":"Risk Comparison","text":"<p>When compared to other scanning approaches, the Kubernetes API approach presents:</p> <ul> <li>Lower risk than the Debug Container approach in terms of required privileges and attack surface</li> <li>Lower risk than the Sidecar Container approach in terms of isolation preservation and container security principles</li> </ul>"},{"location":"security/risk/kubernetes-api/#risk-scenarios-and-mitigations","title":"Risk Scenarios and Mitigations","text":""},{"location":"security/risk/kubernetes-api/#scenario-1-token-compromise","title":"Scenario 1: Token Compromise","text":"<p>Risk: An attacker obtains a scanner's service account token.</p> <p>Mitigations:</p> <ol> <li>Token is short-lived (default 15-minute expiration)</li> <li>Token has minimal permissions (only specific pods)</li> <li>Token can only execute commands, not modify resources</li> <li>Comprehensive audit logging of all API operations</li> </ol> <p>Residual Risk: Low - Even with a compromised token, an attacker's capabilities are severely limited in both scope and time.</p>"},{"location":"security/risk/kubernetes-api/#scenario-2-scanner-process-compromise","title":"Scenario 2: Scanner Process Compromise","text":"<p>Risk: The scanner process itself is compromised during operation.</p> <p>Mitigations:</p> <ol> <li>Scanner has minimal Kubernetes permissions</li> <li>Scanner operates for a limited duration</li> <li>No persistent access to cluster</li> <li>No ability to modify cluster resources</li> </ol> <p>Residual Risk: Low to Medium - A compromised scanner has limited ability to affect the broader cluster.</p>"},{"location":"security/risk/kubernetes-api/#scenario-3-command-injection","title":"Scenario 3: Command Injection","text":"<p>Risk: Malicious input causes unexpected command execution.</p> <p>Mitigations:</p> <ol> <li>Input validation for all parameters</li> <li>Restricted command execution capabilities</li> <li>Non-privileged command execution</li> <li>Container isolation remains intact</li> </ol> <p>Residual Risk: Low - Command execution is constrained by container context and permissions.</p>"},{"location":"security/risk/kubernetes-api/#enterprise-security-considerations","title":"Enterprise Security Considerations","text":"<p>For enterprise deployments:</p> <ol> <li>Audit Logging: Enable comprehensive Kubernetes audit logging</li> <li>Token Management: Implement proper token lifecycle management</li> <li>Scanner Verification: Verify scanner container integrity before deployment</li> <li>Network Policies: Implement network policies to restrict scanner communication</li> <li>Monitoring: Monitor for unexpected scanning operations</li> </ol>"},{"location":"security/risk/kubernetes-api/#conclusion","title":"Conclusion","text":"<p>The Kubernetes API approach presents the lowest overall security risk profile among the available container scanning approaches. Its use of standard Kubernetes interfaces, minimal permissions, and preservation of container isolation principles makes it the preferred choice for security-conscious environments.</p> <p>The approach maintains strong security boundaries while still providing effective container scanning capabilities. Its primary limitation is the requirement for containers to have shell access, which is addressed by alternative approaches for distroless containers.</p>"},{"location":"security/risk/kubernetes-api/#related-documentation","title":"Related Documentation","text":"<ul> <li>Debug Container Approach - Comparison with debug container scanning</li> <li>Sidecar Container Approach - Comparison with sidecar container scanning</li> <li>Risk Mitigations - Comprehensive mitigation strategies</li> <li>Compliance Alignment - Compliance framework alignment</li> </ul>"},{"location":"security/risk/mitigations/","title":"Security Risk Mitigations","text":"<p>This document outlines the comprehensive risk mitigation strategies implemented across all container scanning approaches in the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/risk/mitigations/#universal-mitigations-all-approaches","title":"Universal Mitigations (All Approaches)","text":"<p>These mitigation strategies apply to all scanning approaches:</p>"},{"location":"security/risk/mitigations/#least-privilege-rbac","title":"Least-Privilege RBAC","text":"<ul> <li>Limit service accounts to minimum required permissions</li> <li>Use namespace-scoped roles, not cluster roles</li> <li>Apply label selector constraints when possible</li> <li>Regular review and audit of permissions</li> </ul>"},{"location":"security/risk/mitigations/#short-lived-credentials","title":"Short-lived Credentials","text":"<ul> <li>Generate tokens with 15-minute (or less) expiration</li> <li>Revoke tokens after scan completion</li> <li>Use token request API instead of long-lived secrets</li> <li>Implement proper token lifecycle management</li> </ul>"},{"location":"security/risk/mitigations/#scan-isolation","title":"Scan Isolation","text":"<ul> <li>Run scans from isolated environments</li> <li>Limit network access during scanning</li> <li>Use resource quotas to prevent DoS conditions</li> <li>Separate scanning infrastructure from application infrastructure</li> </ul>"},{"location":"security/risk/mitigations/#security-context","title":"Security Context","text":"<ul> <li>Run scanner containers as non-root users</li> <li>Apply seccomp and AppArmor profiles when possible</li> <li>Use read-only root filesystem for scanner containers</li> <li>Minimize container capabilities</li> </ul>"},{"location":"security/risk/mitigations/#approach-specific-mitigations","title":"Approach-Specific Mitigations","text":""},{"location":"security/risk/mitigations/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<ul> <li>Validate container integrity before scanning</li> <li>Limit scan duration with timeout controls</li> <li>Run scanner with minimal network access</li> <li>Implement input validation for command parameters</li> </ul>"},{"location":"security/risk/mitigations/#debug-container-approach","title":"Debug Container Approach","text":"<ul> <li>Use dedicated, minimal scanner image</li> <li>Apply strict resource limits</li> <li>Automatically terminate debug containers after scan</li> <li>Monitor for unauthorized debug container creation</li> <li>Implement timeout-based forced termination</li> </ul>"},{"location":"security/risk/mitigations/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<ul> <li>Implement process namespace security policies</li> <li>Use dedicated service accounts for sidecar deployment</li> <li>Consider short-lived pods dedicated to scanning</li> <li>Monitor for unauthorized sidecar injection</li> <li>Apply strict network policies to sidecar containers</li> </ul>"},{"location":"security/risk/mitigations/#enterprise-security-recommendations","title":"Enterprise Security Recommendations","text":""},{"location":"security/risk/mitigations/#scanning-governance","title":"Scanning Governance","text":"<ul> <li>Implement approval processes for scanning operations</li> <li>Log all scanning activities with detailed attribution</li> <li>Setup alerts for unauthorized scanning attempts</li> <li>Regular review of scanning access patterns</li> </ul>"},{"location":"security/risk/mitigations/#cicd-pipeline-controls","title":"CI/CD Pipeline Controls","text":"<ul> <li>Ensure pipeline credentials are properly secured</li> <li>Validate scanner configuration before deployment</li> <li>Scan the scanner images themselves for vulnerabilities</li> <li>Implement separation of duties in pipeline configuration</li> </ul>"},{"location":"security/risk/mitigations/#network-controls","title":"Network Controls","text":"<ul> <li>Implement network policies to restrict scanner communication</li> <li>Consider running scanning operations in dedicated namespaces</li> <li>Implement egress filtering for scanning components</li> <li>Restrict scanner to internal Kubernetes API endpoint</li> </ul>"},{"location":"security/risk/mitigations/#monitoring-and-auditing","title":"Monitoring and Auditing","text":"<ul> <li>Monitor for abnormal scanning patterns</li> <li>Audit scanner configuration changes</li> <li>Review scanner logs for suspicious activities</li> <li>Set up alerts for unauthorized scanning operations</li> </ul>"},{"location":"security/risk/mitigations/#image-security","title":"Image Security","text":"<ul> <li>Ensure scanner images are from trusted sources</li> <li>Regularly update scanner components</li> <li>Sign scanner images with trusted signatures</li> <li>Implement scanning image vulnerability management</li> </ul>"},{"location":"security/risk/mitigations/#risk-based-approach-selection","title":"Risk-Based Approach Selection","text":"<p>When selecting a scanning approach based on security risk profile:</p> Consideration Best Approach Maximum Security Kubernetes API Approach Universal Coverage Sidecar Container Approach Feature Compatibility Debug Container Approach Minimal Permissions Kubernetes API Approach CI/CD Integration All approaches equal"},{"location":"security/risk/mitigations/#selection-framework","title":"Selection Framework","text":"<p>The following framework helps select the appropriate approach based on security requirements:</p> <ol> <li>If all containers have shell access \u2192 Use Kubernetes API Approach</li> <li>If using Kubernetes 1.16+ with ephemeral containers \u2192 Consider Debug Container approach for distroless containers</li> <li>If need universal solution or restricted environments \u2192 Use Sidecar Container approach with enhanced security controls</li> </ol> <p>For critical or highly sensitive environments, consider implementing additional security controls regardless of chosen approach.</p>"},{"location":"security/risk/mitigations/#mitigation-implementation-guidelines","title":"Mitigation Implementation Guidelines","text":""},{"location":"security/risk/mitigations/#rbac-implementation","title":"RBAC Implementation","text":"<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  # Optional selector\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre>"},{"location":"security/risk/mitigations/#token-generation","title":"Token Generation","text":"<pre><code># Time-limited token generation (15 minutes)\nkubectl create token scanner-service-account \\\n  --duration=900s \\\n  --bound-object-kind=Pod \\\n  --bound-object-name=scanner-pod\n</code></pre>"},{"location":"security/risk/mitigations/#security-context_1","title":"Security Context","text":"<pre><code>securityContext:\n  runAsNonRoot: true\n  runAsUser: 10001\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop:\n    - ALL\n</code></pre>"},{"location":"security/risk/mitigations/#network-policy","title":"Network Policy","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\n  namespace: scanning-namespace\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []  # No inbound traffic allowed\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - port: 443\n      protocol: TCP\n</code></pre>"},{"location":"security/risk/mitigations/#conclusion","title":"Conclusion","text":"<p>By implementing these comprehensive mitigation strategies, the security risks associated with container scanning are significantly reduced across all scanning approaches. The Kubernetes API approach inherently requires fewer mitigations due to its lower risk profile, while the Debug Container and Sidecar Container approaches require more extensive mitigations to address their higher inherent risks.</p> <p>Organizations should select the scanning approach that best balances their security requirements with their operational needs, and implement the appropriate mitigations based on their risk tolerance and compliance requirements.</p>"},{"location":"security/risk/mitigations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Model - Risk assessment methodology</li> <li>Kubernetes API Approach - Kubernetes API approach risk analysis</li> <li>Debug Container Approach - Debug container approach risk analysis</li> <li>Sidecar Container Approach - Sidecar container approach risk analysis</li> <li>Security Recommendations - Security best practices and recommendations</li> </ul>"},{"location":"security/risk/model/","title":"Security Risk Model","text":"<p>This document outlines the risk assessment methodology and framework used to evaluate security risks for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/risk/model/#risk-assessment-methodology","title":"Risk Assessment Methodology","text":"<p>Our security risk assessment follows a structured methodology:</p> <ol> <li>Identify Assets: Identify the key assets and components being protected</li> <li>Threat Modeling: Identify potential threats to those assets</li> <li>Vulnerability Analysis: Evaluate vulnerabilities in the system</li> <li>Risk Calculation: Calculate risk based on likelihood and impact</li> <li>Mitigation Strategies: Define controls to reduce identified risks</li> <li>Residual Risk Assessment: Evaluate remaining risk after mitigation</li> </ol>"},{"location":"security/risk/model/#risk-classification-framework","title":"Risk Classification Framework","text":""},{"location":"security/risk/model/#likelihood-ratings","title":"Likelihood Ratings","text":"Rating Description Criteria Very Low Highly unlikely to occur Requires advanced capabilities, multiple failures of controls, or insider knowledge Low Unlikely but possible Requires specialized knowledge, deliberate action, and partial control failures Medium Reasonably possible Could occur with moderate effort, common security mistakes, or partial controls High Likely to occur Could occur with minimal effort, using known techniques, or basic security knowledge Very High Almost certain to occur Will occur with basic capabilities, minimal security knowledge, or common attack patterns"},{"location":"security/risk/model/#impact-ratings","title":"Impact Ratings","text":"Rating Description Criteria Very Low Minimal impact No sensitive data exposure, minimal operational disruption, easily remediated Low Limited impact Minor sensitive data exposure, limited operational impact, remediated with routine measures Medium Moderate impact Moderate sensitive data exposure, noticeable operational impact, requires formal response High Significant impact Significant sensitive data exposure, substantial operational disruption, requires incident response Very High Severe impact Critical sensitive data exposure, severe operational disruption, significant business impact"},{"location":"security/risk/model/#risk-matrix","title":"Risk Matrix","text":"Likelihood/Impact Very Low Low Medium High Very High Very Low Minimal Minimal Low Low Medium Low Minimal Low Medium Medium High Medium Low Medium Medium High High High Low Medium High High Critical Very High Medium High High Critical Critical"},{"location":"security/risk/model/#risk-acceptance-thresholds","title":"Risk Acceptance Thresholds","text":"Risk Level Description Required Action Minimal Acceptable risk No action required, routine monitoring Low Generally acceptable risk Standard controls, regular review Medium Attention required Enhanced controls, documented mitigation High Significant risk Substantial controls, formal risk acceptance Critical Unacceptable risk Must be mitigated before deployment"},{"location":"security/risk/model/#assets-under-evaluation","title":"Assets Under Evaluation","text":"<p>The key assets evaluated in our risk assessment include:</p> <ol> <li>Target Containers: The containers being scanned</li> <li>Kubernetes API Server: The API interface for Kubernetes operations</li> <li>Service Account Tokens: Authentication credentials</li> <li>Scanner Components: Software components performing scanning</li> <li>Scan Results: Output data from scanning operations</li> <li>Kubernetes RBAC: Authorization configuration</li> </ol>"},{"location":"security/risk/model/#threat-actors-and-capabilities","title":"Threat Actors and Capabilities","text":"<p>Our risk assessment considers various threat actors:</p> <ol> <li>External Attackers: Actors without internal access</li> <li>Malicious Insiders: Actors with some level of legitimate access</li> <li>Compromised CI/CD Systems: Build systems under attacker control</li> <li>Compromised Cluster Components: Kubernetes components under attacker control</li> </ol>"},{"location":"security/risk/model/#risk-categories","title":"Risk Categories","text":"<p>Risks are categorized into the following areas:</p> <ol> <li>Authentication and Authorization Risks: Related to access control</li> <li>Container Security Risks: Related to container isolation and integrity</li> <li>Operational Risks: Related to scanning operations</li> <li>Data Risks: Related to scan data and results</li> <li>Infrastructure Risks: Related to Kubernetes and underlying infrastructure</li> </ol>"},{"location":"security/risk/model/#risk-evaluation-process","title":"Risk Evaluation Process","text":"<p>Each scanning approach undergoes a systematic risk evaluation process:</p> <ol> <li>Component Identification: Identify all components and interfaces</li> <li>Privilege Analysis: Analyze required permissions and access levels</li> <li>Attack Surface Mapping: Map potential attack vectors</li> <li>Threat Scenario Development: Create realistic attack scenarios</li> <li>Control Evaluation: Assess existing security controls</li> <li>Gap Analysis: Identify control gaps and weaknesses</li> <li>Risk Determination: Calculate final risk ratings</li> </ol>"},{"location":"security/risk/model/#documentation-standards","title":"Documentation Standards","text":"<p>Risk assessment documentation includes:</p> <ol> <li>Risk Identification: Clear description of each risk</li> <li>Likelihood and Impact: Ratings with justification</li> <li>Existing Controls: Currently implemented mitigations</li> <li>Gaps: Identified control weaknesses</li> <li>Recommended Mitigations: Additional controls needed</li> <li>Residual Risk: Expected risk level after mitigations</li> <li>Acceptance Criteria: Requirements for accepting residual risk</li> </ol>"},{"location":"security/risk/model/#related-documentation","title":"Related Documentation","text":"<ul> <li>Risk Analysis by Approach - Specific risk analyses for each scanning approach</li> <li>Mitigations - Detailed mitigation strategies</li> <li>Threat Model - Detailed threat modeling approach</li> </ul>"},{"location":"security/risk/sidecar-container/","title":"Sidecar Container Approach Security Risk Analysis","text":"<p>This document provides a detailed security risk analysis of the Sidecar Container approach to container scanning, which uses shared process namespace between containers in the same pod.</p>"},{"location":"security/risk/sidecar-container/#security-model","title":"Security Model","text":"<p>The Sidecar Container approach modifies pod definitions to enable shared process namespace, allowing a scanner container to access the target container's processes and filesystem.</p>"},{"location":"security/risk/sidecar-container/#security-characteristics","title":"Security Characteristics","text":"Security Factor Rating Description Required Privileges \ud83d\udfe0 Moderate Requires process namespace sharing privileges Attack Surface \ud83d\udfe0 Moderate Permanently increased during pod lifetime Credential Exposure \ud83d\udfe2 Minimal Uses short-lived service account tokens Isolation Level \ud83d\udd34 Lower Permanently breaks container isolation Persistence Risk \ud83d\udfe0 Moderate Container persists during pod lifetime"},{"location":"security/risk/sidecar-container/#detailed-risk-assessment","title":"Detailed Risk Assessment","text":""},{"location":"security/risk/sidecar-container/#authentication-and-authorization-risks","title":"Authentication and Authorization Risks","text":"Risk Likelihood Impact Mitigation Token leakage Low Medium Short-lived tokens, minimal permissions Excessive permissions Medium Medium Careful RBAC implementation Authentication bypass Very Low High Standard Kubernetes authentication mechanisms"},{"location":"security/risk/sidecar-container/#operational-risks","title":"Operational Risks","text":"Risk Likelihood Impact Mitigation Sidecar persistence High Medium Container remains throughout pod lifecycle Resource contention Medium Medium Resource limits on sidecar containers Container interference Medium High Process and filesystem isolation broken"},{"location":"security/risk/sidecar-container/#container-risks","title":"Container Risks","text":"Risk Likelihood Impact Mitigation Container isolation breach High High Permanent process namespace sharing Sidecar container compromise Medium High Could affect target container Data exfiltration Medium Medium Shared process space increases risk"},{"location":"security/risk/sidecar-container/#risk-comparison","title":"Risk Comparison","text":"<p>When compared to other scanning approaches, the Sidecar Container approach presents:</p> <ul> <li>Higher risk than the Kubernetes API approach in terms of isolation, persistence, and container security principles</li> <li>Higher risk than the Debug Container approach in terms of persistence and isolation duration</li> </ul>"},{"location":"security/risk/sidecar-container/#risk-scenarios-and-mitigations","title":"Risk Scenarios and Mitigations","text":""},{"location":"security/risk/sidecar-container/#scenario-1-sidecar-to-target-container-access","title":"Scenario 1: Sidecar to Target Container Access","text":"<p>Risk: The sidecar container accesses or interferes with the target container processes.</p> <p>Mitigations:</p> <ol> <li>Sidecar container runs with minimal privileges</li> <li>Read-only filesystem access</li> <li>Non-root user execution</li> <li>Resource limits prevent denial of service</li> </ol> <p>Residual Risk: Medium-High - The shared process namespace fundamentally allows access between containers.</p>"},{"location":"security/risk/sidecar-container/#scenario-2-process-manipulation","title":"Scenario 2: Process Manipulation","text":"<p>Risk: Sidecar container manipulates processes in the target container.</p> <p>Mitigations:</p> <ol> <li>Non-privileged sidecar execution</li> <li>Process visibility only (limited manipulation capability)</li> <li>Security policies to restrict capabilities</li> <li>Monitoring for unexpected process activities</li> </ol> <p>Residual Risk: Medium - Process visibility doesn't necessarily grant full manipulation capabilities, but the risk remains higher than other approaches.</p>"},{"location":"security/risk/sidecar-container/#scenario-3-sidecar-container-compromise","title":"Scenario 3: Sidecar Container Compromise","text":"<p>Risk: The sidecar container itself is compromised during operation.</p> <p>Mitigations:</p> <ol> <li>Minimal tools and packages in sidecar container</li> <li>Non-privileged execution</li> <li>Limited network access</li> <li>Container security hardening</li> </ol> <p>Residual Risk: Medium-High - A compromised sidecar has access to the target container's processes and filesystem.</p>"},{"location":"security/risk/sidecar-container/#enterprise-security-considerations","title":"Enterprise Security Considerations","text":"<p>For enterprise deployments:</p> <ol> <li>Strict Pod Selection: Limit sidecar deployment to specific, non-sensitive applications</li> <li>Enhanced Monitoring: Implement detailed monitoring of sidecar containers</li> <li>Network Isolation: Apply strict network policies to sidecar-enabled pods</li> <li>Container Hardening: Use minimal, hardened images for sidecar containers</li> <li>Regular Security Reassessment: More frequent security reviews for sidecar deployments</li> </ol>"},{"location":"security/risk/sidecar-container/#conclusion","title":"Conclusion","text":"<p>The Sidecar Container approach presents the highest security risk profile among the available container scanning approaches. Its permanent breaking of container isolation principles and persistence throughout the pod lifecycle represent significant departures from container security best practices.</p> <p>While the approach provides universal container scanning capability (working with both standard and distroless containers), its security implications make it suitable only when other approaches are not viable, and with significant additional security controls in place.</p> <p>For security-sensitive environments, the Sidecar Container approach should be considered only as a last resort, with full documentation of the security implications, formal risk acceptance, and enhanced security monitoring.</p>"},{"location":"security/risk/sidecar-container/#related-documentation","title":"Related Documentation","text":"<ul> <li>Kubernetes API Approach - Comparison with standard container scanning</li> <li>Debug Container Approach - Comparison with debug container scanning</li> <li>Risk Mitigations - Comprehensive mitigation strategies</li> <li>Compliance Alignment - Compliance framework alignment</li> </ul>"},{"location":"security/threat-model/","title":"Security Threat Model","text":"<p>This document provides an overview of the threat model for the Secure CINC Auditor Kubernetes Container Scanning platform.</p>"},{"location":"security/threat-model/#introduction","title":"Introduction","text":"<p>A comprehensive threat model is essential for understanding potential security risks and implementing effective mitigations. This section outlines the threat modeling approach, identified threats, and mitigation strategies.</p>"},{"location":"security/threat-model/#threat-modeling-approach","title":"Threat Modeling Approach","text":"<p>Our threat modeling approach follows the STRIDE methodology to identify potential threats:</p> <ul> <li>Spoofing - Impersonating users or services</li> <li>Tampering - Modifying data or code</li> <li>Repudiation - Denying actions</li> <li>Information disclosure - Exposing sensitive information</li> <li>Denial of service - Disrupting services</li> <li>Elevation of privilege - Gaining unauthorized access</li> </ul>"},{"location":"security/threat-model/#key-threats-and-mitigations","title":"Key Threats and Mitigations","text":""},{"location":"security/threat-model/#identified-threats","title":"Identified Threats","text":"<ol> <li>Unauthorized Access to Container Contents</li> <li>Privilege Escalation</li> <li>Information Disclosure</li> <li>Denial of Service</li> <li>Lateral Movement</li> <li>Token Exposure</li> </ol>"},{"location":"security/threat-model/#mitigation-strategies","title":"Mitigation Strategies","text":"<p>Our comprehensive Threat Mitigations include:</p> <ul> <li>Strong RBAC controls</li> <li>Minimal container capabilities</li> <li>Limited access duration through short-lived tokens</li> <li>Namespace isolation for multi-tenant environments</li> <li>Resource limits on all scanner components</li> <li>Network policies to restrict communication</li> </ul>"},{"location":"security/threat-model/#approach-specific-threat-analysis","title":"Approach-Specific Threat Analysis","text":"<p>Each scanning approach has unique threat characteristics:</p> Threat Category Kubernetes API Approach Debug Container Approach Sidecar Container Approach Attack Surface \ud83d\udfe2 Minimal \ud83d\udfe0 Temporarily increased \ud83d\udfe0 Moderately increased Container Isolation \ud83d\udfe2 Fully preserved \ud83d\udfe0 Temporarily broken \ud83d\udfe0 Partially broken Token Exposure Risk \ud83d\udfe2 Low \ud83d\udfe2 Low \ud83d\udfe2 Low Lateral Movement Risk \ud83d\udfe2 Low \ud83d\udfe0 Medium \ud83d\udfe0 Medium"},{"location":"security/threat-model/#defense-in-depth-strategy","title":"Defense-in-Depth Strategy","text":"<p>Our security approach implements defense-in-depth with multiple security layers:</p> <ol> <li>Authentication Layer</li> <li>Time-limited tokens</li> <li> <p>Service account isolation</p> </li> <li> <p>Authorization Layer</p> </li> <li>Fine-grained RBAC</li> <li> <p>Minimal permission scope</p> </li> <li> <p>Isolation Layer</p> </li> <li>Namespace boundaries</li> <li> <p>Container isolation</p> </li> <li> <p>Monitoring Layer</p> </li> <li>Comprehensive logging</li> <li>Access monitoring</li> </ol>"},{"location":"security/threat-model/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Principles - Core security principles</li> <li>Risk Analysis - Analysis of security risks and mitigations</li> <li>Compliance - Compliance frameworks alignment</li> <li>Security Recommendations - Best practices and guidelines</li> </ul>"},{"location":"security/threat-model/attack-vectors/","title":"Attack Vectors Analysis","text":"<p>This document analyzes potential attack vectors against the Secure CINC Auditor Kubernetes Container Scanning solution, with a focus on their likelihood, impact, and implemented mitigations.</p>"},{"location":"security/threat-model/attack-vectors/#unauthorized-access-to-container-contents","title":"Unauthorized Access to Container Contents","text":""},{"location":"security/threat-model/attack-vectors/#description","title":"Description","text":"<p>This attack vector involves unauthorized users gaining access to container contents, potentially exposing sensitive data, configurations, or intellectual property.</p>"},{"location":"security/threat-model/attack-vectors/#attack-paths","title":"Attack Paths","text":"<ol> <li>Compromised Service Account: Attacker obtains a service account token with container access permissions</li> <li>RBAC Misconfiguration: Overly permissive RBAC roles grant unnecessary access</li> <li>Authentication Bypass: Exploitation of authentication mechanisms to gain unauthorized access</li> <li>Token Theft: Interception or exfiltration of valid access tokens</li> </ol>"},{"location":"security/threat-model/attack-vectors/#mitigations","title":"Mitigations","text":"Mitigation Implementation Effectiveness Least Privilege RBAC Service accounts with minimal permissions High Time-limited Tokens Tokens expire after 15-30 minutes High Namespace Isolation RBAC roles limited to specific namespaces Medium-High Resource Name Constraints Access limited to specific pods High Audit Logging Comprehensive logging of all access attempts Medium"},{"location":"security/threat-model/attack-vectors/#approach-specific-considerations","title":"Approach-Specific Considerations","text":"Scanning Approach Attack Vector Exposure Additional Mitigations Kubernetes API Low Standard API access controls Debug Container Medium Ephemeral container lifecycle management Sidecar Container Medium-High Process namespace restrictions, security contexts"},{"location":"security/threat-model/attack-vectors/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"security/threat-model/attack-vectors/#description_1","title":"Description","text":"<p>This attack vector involves attackers gaining higher privileges than intended, potentially allowing them to modify resources, access sensitive data, or compromise the cluster.</p>"},{"location":"security/threat-model/attack-vectors/#attack-paths_1","title":"Attack Paths","text":"<ol> <li>Container Escape: Breaking out of container boundaries to access host or other containers</li> <li>Permission Escalation: Leveraging permissions to gain additional access</li> <li>Capability Abuse: Exploiting container capabilities to perform privileged operations</li> <li>Vulnerable Components: Exploiting vulnerabilities in scanner or Kubernetes components</li> </ol>"},{"location":"security/threat-model/attack-vectors/#mitigations_1","title":"Mitigations","text":"Mitigation Implementation Effectiveness Non-privileged Execution Scanner runs as non-root user High Minimal Capabilities Containers run with minimal Linux capabilities High Read-only Filesystem Scanner uses read-only root filesystem Medium-High Security Contexts Strict security contexts for all containers High No Host Mounts Containers have no access to host filesystem High"},{"location":"security/threat-model/attack-vectors/#approach-specific-considerations_1","title":"Approach-Specific Considerations","text":"Scanning Approach Attack Vector Exposure Additional Mitigations Kubernetes API Low Standard container boundaries maintained Debug Container Medium Limited debug container capabilities Sidecar Container Medium-High Process isolation controls, additional security contexts"},{"location":"security/threat-model/attack-vectors/#information-disclosure","title":"Information Disclosure","text":""},{"location":"security/threat-model/attack-vectors/#description_2","title":"Description","text":"<p>This attack vector involves unauthorized access to sensitive information, such as container contents, scanning results, or security findings.</p>"},{"location":"security/threat-model/attack-vectors/#attack-paths_2","title":"Attack Paths","text":"<ol> <li>Result Interception: Capturing scan results during transmission</li> <li>Log Analysis: Extracting sensitive information from logs</li> <li>Token Extraction: Obtaining service account tokens from exposed locations</li> <li>Scanning Process Analysis: Analyzing scanner behavior to infer container contents</li> </ol>"},{"location":"security/threat-model/attack-vectors/#mitigations_2","title":"Mitigations","text":"Mitigation Implementation Effectiveness TLS Communication All API communication encrypted High Secure Result Handling Proper encryption and access controls for results Medium-High Minimal Logging Limited sensitive data in logs Medium Token Security Secure handling of service account tokens High Network Policies Restricted communication between components Medium-High"},{"location":"security/threat-model/attack-vectors/#approach-specific-considerations_2","title":"Approach-Specific Considerations","text":"Scanning Approach Attack Vector Exposure Additional Mitigations Kubernetes API Low Standard API security controls Debug Container Medium Ephemeral container network isolation Sidecar Container Medium Pod-level network policies"},{"location":"security/threat-model/attack-vectors/#denial-of-service","title":"Denial of Service","text":""},{"location":"security/threat-model/attack-vectors/#description_3","title":"Description","text":"<p>This attack vector involves disrupting scanning operations or targeting container workloads through resource exhaustion or service interruption.</p>"},{"location":"security/threat-model/attack-vectors/#attack-paths_3","title":"Attack Paths","text":"<ol> <li>Resource Exhaustion: Consuming excessive CPU, memory, or I/O resources</li> <li>Long-running Scans: Initiating many concurrent or long-running scans</li> <li>API Flooding: Overwhelming the Kubernetes API server with requests</li> <li>Scanner Process Disruption: Interfering with scanner processes</li> </ol>"},{"location":"security/threat-model/attack-vectors/#mitigations_3","title":"Mitigations","text":"Mitigation Implementation Effectiveness Resource Limits CPU and memory limits on scanner containers High Rate Limiting Limiting scan frequency and concurrency Medium-High Timeouts Automatic termination of long-running scans Medium Graceful Failure Handling Proper error handling for disrupted scans Medium Dedicated Namespaces Isolation of scanner resources Medium-High"},{"location":"security/threat-model/attack-vectors/#approach-specific-considerations_3","title":"Approach-Specific Considerations","text":"Scanning Approach Attack Vector Exposure Additional Mitigations Kubernetes API Low API request throttling Debug Container Medium Ephemeral container resource constraints Sidecar Container Medium Pod-level resource quotas"},{"location":"security/threat-model/attack-vectors/#mitre-attck-mapping","title":"MITRE ATT&amp;CK Mapping","text":"<p>The scanning approaches help mitigate several container-related attack techniques from the MITRE ATT&amp;CK framework:</p> ATT&amp;CK Technique Description Mitigations T1610 - Deploy Container Attackers deploy malicious containers Strong RBAC prevents unauthorized container deployment T1613 - Container Discovery Discovery of container environment Limited visibility to container resources T1543.005 - Container Service Creating persistent container services Prevents modification of container configurations T1552 - Unsecured Credentials Discovering credentials in containers Short-lived tokens prevent credential theft T1611 - Container Escape Breaking out of container isolation Minimal privileges and container hardening"},{"location":"security/threat-model/attack-vectors/#attack-surface-comparison","title":"Attack Surface Comparison","text":"<p>When comparing the attack surface of each scanning approach:</p> Attack Surface Factor Kubernetes API Approach Debug Container Approach Sidecar Container Approach Number of Components \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Added Container Processes \ud83d\udfe2 None \ud83d\udfe0 Temporary \ud83d\udd34 Permanent Required Permissions \ud83d\udfe2 Minimal \ud83d\udfe0 Moderate \ud83d\udfe0 Moderate Network Interfaces \ud83d\udfe2 Standard API only \ud83d\udfe2 Standard API only \ud83d\udfe2 Standard API only Duration of Exposure \ud83d\udfe2 Scan duration only \ud83d\udfe0 Scan duration plus setup \ud83d\udd34 Pod lifetime"},{"location":"security/threat-model/attack-vectors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Lateral Movement - Analysis of lateral movement risks</li> <li>Token Exposure - Analysis of token exposure risks</li> <li>Threat Mitigations - Comprehensive mitigation strategies</li> <li>Security Risk Analysis - Detailed risk assessment</li> </ul>"},{"location":"security/threat-model/inventory/","title":"Security Threat Model Directory","text":"<p>This directory contains documentation on the security threat modeling for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/threat-model/inventory/#available-documents","title":"Available Documents","text":"Document Description Index Overview of security threat model Attack Vectors Analysis of potential attack vectors Lateral Movement Analysis of lateral movement risks Token Exposure Analysis of token exposure risks Threat Mitigations Comprehensive mitigation strategies"},{"location":"security/threat-model/inventory/#related-directories","title":"Related Directories","text":"Directory Description Security Principles Core security principles Risk Analysis Security risk assessment Compliance Compliance framework alignment Recommendations Security best practices and recommendations"},{"location":"security/threat-model/lateral-movement/","title":"Lateral Movement Analysis","text":"<p>This document analyzes lateral movement risks in the Secure CINC Auditor Kubernetes Container Scanning solution, focusing on how an attacker might move from one compromised component to others.</p>"},{"location":"security/threat-model/lateral-movement/#lateral-movement-risks","title":"Lateral Movement Risks","text":"<p>Lateral movement involves an attacker expanding their access from an initial foothold to other components within the Kubernetes cluster. In the context of container scanning, this could involve:</p> <ol> <li>Moving from scanner access to wider pod/namespace access</li> <li>Accessing secrets or sensitive configuration data</li> <li>Gaining access to other containers in the cluster</li> <li>Escalating privileges to modify resources or access host resources</li> </ol>"},{"location":"security/threat-model/lateral-movement/#rbac-based-prevention","title":"RBAC-Based Prevention","text":"<p>The RBAC configuration in our solution prevents lateral movement through careful permission scoping:</p>"},{"location":"security/threat-model/lateral-movement/#no-access-to-secrets","title":"No Access to Secrets","text":"<pre><code># What's NOT in our RBAC configuration:\n# We explicitly do not grant access to secrets\napiGroups: [\"\"]\nresources: [\"secrets\"]\nverbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>Without secrets access, attackers cannot retrieve:</p> <ul> <li>API credentials</li> <li>Encryption keys</li> <li>Database passwords</li> <li>Other sensitive information</li> </ul>"},{"location":"security/threat-model/lateral-movement/#no-access-to-configmaps","title":"No Access to ConfigMaps","text":"<pre><code># What's NOT in our RBAC configuration:\n# We explicitly do not grant access to configmaps\napiGroups: [\"\"]\nresources: [\"configmaps\"]\nverbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>Without configmap access, attackers cannot retrieve:</p> <ul> <li>Configuration data</li> <li>Connection strings</li> <li>Environment settings</li> <li>Other non-sensitive but useful information</li> </ul>"},{"location":"security/threat-model/lateral-movement/#no-ability-to-create-new-resources","title":"No Ability to Create New Resources","text":"<pre><code># What's NOT in our RBAC configuration:\n# We explicitly do not grant resource creation permissions\napiGroups: [\"\"]\nresources: [\"pods\"]\nverbs: [\"create\", \"update\", \"patch\", \"delete\"]\n</code></pre> <p>Without resource creation permissions, attackers cannot:</p> <ul> <li>Deploy new malicious pods</li> <li>Modify existing deployments</li> <li>Create persistent access mechanisms</li> <li>Deploy privileged containers</li> </ul>"},{"location":"security/threat-model/lateral-movement/#no-ability-to-modify-service-accounts","title":"No Ability to Modify Service Accounts","text":"<pre><code># What's NOT in our RBAC configuration:\n# We explicitly do not grant service account management\napiGroups: [\"\"]\nresources: [\"serviceaccounts\"]\nverbs: [\"get\", \"list\", \"create\", \"update\", \"patch\", \"delete\"]\n</code></pre> <p>Without service account management permissions, attackers cannot:</p> <ul> <li>Create new service accounts</li> <li>Modify existing service account permissions</li> <li>Access service account tokens</li> <li>Create persistence through service account changes</li> </ul>"},{"location":"security/threat-model/lateral-movement/#approach-specific-lateral-movement-risks","title":"Approach-Specific Lateral Movement Risks","text":"<p>Each scanning approach has different lateral movement characteristics:</p>"},{"location":"security/threat-model/lateral-movement/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"<p>Risk Level: Low</p> <p>Key characteristics:</p> <ul> <li>Standard API access only</li> <li>No additional containers deployed</li> <li>Container boundaries fully preserved</li> <li>Least privilege implementation</li> </ul> <p>Potential lateral movement paths:</p> <ul> <li>Limited to accessing other pods with the same RBAC permissions</li> <li>No process or network-based lateral movement paths</li> </ul>"},{"location":"security/threat-model/lateral-movement/#debug-container-approach","title":"Debug Container Approach","text":"<p>Risk Level: Medium</p> <p>Key characteristics:</p> <ul> <li>Ephemeral debug container with process namespace access</li> <li>Temporary existence</li> <li>Access to target container filesystem</li> </ul> <p>Potential lateral movement paths:</p> <ul> <li>Access to target container files and processes</li> <li>Potential for credential harvesting from process memory</li> <li>Limited by ephemeral nature of debug container</li> </ul>"},{"location":"security/threat-model/lateral-movement/#sidecar-container-approach","title":"Sidecar Container Approach","text":"<p>Risk Level: Medium-High</p> <p>Key characteristics:</p> <ul> <li>Shared process namespace with target container</li> <li>Persistent existence throughout pod lifecycle</li> <li>Direct access to target container processes and filesystem</li> </ul> <p>Potential lateral movement paths:</p> <ul> <li>Complete access to target container memory, files, and processes</li> <li>Potential for credential harvesting from process memory</li> <li>Network visibility from container perspective</li> <li>Persistent access to container resources</li> </ul>"},{"location":"security/threat-model/lateral-movement/#namespace-isolation","title":"Namespace Isolation","text":"<p>Namespace isolation provides an additional barrier to lateral movement:</p> <ol> <li>Resource Scope: RBAC roles are limited to specific namespaces</li> <li>Network Boundaries: Network policies can limit cross-namespace communication</li> <li>Resource Isolation: Resources from different namespaces are isolated</li> <li>Service Segregation: Services are namespace-scoped by default</li> </ol>"},{"location":"security/threat-model/lateral-movement/#network-based-lateral-movement-prevention","title":"Network-Based Lateral Movement Prevention","text":"<p>Network policies can further restrict lateral movement:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\n  namespace: scanning-namespace\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress: []  # No inbound traffic allowed\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - port: 443\n      protocol: TCP\n</code></pre> <p>This network policy:</p> <ul> <li>Restricts scanner pods from connecting to other pods</li> <li>Only allows API server communication</li> <li>Prevents network-based lateral movement</li> <li>Blocks external network access</li> </ul>"},{"location":"security/threat-model/lateral-movement/#process-based-lateral-movement-prevention","title":"Process-Based Lateral Movement Prevention","text":"<p>For approaches that involve process interaction (Debug Container and Sidecar Container):</p> <ol> <li>Non-root Execution: Scanner containers run as non-root users</li> <li>Minimal Capabilities: Scanner containers have minimal Linux capabilities</li> <li>Security Contexts: Strict security contexts prevent privilege escalation</li> <li>Read-only Filesystem: Prevents modification of scanner container files</li> </ol>"},{"location":"security/threat-model/lateral-movement/#mitigation-recommendations","title":"Mitigation Recommendations","text":"<p>To further reduce lateral movement risks:</p> <ol> <li>Dedicated Scanning Namespaces: Use dedicated namespaces for scanning infrastructure</li> <li>Network Segmentation: Implement strict network policies</li> <li>Just-in-Time Access: Generate short-lived tokens only when needed</li> <li>Monitoring and Alerting: Implement monitoring for unusual access patterns</li> <li>Regular Audit: Review RBAC permissions and scan operations logs</li> </ol> <p>For the Sidecar Container approach specifically:</p> <ol> <li>Enhanced Container Hardening: Additional security measures for sidecar containers</li> <li>Process Monitoring: Monitor for unusual process access patterns</li> <li>Resource Isolation: Strict resource limits to contain potential compromise</li> </ol>"},{"location":"security/threat-model/lateral-movement/#related-documentation","title":"Related Documentation","text":"<ul> <li>Attack Vectors - Analysis of general attack vectors</li> <li>Token Exposure - Analysis of token exposure risks</li> <li>Threat Mitigations - Comprehensive mitigation strategies</li> <li>Risk Analysis - Detailed risk assessment</li> </ul>"},{"location":"security/threat-model/threat-mitigations/","title":"Threat Mitigations","text":"<p>This document outlines the comprehensive mitigations implemented to address the threats identified in the threat model for the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"security/threat-model/threat-mitigations/#spoofing-mitigations","title":"Spoofing Mitigations","text":"<p>Spoofing involves impersonating a legitimate user, system, or component.</p>"},{"location":"security/threat-model/threat-mitigations/#identity-controls","title":"Identity Controls","text":"Mitigation Implementation Target Threats Service Account Authentication Dedicated service accounts for scanner components Impersonation attacks Short-lived Tokens Tokens expire after 15-30 minutes Stolen credential reuse TLS Client Verification API server certificate validation Man-in-the-middle attacks Token Binding Tokens bound to specific pods or operations Token reuse across contexts"},{"location":"security/threat-model/threat-mitigations/#configuration-example","title":"Configuration Example","text":"<pre><code># Service account configuration\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: scanner-service-account\n  namespace: scanner-namespace\n  annotations:\n    kubernetes.io/enforce-mountable-secrets: \"true\"\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#tampering-mitigations","title":"Tampering Mitigations","text":"<p>Tampering involves malicious modification of data or code.</p>"},{"location":"security/threat-model/threat-mitigations/#data-integrity-controls","title":"Data Integrity Controls","text":"Mitigation Implementation Target Threats Read-only Filesystem Immutable container filesystems Scanner code modification Signed Scanner Images Image signature verification Supply chain attacks Result Validation Cryptographic validation of scan results Result tampering Non-privileged Execution No ability to modify container state Target container modification"},{"location":"security/threat-model/threat-mitigations/#configuration-example_1","title":"Configuration Example","text":"<pre><code># Pod security context\nsecurityContext:\n  readOnlyRootFilesystem: true\n  runAsNonRoot: true\n  runAsUser: 10001\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#repudiation-mitigations","title":"Repudiation Mitigations","text":"<p>Repudiation involves denying that an action was performed.</p>"},{"location":"security/threat-model/threat-mitigations/#audit-controls","title":"Audit Controls","text":"Mitigation Implementation Target Threats API Audit Logging Comprehensive Kubernetes API auditing Unauthorized access denial Scanner Logging Detailed scanner operation logs Scan tampering denial Unique Identifiers Unique scan and operation IDs Activity attribution Result Signatures Cryptographic signing of scan results Result authenticity verification"},{"location":"security/threat-model/threat-mitigations/#configuration-example_2","title":"Configuration Example","text":"<pre><code># API server audit policy\napiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n- level: RequestResponse\n  resources:\n  - group: \"\"\n    resources: [\"pods/exec\"]\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#information-disclosure-mitigations","title":"Information Disclosure Mitigations","text":"<p>Information disclosure involves unauthorized access to sensitive information.</p>"},{"location":"security/threat-model/threat-mitigations/#data-protection-controls","title":"Data Protection Controls","text":"Mitigation Implementation Target Threats TLS Encryption Encrypted API server communication Network eavesdropping Minimal Container Access Access only to required containers Sensitive data exposure Result Encryption Encryption of scan results Unauthorized result access Log Sanitization Removal of sensitive data from logs Log-based information leakage"},{"location":"security/threat-model/threat-mitigations/#configuration-example_3","title":"Configuration Example","text":"<pre><code># Network policy for scanner pods\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      role: scanner\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: kube-system\n    ports:\n    - port: 443\n      protocol: TCP\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#denial-of-service-mitigations","title":"Denial of Service Mitigations","text":"<p>Denial of service involves disrupting services or resource availability.</p>"},{"location":"security/threat-model/threat-mitigations/#availability-controls","title":"Availability Controls","text":"Mitigation Implementation Target Threats Resource Limits CPU and memory constraints Resource exhaustion attacks Scanner Timeouts Automatic termination of long-running scans Scan operation hanging Rate Limiting Limiting scan frequency API server flooding Graceful Error Handling Proper handling of failures Service disruption attacks"},{"location":"security/threat-model/threat-mitigations/#configuration-example_4","title":"Configuration Example","text":"<pre><code># Resource limits for scanner containers\nresources:\n  limits:\n    cpu: \"500m\"\n    memory: \"512Mi\"\n  requests:\n    cpu: \"100m\"\n    memory: \"128Mi\"\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#elevation-of-privilege-mitigations","title":"Elevation of Privilege Mitigations","text":"<p>Elevation of privilege involves gaining access or capabilities beyond what is authorized.</p>"},{"location":"security/threat-model/threat-mitigations/#privilege-controls","title":"Privilege Controls","text":"Mitigation Implementation Target Threats Least Privilege RBAC Minimal permissions for service accounts Permission escalation Non-root Execution Containers run as non-root users Root access exploitation Capability Restrictions Dropping all unnecessary capabilities Linux capability abuse No Privilege Escalation allowPrivilegeEscalation: false Container breakout"},{"location":"security/threat-model/threat-mitigations/#configuration-example_5","title":"Configuration Example","text":"<pre><code># Security context with privilege restrictions\nsecurityContext:\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop:\n    - ALL\n  seccompProfile:\n    type: RuntimeDefault\n</code></pre>"},{"location":"security/threat-model/threat-mitigations/#approach-specific-mitigations","title":"Approach-Specific Mitigations","text":""},{"location":"security/threat-model/threat-mitigations/#kubernetes-api-approach","title":"Kubernetes API Approach","text":"Threat Category Specific Mitigations Spoofing Standard API authentication, no additional requirements Tampering No container modification, standard controls sufficient Information Disclosure Limited container visibility through exec operations only Elevation of Privilege Standard RBAC controls, no additional attack paths"},{"location":"security/threat-model/threat-mitigations/#debug-container-approach","title":"Debug Container Approach","text":"Threat Category Specific Mitigations Spoofing Standard mitigations plus ephemeral container authentication Tampering Read-only filesystem access to target container Information Disclosure Short-lived access, automatic container removal Elevation of Privilege Strict security context for ephemeral containers"},{"location":"security/threat-model/threat-mitigations/#sidecar-container-approach","title":"Sidecar Container Approach","text":"Threat Category Specific Mitigations Spoofing Standard mitigations plus process namespace controls Tampering Read-only filesystem access, no modification capabilities Information Disclosure Process namespace security contexts, enhanced monitoring Elevation of Privilege Enhanced isolation controls, strict security policies"},{"location":"security/threat-model/threat-mitigations/#defense-in-depth-strategy","title":"Defense-in-Depth Strategy","text":"<p>Our mitigation strategy implements defense-in-depth with multiple security layers:</p>"},{"location":"security/threat-model/threat-mitigations/#authentication-layer","title":"Authentication Layer","text":"<ul> <li>Service account separation</li> <li>Time-limited tokens</li> <li>Audience-bound tokens</li> <li>TLS client validation</li> </ul>"},{"location":"security/threat-model/threat-mitigations/#authorization-layer","title":"Authorization Layer","text":"<ul> <li>Namespace-scoped RBAC</li> <li>Resource-specific permissions</li> <li>Resource name constraints</li> <li>Verb-limited operations</li> </ul>"},{"location":"security/threat-model/threat-mitigations/#isolation-layer","title":"Isolation Layer","text":"<ul> <li>Pod security contexts</li> <li>Network policies</li> <li>Non-privileged execution</li> <li>Container hardening</li> </ul>"},{"location":"security/threat-model/threat-mitigations/#monitoring-layer","title":"Monitoring Layer","text":"<ul> <li>API server audit logging</li> <li>Scanner operation logging</li> <li>Token usage monitoring</li> <li>Abnormal access detection</li> </ul>"},{"location":"security/threat-model/threat-mitigations/#cicd-pipeline-security","title":"CI/CD Pipeline Security","text":"<p>Special considerations for CI/CD pipeline integration:</p> <ol> <li>Variable Masking: Configure CI/CD systems to mask token values</li> <li>Pipeline-scoped Tokens: Generate unique tokens for each pipeline run</li> <li>Immutable Reference Images: Use immutable image references with digests</li> <li>Pipeline-specific Service Accounts: Dedicated service accounts per pipeline</li> <li>Scanner Verification: Verify scanner image integrity before use</li> </ol>"},{"location":"security/threat-model/threat-mitigations/#conclusion","title":"Conclusion","text":"<p>The comprehensive threat mitigation strategy addresses the key threats identified in the threat model. By implementing multiple layers of protection and specific controls for each threat category, the solution provides a robust security posture for container scanning operations.</p> <p>The Kubernetes API Approach inherently requires fewer additional mitigations, while the Debug Container and Sidecar Container approaches require more extensive controls to address their expanded attack surface and isolation implications.</p>"},{"location":"security/threat-model/threat-mitigations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Attack Vectors - Analysis of attack vectors</li> <li>Lateral Movement - Analysis of lateral movement risks</li> <li>Token Exposure - Analysis of token exposure risks</li> <li>Risk Mitigations - Detailed risk mitigation strategies</li> </ul>"},{"location":"security/threat-model/token-exposure/","title":"Token Exposure Analysis","text":"<p>This document analyzes the risks associated with service account token exposure in the Secure CINC Auditor Kubernetes Container Scanning solution, and the mitigations implemented to address these risks.</p>"},{"location":"security/threat-model/token-exposure/#token-exposure-risks","title":"Token Exposure Risks","text":"<p>Service account tokens are used to authenticate with the Kubernetes API server. If exposed, these tokens could potentially allow unauthorized access to Kubernetes resources.</p>"},{"location":"security/threat-model/token-exposure/#limited-token-capabilities","title":"Limited Token Capabilities","text":"<p>If a token is exposed, the attacker can only:</p> <ol> <li>List pods in the target namespace</li> <li>Execute commands in specifically allowed containers</li> <li>View logs of specifically allowed containers</li> </ol> <p>The token cannot be used to:</p> <ol> <li>Create, modify, or delete any resources</li> <li>Access any other containers</li> <li>Access any cluster-wide information</li> <li>Escalate privileges</li> </ol>"},{"location":"security/threat-model/token-exposure/#potential-token-exposure-scenarios","title":"Potential Token Exposure Scenarios","text":""},{"location":"security/threat-model/token-exposure/#cicd-pipeline-exposure","title":"CI/CD Pipeline Exposure","text":"<p>Scenario: Tokens stored in CI/CD variables are exposed through pipeline logs or configuration.</p> <p>Mitigations:</p> <ul> <li>Short-lived tokens generated for each pipeline run</li> <li>Masked variables in CI/CD systems</li> <li>Tokens automatically expire after pipeline completion</li> <li>Just-in-time token generation</li> </ul>"},{"location":"security/threat-model/token-exposure/#scanner-process-compromise","title":"Scanner Process Compromise","text":"<p>Scenario: The scanner process itself is compromised, exposing the token it uses.</p> <p>Mitigations:</p> <ul> <li>Token has minimal permissions through RBAC</li> <li>Token expires automatically (default: 15 minutes)</li> <li>Network policies restrict token usage</li> <li>Comprehensive audit logging of token usage</li> </ul>"},{"location":"security/threat-model/token-exposure/#log-exposure","title":"Log Exposure","text":"<p>Scenario: Tokens are accidentally logged in debug output or error messages.</p> <p>Mitigations:</p> <ul> <li>Sanitized logging to prevent token logging</li> <li>Token format detection in log pipelines</li> <li>Automatic token revocation if detected in logs</li> <li>Log access restrictions</li> </ul>"},{"location":"security/threat-model/token-exposure/#network-interception","title":"Network Interception","text":"<p>Scenario: Tokens are intercepted during transmission between components.</p> <p>Mitigations:</p> <ul> <li>TLS encryption for all API communication</li> <li>Internal Kubernetes DNS for service communication</li> <li>Network policies restricting communication paths</li> <li>Token bound to specific service accounts</li> </ul>"},{"location":"security/threat-model/token-exposure/#time-limited-token-implementation","title":"Time-Limited Token Implementation","text":"<p>A key mitigation for token exposure is the use of short-lived tokens:</p> <pre><code># Generate a token valid for 15 minutes\nkubectl create token scanner-service-account \\\n  --duration=900s \\\n  --bound-object-kind=Pod \\\n  --bound-object-name=scanner-pod\n</code></pre> <p>This token:</p> <ul> <li>Automatically expires after 15 minutes</li> <li>Is bound to a specific pod</li> <li>Cannot be used from other contexts</li> <li>Does not need manual revocation</li> </ul>"},{"location":"security/threat-model/token-exposure/#rbac-limitations","title":"RBAC Limitations","text":"<p>The following RBAC configuration limits what can be done with an exposed token:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: target-namespace\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  # Optional: further restrict by resource name or label selector\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"app-pod-1\", \"app-pod-2\"]\n</code></pre> <p>This configuration:</p> <ul> <li>Limits access to specific pods</li> <li>Only allows execution, not modification</li> <li>Is namespace-scoped</li> <li>Provides no access to secrets or other resources</li> </ul>"},{"location":"security/threat-model/token-exposure/#token-storage-recommendations","title":"Token Storage Recommendations","text":"<p>To minimize token exposure risk:</p> <ol> <li>Ephemeral Storage: Store tokens in memory, not on disk</li> <li>Environment Variables: Use environment variables instead of files when possible</li> <li>Secure Distribution: Implement secure token distribution mechanisms</li> <li>No Caching: Generate new tokens for each operation, don't cache tokens</li> <li>Masked Variables: Mask tokens in CI/CD variables and logs</li> </ol>"},{"location":"security/threat-model/token-exposure/#token-exposure-detection","title":"Token Exposure Detection","text":"<p>Mechanisms to detect potential token exposure:</p> <ol> <li>Audit Logging: Enable comprehensive API server audit logging</li> <li>Usage Monitoring: Monitor token usage patterns for anomalies</li> <li>Access Analysis: Analyze access patterns for unusual behavior</li> <li>Failed Authentication Monitoring: Alert on multiple failed authentication attempts</li> </ol>"},{"location":"security/threat-model/token-exposure/#cicd-system-integration","title":"CI/CD System Integration","text":"<p>Best practices for token handling in CI/CD systems:</p> <ol> <li>Masked Variables: Configure CI/CD systems to mask token values</li> <li>Pipeline-scoped Tokens: Generate unique tokens for each pipeline run</li> <li>Token Rotation: Rotate service accounts regularly</li> <li>Just-in-Time Generation: Generate tokens only when needed, not in advance</li> <li>Post-pipeline Cleanup: Ensure tokens are not persisted after pipeline completion</li> </ol>"},{"location":"security/threat-model/token-exposure/#approach-specific-considerations","title":"Approach-Specific Considerations","text":"<p>All scanning approaches use the same token mechanism with similar exposure risks and mitigations. There are no significant differences in token handling between approaches.</p>"},{"location":"security/threat-model/token-exposure/#related-documentation","title":"Related Documentation","text":"<ul> <li>Attack Vectors - Analysis of general attack vectors</li> <li>Lateral Movement - Analysis of lateral movement risks</li> <li>Threat Mitigations - Comprehensive mitigation strategies</li> <li>Ephemeral Credentials - Details on ephemeral credential implementation</li> </ul>"},{"location":"service-accounts/","title":"Service Account Configuration","text":"<p>Directory Inventory</p> <p>See the Service Accounts Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This guide covers the setup and management of service accounts for secure container scanning.</p>"},{"location":"service-accounts/#basic-service-account-setup","title":"Basic Service Account Setup","text":"<p>Create a dedicated service account for InSpec scanning:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: inspec-scanner\n  namespace: inspec-test\n  labels:\n    app: inspec-scanner\n    purpose: security-scanning\n</code></pre>"},{"location":"service-accounts/#serviceaccount-naming-conventions","title":"ServiceAccount Naming Conventions","text":"<p>Consider using a consistent naming convention for scanner service accounts:</p> <ul> <li>Dedicated namespace: <code>inspec-scanner</code></li> <li>CI/CD pipelines: <code>inspec-scanner-{pipeline-id}</code></li> <li>Team-specific: <code>inspec-scanner-{team-name}</code></li> </ul>"},{"location":"service-accounts/#service-account-annotations","title":"Service Account Annotations","text":"<p>You can add annotations to service accounts for additional metadata:</p> <pre><code>metadata:\n  annotations:\n    description: \"Service account for InSpec container scanning\"\n    owner: \"security-team\"\n    expires: \"2025-12-31\"\n</code></pre>"},{"location":"service-accounts/#token-related-serviceaccount-features","title":"Token-Related ServiceAccount Features","text":"<p>In Kubernetes 1.24+, service accounts no longer automatically get long-lived token secrets. You need to explicitly create tokens.</p>"},{"location":"service-accounts/#for-short-lived-tokens-recommended","title":"For Short-Lived Tokens (Recommended)","text":"<p>Use the Kubernetes API to create short-lived tokens:</p> <pre><code>kubectl create token inspec-scanner -n inspec-test\n</code></pre> <p>This creates a token with a default expiration of 1 hour.</p>"},{"location":"service-accounts/#for-long-lived-tokens-use-with-caution","title":"For Long-Lived Tokens (Use With Caution)","text":"<p>Create a token secret with an explicit reference to the service account:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: inspec-scanner-token\n  namespace: inspec-test\n  annotations:\n    kubernetes.io/service-account.name: inspec-scanner\ntype: kubernetes.io/service-account-token\n</code></pre>"},{"location":"service-accounts/#service-account-auditing","title":"Service Account Auditing","text":"<p>Regularly audit your service accounts:</p> <pre><code># List all service accounts\nkubectl get serviceaccounts --all-namespaces\n\n# Check token secrets for a service account\nkubectl get secrets -n inspec-test -o json | jq '.items[] | select(.metadata.annotations.\"kubernetes.io/service-account.name\"==\"inspec-scanner\")'\n</code></pre>"},{"location":"service-accounts/#rotating-service-accounts","title":"Rotating Service Accounts","text":"<p>For enhanced security, rotate service accounts regularly:</p> <pre><code># Create a new service account\nkubectl apply -f new-scanner-sa.yaml\n\n# Update role bindings to reference the new account\nkubectl apply -f updated-rolebinding.yaml\n\n# Delete the old service account\nkubectl delete serviceaccount old-scanner-sa -n inspec-test\n</code></pre>"},{"location":"service-accounts/#security-considerations","title":"Security Considerations","text":"<ol> <li>Use dedicated service accounts - never reuse default accounts</li> <li>Limit the number of service accounts with scanning capabilities</li> <li>Regularly review and rotate service accounts</li> <li>Use namespaces to isolate service accounts by sensitivity level</li> <li>Consider using Kubernetes PodSecurityPolicies (or Pod Security Admission in 1.25+) to constrain service account usage</li> </ol>"},{"location":"service-accounts/#references","title":"References","text":"<ul> <li>Kubernetes Service Accounts Documentation</li> <li>Managing Service Account Tokens</li> <li>Kubernetes Secret Types</li> </ul>"},{"location":"service-accounts/inventory/","title":"Service Accounts Directory Inventory","text":"<p>This document provides a directory overview of the service accounts resources and documentation.</p>"},{"location":"service-accounts/inventory/#directory-contents","title":"Directory Contents","text":"<p>The service-accounts directory contains documentation for configuring and managing Kubernetes service accounts for secure container scanning:</p> <ul> <li>README.md: Original documentation (being migrated to this structure)</li> <li>index.md: Main MkDocs documentation page for service account configuration</li> </ul>"},{"location":"service-accounts/inventory/#service-account-features","title":"Service Account Features","text":"<p>This directory covers best practices for service account management:</p> <ul> <li>Basic Setup: Creating dedicated service accounts for scanning operations</li> <li>Naming Conventions: Consistent naming patterns for different environments</li> <li>Annotations: Using metadata to track service account purpose and ownership</li> <li>Token Management: Creating and managing service account tokens</li> <li>Rotation: Procedures for regularly rotating service accounts</li> <li>Auditing: Methods for reviewing service account usage</li> </ul>"},{"location":"service-accounts/inventory/#security-practices","title":"Security Practices","text":"<p>The documentation emphasizes secure service account management:</p> <ul> <li>Isolating service accounts in dedicated namespaces</li> <li>Using short-lived tokens instead of long-lived credentials</li> <li>Implementing the principle of least privilege</li> <li>Regular rotation of service accounts</li> <li>Proper security constraints with PodSecurityPolicies</li> </ul>"},{"location":"service-accounts/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>RBAC Configuration</li> <li>Token Management</li> <li>Kubeconfig Configuration</li> <li>Security Overview</li> </ul>"},{"location":"tasks/","title":"Tasks","text":"<p>Welcome to the Kube CINC Secure Scanner tasks section. These task-oriented guides provide clear, step-by-step instructions for common scanning and security operations.</p>"},{"location":"tasks/#available-tasks","title":"Available Tasks","text":""},{"location":"tasks/#container-scanning-tasks","title":"Container Scanning Tasks","text":"<ul> <li>Standard Container Scanning - Scan standard containers using the Kubernetes API approach</li> <li>Distroless Container Scanning - Scan distroless containers using the debug container approach</li> <li>Sidecar Container Scanning - Scan containers using the sidecar container approach</li> </ul>"},{"location":"tasks/#cicd-integration-tasks","title":"CI/CD Integration Tasks","text":"<ul> <li>GitHub Actions Integration - Integrate scanning with GitHub Actions</li> <li>GitLab CI Integration - Integrate scanning with GitLab CI</li> <li>Configuring Thresholds - Set up thresholds for scan results</li> </ul>"},{"location":"tasks/#security-setup-tasks","title":"Security Setup Tasks","text":"<ul> <li>RBAC Configuration - Configure role-based access control for scanner</li> <li>Token Management - Manage authentication tokens securely</li> </ul>"},{"location":"tasks/#deployment-tasks","title":"Deployment Tasks","text":"<ul> <li>Kubernetes Setup - Prepare Kubernetes environment</li> <li>Helm Chart Deployment - Deploy using Helm charts</li> <li>Script-Based Deployment - Deploy using provided scripts</li> </ul>"},{"location":"tasks/#task-organization","title":"Task Organization","text":"<p>Each task page follows a consistent format:</p> <ol> <li>Overview - Brief description with security context</li> <li>Security Prerequisites - Required permissions and security configurations</li> <li>Step-by-Step Instructions - Clear steps with security notes</li> <li>Security Best Practices - Important security recommendations</li> <li>Verification Steps - How to verify successful completion</li> <li>Troubleshooting - Common issues and solutions</li> <li>Next Steps - Logical next tasks to perform</li> <li>Related Security Considerations - Links to related security documentation</li> </ol>"},{"location":"tasks/#security-focus","title":"Security Focus","text":"<p>All tasks include security considerations throughout. Look for the security admonitions:</p> <p>Security Emphasis</p> <p>These highlight key security aspects and why they matter.</p> <p>Security Consideration</p> <p>These provide step-specific security guidance.</p>"},{"location":"tasks/distroless-container-scan/","title":"Distroless Container Scanning","text":""},{"location":"tasks/distroless-container-scan/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Distroless containers provide enhanced security by minimizing the attack surface, but they're challenging to scan. This task uses ephemeral debug containers to inspect distroless containers without modifying them, maintaining their security benefits while enabling compliance validation.</p> <p>This task guides you through scanning a distroless container using the ephemeral debug container approach. This method allows you to scan containers that lack a shell or basic OS utilities without compromising their security benefits.</p> <p>Time to complete: 15-20 minutes</p> <p>Security risk: \ud83d\udd34 High - Requires ephemeral debug containers with elevated privileges</p> <p>Security approach: Implements controlled use of ephemeral debug containers with proper isolation, limited-scope access, and secure chroot techniques</p>"},{"location":"tasks/distroless-container-scan/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Distroless container scanning requires managing permissions across specialized layers:</p> <p>1. Debug Container Permissions * Control: Ability to create and attach ephemeral debug containers * Risk area: Debug containers have elevated access to inspect distroless containers * Mitigation: Use short-lived debug containers with strict lifecycle management</p> <p>2. Process Namespace Permissions * Control: Access to shared process namespaces between containers * Risk area: Potential for cross-container visibility and information leakage * Mitigation: Carefully configure pod security context and limit debug container capabilities</p> <p>3. Filesystem Access Permissions * Control: Access to distroless container filesystem through chroot * Risk area: Improper access could expose sensitive files or alter container state * Mitigation: Implement read-only filesystem access with controlled mount points</p>"},{"location":"tasks/distroless-container-scan/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Kubernetes cluster with ephemeral containers support (v1.23+) (see Existing Cluster Requirements)</li> <li> kubectl configured for the target cluster</li> <li> Permissions to create ephemeral containers</li> <li> Permissions to create service accounts and roles in the target namespace</li> <li> CINC Auditor installed (see prerequisites section)</li> <li> SAF CLI installed (will be automatically installed if missing)</li> </ul> <p>Kubernetes Setup</p> <p>If you don't have a Kubernetes cluster available, you can set up a local test environment using our Minikube Setup guide with the <code>--with-distroless</code> flag.</p>"},{"location":"tasks/distroless-container-scan/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/distroless-container-scan/#step-1-verify-prerequisites","title":"Step 1: Verify Prerequisites","text":"<p>Security Consideration</p> <p>The debug container approach requires elevated permissions to create ephemeral containers. Use dedicated service accounts with least privilege permissions for this operation.</p> <p>Ensure you have CINC Auditor installed:</p> <pre><code># Check if CINC Auditor is installed\ncinc-auditor version\n\n# Verify kubectl access and ephemeral container capability\nkubectl version --short\n</code></pre> <p>Check if your cluster supports ephemeral containers:</p> <pre><code># API Resources should include pods/ephemeralcontainers\nkubectl api-resources | grep ephemeralcontainers\n</code></pre>"},{"location":"tasks/distroless-container-scan/#step-2-locate-or-create-a-profile","title":"Step 2: Locate or Create a Profile","text":"<p>Security Consideration</p> <p>Distroless containers require specialized profiles that focus on filesystem checks rather than process or package checks, as they have minimal operating system components.</p> <pre><code># Example for using the built-in container baseline profile\n# The project includes sample profiles in examples/cinc-profiles/\ncd /path/to/kube-secure-scanner\nls examples/cinc-profiles/container-baseline\n</code></pre> <p>You can use the built-in examples or provide your own InSpec profile path.</p>"},{"location":"tasks/distroless-container-scan/#step-3-run-the-scanning-script","title":"Step 3: Run the Scanning Script","text":"<p>Security Consideration</p> <p>The script creates temporary resources with minimal permissions and short-lived tokens. The ephemeral debug container is removed immediately after the scan completes, minimizing the security exposure window.</p> <pre><code># Syntax: ./kubernetes-scripts/scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n./kubernetes-scripts/scan-distroless-container.sh default distroless-pod app-container examples/cinc-profiles/container-baseline\n</code></pre> <p>For advanced usage with threshold validation:</p> <pre><code># Using a custom threshold file\n./kubernetes-scripts/scan-distroless-container.sh default distroless-pod app-container examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre>"},{"location":"tasks/distroless-container-scan/#step-4-review-scan-results","title":"Step 4: Review Scan Results","text":"<p>Security Consideration</p> <p>The scan results may include system configuration findings that can help identify security misconfigurations in your distroless container.</p> <p>The script will output the scan results to the console and save detailed results to JSON and Markdown files.</p> <pre><code># View detailed results (replace timestamp with actual value)\ncat scan-results-1616844322.json\n\n# View summary report (replace timestamp with actual value)\ncat scan-summary-1616844322.md\n</code></pre>"},{"location":"tasks/distroless-container-scan/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use custom profiles designed specifically for distroless containers that focus on filesystem and static configuration checks</li> <li>Implement threshold validation to ensure security compliance requirements are met</li> <li>Use a dedicated restricted service account for scanning operations</li> <li>Run the scanner in a separate namespace with strict network policies</li> <li>Ensure ephemeral containers are removed immediately after scanning</li> <li>Configure the ephemeral container with the minimum necessary privileges</li> <li>Store scan results securely if they contain sensitive information</li> <li>Consider scanning distroless container images before deployment using pre-deployment pipelines</li> </ul>"},{"location":"tasks/distroless-container-scan/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify the scan completed successfully with an exit code of 0</li> </ol> <pre><code>echo $?\n</code></pre> <ol> <li>Check the scan results files exist</li> </ol> <pre><code>ls scan-results-*.json scan-summary-*.md\n</code></pre> <ol> <li>Verify temporary resources were cleaned up</li> </ol> <pre><code># Should return \"No resources found\"\nkubectl get serviceaccount scanner-* -n default\nkubectl get role scanner-role-* -n default\nkubectl get rolebinding scanner-binding-* -n default\n</code></pre> <ol> <li>Verify the ephemeral container was removed</li> </ol> <pre><code># Should not show any debug containers\nkubectl get pod distroless-pod -n default -o jsonpath='{.status.ephemeralContainerStatuses}'\n</code></pre>"},{"location":"tasks/distroless-container-scan/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"Ephemeral containers are disabled\" Upgrade your Kubernetes cluster to v1.23+ or enable the EphemeralContainers feature gate. Permission denied Ensure you have permissions to create ephemeral containers and service accounts in the target namespace. Check cluster RBAC settings. Container not found Verify the namespace, pod name, and container name. Use <code>kubectl get pods -n &lt;namespace&gt;</code> to list available pods. Scan fails with \"chroot: command not found\" The Alpine debug container image may be missing required tools. Use a more comprehensive debug image like busybox or cincproject/auditor. InSpec profile errors Ensure the profile is designed for distroless containers with a focus on filesystem checks rather than package or process checks."},{"location":"tasks/distroless-container-scan/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configuring Thresholds for automated compliance validation</li> <li>GitLab CI Integration or GitHub Actions Integration to automate scanning</li> <li>RBAC Configuration for fine-tuning scanner permissions</li> <li>Try Sidecar Container Scanning for an alternative approach to scanning distroless containers</li> </ul>"},{"location":"tasks/distroless-container-scan/#compliance-and-security-considerations","title":"Compliance and Security Considerations","text":"<ul> <li> <p> Risk Analysis</p> <p>Review comprehensive security risk assessment for this approach:</p> <ul> <li>Debug Container Security Risks</li> <li>Key risk: Temporary container isolation disruption</li> <li>Overall risk rating: \ud83d\udfe0 Moderate</li> </ul> <p> Full Risk Analysis</p> </li> <li> <p> Compliance Impact</p> <p>This approach has specific compliance implications:</p> <ul> <li>DoD 8500.01: \u26a0\ufe0f Partial alignment (uses debug features)</li> <li>STIG V-242433: \u26a0\ufe0f Partial alignment (requires debug privileges)</li> <li>CIS 5.2.1: \u26a0\ufe0f Partial alignment (may need elevated privileges)</li> </ul> <p> Compliance Comparison</p> </li> <li> <p> Security Principles</p> <p>Core security principles applied in this task:</p> <ul> <li>Ephemeral Credentials</li> <li>Resource Isolation</li> <li>Container Security Threat Model</li> </ul> <p> Security Principles</p> </li> <li> <p> Documentation Requirements</p> <p>For compliance documentation, be sure to:</p> <ul> <li>Document the security rationale for using this approach</li> <li>Explain mitigations implemented for identified risks</li> <li>Include time-limited nature of debug container access</li> <li>Reference formal risk acceptance if required for your environment</li> </ul> <p> Risk Documentation</p> </li> </ul>"},{"location":"tasks/github-integration/","title":"GitHub Actions Integration","text":""},{"location":"tasks/github-integration/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>GitHub Actions workflows have access to your Kubernetes clusters, containers, and can potentially access sensitive information. This task implements security best practices including least-privilege RBAC, ephemeral credentials, and secure token management to minimize risk.</p> <p>This task guides you through integrating Kube CINC Secure Scanner with GitHub Actions. Completing this task will enable you to automate container security scanning within your CI/CD pipeline while maintaining a strong security posture. The integration supports both standalone scanning of existing containers and fully automated end-to-end CI/CD pipelines with dynamic container building, deployment, and scanning.</p> <p>Time to complete: 30-45 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Requires GitHub Actions with Kubernetes cluster access</p> <p>Security approach: Implements secure CI/CD integration with ephemeral credentials, dynamic RBAC generation, and proper permission boundaries between GitHub and Kubernetes resources</p>"},{"location":"tasks/github-integration/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Integrating GitHub Actions with Kubernetes scanning requires managing multiple permission layers:</p> <p>1. GitHub Runner/Pipeline Permissions * Control: Access to GitHub repository resources, ability to run workflows, upload artifacts * Risk area: Could expose repository secrets or allow unauthorized workflow execution * Mitigation: Grant GitHub Actions only the necessary permissions to perform its tasks</p> <p>2. User/CI System Kubernetes Permissions * Control: Initial access to create and manage Kubernetes resources, including RBAC setup * Risk area: Overly permissive access could allow broader cluster access than needed * Mitigation: Use a service account with limited namespace access for CI/CD operations</p> <p>3. Container Scanner RBAC Permissions * Control: What the scanner itself can access within Kubernetes during scan operations * Risk area: Scanning permissions that are too broad could allow access to unintended resources * Mitigation: Generate short-lived, minimal-scope tokens scoped only to target containers</p> <p>The workflows in this guide demonstrate proper separation of these permission layers with dynamically generated RBAC permissions that are valid only for the specific scan operation and automatically cleaned up afterward.</p>"},{"location":"tasks/github-integration/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> A GitHub repository where you have permissions to create workflows</li> <li> A Kubernetes cluster that meets the requirements for existing clusters</li> <li> Understanding of Kubernetes RBAC for creating secure service accounts</li> <li> An authenticated environment where you can run <code>kubectl</code> commands</li> <li> A Kubernetes setup with appropriate permissions</li> </ul>"},{"location":"tasks/github-integration/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<p>In this guide, we'll cover two main integration approaches:</p> <ol> <li>Basic container scanning workflow for existing containers</li> <li>End-to-end CI/CD pipeline that builds, deploys, and scans containers dynamically</li> </ol>"},{"location":"tasks/github-integration/#approach-1-basic-container-scanning-workflow","title":"Approach 1: Basic Container Scanning Workflow","text":"<p>Security Consideration</p> <p>We'll start with the most secure approach (standard container scanning) with proper RBAC controls. This workflow only accesses what it needs through temporary credentials.</p> <ol> <li>Create a <code>.github/workflows</code> directory in your repository if it doesn't already exist:</li> </ol> <pre><code>mkdir -p .github/workflows\n</code></pre> <ol> <li>Create a new workflow file called <code>container-scan.yml</code> in the <code>.github/workflows</code> directory:</li> </ol> <pre><code>touch .github/workflows/container-scan.yml\n</code></pre> <ol> <li>Copy the following secure workflow content to the file:</li> </ol> <pre><code>name: Kubernetes Container Security Scan\n\non:\n  workflow_dispatch:\n    inputs:\n      namespace:\n        description: 'Kubernetes namespace to scan'\n        required: true\n        default: 'default'\n      pod_name:\n        description: 'Pod name to scan'\n        required: true\n      container_name:\n        description: 'Container name to scan'\n        required: true\n      cinc_profile:\n        description: 'CINC Auditor profile to run'\n        required: true\n        default: 'dev-sec/linux-baseline'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  scan-container:\n    name: Scan Kubernetes Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up CINC Auditor environment\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI for result processing\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Set up RBAC configuration\n        env:\n          NAMESPACE: ${{ github.event.inputs.namespace }}\n          POD_NAME: ${{ github.event.inputs.pod_name }}\n        run: |\n          # Create service account\n          kubectl create serviceaccount inspec-scanner -n ${NAMESPACE}\n\n          # Create role with minimal permissions for the specific pod\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: inspec-container-role\n            namespace: ${NAMESPACE}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n            resourceNames: [\"${POD_NAME}\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n            resourceNames: [\"${POD_NAME}\"]\n          EOF\n\n          # Create role binding\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: RoleBinding\n          metadata:\n            name: inspec-container-rolebinding\n            namespace: ${NAMESPACE}\n          subjects:\n          - kind: ServiceAccount\n            name: inspec-scanner\n            namespace: ${NAMESPACE}\n          roleRef:\n            kind: Role\n            name: inspec-container-role\n            apiGroup: rbac.authorization.k8s.io\n          EOF\n\n          # Verify RBAC setup\n          kubectl get serviceaccount,role,rolebinding -n ${NAMESPACE}\n\n      - name: Generate restricted kubeconfig\n        env:\n          NAMESPACE: ${{ github.event.inputs.namespace }}\n        run: |\n          # Get token (15 minute duration for security)\n          TOKEN=$(kubectl create token inspec-scanner -n ${NAMESPACE} --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create kubeconfig with minimal permissions\n          cat &gt; restricted-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${NAMESPACE}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Set secure permissions\n          chmod 600 restricted-kubeconfig.yaml\n\n          # Test the kubeconfig\n          KUBECONFIG=restricted-kubeconfig.yaml kubectl get pods -n ${NAMESPACE}\n\n      - name: Run CINC Auditor scan with restricted access\n        env:\n          NAMESPACE: ${{ github.event.inputs.namespace }}\n          POD_NAME: ${{ github.event.inputs.pod_name }}\n          CONTAINER_NAME: ${{ github.event.inputs.container_name }}\n          CINC_PROFILE: ${{ github.event.inputs.cinc_profile }}\n        run: |\n          # Run CINC Auditor with the train-k8s-container transport\n          KUBECONFIG=restricted-kubeconfig.yaml cinc-auditor exec ${CINC_PROFILE} \\\n            -t k8s-container://${NAMESPACE}/${POD_NAME}/${CONTAINER_NAME} \\\n            --reporter cli json:cinc-results.json\n\n          # Store the exit code\n          CINC_EXIT_CODE=$?\n          echo \"CINC Auditor scan completed with exit code: ${CINC_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        env:\n          THRESHOLD: ${{ github.event.inputs.threshold }}\n        run: |\n          # Generate summary report with SAF-CLI\n          echo \"Generating scan summary with SAF-CLI:\"\n          saf summary --input cinc-results.json --output-md scan-summary.md\n\n          # Display the summary in the logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## CINC Auditor Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Create a proper threshold file\n          cat &gt; threshold.yml &lt;&lt; EOF\n          compliance:\n            min: ${THRESHOLD}\n          failed:\n            critical:\n              max: 0  # No critical failures allowed\n          EOF\n\n          # Apply threshold check\n          echo \"Checking against threshold with min compliance of ${THRESHOLD}%:\"\n          saf threshold -i cinc-results.json -t threshold.yml\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncomment to enforce the threshold as a quality gate\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload CINC Auditor results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: cinc-results\n          path: |\n            cinc-results.json\n            scan-summary.md\n\n      - name: Cleanup RBAC resources\n        if: always()\n        env:\n          NAMESPACE: ${{ github.event.inputs.namespace }}\n        run: |\n          # Cleanup role and rolebinding\n          kubectl delete rolebinding inspec-container-rolebinding -n ${NAMESPACE}\n          kubectl delete role inspec-container-role -n ${NAMESPACE}\n          kubectl delete serviceaccount inspec-scanner -n ${NAMESPACE}\n</code></pre>"},{"location":"tasks/github-integration/#step-2-set-up-github-repository-permissions","title":"Step 2: Set Up GitHub Repository Permissions","text":"<p>Security Consideration</p> <p>GitHub Actions need proper permissions to upload artifacts and write step summaries. This is safe as it only affects GitHub Actions operations, not your Kubernetes cluster.</p> <ol> <li>In your GitHub repository, go to Settings &gt; Actions &gt; General</li> <li>Under \"Workflow permissions\", select \"Read and write permissions\"</li> <li>Save your changes</li> </ol>"},{"location":"tasks/github-integration/#step-3-connect-to-your-kubernetes-cluster","title":"Step 3: Connect to Your Kubernetes Cluster","text":"<p>Security Consideration</p> <p>For production systems, you should store your Kubernetes credentials securely in GitHub Secrets. Never check kubeconfig files into your repository.</p> <ol> <li>If your workflow will run against an existing Kubernetes cluster, create a GitHub Secret for your kubeconfig:</li> </ol> <pre><code># First export your kubeconfig to a base64-encoded string\nKUBECONFIG_B64=$(cat ~/.kube/config | base64 -w 0)\n</code></pre> <ol> <li>In GitHub, go to Settings &gt; Secrets and variables &gt; Actions</li> <li> <p>Create a new repository secret named <code>KUBE_CONFIG</code> with the value from the previous step</p> </li> <li> <p>Modify the workflow to use this secret by adding this step before the RBAC setup:</p> </li> </ol> <pre><code>- name: Set up kubeconfig\n  run: |\n    mkdir -p ~/.kube\n    echo \"${{ secrets.KUBE_CONFIG }}\" | base64 -d &gt; ~/.kube/config\n    chmod 600 ~/.kube/config\n    kubectl get nodes\n</code></pre>"},{"location":"tasks/github-integration/#approach-2-end-to-end-cicd-pipeline-with-dynamic-rbac","title":"Approach 2: End-to-End CI/CD Pipeline with Dynamic RBAC","text":"<p>This approach demonstrates a complete end-to-end workflow that:</p> <ol> <li>Builds a container using a simple Docker build process</li> <li>Deploys it to Kubernetes with specific labels</li> <li>Creates dynamic RBAC permissions specifically for that deployment</li> <li>Scans the container using those permissions</li> </ol> <p>Create a new workflow file called <code>ci-cd-pipeline.yml</code>:</p> <pre><code>touch .github/workflows/ci-cd-pipeline.yml\n</code></pre> <p>Add the following content:</p> <pre><code>name: CI/CD Pipeline with Container Scanning\n\non:\n  workflow_dispatch:\n    inputs:\n      image_tag:\n        description: 'Tag for the container image'\n        required: true\n        default: 'scan-target'\n      scan_namespace:\n        description: 'Kubernetes namespace for scanning'\n        required: true\n        default: 'app-scan'\n      threshold:\n        description: 'Minimum passing score (0-100)'\n        required: true\n        default: '70'\n\njobs:\n  build-deploy-scan:\n    name: Build, Deploy and Scan Container\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Create application files for build\n        run: |\n          # Create a mock application directory\n          mkdir -p ./app\n\n          # Create a simple Dockerfile\n          cat &gt; ./app/Dockerfile &lt;&lt; 'EOF'\n          FROM alpine:latest\n\n          # Add some packages for testing\n          RUN apk add --no-cache bash curl nginx\n\n          # Create a sample configuration file\n          RUN mkdir -p /etc/app\n          COPY app.conf /etc/app/app.conf\n\n          # Set execution mode\n          CMD [\"nginx\", \"-g\", \"daemon off;\"]\n          EOF\n\n          # Create a sample config file\n          cat &gt; ./app/app.conf &lt;&lt; 'EOF'\n          # Sample application configuration\n          app_name=test-application\n          log_level=info\n          max_connections=100\n          EOF\n\n      - name: Set up Minikube\n        uses: medyagh/setup-minikube@master\n        with:\n          driver: docker\n          start-args: --nodes=2\n\n      - name: Build and tag container image\n        run: |\n          # Use minikube's Docker daemon\n          eval $(minikube docker-env)\n\n          # Build the image with dynamic tag\n          cd ./app\n          docker build -t app-image:${{ github.event.inputs.image_tag }} .\n\n          # List images to confirm build\n          docker images | grep app-image\n\n      - name: Deploy to Kubernetes\n        run: |\n          # Create namespace\n          kubectl create namespace ${{ github.event.inputs.scan_namespace }}\n\n          # Create deployment\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: apps/v1\n          kind: Deployment\n          metadata:\n            name: test-app\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          spec:\n            replicas: 1\n            selector:\n              matchLabels:\n                app: test-app\n            template:\n              metadata:\n                labels:\n                  app: test-app\n                  scan-target: \"true\"\n              spec:\n                containers:\n                - name: app\n                  image: app-image:${{ github.event.inputs.image_tag }}\n                  imagePullPolicy: Never\n                  ports:\n                  - containerPort: 80\n          EOF\n\n          # Wait for deployment to be ready\n          kubectl -n ${{ github.event.inputs.scan_namespace }} rollout status deployment/test-app --timeout=120s\n\n          # Show running pods with labels\n          kubectl get pods -n ${{ github.event.inputs.scan_namespace }} --show-labels\n\n      - name: Install CINC Auditor and SAF-CLI\n        run: |\n          # Install CINC Auditor\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n          # Install train-k8s-container plugin\n          cinc-auditor plugin install train-k8s-container\n\n          # Install SAF-CLI\n          npm install -g @mitre/saf\n\n          # Verify installation\n          cinc-auditor --version\n          cinc-auditor plugin list\n          saf --version\n\n      - name: Create dynamic RBAC for scanning\n        run: |\n          # Generate a unique ID for this workflow run\n          SCAN_ID=$(date +%s)\n          echo \"SCAN_ID=${SCAN_ID}\" &gt;&gt; $GITHUB_ENV\n\n          # Create service account\n          kubectl create serviceaccount scanner-${SCAN_ID} -n ${{ github.event.inputs.scan_namespace }}\n\n          # Create role with label selector permissions\n          cat &lt;&lt;EOF | kubectl apply -f -\n          apiVersion: rbac.authorization.k8s.io/v1\n          kind: Role\n          metadata:\n            name: scanner-role-${SCAN_ID}\n            namespace: ${{ github.event.inputs.scan_namespace }}\n          rules:\n          - apiGroups: [\"\"]\n            resources: [\"pods\"]\n            verbs: [\"get\", \"list\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/exec\"]\n            verbs: [\"create\"]\n          - apiGroups: [\"\"]\n            resources: [\"pods/log\"]\n            verbs: [\"get\"]\n          EOF\n\n          # Create role binding\n          kubectl create rolebinding scanner-binding-${SCAN_ID} \\\n            --role=scanner-role-${SCAN_ID} \\\n            --serviceaccount=${{ github.event.inputs.scan_namespace }}:scanner-${SCAN_ID} \\\n            -n ${{ github.event.inputs.scan_namespace }}\n\n          # Generate short-lived token (15 minutes)\n          TOKEN=$(kubectl create token scanner-${SCAN_ID} \\\n            -n ${{ github.event.inputs.scan_namespace }} \\\n            --duration=15m)\n\n          # Get cluster information\n          SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\n          CA_DATA=$(kubectl config view --raw --minify --flatten \\\n            -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n          # Create restricted kubeconfig\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${SERVER}\n              certificate-authority-data: ${CA_DATA}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: ${{ github.event.inputs.scan_namespace }}\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          # Secure permissions\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Run container scan with label selection\n        run: |\n          # Run CINC Auditor with label selection\n          KUBECONFIG=scanner-kubeconfig.yaml cinc-auditor exec dev-sec/linux-baseline \\\n            -t k8s-container://${{ github.event.inputs.scan_namespace }}?pod_label=scan-target=true/app \\\n            --reporter cli json:scan-results.json\n\n          # Check exit code\n          SCAN_EXIT_CODE=$?\n          echo \"Scan completed with exit code: ${SCAN_EXIT_CODE}\"\n\n      - name: Process results with SAF-CLI\n        run: |\n          # Generate report summary\n          saf summary --input scan-results.json --output-md scan-summary.md\n\n          # Display summary in logs\n          cat scan-summary.md\n\n          # Add to GitHub step summary\n          echo \"## Container Security Scan Results\" &gt; $GITHUB_STEP_SUMMARY\n          cat scan-summary.md &gt;&gt; $GITHUB_STEP_SUMMARY\n\n          # Check compliance threshold\n          echo \"Checking against threshold of ${{ github.event.inputs.threshold }}%\"\n          saf threshold -i scan-results.json -t ${{ github.event.inputs.threshold }}\n          THRESHOLD_EXIT_CODE=$?\n\n          if [ $THRESHOLD_EXIT_CODE -eq 0 ]; then\n            echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n          else\n            echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n            # Uncommenting the next line would fail the workflow when thresholds are not met\n            # exit $THRESHOLD_EXIT_CODE\n          fi\n\n      - name: Upload scan results\n        uses: actions/upload-artifact@v4\n        with:\n          name: security-scan-results\n          path: |\n            scan-results.json\n            scan-summary.md\n\n      - name: Cleanup resources\n        if: always()\n        run: |\n          # Clean up Kubernetes resources\n          kubectl delete rolebinding scanner-binding-${SCAN_ID} -n ${{ github.event.inputs.scan_namespace }} || true\n          kubectl delete role scanner-role-${SCAN_ID} -n ${{ github.event.inputs.scan_namespace }} || true\n          kubectl delete serviceaccount scanner-${SCAN_ID} -n ${{ github.event.inputs.scan_namespace }} || true\n          kubectl delete namespace ${{ github.event.inputs.scan_namespace }} || true\n</code></pre>"},{"location":"tasks/github-integration/#step-4-run-the-workflows","title":"Step 4: Run the Workflows","text":""},{"location":"tasks/github-integration/#for-basic-container-scanning","title":"For Basic Container Scanning","text":"<ol> <li>In your GitHub repository, go to the Actions tab</li> <li>Select the \"Kubernetes Container Security Scan\" workflow</li> <li>Click Run workflow</li> <li>Fill in the required parameters:</li> <li>Namespace: The Kubernetes namespace containing your target pod</li> <li>Pod name: The name of the pod to scan</li> <li>Container name: The specific container within the pod to scan</li> <li>CINC profile: The profile to run (e.g., <code>dev-sec/linux-baseline</code>)</li> <li>Threshold: The minimum passing score (0-100)</li> <li>Click Run workflow</li> </ol>"},{"location":"tasks/github-integration/#for-end-to-end-cicd-pipeline","title":"For End-to-End CI/CD Pipeline","text":"<ol> <li>In your GitHub repository, go to the Actions tab</li> <li>Select the \"CI/CD Pipeline with Container Scanning\" workflow</li> <li>Click Run workflow</li> <li>Fill in the required parameters:</li> <li>Image tag: A unique tag for your container image (default: scan-target)</li> <li>Scan namespace: The namespace where the container will be deployed (default: app-scan)</li> <li>Threshold: The minimum passing score (0-100) (default: 70)</li> <li>Click Run workflow</li> </ol>"},{"location":"tasks/github-integration/#step-5-review-scan-results","title":"Step 5: Review Scan Results","text":"<p>Security Consideration</p> <p>Scan results may contain sensitive information about your container. GitHub Actions artifacts are only accessible to users with repository access.</p> <ol> <li>After the workflow completes, go to the workflow run in the Actions tab</li> <li>Scroll down to see the detailed logs</li> <li>Review the workflow summary which shows the scan results overview</li> <li>Download the artifacts to access the detailed JSON and Markdown reports</li> </ol>"},{"location":"tasks/github-integration/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use time-limited tokens (default: 15 minutes) to minimize the access window</li> <li>Configure RBAC to limit access to only the specific resources needed</li> <li>Enforce threshold requirements as quality gates in production pipelines</li> <li>Store sensitive information (like kubeconfig files) in GitHub Secrets</li> <li>Implement cleanup steps to remove temporary RBAC resources</li> <li>Verify that tokens have the minimal required permissions for scanning</li> <li>Run scans against immutable containers to ensure consistency</li> </ul>"},{"location":"tasks/github-integration/#verification-steps","title":"Verification Steps","text":"<ol> <li>Confirm the workflow completed successfully</li> </ol> <pre><code># Check the Actions tab in GitHub or run\ngh run list --limit 1\n</code></pre> <ol> <li>Verify that the RBAC resources were properly created and then cleaned up</li> </ol> <pre><code># Should return \"No resources found\"\nkubectl get role inspec-container-role -n &lt;namespace&gt;\nkubectl get rolebinding inspec-container-rolebinding -n &lt;namespace&gt;\nkubectl get serviceaccount inspec-scanner -n &lt;namespace&gt;\n</code></pre> <ol> <li>Review the scan results and compliance score in the workflow summary</li> </ol>"},{"location":"tasks/github-integration/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Workflow fails with authentication errors Verify that the kubeconfig secret is correctly set up or that your GitHub Actions runner has proper access to the cluster RBAC permissions errors Check that the workflow is creating the correct RBAC resources with proper names and permissions Scan fails with access denied Verify that the generated token has the necessary permissions and that the pod/container exists Token expires during scan Increase the token duration (--duration=30m) for larger scans, but keep it as short as practically possible Threshold check fails Review the detailed scan results to identify failing controls, or adjust the threshold if appropriate"},{"location":"tasks/github-integration/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configure threshold values for pass/fail criteria</li> <li>Set up RBAC with label-based targeting for flexible container selection</li> <li>Integrate with distroless containers if you need to scan distroless images</li> <li>Implement sidecar container scanning for specialized container types</li> </ul>"},{"location":"tasks/github-integration/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Kubernetes RBAC Configuration</li> <li>Ephemeral Security Credentials</li> <li>Least Privilege Principle</li> <li>Token Management</li> <li>Kubernetes Setup Best Practices</li> </ul>"},{"location":"tasks/gitlab-integration/","title":"GitLab CI Integration","text":""},{"location":"tasks/gitlab-integration/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>GitLab CI pipelines have access to your Kubernetes clusters and containers, potentially exposing sensitive information. This task implements security best practices including pipeline-specific RBAC, ephemeral credentials, and automatic resource cleanup to minimize security risks.</p> <p>This task guides you through integrating Kube CINC Secure Scanner with GitLab CI/CD pipelines. Completing this task will enable you to automate container security scanning within your GitLab pipelines while maintaining a strong security posture.</p> <p>Time to complete: 30-45 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Requires GitLab CI with Kubernetes cluster access</p> <p>Security approach: Implements secure CI/CD integration with ephemeral credentials, pipeline-specific RBAC generation, and proper permission boundaries between GitLab and Kubernetes resources</p>"},{"location":"tasks/gitlab-integration/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Integrating GitLab CI with Kubernetes scanning requires managing multiple permission layers:</p> <p>1. GitLab Runner/Pipeline Permissions * Control: Access to GitLab repository resources, ability to run pipelines, store artifacts * Risk area: Could expose repository secrets or allow unauthorized access * Mitigation: Use protected variables and dedicated runners with limited scope</p> <p>2. CI/CD System Kubernetes Permissions * Control: Initial access to create and manage Kubernetes resources, including RBAC setup * Risk area: Overly permissive access could allow broader cluster access than needed * Mitigation: Store kubeconfig as protected variable with namespace-scoped permissions</p> <p>3. Container Scanner RBAC Permissions * Control: What the scanner itself can access within Kubernetes during scan operations * Risk area: Scanning permissions that are too broad could allow access to unintended resources * Mitigation: Generate short-lived, minimal-scope tokens scoped only to target containers</p> <p>The pipelines in this guide demonstrate proper separation of these permission layers with pipeline-specific RBAC permissions that are unique to each pipeline run and automatically cleaned up afterward.</p>"},{"location":"tasks/gitlab-integration/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> A GitLab repository where you have permissions to set up CI/CD pipelines</li> <li> A Kubernetes cluster that meets the requirements for existing clusters</li> <li> Understanding of Kubernetes RBAC for creating secure service accounts</li> <li> GitLab runners with the ability to execute commands against your Kubernetes cluster</li> <li> Kubernetes setup with appropriate permissions</li> </ul>"},{"location":"tasks/gitlab-integration/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/gitlab-integration/#step-1-configure-gitlab-cicd-variables","title":"Step 1: Configure GitLab CI/CD Variables","text":"<p>Security Consideration</p> <p>Store Kubernetes credentials as protected and masked variables to prevent exposure in logs and limit their use to protected branches only.</p> <ol> <li>In your GitLab repository, go to Settings &gt; CI/CD &gt; Variables</li> <li>Add the following variables:</li> <li> <p><code>KUBE_CONFIG</code>: Base64-encoded kubeconfig file (mark as Protected and Masked)</p> <pre><code># Generate using:\ncat ~/.kube/config | base64 -w 0\n</code></pre> </li> <li> <p><code>SCANNER_NAMESPACE</code>: The namespace where scanning resources will be created</p> </li> <li><code>CINC_PROFILE_PATH</code>: Path to the CINC Auditor profile (e.g., <code>dev-sec/linux-baseline</code>)</li> <li><code>THRESHOLD_VALUE</code>: Minimum passing score for scans (e.g., <code>70</code>)</li> </ol>"},{"location":"tasks/gitlab-integration/#step-2-create-gitlab-ciyml-file","title":"Step 2: Create .gitlab-ci.yml File","text":"<p>Security Consideration</p> <p>The pipeline creates isolated, temporary RBAC resources with unique identifiers for each pipeline run to prevent permission reuse.</p> <ol> <li>Create a <code>.gitlab-ci.yml</code> file in your repository root:</li> </ol> <pre><code>stages:\n  - deploy\n  - scan\n  - report\n  - cleanup\n\nvariables:\n  SCANNER_NAMESPACE: \"inspec-test\"\n  TARGET_LABEL: \"app=target-app\"\n  THRESHOLD_VALUE: \"70\"  # Minimum passing score (0-100)\n\ndeploy_container:\n  stage: deploy\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n        labels:\n          app: target-app\n          pipeline: \"${CI_PIPELINE_ID}\"\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n    - |\n      # Wait for pod to be ready\n      kubectl wait --for=condition=ready pod/scan-target-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --timeout=120s\n    - |\n      # Save target info for later stages\n      echo \"TARGET_POD=scan-target-${CI_PIPELINE_ID}\" &gt;&gt; deploy.env\n      echo \"TARGET_CONTAINER=target\" &gt;&gt; deploy.env\n  artifacts:\n    reports:\n      dotenv: deploy.env\n\ncreate_access:\n  stage: scan\n  needs: [deploy_container]\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Create the role for this specific pod\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: Role\n      metadata:\n        name: scanner-role-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      rules:\n      - apiGroups: [\"\"]\n        resources: [\"pods\"]\n        verbs: [\"get\", \"list\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/exec\"]\n        verbs: [\"create\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      - apiGroups: [\"\"]\n        resources: [\"pods/log\"]\n        verbs: [\"get\"]\n        resourceNames: [\"${TARGET_POD}\"]\n      EOF\n    - |\n      # Create service account\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      EOF\n    - |\n      # Create role binding\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: RoleBinding\n      metadata:\n        name: scanner-binding-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      subjects:\n      - kind: ServiceAccount\n        name: scanner-sa-${CI_PIPELINE_ID}\n        namespace: ${SCANNER_NAMESPACE}\n      roleRef:\n        kind: Role\n        name: scanner-role-${CI_PIPELINE_ID}\n        apiGroup: rbac.authorization.k8s.io\n      EOF\n    - |\n      # Generate token with 15-minute lifespan\n      TOKEN=$(kubectl create token scanner-sa-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --duration=15m)\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; scanner.env\n\n      # Save cluster info\n      SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')\n      CA_DATA=$(kubectl config view --raw --minify --flatten \\\n        -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n      echo \"CLUSTER_SERVER=${SERVER}\" &gt;&gt; scanner.env\n      echo \"CLUSTER_CA_DATA=${CA_DATA}\" &gt;&gt; scanner.env\n  artifacts:\n    reports:\n      dotenv: scanner.env\n\nrun_scan:\n  stage: scan\n  needs: [deploy_container, create_access]\n  script:\n    - |\n      # Create a kubeconfig file with restricted permissions\n      cat &gt; scan-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: ${SCANNER_NAMESPACE}\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n\n      # Set proper permissions on kubeconfig\n      chmod 600 scan-kubeconfig.yaml\n    - |\n      # Install CINC Auditor\n      curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n\n      # Install train-k8s-container plugin\n      cinc-auditor plugin install train-k8s-container\n\n      # Install SAF CLI\n      npm install -g @mitre/saf\n\n      # Run cinc-auditor scan\n      KUBECONFIG=scan-kubeconfig.yaml \\\n        cinc-auditor exec ${CINC_PROFILE_PATH} \\\n        -t k8s-container://${SCANNER_NAMESPACE}/${TARGET_POD}/${TARGET_CONTAINER} \\\n        --reporter json:scan-results.json\n\n      # Generate scan summary using SAF CLI\n      saf summary --input scan-results.json --output-md scan-summary.md\n\n      # Display summary in job output\n      cat scan-summary.md\n\n      # Check scan against threshold\n      saf threshold -i scan-results.json -t ${THRESHOLD_VALUE}\n      THRESHOLD_RESULT=$?\n\n      # Save result for later stages\n      echo \"THRESHOLD_PASSED=${THRESHOLD_RESULT}\" &gt;&gt; scan.env\n\n      if [ ${THRESHOLD_RESULT} -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Uncomment to enforce threshold as a gate\n        # exit ${THRESHOLD_RESULT}\n      fi\n  artifacts:\n    paths:\n      - scan-results.json\n      - scan-summary.md\n    reports:\n      dotenv: scan.env\n\ngenerate_report:\n  stage: report\n  needs: [run_scan]\n  script:\n    - |\n      # Install SAF CLI if needed in this stage\n      which saf || npm install -g @mitre/saf\n\n      # Generate a more comprehensive report\n      saf view -i scan-results.json --output scan-report.html\n\n      # Create a simple markdown report for the MR\n      cat &gt; scan-report.md &lt;&lt; EOF\n      # Security Scan Results\n\n      ## Summary\n\n      $(cat scan-summary.md)\n\n      ## Threshold Check\n\n      ${THRESHOLD_PASSED} -eq 0 &amp;&amp; echo \"\u2705 **PASSED**\" || echo \"\u274c **FAILED**\"\n\n      Threshold: ${THRESHOLD_VALUE}%\n\n      ## Details\n\n      For full results, see the artifacts.\n      EOF\n  artifacts:\n    paths:\n      - scan-report.html\n      - scan-report.md\n    when: always\n\ncleanup:\n  stage: cleanup\n  needs: [run_scan]\n  when: always  # Run even if previous stages failed\n  script:\n    - echo \"$KUBE_CONFIG\" | base64 -d &gt; kubeconfig.yaml\n    - export KUBECONFIG=kubeconfig.yaml\n    - |\n      # Delete all resources\n      kubectl delete pod/${TARGET_POD} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete role/scanner-role-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete sa/scanner-sa-${CI_PIPELINE_ID} -n ${SCANNER_NAMESPACE} --ignore-not-found\n      kubectl delete rolebinding/scanner-binding-${CI_PIPELINE_ID} \\\n        -n ${SCANNER_NAMESPACE} --ignore-not-found\n</code></pre>"},{"location":"tasks/gitlab-integration/#step-3-advanced-approach-pipeline-specific-namespaces","title":"Step 3: Advanced Approach: Pipeline-Specific Namespaces","text":"<p>Security Consideration</p> <p>For higher security, you can isolate each scan pipeline in its own namespace to provide complete resource isolation.</p> <p>Create a more secure version with isolated namespaces:</p> <pre><code># Add this to your .gitlab-ci.yml\ndeploy_container:\n  script:\n    - |\n      # Create namespace with unique name for this pipeline\n      PIPELINE_NAMESPACE=\"${SCANNER_NAMESPACE}-${CI_PIPELINE_ID}\"\n      kubectl create namespace ${PIPELINE_NAMESPACE}\n\n      # Set variable for other stages\n      echo \"PIPELINE_NAMESPACE=${PIPELINE_NAMESPACE}\" &gt;&gt; deploy.env\n\n      # Create pod in isolated namespace\n      cat &lt;&lt;EOF | kubectl apply -f -\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: scan-target\n        namespace: ${PIPELINE_NAMESPACE}\n        labels:\n          app: target-app\n      spec:\n        containers:\n        - name: target\n          image: registry.example.com/my-image:latest\n          command: [\"sleep\", \"1h\"]\n      EOF\n\n# Update the cleanup stage to delete the entire namespace\ncleanup:\n  script:\n    - |\n      # Delete entire namespace (removes all resources at once)\n      kubectl delete namespace ${PIPELINE_NAMESPACE}\n</code></pre>"},{"location":"tasks/gitlab-integration/#step-4-configure-quality-gates","title":"Step 4: Configure Quality Gates","text":"<p>Security Consideration</p> <p>Enforcing quality gates in the pipeline prevents security issues from progressing further in your CI/CD process.</p> <p>Modify the <code>run_scan</code> job to enforce security thresholds:</p> <pre><code>run_scan:\n  script:\n    # ... existing scan commands ...\n\n    # Create a more advanced threshold file\n    cat &gt; threshold.yml &lt;&lt; EOF\n    compliance:\n      min: ${THRESHOLD_VALUE}\n    failed:\n      critical:\n        max: 0  # No critical failures allowed\n      high: \n        max: 2  # At most 2 high failures allowed\n    EOF\n\n    # Apply threshold check with the configuration file\n    saf threshold -i scan-results.json -t threshold.yml\n    THRESHOLD_RESULT=$?\n\n    # Enforce threshold as a quality gate\n    exit ${THRESHOLD_RESULT}\n</code></pre>"},{"location":"tasks/gitlab-integration/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use short-lived tokens (15 minutes or less) to minimize the access window</li> <li>Configure RBAC to limit access to only the specific resources needed for scanning</li> <li>Use pipeline-specific resource names with unique identifiers (${CI_PIPELINE_ID})</li> <li>Store sensitive information in protected and masked CI/CD variables</li> <li>Clean up all resources even when pipelines fail using the <code>when: always</code> option</li> <li>Limit the permissions of the kubeconfig file stored in CI/CD variables</li> <li>Consider using pipeline-specific namespaces for complete isolation</li> </ul>"},{"location":"tasks/gitlab-integration/#verification-steps","title":"Verification Steps","text":"<ol> <li>Check that the pipeline runs successfully</li> </ol> <pre><code># Check the pipeline status in GitLab UI or using GitLab CLI\ngitlab-cli pipeline list --project your-project-id --status success\n</code></pre> <ol> <li>Verify that RBAC resources are automatically cleaned up after the pipeline completes</li> </ol> <pre><code># Should return \"No resources found\"\nkubectl get role/scanner-role-* -n ${SCANNER_NAMESPACE}\nkubectl get sa/scanner-sa-* -n ${SCANNER_NAMESPACE}\n</code></pre> <ol> <li>Review the scan results in the GitLab pipeline artifacts or merge request comments</li> </ol>"},{"location":"tasks/gitlab-integration/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Pipeline fails at the deploy stage Verify that the kubeconfig has proper permissions and the namespace exists RBAC creation fails Check the permissions of the kubeconfig and ensure it can create RBAC resources Token generation fails Make sure you're using Kubernetes 1.24+ for the token creation command or implement a different token generation approach for older versions Scan fails with access denied Verify that the token is being correctly created and roles have the proper permissions SAF-CLI installation fails Ensure your GitLab runner has Node.js properly installed"},{"location":"tasks/gitlab-integration/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configure threshold values for comprehensive pass/fail criteria</li> <li>Set up RBAC with label-based targeting for flexible container selection</li> <li>Integrate with GitLab security dashboards</li> <li>Use GitLab services for advanced container scanning</li> </ul>"},{"location":"tasks/gitlab-integration/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Kubernetes RBAC Configuration</li> <li>Ephemeral Security Credentials</li> <li>Least Privilege Principle</li> <li>Token Management</li> <li>Kubernetes Setup Best Practices</li> </ul>"},{"location":"tasks/helm-deployment/","title":"Helm Chart Deployment","text":""},{"location":"tasks/helm-deployment/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This task implements a secure Helm-based deployment that follows security best practices including proper RBAC isolation, least-privilege service accounts, and secure configuration management, ensuring that your container scanning infrastructure maintains a strong security posture.</p> <p>This task guides you through deploying Kube CINC Secure Scanner using Helm charts. Helm charts provide a standardized, repeatable method for deploying the scanner infrastructure with proper security controls and configuration.</p> <p>Time to complete: 30-45 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Involves deploying infrastructure components with Kubernetes permissions</p> <p>Security approach: Implements layered security architecture with proper separation of concerns, RBAC isolation, and secure default configurations</p>"},{"location":"tasks/helm-deployment/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Helm deployment of scanner infrastructure involves multiple permission boundaries:</p> <p>1. Helm Installation Permissions * Control: Ability to deploy Helm charts to the cluster * Risk area: Excessive Helm permissions could allow unauthorized deployments * Mitigation: Use dedicated service accounts with limited scope for Helm operations</p> <p>2. Chart RBAC Permissions * Control: What permissions are granted to deployed components * Risk area: Overly permissive RBAC in charts could compromise security * Mitigation: Charts implement least-privilege RBAC with proper isolation</p> <p>3. Runtime Scanner Permissions * Control: What deployed scanner components can access at runtime * Risk area: Insecure configurations could grant excessive access * Mitigation: Implement security contexts, network policies, and proper isolation</p>"},{"location":"tasks/helm-deployment/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Kubernetes cluster with Helm v3 installed</li> <li> Administrative access to create namespaces and RBAC resources</li> <li> Local machine with kubectl configured for cluster access</li> <li> Basic understanding of Helm chart structure and values</li> <li> Understanding of Kubernetes setup requirements</li> </ul>"},{"location":"tasks/helm-deployment/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/helm-deployment/#step-1-understand-chart-structure","title":"Step 1: Understand Chart Structure","text":"<p>Security Consideration</p> <p>Understanding the chart structure helps ensure you deploy only the components you need, reducing attack surface.</p> <p>The Kube CINC Secure Scanner Helm charts follow a modular, layered design:</p> <ol> <li>scanner-infrastructure: Core RBAC, service accounts, and base infrastructure</li> <li>common-scanner: Shared components used by all scanner types</li> <li>standard-scanner: For scanning standard containers using Kubernetes API</li> <li>distroless-scanner: For scanning distroless containers using ephemeral debug containers</li> <li>sidecar-scanner: For scanning containers using the sidecar approach</li> </ol>"},{"location":"tasks/helm-deployment/#step-2-deploy-the-scanner-infrastructure","title":"Step 2: Deploy the Scanner Infrastructure","text":"<p>Security Consideration</p> <p>The scanner infrastructure chart creates the base security components including namespaces, service accounts, and RBAC.</p> <ol> <li>Clone the repository and navigate to the helm-charts directory:</li> </ol> <pre><code>cd helm-charts/\n</code></pre> <ol> <li>Review the infrastructure chart values:</li> </ol> <pre><code>cat scanner-infrastructure/values.yaml\n</code></pre> <ol> <li>Create a custom values file for the infrastructure:</li> </ol> <pre><code>cat &gt; my-infrastructure-values.yaml &lt;&lt; EOF\nnamespace:\n  name: cinc-scanner\n  labels:\n    purpose: security-scanning\n\nserviceAccount:\n  create: true\n  name: scanner-sa\n  annotations:\n    security.owner: \"security-team\"\n\nrbac:\n  create: true\n  strictMode: true  # Enforce strict RBAC permissions\nEOF\n</code></pre> <ol> <li>Install the scanner infrastructure:</li> </ol> <pre><code>helm install scanner-infrastructure ./scanner-infrastructure \\\n  --values my-infrastructure-values.yaml \\\n  --namespace cinc-scanner \\\n  --create-namespace\n</code></pre>"},{"location":"tasks/helm-deployment/#step-3-deploy-the-common-scanner-components","title":"Step 3: Deploy the Common Scanner Components","text":"<p>Security Consideration</p> <p>The common scanner chart deploys shared components used by all scanner types with secure defaults.</p> <ol> <li>Review the common scanner values:</li> </ol> <pre><code>cat common-scanner/values.yaml\n</code></pre> <ol> <li>Create a custom values file for common components:</li> </ol> <pre><code>cat &gt; my-common-values.yaml &lt;&lt; EOF\n# Reference the infrastructure chart components\ninfrastructure:\n  serviceAccount:\n    name: scanner-sa\n\n# Configure scripts and thresholds\nconfigMaps:\n  scripts:\n    create: true\n  thresholds:\n    create: true\n    defaultThreshold: 80  # Minimum passing score percentage\n    criticalFailures: 0   # No critical failures allowed\n    highFailures: 2       # Maximum allowed high severity failures\n\nsecurity:\n  podSecurityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    runAsGroup: 1000\n    fsGroup: 1000\nEOF\n</code></pre> <ol> <li>Install the common scanner components:</li> </ol> <pre><code>helm install common-scanner ./common-scanner \\\n  --values my-common-values.yaml \\\n  --namespace cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#step-4-deploy-a-scanner-type","title":"Step 4: Deploy a Scanner Type","text":"<p>Security Consideration</p> <p>Choose the scanner type that best matches your security requirements. The standard scanner is the most secure for regular containers.</p>"},{"location":"tasks/helm-deployment/#for-standard-container-scanning","title":"For Standard Container Scanning","text":"<ol> <li>Review the standard scanner values:</li> </ol> <pre><code>cat standard-scanner/values.yaml\n</code></pre> <ol> <li>Create a custom values file:</li> </ol> <pre><code>cat &gt; my-standard-values.yaml &lt;&lt; EOF\n# Reference common components\ncommon:\n  enabled: true\n  serviceAccount:\n    name: scanner-sa\n\n# Scanner configuration\nscanner:\n  image:\n    repository: ghcr.io/mitre/cinc-auditor-container\n    tag: latest\n  resources:\n    limits:\n      cpu: 500m\n      memory: 512Mi\n    requests:\n      cpu: 100m\n      memory: 128Mi\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    capabilities:\n      drop:\n      - ALL\n\n# Profile configuration\nprofiles:\n  - name: linux-baseline\n    source: dev-sec/linux-baseline\n    threshold: 80\nEOF\n</code></pre> <ol> <li>Install the standard scanner:</li> </ol> <pre><code>helm install standard-scanner ./standard-scanner \\\n  --values my-standard-values.yaml \\\n  --namespace cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#for-distroless-container-scanning","title":"For Distroless Container Scanning","text":"<pre><code>cat &gt; my-distroless-values.yaml &lt;&lt; EOF\n# Reference common components\ncommon:\n  enabled: true\n  serviceAccount:\n    name: scanner-sa\n\n# Scanner configuration\nscanner:\n  image:\n    repository: ghcr.io/mitre/cinc-auditor-debug-container\n    tag: latest\n  resources:\n    limits:\n      cpu: 500m\n      memory: 512Mi\n  securityContext:\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop:\n      - ALL\n\n# Profile configuration\nprofiles:\n  - name: linux-baseline\n    source: dev-sec/linux-baseline\n    threshold: 75\nEOF\n\nhelm install distroless-scanner ./distroless-scanner \\\n  --values my-distroless-values.yaml \\\n  --namespace cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#for-sidecar-container-scanning","title":"For Sidecar Container Scanning","text":"<pre><code>cat &gt; my-sidecar-values.yaml &lt;&lt; EOF\n# Reference common components\ncommon:\n  enabled: true\n  serviceAccount:\n    name: scanner-sa\n\n# Scanner configuration\nscanner:\n  image:\n    repository: ghcr.io/mitre/cinc-auditor-sidecar\n    tag: latest\n  resources:\n    limits:\n      cpu: 300m\n      memory: 384Mi\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n\n# Pod configuration\npod:\n  shareProcessNamespace: true\n\n# Profile configuration\nprofiles:\n  - name: linux-baseline\n    source: dev-sec/linux-baseline\n    threshold: 80\nEOF\n\nhelm install sidecar-scanner ./sidecar-scanner \\\n  --values my-sidecar-values.yaml \\\n  --namespace cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#step-5-verify-the-deployment","title":"Step 5: Verify the Deployment","text":"<ol> <li>Check that all components deployed successfully:</li> </ol> <pre><code>helm list -n cinc-scanner\nkubectl get all -n cinc-scanner\n</code></pre> <ol> <li>Verify RBAC resources:</li> </ol> <pre><code>kubectl get serviceaccounts,roles,rolebindings -n cinc-scanner\n</code></pre> <ol> <li>Check configmaps for scripts and thresholds:</li> </ol> <pre><code>kubectl get configmaps -n cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#step-6-run-a-test-scan","title":"Step 6: Run a Test Scan","text":"<p>Security Consideration</p> <p>Running a test scan validates that your deployment has the correct permissions while also checking your container security.</p> <ol> <li>Deploy a test pod:</li> </ol> <pre><code># For standard scanner\nkubectl apply -f standard-scanner/templates/test-pod.yaml -n cinc-scanner\n\n# For distroless scanner\nkubectl apply -f distroless-scanner/templates/test-pod.yaml -n cinc-scanner\n\n# For sidecar scanner\nkubectl apply -f sidecar-scanner/templates/test-pod.yaml -n cinc-scanner\n</code></pre> <ol> <li>Wait for the pod to complete:</li> </ol> <pre><code>kubectl wait --for=condition=complete job/scanner-test-job -n cinc-scanner --timeout=300s\n</code></pre> <ol> <li>Check the scan results:</li> </ol> <pre><code>kubectl logs job/scanner-test-job -n cinc-scanner\n</code></pre>"},{"location":"tasks/helm-deployment/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Review chart values thoroughly before deployment</li> <li>Use custom values files rather than modifying chart files directly</li> <li>Enable the strictMode RBAC option for tighter security controls</li> <li>Configure resource limits for all containers to prevent resource exhaustion</li> <li>Implement proper pod security contexts with non-root execution</li> <li>Set appropriate threshold values based on your security requirements</li> <li>Use a specific image tag rather than 'latest' for production deployments</li> <li>Apply network policies to restrict scanner communication</li> <li>Store sensitive values in Kubernetes secrets rather than values files</li> <li>Regularly update scanner images to include security patches</li> </ul>"},{"location":"tasks/helm-deployment/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify service account permissions</li> </ol> <pre><code>kubectl auth can-i --as=system:serviceaccount:cinc-scanner:scanner-sa \\\n  get pods -n cinc-scanner\n\nkubectl auth can-i --as=system:serviceaccount:cinc-scanner:scanner-sa \\\n  create pods/exec -n cinc-scanner\n</code></pre> <ol> <li>Validate security contexts</li> </ol> <pre><code>kubectl get pods -n cinc-scanner -o jsonpath='{.items[*].spec.securityContext}'\n</code></pre> <ol> <li>Check resource limits</li> </ol> <pre><code>kubectl get pods -n cinc-scanner -o jsonpath='{.items[*].spec.containers[*].resources}'\n</code></pre>"},{"location":"tasks/helm-deployment/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Helm chart installation fails Verify Helm version (v3+) and proper cluster access Permission denied errors Check RBAC configuration and service account permissions Scanner pods failing to start Inspect logs with <code>kubectl logs</code> and verify image exists and is accessible Security context issues Verify that your cluster's Pod Security Admission allows the security contexts defined in values Charts not finding dependencies Make sure you're in the helm-charts directory and dependency charts are available"},{"location":"tasks/helm-deployment/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configure scanning thresholds to set appropriate security baselines</li> <li>Set up CI/CD integration to automate container scanning</li> <li>Implement custom profiles for your specific security requirements</li> <li>Configure RBAC for multi-tenant environments to enhance isolation</li> </ul>"},{"location":"tasks/helm-deployment/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Helm Chart Security Best Practices</li> <li>RBAC Hardening</li> <li>Kubernetes Setup</li> <li>Container Scanner Security Models</li> </ul>"},{"location":"tasks/inventory/","title":"Tasks Directory Inventory","text":"<p>This directory contains task-oriented guides for common scanning and security operations with the Kube CINC Secure Scanner.</p>"},{"location":"tasks/inventory/#files","title":"Files","text":"<ul> <li>index.md - Overview and introduction to tasks</li> <li>template.md - Template for creating new task pages</li> </ul>"},{"location":"tasks/inventory/#container-scanning-tasks","title":"Container Scanning Tasks","text":"<ul> <li>standard-container-scan.md - Standard container scanning task</li> <li>distroless-container-scan.md - Distroless container scanning task</li> <li>sidecar-container-scan.md - Sidecar container scanning task</li> </ul>"},{"location":"tasks/inventory/#cicd-integration-tasks","title":"CI/CD Integration Tasks","text":"<ul> <li>github-integration.md - GitHub Actions integration task</li> <li>gitlab-integration.md - GitLab CI integration task</li> <li>thresholds-configuration.md - Thresholds configuration task</li> </ul>"},{"location":"tasks/inventory/#security-setup-tasks","title":"Security Setup Tasks","text":"<ul> <li>rbac-setup.md - RBAC configuration task</li> <li>token-management.md - Token management task</li> </ul>"},{"location":"tasks/inventory/#deployment-tasks","title":"Deployment Tasks","text":"<ul> <li>helm-deployment.md - Helm chart deployment task</li> <li>script-deployment.md - Script-based deployment task</li> <li>kubernetes-setup.md - Kubernetes setup task</li> </ul>"},{"location":"tasks/inventory/#purpose","title":"Purpose","text":"<p>Task pages provide practical, step-by-step instructions for common operations with a strong focus on security considerations. They are designed to be more concise and action-oriented than the learning paths, focusing on specific tasks rather than broader learning objectives.</p>"},{"location":"tasks/kubernetes-setup/","title":"Kubernetes Setup","text":""},{"location":"tasks/kubernetes-setup/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Proper Kubernetes setup is the foundation of secure container scanning. This task implements security best practices for cluster preparation, ensuring proper isolation, network security, and access controls for scanner operations.</p> <p>This task guides you through setting up a Kubernetes environment for secure container scanning. It covers both existing cluster preparation and local testing environment setup, with a focus on security considerations throughout.</p> <p>Time to complete: 30-45 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Involves cluster configuration and service setup</p> <p>Security approach: Implements proper namespace isolation, secure service account configuration, and network security controls for scanner operations</p>"},{"location":"tasks/kubernetes-setup/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Kubernetes setup for secure scanning involves multiple security boundaries:</p> <p>1. Cluster Administration Permissions * Control: Ability to create and manage namespaces, ClusterRoles, and system resources * Risk area: Excessive administrative access could compromise the entire cluster * Mitigation: Use dedicated service accounts with specific permissions for administrative tasks</p> <p>2. Namespace-Level Permissions * Control: Access to resources within the scanner namespace * Risk area: Cross-namespace access could lead to privilege escalation * Mitigation: Implement proper namespace isolation with resource quotas and network policies</p> <p>3. Pod Security Standards * Control: Security context and capabilities of deployed pods * Risk area: Insecure pod configurations could lead to container escapes * Mitigation: Enforce restrictive Pod Security Standards for all scanner components</p>"},{"location":"tasks/kubernetes-setup/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Access to a Kubernetes cluster (existing or ability to create a local one)</li> <li> kubectl installed and configured</li> <li> Administrative access to create namespaces and RBAC resources</li> <li> Basic understanding of Kubernetes security principles</li> </ul>"},{"location":"tasks/kubernetes-setup/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/kubernetes-setup/#step-1-choose-your-environment-type","title":"Step 1: Choose Your Environment Type","text":"<p>Security Consideration</p> <p>Different environments have different security requirements. Choose the one most appropriate for your needs.</p> <p>There are two main approaches to setting up your Kubernetes environment:</p> <ol> <li>Existing Cluster Setup: Configure an existing Kubernetes cluster for scanning</li> <li>Local Minikube Setup: Create a local testing environment using Minikube</li> </ol>"},{"location":"tasks/kubernetes-setup/#step-2-existing-cluster-setup","title":"Step 2: Existing Cluster Setup","text":"<p>Follow these steps if you're using an existing Kubernetes cluster:</p> <ol> <li>Verify cluster requirements:</li> </ol> <pre><code># Check Kubernetes version\nkubectl version --short\n\n# Verify RBAC is enabled\nkubectl api-versions | grep rbac\n</code></pre> <ol> <li>Create a dedicated namespace for scanning operations:</li> </ol> <pre><code>kubectl create namespace scanner-system\n</code></pre> <ol> <li>Apply resource quotas for proper isolation:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: scanner-quota\n  namespace: scanner-system\nspec:\n  hard:\n    pods: \"10\"\n    requests.cpu: \"1\"\n    requests.memory: 1Gi\n    limits.cpu: \"2\"\n    limits.memory: 2Gi\nEOF\n</code></pre> <ol> <li>Apply network policies for enhanced security:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: scanner-network-policy\n  namespace: scanner-system\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: scanner-system\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: scanner-system\n  - to:\n    ports:\n    - port: 443\n      protocol: TCP\nEOF\n</code></pre> <ol> <li>Label the namespace for network policy targeting:</li> </ol> <pre><code>kubectl label namespace scanner-system name=scanner-system\n</code></pre> <p>For more details, follow the Existing Cluster Requirements guide.</p>"},{"location":"tasks/kubernetes-setup/#step-3-local-minikube-setup","title":"Step 3: Local Minikube Setup","text":"<p>Security Consideration</p> <p>Even in local testing environments, proper security controls should be implemented.</p> <p>If you don't have access to an existing cluster, or want a dedicated testing environment, you can set up Minikube:</p> <ol> <li>Install Minikube if not already installed:</li> </ol> <pre><code># For macOS (using Homebrew)\nbrew install minikube\n\n# For Linux\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n</code></pre> <ol> <li>Start Minikube with appropriate resources:</li> </ol> <pre><code>minikube start --cpus=2 --memory=4g --disk-size=20g --driver=docker\n</code></pre> <ol> <li>For distroless container scanning support, enable feature gates:</li> </ol> <pre><code>minikube start --cpus=2 --memory=4g --feature-gates=EphemeralContainers=true\n</code></pre> <ol> <li>Verify the setup:</li> </ol> <pre><code>minikube status\nkubectl get nodes\n</code></pre> <ol> <li>Create the scanner namespace:</li> </ol> <pre><code>kubectl create namespace scanner-system\n</code></pre> <p>For a more automated setup, you can use the provided setup script:</p> <pre><code># Basic setup\n./scripts/kubernetes/setup-minikube.sh\n\n# Setup with distroless container support\n./scripts/kubernetes/setup-minikube.sh --with-distroless\n</code></pre> <p>For detailed steps and more options, see the Minikube Setup Guide.</p>"},{"location":"tasks/kubernetes-setup/#step-4-configure-service-accounts","title":"Step 4: Configure Service Accounts","text":"<p>Security Consideration</p> <p>Using dedicated service accounts with minimal permissions is essential for secure scanner operations.</p> <ol> <li>Create a service account for scanner operations:</li> </ol> <pre><code>kubectl create serviceaccount scanner-sa -n scanner-system\n</code></pre> <ol> <li>Create a role with minimal required permissions:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: scanner-role\n  namespace: scanner-system\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\nEOF\n</code></pre> <ol> <li>Bind the role to the service account:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: scanner-rolebinding\n  namespace: scanner-system\nsubjects:\n- kind: ServiceAccount\n  name: scanner-sa\n  namespace: scanner-system\nroleRef:\n  kind: Role\n  name: scanner-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n</code></pre>"},{"location":"tasks/kubernetes-setup/#step-5-deploy-test-pods-for-scanning","title":"Step 5: Deploy Test Pods for Scanning","text":"<p>Security Consideration</p> <p>Test pods should follow security best practices even in testing environments.</p> <ol> <li>Deploy a standard container test pod:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-standard\n  namespace: scanner-system\n  labels:\n    app: test-pod\n    type: standard\nspec:\n  containers:\n  - name: nginx\n    image: nginx:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsUser: 1000\n      runAsGroup: 1000\nEOF\n</code></pre> <ol> <li>For testing with a distroless container:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-distroless\n  namespace: scanner-system\n  labels:\n    app: test-pod\n    type: distroless\nspec:\n  containers:\n  - name: distroless\n    image: gcr.io/distroless/java:latest\n    command: [\"java\", \"-jar\", \"/app.jar\"]\nEOF\n</code></pre> <ol> <li>Verify test pods are running:</li> </ol> <pre><code>kubectl get pods -n scanner-system --show-labels\n</code></pre>"},{"location":"tasks/kubernetes-setup/#step-6-configure-kubeconfig-for-scanning","title":"Step 6: Configure Kubeconfig for Scanning","text":"<p>Security Consideration</p> <p>Using properly scoped kubeconfig files enhances security by limiting access.</p> <ol> <li>Generate a restricted kubeconfig for scanner operations:</li> </ol> <pre><code>./scripts/kubernetes/generate-kubeconfig.sh scanner-sa scanner-system\n</code></pre> <ol> <li>This script performs these actions:</li> <li>Creates a token for the service account</li> <li>Extracts cluster information</li> <li>Generates a kubeconfig file with minimal permissions</li> <li> <p>Sets proper file permissions</p> </li> <li> <p>Alternatively, you can create the kubeconfig manually:</p> </li> </ol> <pre><code># Generate token\nTOKEN=$(kubectl create token scanner-sa -n scanner-system --duration=1h)\n\n# Get cluster information\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create kubeconfig\ncat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: scanner-system\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n\n# Set secure permissions\nchmod 600 scanner-kubeconfig.yaml\n</code></pre>"},{"location":"tasks/kubernetes-setup/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use dedicated namespaces for scanner operations</li> <li>Implement network policies to restrict pod communication</li> <li>Apply resource quotas to prevent resource exhaustion</li> <li>Use non-root users for all containers</li> <li>Implement least-privilege RBAC for service accounts</li> <li>Generate short-lived tokens for scanner operations</li> <li>Use appropriate Pod Security Standards</li> <li>Regularly rotate credentials and tokens</li> <li>Monitor and audit scanner operations</li> <li>Keep Kubernetes and all components up to date</li> <li>Use secure container images with minimal attack surface</li> </ul>"},{"location":"tasks/kubernetes-setup/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify namespace isolation</li> </ol> <pre><code># Test network policy\nkubectl run temp-pod --rm -it --image=busybox -n default -- wget -T 5 -O- http://test-standard.scanner-system\n# Should timeout or fail due to network policy\n</code></pre> <ol> <li>Test RBAC configuration</li> </ol> <pre><code># Test service account permissions\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner-sa get pods -n scanner-system\n# Should return \"yes\"\n\nkubectl auth can-i --as=system:serviceaccount:scanner-system:scanner-sa get pods -n default\n# Should return \"no\"\n</code></pre> <ol> <li>Verify kubeconfig works as expected</li> </ol> <pre><code>KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n scanner-system\n# Should list pods in scanner-system namespace\n\nKUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n default\n# Should return \"Error from server (Forbidden)\"\n</code></pre>"},{"location":"tasks/kubernetes-setup/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Minikube fails to start Increase allocated resources or try a different driver Permission denied errors Verify RBAC configuration and service account permissions Network policy issues Ensure namespace labels are correctly applied Ephemeral containers not working Verify Kubernetes version (1.23+) and feature gates Service account token creation fails Use an alternative method appropriate for your Kubernetes version"},{"location":"tasks/kubernetes-setup/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Deploy the scanner with scripts for a lightweight approach</li> <li>Deploy using Helm charts for a more structured setup</li> <li>Configure RBAC for more advanced security scenarios</li> <li>Set up token management for better credential security</li> <li>Run container scans to validate your setup</li> </ul>"},{"location":"tasks/kubernetes-setup/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Kubernetes Best Practices</li> <li>Network Security</li> <li>Resource Isolation</li> <li>Security Principles</li> </ul>"},{"location":"tasks/rbac-setup/","title":"RBAC Configuration","text":""},{"location":"tasks/rbac-setup/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Properly configured RBAC is the cornerstone of Kubernetes security. This task implements the principle of least privilege, ensuring that scanner components have only the minimum permissions required to perform their functions, minimizing the potential blast radius of any compromise.</p> <p>This task guides you through setting up secure Role-Based Access Control (RBAC) for Kube CINC Secure Scanner. Proper RBAC configuration ensures that scanning operations maintain a strong security posture while having sufficient permissions to perform container inspections.</p> <p>Time to complete: 20-30 minutes</p> <p>Security risk: \ud83d\udd34 High - Involves creating security-critical Kubernetes RBAC resources</p> <p>Security approach: Implements least-privilege access controls, time-limited credentials, and precise permission scoping for container scanning operations</p>"},{"location":"tasks/rbac-setup/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>RBAC configuration for secure container scanning involves multiple permission layers:</p> <p>1. Administrative Permissions * Control: Ability to create and manage RBAC resources (Roles, RoleBindings, ClusterRoles) * Risk area: Overly broad administrative access could compromise cluster security * Mitigation: Use dedicated admin service accounts with limited scope for RBAC management</p> <p>2. Scanner Service Account Permissions * Control: Scanner's ability to interact with target containers through the Kubernetes API * Risk area: Excessive permissions could allow unauthorized container access * Mitigation: Create highly-scoped roles with precise resource and verb limitations</p> <p>3. Pod-Level Security Context * Control: Container-level permissions affecting the scanner's capabilities * Risk area: Improper security contexts could grant excessive privileges  * Mitigation: Apply restrictive pod security contexts with non-root execution</p>"},{"location":"tasks/rbac-setup/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Administrative access to create service accounts, roles, and role bindings in your Kubernetes cluster</li> <li> Understanding of Kubernetes RBAC concepts (roles, bindings, service accounts)</li> <li> Knowledge of your target container scanning approach (Standard, Distroless, or Sidecar)</li> <li> Access to the kubectl command line tool configured for your cluster</li> </ul>"},{"location":"tasks/rbac-setup/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/rbac-setup/#step-1-create-a-dedicated-namespace","title":"Step 1: Create a Dedicated Namespace","text":"<p>Security Consideration</p> <p>Using a dedicated namespace isolates scanner resources and simplifies permission management.</p> <ol> <li>Create a namespace for scanner operations:</li> </ol> <pre><code>kubectl create namespace cinc-scanner\n</code></pre> <ol> <li>Add labels for better organization:</li> </ol> <pre><code>kubectl label namespace cinc-scanner purpose=security-scanning owner=security-team\n</code></pre>"},{"location":"tasks/rbac-setup/#step-2-create-a-service-account","title":"Step 2: Create a Service Account","text":"<p>Security Consideration</p> <p>Each scanning operation should use a dedicated service account to maintain proper access controls and auditability.</p> <ol> <li>Create a service account for the scanner:</li> </ol> <pre><code>kubectl create serviceaccount cinc-scanner -n cinc-scanner\n</code></pre> <ol> <li>For more advanced configuration, use a YAML definition:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: cinc-scanner\n  namespace: cinc-scanner\n  labels:\n    app: cinc-scanner\n    security: restricted\nEOF\n</code></pre>"},{"location":"tasks/rbac-setup/#step-3-create-role-for-standard-container-scanning","title":"Step 3: Create Role for Standard Container Scanning","text":"<p>Security Consideration</p> <p>The role should only grant permissions to the specific resources needed for scanning, avoiding overly broad access.</p> <ol> <li>Create a role for standard container scanning:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: cinc-scanner-role\n  namespace: cinc-scanner\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\nEOF\n</code></pre> <ol> <li>For target-specific scanning with even tighter restrictions:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: cinc-scanner-restricted-role\n  namespace: cinc-scanner\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n  # Optional: Add resourceNames if you want to restrict to specific pods\n  # resourceNames: [\"pod-to-scan-1\", \"pod-to-scan-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"pod-to-scan-1\", \"pod-to-scan-2\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"pod-to-scan-1\", \"pod-to-scan-2\"]\nEOF\n</code></pre>"},{"location":"tasks/rbac-setup/#step-4-create-label-based-rbac-advanced","title":"Step 4: Create Label-Based RBAC (Advanced)","text":"<p>Security Consideration</p> <p>Label-based RBAC allows for dynamic selection of containers to scan without modifying RBAC configurations.</p> <ol> <li>Create a role that uses label selectors for more dynamic targeting:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: cinc-scanner-label-role\n  namespace: cinc-scanner\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  # This allows exec only on pods with the scan-target=true label\n  resourceSelector:\n    matchLabels:\n      scan-target: \"true\"\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceSelector:\n    matchLabels:\n      scan-target: \"true\"\nEOF\n</code></pre> <ol> <li>To use this approach, ensure your target pods have the appropriate label:</li> </ol> <pre><code>kubectl label pod &lt;pod-name&gt; scan-target=true -n cinc-scanner\n</code></pre>"},{"location":"tasks/rbac-setup/#step-5-create-role-binding","title":"Step 5: Create Role Binding","text":"<p>Security Consideration</p> <p>The role binding links the service account to its permissions. Each scan role should have its own binding.</p> <ol> <li>Create a role binding for the scanner service account:</li> </ol> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: cinc-scanner-binding\n  namespace: cinc-scanner\nsubjects:\n- kind: ServiceAccount\n  name: cinc-scanner\n  namespace: cinc-scanner\nroleRef:\n  kind: Role\n  name: cinc-scanner-role\n  apiGroup: rbac.authorization.k8s.io\nEOF\n</code></pre>"},{"location":"tasks/rbac-setup/#step-6-generate-short-lived-token","title":"Step 6: Generate Short-Lived Token","text":"<p>Security Consideration</p> <p>Using short-lived tokens limits the window of credential validity, enhancing security.</p> <ol> <li>Generate a token with a short expiration time (15 minutes):</li> </ol> <pre><code>TOKEN=$(kubectl create token cinc-scanner -n cinc-scanner --duration=15m)\necho $TOKEN\n</code></pre> <ol> <li>Create a kubeconfig file using this token:</li> </ol> <pre><code>SERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\ncat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: cinc-scanner\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n\n# Set proper permissions\nchmod 600 scanner-kubeconfig.yaml\n</code></pre>"},{"location":"tasks/rbac-setup/#step-7-test-rbac-configuration","title":"Step 7: Test RBAC Configuration","text":"<ol> <li>Verify scanner service account can list pods:</li> </ol> <pre><code>KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n cinc-scanner\n</code></pre> <ol> <li>Verify scanner can execute commands in a target pod:</li> </ol> <pre><code>KUBECONFIG=scanner-kubeconfig.yaml kubectl exec -it &lt;pod-name&gt; -n cinc-scanner -- ls\n</code></pre> <ol> <li>Verify the scanner cannot access other namespaces:</li> </ol> <pre><code>KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n default\n# This should fail with a permissions error\n</code></pre>"},{"location":"tasks/rbac-setup/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Create dedicated service accounts for each scanning use case</li> <li>Use role bindings scoped to specific namespaces, avoiding cluster-wide permissions</li> <li>Generate short-lived tokens (15 minutes or less) for scanning operations</li> <li>Implement resource name restrictions when possible to limit access to specific pods</li> <li>Use label selectors for dynamic targeting of containers to scan</li> <li>Regularly audit and rotate all scanner credentials</li> <li>Apply the principle of least privilege by only granting required permissions</li> <li>Avoid giving scanner accounts permissions to modify pod specs or create new pods</li> <li>Use separate RBAC configurations for CI/CD scanning vs. operational scanning</li> </ul>"},{"location":"tasks/rbac-setup/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify proper RBAC scoping</li> </ol> <pre><code># Check that scanner role has minimal permissions\nkubectl describe role cinc-scanner-role -n cinc-scanner\n</code></pre> <ol> <li>Test token expiration</li> </ol> <pre><code># Wait for token to expire (15+ minutes)\nsleep 900\n# This should fail with an authentication error\nKUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n cinc-scanner\n</code></pre> <ol> <li>Verify namespace isolation</li> </ol> <pre><code># Should succeed\nKUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n cinc-scanner\n\n# Should fail with permission error\nKUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n kube-system\n</code></pre>"},{"location":"tasks/rbac-setup/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Permission denied errors Verify that the role and role binding are correctly configured and the service account has the necessary permissions Token expired errors Generate a new token using kubectl create token with an appropriate duration Cannot access target pod Check that the pod is in the correct namespace and that resourceNames are correctly specified in the role Cannot create token Ensure you're using Kubernetes 1.24+ or implement an alternative token generation method for older versions Label selector not working Verify that pods have the correct labels and that the label selector syntax is correct"},{"location":"tasks/rbac-setup/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configure token management for more advanced credential handling</li> <li>Implement GitLab CI integration using the RBAC configuration</li> <li>Set up GitHub Actions integration with secure scanner credentials</li> <li>Configure namespace-specific scanning for multi-tenant environments</li> </ul>"},{"location":"tasks/rbac-setup/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Kubernetes RBAC Best Practices</li> <li>Ephemeral Credentials Management</li> <li>Namespace Isolation</li> <li>RBAC Hardening</li> </ul>"},{"location":"tasks/script-deployment/","title":"Script-Based Deployment","text":""},{"location":"tasks/script-deployment/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This task implements a secure script-based deployment that follows security best practices including temporary RBAC resources, ephemeral credentials, and automatic cleanup to maintain a strong security posture without requiring Helm or other complex deployment tools.</p> <p>This task guides you through the hands-on approach of deploying and using Kube CINC Secure Scanner using direct shell scripts. These scripts provide a lightweight, flexible approach to container scanning with a focus on local Minikube environments and direct command execution.</p> <p>Alternative Deployment Option</p> <p>This task focuses on the script-based deployment approach with direct commands. If you prefer a more structured, repeatable deployment method, see the Helm Deployment task which uses Helm charts to accomplish similar goals.</p> <p>Time to complete: 15-20 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Involves creating and executing scripts with Kubernetes access</p> <p>Security approach: Implements least-privilege access controls, time-limited credentials, and proper resource cleanup using simple shell scripts</p>"},{"location":"tasks/script-deployment/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Script-based deployment involves managing permissions across several layers:</p> <p>1. Script Execution Permissions * Control: Who can run the scanning scripts and with what privileges * Risk area: Unrestricted script execution could lead to security issues * Mitigation: Implement proper file permissions and execute scripts with minimal privileges</p> <p>2. Kubernetes API Permissions * Control: What Kubernetes resources the scripts can access * Risk area: Overly permissive kubeconfig could allow unintended access * Mitigation: Scripts generate dedicated service accounts with minimal, time-limited permissions</p> <p>3. Scanner Runtime Permissions * Control: What the scanner can access within target containers * Risk area: Excessive access to container internals * Mitigation: Apply principle of least privilege with clearly defined resource scopes</p>"},{"location":"tasks/script-deployment/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Bash shell environment</li> <li> kubectl configured with access to your Kubernetes cluster</li> <li> CINC Auditor installed locally</li> <li> Permission to create service accounts, roles, and role bindings in your cluster</li> <li> Kubernetes cluster that meets the requirements for existing clusters</li> </ul>"},{"location":"tasks/script-deployment/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/script-deployment/#step-1-download-scanner-scripts","title":"Step 1: Download Scanner Scripts","text":"<p>Security Consideration</p> <p>Always verify scripts before executing them to ensure they don't contain malicious code.</p> <ol> <li>Clone the repository to access the scripts:</li> </ol> <pre><code>git clone https://github.com/mitre/kube-secure-scanner.git\ncd kube-secure-scanner\n</code></pre> <ol> <li>Navigate to the scripts directory:</li> </ol> <pre><code>cd scripts/kubernetes\n</code></pre> <ol> <li>Make the scripts executable:</li> </ol> <pre><code>chmod +x *.sh\n</code></pre>"},{"location":"tasks/script-deployment/#step-2-understanding-available-scripts","title":"Step 2: Understanding Available Scripts","text":"<p>Security Consideration</p> <p>Different scanning approaches have different security implications. Choose the most appropriate one for your security requirements.</p> <p>The repository includes several scripts for different scanning approaches:</p> <ol> <li>scan-container.sh: Standard container scanning using the Kubernetes API</li> <li>scan-distroless-container.sh: For scanning distroless containers using ephemeral debug containers</li> <li>scan-with-sidecar.sh: For scanning containers using the sidecar container approach</li> <li>generate-kubeconfig.sh: Helper script to create restricted kubeconfig files</li> <li>setup-minikube.sh: For setting up a local testing environment</li> </ol>"},{"location":"tasks/script-deployment/#step-3-review-script-security-features","title":"Step 3: Review Script Security Features","text":"<p>Let's examine the security features in the <code>scan-container.sh</code> script:</p> <pre><code># Key security features:\n# 1. Unique identifiers for all resources to prevent conflicts\nRUN_ID=$(date +%s)\nSA_NAME=\"scanner-${RUN_ID}\"\nROLE_NAME=\"scanner-role-${RUN_ID}\"\nBINDING_NAME=\"scanner-binding-${RUN_ID}\"\n\n# 2. Creation of dedicated service account\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ${SA_NAME}\n  namespace: ${NAMESPACE}\nEOF\n\n# 3. Least-privilege RBAC role with resource name restrictions\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: ${ROLE_NAME}\n  namespace: ${NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods/exec\"]\n  verbs: [\"create\"]\n  resourceNames: [\"${POD_NAME}\"]  # Restricted to specific pod\n- apiGroups: [\"\"]\n  resources: [\"pods/log\"]\n  verbs: [\"get\"]\n  resourceNames: [\"${POD_NAME}\"]  # Restricted to specific pod\nEOF\n\n# 4. Proper kubeconfig file permissions\nchmod 600 ${KUBECONFIG_FILE}\n\n# 5. Automatic cleanup of all resources\nkubectl delete rolebinding ${BINDING_NAME} -n ${NAMESPACE}\nkubectl delete role ${ROLE_NAME} -n ${NAMESPACE}\nkubectl delete serviceaccount ${SA_NAME} -n ${NAMESPACE}\nrm ${KUBECONFIG_FILE}\n</code></pre>"},{"location":"tasks/script-deployment/#step-4-basic-container-scanning","title":"Step 4: Basic Container Scanning","text":"<p>Security Consideration</p> <p>This script creates temporary RBAC resources for the duration of the scan and then removes them, minimizing the security risk.</p> <ol> <li>Scan a standard container using the scan-container.sh script:</li> </ol> <pre><code>./scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./scan-container.sh default nginx-pod nginx ~/profiles/linux-baseline\n</code></pre> <ol> <li>The script performs these actions:</li> <li>Creates a temporary service account</li> <li>Creates a role with minimal permissions</li> <li>Creates a role binding</li> <li>Generates a kubeconfig file with the service account token</li> <li>Runs the CINC Auditor scan</li> <li>Processes results with SAF-CLI</li> <li>Cleans up all resources</li> </ol>"},{"location":"tasks/script-deployment/#step-5-distroless-container-scanning","title":"Step 5: Distroless Container Scanning","text":"<p>Security Consideration</p> <p>Distroless scanning requires additional permissions for ephemeral containers, which should be handled carefully.</p> <p>To scan a distroless container:</p> <pre><code>./scan-distroless-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./scan-distroless-container.sh default distroless-app app ~/profiles/linux-baseline\n</code></pre> <p>The script includes additional code to handle ephemeral debug containers:</p> <pre><code># Launch debug container\nkubectl debug -it ${POD_NAME} -n ${NAMESPACE} \\\n  --image=busybox:latest \\\n  --share-processes \\\n  --container=debugger\n\n# Then perform chroot scan operations\n</code></pre>"},{"location":"tasks/script-deployment/#step-6-sidecar-container-scanning","title":"Step 6: Sidecar Container Scanning","text":"<p>Security Consideration</p> <p>Sidecar scanning requires shared process namespace, which must be properly secured.</p> <p>To scan using the sidecar approach:</p> <pre><code>./scan-with-sidecar.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;profile-path&gt; [threshold_file]\n</code></pre> <p>Example:</p> <pre><code>./scan-with-sidecar.sh default app-with-sidecar ~/profiles/linux-baseline\n</code></pre> <p>The script deploys a pod with shared process namespace:</p> <pre><code># Deploy pod with shared process namespace\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: ${POD_NAME}-sidecar\n  namespace: ${NAMESPACE}\nspec:\n  shareProcessNamespace: true\n  containers:\n  - name: app\n    image: ${APP_IMAGE}\n  - name: scanner\n    image: cinc-auditor:latest\n    command: [\"sleep\", \"infinity\"]\nEOF\n</code></pre>"},{"location":"tasks/script-deployment/#step-7-cicd-integration","title":"Step 7: CI/CD Integration","text":"<p>Security Consideration</p> <p>Embedding these scripts in CI/CD pipelines requires secure handling of Kubernetes credentials.</p> <ol> <li>To use these scripts in a GitHub Actions workflow:</li> </ol> <pre><code>jobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up kubeconfig\n        run: |\n          echo \"${{ secrets.KUBECONFIG }}\" &gt; kubeconfig\n          chmod 600 kubeconfig\n          export KUBECONFIG=kubeconfig\n\n      - name: Install CINC Auditor\n        run: |\n          curl -L https://omnitruck.cinc.sh/install.sh | sudo bash -s -- -P cinc-auditor\n          cinc-auditor plugin install train-k8s-container\n\n      - name: Run container scan\n        run: |\n          ./scripts/kubernetes/scan-container.sh default nginx-pod nginx dev-sec/linux-baseline\n</code></pre> <ol> <li>For GitLab CI:</li> </ol> <pre><code>scan-job:\n  stage: security\n  script:\n    - echo \"$KUBECONFIG\" &gt; kubeconfig\n    - chmod 600 kubeconfig\n    - export KUBECONFIG=kubeconfig\n    - curl -L https://omnitruck.cinc.sh/install.sh | bash -s -- -P cinc-auditor\n    - cinc-auditor plugin install train-k8s-container\n    - ./scripts/kubernetes/scan-container.sh default nginx-pod nginx dev-sec/linux-baseline\n  artifacts:\n    paths:\n      - scan-results-*.json\n      - scan-summary-*.md\n</code></pre>"},{"location":"tasks/script-deployment/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Review script content before execution</li> <li>Set restrictive file permissions (700 or 750) on scripts</li> <li>Store kubeconfig files securely with 600 permissions</li> <li>Use different threshold values for different environments</li> <li>Do not store tokens or credentials in version control</li> <li>Run scripts with the principle of least privilege</li> <li>Always enable script cleanup sections to remove temporary resources</li> <li>Verify script execution logs to ensure proper resource cleanup</li> <li>Keep scripts updated with the latest security practices</li> <li>Consider using OpenSSH's StrictModes feature when executing remotely</li> </ul>"},{"location":"tasks/script-deployment/#verification-steps","title":"Verification Steps","text":"<ol> <li>Check that temporary resources are properly cleaned up</li> </ol> <pre><code># Run after script execution - should return \"No resources found\"\nkubectl get serviceaccount scanner-* -n &lt;namespace&gt;\nkubectl get role scanner-role-* -n &lt;namespace&gt;\nkubectl get rolebinding scanner-binding-* -n &lt;namespace&gt;\n</code></pre> <ol> <li>Verify script file permissions</li> </ol> <pre><code># Should show -rwx------ (700) or -rwxr-x--- (750) permissions\nls -la scripts/kubernetes/*.sh\n</code></pre> <ol> <li>Verify successful scanning</li> </ol> <pre><code># Check scan results file\ncat scan-results-*.json | jq '.profiles[0].controls[0]'\n</code></pre>"},{"location":"tasks/script-deployment/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Permission denied when running scripts Ensure scripts are executable (<code>chmod +x *.sh</code>) Kubernetes authentication failure Verify your kubeconfig is valid and has required permissions CINC Auditor plugin missing Install required plugins with <code>cinc-auditor plugin install train-k8s-container</code> Container not accessible Check if pod is running and RBAC permissions are correct Script hangs during execution Check for potential deadlocks or resource constraints Resources not cleaned up Add <code>trap</code> commands to ensure cleanup on script failure"},{"location":"tasks/script-deployment/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configure scanning thresholds for customized security requirements</li> <li>Implement GitLab CI integration for automated scanning</li> <li>Set up GitHub Actions workflows for regular security scanning</li> <li>Create custom scanning profiles for your specific needs</li> </ul>"},{"location":"tasks/script-deployment/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>RBAC Configuration</li> <li>Token Management</li> <li>Kubernetes Setup</li> <li>Security Principles</li> </ul>"},{"location":"tasks/script-deployment/#related-learning-paths","title":"Related Learning Paths","text":"<p>Recommended Learning</p> <p>These learning paths provide additional context and knowledge that will help you understand this task better:</p> <ul> <li>Implementation Guide - Comprehensive implementation instructions including script deployment</li> <li>Core Concepts - Understand the fundamental concepts behind the scanning approaches</li> <li>Security-First Implementation - Focus on security aspects of script-based deployment</li> </ul>"},{"location":"tasks/sidecar-container-scan/","title":"Sidecar Container Scanning","text":""},{"location":"tasks/sidecar-container-scan/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>The sidecar container approach provides an alternative scanning method that works for both standard and distroless containers. It offers enhanced security by not requiring privileged debug containers, making it suitable for environments with strict security policies.</p> <p>This task guides you through scanning a container using the sidecar container approach, which utilizes a shared process namespace to enable scanning of both standard and distroless containers. This approach is particularly useful in environments where ephemeral containers are not available.</p> <p>Time to complete: 15-20 minutes</p> <p>Security risk: \ud83d\udfe1 Medium - Requires shared process namespace between containers</p> <p>Security approach: Implements container isolation with controlled shared process namespace, proper pod-level security contexts, and least-privilege sidecar configuration</p>"},{"location":"tasks/sidecar-container-scan/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Sidecar container scanning involves careful management of shared boundaries:</p> <p>1. Pod-Level Security Context * Control: Overall pod security context including shared process namespace * Risk area: Shared namespaces could allow unwanted visibility between containers * Mitigation: Configure minimal shared resources and apply pod security policies</p> <p>2. Sidecar Container Permissions * Control: Scanner's access to target container processes and filesystem * Risk area: Over-permissive sidecar could expose more container data than intended * Mitigation: Run sidecar with non-root user and restricted capabilities</p> <p>3. Target Container Isolation * Control: Primary container's isolation despite shared namespace * Risk area: Target container operation could be affected by sidecar activities * Mitigation: Run sidecar with read-only filesystem access and no write capabilities</p>"},{"location":"tasks/sidecar-container-scan/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Kubernetes cluster with shared process namespace support (v1.17+) (see Existing Cluster Requirements)</li> <li> kubectl configured for the target cluster</li> <li> Permissions to create pods and service accounts in the target namespace</li> <li> Container image to scan</li> <li> CINC Auditor profile for scanning</li> <li> Optional: Threshold file for compliance validation</li> </ul> <p>Kubernetes Setup</p> <p>If you don't have a Kubernetes cluster available, you can set up a local test environment using our Minikube Setup guide.</p>"},{"location":"tasks/sidecar-container-scan/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/sidecar-container-scan/#step-1-verify-prerequisites","title":"Step 1: Verify Prerequisites","text":"<p>Security Consideration</p> <p>The sidecar approach requires the ability to create pods with a shared process namespace. Ensure your cluster's security policies allow this feature, as it enables containers within the same pod to see each other's processes.</p> <p>Ensure your Kubernetes cluster supports shared process namespaces:</p> <pre><code># Check Kubernetes version - should be 1.17+\nkubectl version --short\n\n# Verify you have permissions to create pods in the target namespace\nkubectl auth can-i create pods --namespace=default\n</code></pre>"},{"location":"tasks/sidecar-container-scan/#step-2-prepare-your-inspec-profile","title":"Step 2: Prepare Your InSpec Profile","text":"<p>Security Consideration</p> <p>Select an appropriate InSpec profile that aligns with your security requirements. For distroless containers, focus on filesystem checks rather than process or package checks.</p> <pre><code># Example for using the built-in container baseline profile\n# The project includes sample profiles in examples/cinc-profiles/\ncd /path/to/kube-secure-scanner\nls examples/cinc-profiles/container-baseline\n</code></pre> <p>You can use the built-in examples or provide your own InSpec profile path.</p>"},{"location":"tasks/sidecar-container-scan/#step-3-run-the-scanning-script","title":"Step 3: Run the Scanning Script","text":"<p>Security Consideration</p> <p>The script creates a pod with shared process namespace, which allows the scanner container to access the target container's filesystem. While this is more secure than privileged containers, it still represents a reduction in container isolation.</p> <pre><code># Syntax: ./kubernetes-scripts/scan-with-sidecar.sh &lt;namespace&gt; &lt;target-image&gt; &lt;profile-path&gt; [threshold_file]\n./kubernetes-scripts/scan-with-sidecar.sh default busybox:latest examples/cinc-profiles/container-baseline\n</code></pre> <p>For advanced usage with threshold validation:</p> <pre><code># Using a custom threshold file\n./kubernetes-scripts/scan-with-sidecar.sh default busybox:latest examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre>"},{"location":"tasks/sidecar-container-scan/#step-4-review-and-retrieve-results","title":"Step 4: Review and Retrieve Results","text":"<p>Security Consideration</p> <p>The scan results may identify security issues in your container. Review the results carefully and address any critical findings promptly.</p> <p>The script automatically retrieves the scan results and displays a summary. The results are also saved to a local directory.</p> <pre><code># View the results directory (timestamped)\nls -la scan-results-*\n\n# View detailed results\ncat scan-results-*/scan-results.json\n\n# View summary report\ncat scan-results-*/scan-summary.md\n</code></pre>"},{"location":"tasks/sidecar-container-scan/#step-5-cleanup-resources-optional","title":"Step 5: Cleanup Resources (Optional)","text":"<p>The script will ask if you want to clean up the resources it created. If you choose not to clean up during the script execution, you can do it manually later:</p> <pre><code># Replace with the actual pod name and namespace\nkubectl delete pod/sidecar-scanner-1234567890 -n default\nkubectl delete configmap/inspec-profile-1234567890 -n default\nkubectl delete configmap/inspec-threshold-1234567890 -n default\n</code></pre>"},{"location":"tasks/sidecar-container-scan/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use dedicated namespaces for scanning operations to isolate the scanner from other workloads</li> <li>Apply strict resource limits to scanner pods to prevent resource exhaustion</li> <li>Use read-only filesystem mounts where possible to minimize risk</li> <li>Implement network policies to restrict scanner pod communications</li> <li>Use custom profiles that align with your organization's security requirements</li> <li>Implement threshold validation to ensure compliance with security standards</li> <li>Clean up scanner pods immediately after use to minimize the security exposure window</li> <li>Use RBAC to limit which users can create pods with shared process namespaces</li> <li>Regularly update your scanner image to include the latest security fixes</li> </ul>"},{"location":"tasks/sidecar-container-scan/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify the scan completed successfully</li> </ol> <pre><code>cat scan-results-*/threshold-result.txt\n# Should show THRESHOLD_RESULT=0 for a passing scan\n</code></pre> <ol> <li>Check that the scan results contain valid data</li> </ol> <pre><code># Check file size - should be non-zero\nls -la scan-results-*/scan-results.json\n\n# Check that the JSON is valid\ncat scan-results-*/scan-results.json | jq '.'\n</code></pre> <ol> <li>Verify resources were cleaned up (if you chose to clean up)</li> </ol> <pre><code># These should return \"No resources found\" if cleanup was performed\nkubectl get pods -l run-id=1234567890 -n default\nkubectl get configmap/inspec-profile-1234567890 -n default\nkubectl get configmap/inspec-threshold-1234567890 -n default\n</code></pre>"},{"location":"tasks/sidecar-container-scan/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \"shareProcessNamespace is invalid\" Your Kubernetes version may not support shared process namespaces. Upgrade to v1.17+ or use a different scanning approach. Permission denied Ensure you have permissions to create pods and ConfigMaps in the target namespace. Check cluster RBAC settings. \"Target process not found\" The scanner couldn't identify the main process in the target container. You may need to modify the <code>TARGET_PROCESS</code> variable in the script to match your specific container. Scan times out Increase the timeout value in the script or check if the target container is functioning properly. \"Failed to scan target filesystem\" The target container's filesystem might not be accessible through /proc. Check if the container uses a custom mount namespace or PID namespace. InSpec profile errors Ensure the profile is compatible with the target container's operating system and configuration."},{"location":"tasks/sidecar-container-scan/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Configuring Thresholds for automated compliance validation</li> <li>GitLab CI Integration or GitHub Actions Integration to automate scanning</li> <li>RBAC Configuration for fine-tuning scanner permissions</li> <li>Compare with other scanning approaches: Standard Container Scanning or Distroless Container Scanning</li> </ul>"},{"location":"tasks/sidecar-container-scan/#compliance-and-security-considerations","title":"Compliance and Security Considerations","text":"<ul> <li> <p> Risk Analysis</p> <p>Review comprehensive security risk assessment for this approach:</p> <ul> <li>Sidecar Container Security Risks</li> <li>Key risk: Permanent container isolation compromise</li> <li>Overall risk rating: \ud83d\udfe0 Medium-High</li> </ul> <p> Full Risk Analysis</p> </li> <li> <p> Compliance Impact</p> <p>This approach has significant compliance implications:</p> <ul> <li>CIS 5.2.4: \u274c Non-alignment (requires process namespace sharing)</li> <li>STIG V-242432: \u26a0\ufe0f Partial alignment (breaks process isolation)</li> <li>DoD 8500.01: \u26a0\ufe0f Partial alignment (non-standard access pattern)</li> </ul> <p> Compliance Comparison</p> </li> <li> <p> Security Principles</p> <p>Core security principles to consider:</p> <ul> <li>Resource Isolation</li> <li>Least Privilege Principle</li> <li>Secure Transport</li> </ul> <p> Security Principles</p> </li> <li> <p> Documentation Requirements</p> <p>For compliance documentation, you MUST:</p> <ul> <li>Create formal risk acceptance documentation</li> <li>Justify the business need for process namespace sharing</li> <li>Document all mitigations implemented</li> <li>Include sign-off from security authority</li> <li>Establish enhanced monitoring controls</li> </ul> <p> Risk Documentation</p> </li> </ul>"},{"location":"tasks/standard-container-scan/","title":"Standard Container Scanning","text":""},{"location":"tasks/standard-container-scan/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This task implements security best practices including least privilege RBAC, short-lived tokens, and temporary credentials. The standard container scanning approach is the most secure scanning method for non-distroless containers.</p> <ul> <li> <p> Standard Container Scanning</p> <p>This task guides you through scanning a standard (non-distroless) container using the Kubernetes API approach. The approach uses the train-k8s-container transport to execute commands inside the target container through the Kubernetes API.</p> </li> <li> <p> Task Details</p> <p>Time to complete: 10-15 minutes Security risk: \ud83d\udfe1 Medium - Requires creation of temporary service accounts and RBAC resources Security approach: Implements security best practices including ephemeral credentials, least-privilege RBAC, and proper resource lifecycle management</p> </li> </ul>"},{"location":"tasks/standard-container-scan/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Standard container scanning involves multiple distinct permission layers that must be properly isolated:</p> <p>1. Administrator/Operator Permissions * Control: Ability to create service accounts, roles, and role bindings * Risk area: Over-privileged administrator access could affect other resources * Mitigation: Use service accounts with scoped permissions limited to RBAC management</p> <p>2. Scanner Service Account Permissions * Control: Scanner's ability to access and execute commands in target containers * Risk area: Overly permissive scanner permissions could allow unintended access * Mitigation: Create time-limited, namespace-scoped permissions for specific containers</p> <p>3. Container Context Permissions * Control: What the scanner can access inside the container during execution * Risk area: Root-level scanning might access sensitive container data * Mitigation: Run containers with non-root users and restricted capabilities</p>"},{"location":"tasks/standard-container-scan/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Kubernetes cluster with RBAC enabled (see Existing Cluster Requirements)</li> <li> kubectl configured for the target cluster</li> <li> Permissions to create service accounts and roles in the target namespace</li> <li> CINC Auditor installed (see prerequisites section)</li> <li> SAF CLI installed (will be automatically installed if missing)</li> </ul> <p>Kubernetes Setup</p> <p>If you don't have a Kubernetes cluster available, you can set up a local test environment using our Minikube Setup guide.</p>"},{"location":"tasks/standard-container-scan/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/standard-container-scan/#step-1-verify-prerequisites","title":"Step 1: Verify Prerequisites","text":"<p>Security Consideration</p> <p>The scanner uses CINC Auditor (open-source InSpec) to avoid licensing issues in automated environments.</p> <p>Ensure you have CINC Auditor installed:</p> <pre><code># Check if CINC Auditor is installed\ncinc-auditor version\n\n# If not installed, install it following the project documentation\n# For example, on Ubuntu/Debian:\n# sudo apt-get install cinc-auditor\n</code></pre> <p>Verify kubectl access to the cluster:</p> <pre><code># Check kubectl connection\nkubectl get nodes\n</code></pre>"},{"location":"tasks/standard-container-scan/#step-2-locate-or-create-a-profile","title":"Step 2: Locate or Create a Profile","text":"<p>Security Consideration</p> <p>Using appropriate security profiles is crucial. Ensure the profile matches the container's purpose and requirements.</p> <pre><code># Example for using the built-in container baseline profile\n# The project includes sample profiles in examples/cinc-profiles/\ncd /path/to/kube-secure-scanner\nls examples/cinc-profiles/container-baseline\n</code></pre> <p>You can use the built-in examples or provide your own InSpec profile path.</p>"},{"location":"tasks/standard-container-scan/#step-3-run-the-scanning-script","title":"Step 3: Run the Scanning Script","text":"<p>Security Consideration</p> <p>The script creates temporary resources with minimal permissions and short-lived tokens (default 1 hour). All resources are cleaned up after the scan completes.</p> <pre><code># Syntax: ./kubernetes-scripts/scan-container.sh &lt;namespace&gt; &lt;pod-name&gt; &lt;container-name&gt; &lt;profile-path&gt; [threshold_file]\n./kubernetes-scripts/scan-container.sh default nginx-pod nginx-container examples/cinc-profiles/container-baseline\n</code></pre> <p>For advanced usage with threshold validation:</p> <pre><code># Using a custom threshold file\n./kubernetes-scripts/scan-container.sh default nginx-pod nginx-container examples/cinc-profiles/container-baseline examples/thresholds/strict.yml\n</code></pre>"},{"location":"tasks/standard-container-scan/#step-4-review-scan-results","title":"Step 4: Review Scan Results","text":"<p>The script will output the scan results to the console and save detailed results to JSON and Markdown files.</p> <pre><code># View detailed results (replace timestamp with actual value)\ncat scan-results-1616844322.json\n\n# View summary report (replace timestamp with actual value)\ncat scan-summary-1616844322.md\n</code></pre>"},{"location":"tasks/standard-container-scan/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use namespace-specific service accounts for isolation</li> <li>Implement threshold validation to ensure compliance requirements are met</li> <li>Run scans with least privilege - only scan containers you need to assess</li> <li>Store scan results securely if they contain sensitive information</li> <li>Consider using GitOps to manage scanning profiles in version control</li> <li>Configure scan thresholds to align with your organization's compliance requirements</li> </ul>"},{"location":"tasks/standard-container-scan/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify the scan completed successfully with an exit code of 0</li> </ol> <pre><code>echo $?\n</code></pre> <ol> <li>Check the scan results files exist</li> </ol> <pre><code>ls scan-results-*.json scan-summary-*.md\n</code></pre> <ol> <li>Verify temporary resources were cleaned up</li> </ol> <pre><code># Should return \"No resources found\"\nkubectl get serviceaccount scanner-* -n default\nkubectl get role scanner-role-* -n default\nkubectl get rolebinding scanner-binding-* -n default\n</code></pre>"},{"location":"tasks/standard-container-scan/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p> Permission Denied</p> <p>Ensure you have permissions to create service accounts and roles in the target namespace.</p> <pre><code># Check your permissions\nkubectl auth can-i create serviceaccount --namespace=default\nkubectl auth can-i create role --namespace=default\nkubectl auth can-i create rolebinding --namespace=default\n</code></pre> </li> <li> <p> Container Not Found</p> <p>Verify the namespace, pod name, and container name.</p> <pre><code># List available pods\nkubectl get pods -n &lt;namespace&gt;\n\n# Get details of a specific pod\nkubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;\n</code></pre> </li> <li> <p> InSpec Profile Errors</p> <p>Ensure the profile exists and is correctly formatted.</p> <pre><code># Check profile structure\nls -la &lt;profile-path&gt;\n\n# Validate profile syntax\ncinc-auditor check &lt;profile-path&gt;\n</code></pre> </li> <li> <p> SAF CLI Not Found</p> <p>The script attempts to install SAF CLI automatically, but you may need to install Node.js first.</p> <pre><code># Check Node.js installation\nnode -v\n\n# Install SAF CLI manually if needed\nnpm install -g @mitre/saf\n</code></pre> </li> <li> <p> Threshold Validation Failed</p> <p>Review scan results and adjust either your container security posture or threshold requirements.</p> <pre><code># View detailed scan results\ncat scan-results-*.json | jq '.profiles[0].controls[] | select(.status==\"failed\")'\n</code></pre> </li> </ul>"},{"location":"tasks/standard-container-scan/#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-threshold:{ .lg .middle } Configure Security Thresholds</p> <p>Set up automated compliance validation with custom threshold files.</p> <p> Configure Thresholds</p> </li> <li> <p> CI/CD Integration</p> <p>Automate scanning in your continuous integration pipelines.</p> <p> GitHub Actions \u00b7  GitLab CI</p> </li> <li> <p> Security Hardening</p> <p>Fine-tune RBAC permissions and access controls.</p> <p> RBAC Configuration</p> </li> <li> <p> Advanced Scanning</p> <p>Explore scanning of specialized container types.</p> <p> Distroless Container Scanning</p> </li> </ul>"},{"location":"tasks/standard-container-scan/#compliance-and-security-considerations","title":"Compliance and Security Considerations","text":"<ul> <li> <p> Risk Analysis</p> <p>Review comprehensive security risk assessment for this approach:</p> <ul> <li>Kubernetes API Security Risks</li> <li>Key risk: Minimal - uses standard K8s APIs</li> <li>Overall risk rating: \ud83d\udfe2 Low</li> </ul> <p> Full Risk Analysis</p> </li> <li> <p> Compliance Impact</p> <p>This approach has strong compliance alignment:</p> <ul> <li>DoD 8500.01: \u2705 Full alignment (standard interfaces)</li> <li>SRG-APP-000142: \u2705 Full alignment (least privilege)</li> <li>STIG V-242423: \u2705 Full alignment (clear RBAC implementation)</li> <li>CIS 5.2.4: \u2705 Full alignment (no process sharing needed)</li> </ul> <p> Compliance Comparison</p> </li> <li> <p> Security Principles</p> <p>Core security principles applied in this task:</p> <ul> <li>Least Privilege Principle</li> <li>RBAC Security</li> <li>Security Threat Model</li> <li>Token Exposure Protection</li> </ul> <p> Security Principles</p> </li> <li> <p> Documentation Requirements</p> <p>For compliance documentation:</p> <ul> <li>Standard documentation of RBAC implementation is sufficient</li> <li>No special risk acceptance documentation required</li> <li>Document token lifecycle management</li> <li>Include audit logging configuration</li> </ul> <p> Risk Documentation</p> </li> </ul>"},{"location":"tasks/template/","title":"Task Title","text":""},{"location":"tasks/template/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>This section highlights key security aspects of this task and why they matter.</p> <p>This task guides you through [brief description]. Completing this task will enable you to [key outcome] while maintaining a strong security posture.</p> <p>Time to complete: [estimated time]</p> <p>Security risk: \ud83d\udfe1 Medium - [Brief description of security considerations]</p> <p>Security approach: [Brief description of how security is managed in this task]</p>"},{"location":"tasks/template/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>[Task name] involves multiple distinct permission layers that must be properly isolated:</p> <p>1. [Layer Name] Permissions * Control: [What this permission layer governs] * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p> <p>2. [Layer Name] Permissions * Control: [What this permission layer governs]  * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p> <p>3. [Layer Name] Permissions * Control: [What this permission layer governs] * Risk area: [Potential security issues in this layer] * Mitigation: [How the project addresses these risks]</p>"},{"location":"tasks/template/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> [Required permission 1]</li> <li> [Required security configuration 1]</li> <li> [Risk consideration 1]</li> </ul>"},{"location":"tasks/template/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/template/#step-1-first-step","title":"Step 1: [First Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 1]</p> <pre><code># Example command\ncommand example --with parameters\n</code></pre>"},{"location":"tasks/template/#step-2-second-step","title":"Step 2: [Second Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 2]</p> <pre><code># Example command\ncommand example --with parameters\n</code></pre>"},{"location":"tasks/template/#step-3-third-step","title":"Step 3: [Third Step]","text":"<p>Security Consideration</p> <p>[Security consideration for this step]</p> <p>[Detailed instructions for step 3]</p> <pre><code># Example command\ncommand example --with parameters\n</code></pre>"},{"location":"tasks/template/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>[Security recommendation 1]</li> <li>[Security recommendation 2]</li> <li>[Security recommendation 3]</li> </ul>"},{"location":"tasks/template/#verification-steps","title":"Verification Steps","text":"<ol> <li>[Verification step 1]</li> </ol> <pre><code># Verification command\nverification command --with parameters\n</code></pre> <ol> <li>[Verification step 2]</li> </ol> <pre><code># Verification command\nverification command --with parameters\n</code></pre>"},{"location":"tasks/template/#troubleshooting","title":"Troubleshooting","text":"Issue Solution [Common issue 1] [Security-aware solution 1] [Common issue 2] [Security-aware solution 2] [Common issue 3] [Security-aware solution 3]"},{"location":"tasks/template/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>[Next logical task 1]</li> <li>[Next logical task 2]</li> <li>[Related security task]</li> </ul>"},{"location":"tasks/template/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>[Link to related security documentation 1]</li> <li>[Link to related security documentation 2]</li> <li>[Link to related security documentation 3]</li> </ul>"},{"location":"tasks/thresholds-configuration/","title":"Configuring Thresholds","text":""},{"location":"tasks/thresholds-configuration/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Threshold configuration is a critical security control that determines which security issues are acceptable in your environment. Properly implemented thresholds prevent insecure containers from being deployed while allowing operations to continue when minor issues are detected.</p> <p>This task guides you through configuring security scan thresholds for Kube CINC Secure Scanner. Thresholds define the boundaries between acceptable and unacceptable security postures, enabling automated quality gates in your CI/CD pipelines.</p> <p>Time to complete: 15-20 minutes</p> <p>Security risk: \ud83d\udfe2 Low - Configuration activity without direct system access</p> <p>Security approach: Implements customizable security boundaries, multi-dimensional compliance criteria, and balanced risk management controls</p>"},{"location":"tasks/thresholds-configuration/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Threshold configuration involves managing permissions across several layers:</p> <p>1. Threshold Definition Permissions * Control: Who can define and modify threshold values * Risk area: Overly permissive thresholds could allow insecure containers to pass checks * Mitigation: Store threshold files in version-controlled repositories with proper review processes</p> <p>2. Threshold Implementation Permissions * Control: How thresholds are applied during scanning operations * Risk area: Bypassing threshold checks could undermine security controls * Mitigation: Enforce threshold validation in CI/CD pipelines with proper separation of duties</p> <p>3. Threshold Override Permissions * Control: Who can bypass threshold requirements in exceptional cases * Risk area: Excessive overrides could weaken security posture * Mitigation: Implement audit logging for all threshold overrides and require documented justification</p>"},{"location":"tasks/thresholds-configuration/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Basic understanding of compliance requirements for your containers</li> <li> CINC Auditor profiles selected for scanning</li> <li> SAF-CLI installed for threshold evaluation</li> <li> Permission to update CI/CD pipeline configurations (if implementing automated gates)</li> </ul>"},{"location":"tasks/thresholds-configuration/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/thresholds-configuration/#step-1-understanding-threshold-components","title":"Step 1: Understanding Threshold Components","text":"<p>Security Consideration</p> <p>Different components of your infrastructure may require different threshold configurations based on their risk profile and exposure.</p> <p>Thresholds in Kube CINC Secure Scanner can be defined across multiple dimensions:</p> <ol> <li>Overall Compliance Score: A percentage of passing controls</li> <li>Severity-Based Limits: Maximum number of failures by severity level</li> <li>Impact-Based Limits: Thresholds based on the impact score of findings</li> <li>Control-Specific Overrides: Allow/deny lists for specific controls</li> </ol>"},{"location":"tasks/thresholds-configuration/#step-2-create-a-basic-threshold-configuration","title":"Step 2: Create a Basic Threshold Configuration","text":"<p>Security Consideration</p> <p>Start with strict thresholds and allow exceptions only where necessary, rather than starting with lenient thresholds.</p> <ol> <li>Create a file named <code>threshold.yml</code> with the following content:</li> </ol> <pre><code>compliance:\n  min: 80  # Minimum passing score (percentage)\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\n  high:\n    max: 2  # At most 2 high failures allowed\n  medium:\n    max: 5  # At most 5 medium failures allowed\n  low:\n    max: 10  # At most 10 low failures allowed\n</code></pre> <ol> <li>This configuration enforces:</li> <li>At least 80% overall compliance</li> <li>Zero critical severity findings</li> <li>Limited number of less severe findings</li> </ol>"},{"location":"tasks/thresholds-configuration/#step-3-implement-advanced-threshold-configurations","title":"Step 3: Implement Advanced Threshold Configurations","text":"<p>Security Consideration</p> <p>Different environments (development, testing, production) should have appropriate threshold levels to balance security and operational needs.</p> <p>For more granular control, create environment-specific threshold files:</p> <p>development-threshold.yml:</p> <pre><code>compliance:\n  min: 70  # More lenient for development\nfailed:\n  critical:\n    max: 0  # Still no critical failures allowed\n  high:\n    max: 5  # More high failures allowed in development\n  medium:\n    max: 10\n  low:\n    max: 15\n</code></pre> <p>production-threshold.yml:</p> <pre><code>compliance:\n  min: 90  # More strict for production\nfailed:\n  critical:\n    max: 0  # No critical failures allowed\n  high:\n    max: 0  # No high failures allowed in production\n  medium:\n    max: 2  # Very few medium failures allowed\n  low:\n    max: 5  # Limited low failures allowed\n</code></pre>"},{"location":"tasks/thresholds-configuration/#step-4-create-control-specific-configurations","title":"Step 4: Create Control-Specific Configurations","text":"<p>Security Consideration</p> <p>Some security controls may be temporarily acceptable to fail due to business constraints, but these exceptions should be documented and time-limited.</p> <p>For scenarios where specific controls need exceptions:</p> <pre><code>compliance:\n  min: 85\nfailed:\n  critical:\n    max: 0\n  high:\n    max: 0\nexcept:\n  controls:\n    # Exception with justification and expiration\n    - id: \"os-hardening-1.2\"\n      justification: \"Waiting for vendor patch. Ticket #1234\"\n      expires: \"2025-05-01\"\n    - id: \"container-3.5\"\n      justification: \"Approved exception by security team. Ticket #5678\"\n      expires: \"2025-06-15\"\n</code></pre>"},{"location":"tasks/thresholds-configuration/#step-5-integrate-with-saf-cli","title":"Step 5: Integrate with SAF-CLI","text":"<p>Security Consideration</p> <p>Automated threshold validation ensures consistent application of security standards across all scans.</p> <ol> <li>Use SAF-CLI to evaluate scan results against your threshold configuration:</li> </ol> <pre><code># Check scan results against a threshold file\nsaf threshold -i scan-results.json -t threshold.yml\n\n# Check exit code to determine pass/fail\nif [ $? -eq 0 ]; then\n  echo \"\u2705 Security scan passed threshold requirements\"\nelse\n  echo \"\u274c Security scan failed to meet threshold requirements\"\nfi\n</code></pre> <ol> <li>For command-line thresholds without a file:</li> </ol> <pre><code># Directly specify threshold criteria in the command\nsaf threshold -i scan-results.json -t 80 --failed-critical 0 --failed-high 2\n</code></pre>"},{"location":"tasks/thresholds-configuration/#step-6-implement-in-cicd-pipelines","title":"Step 6: Implement in CI/CD Pipelines","text":"<p>Security Consideration</p> <p>CI/CD pipelines should enforce thresholds automatically to prevent manual override of security controls.</p> <p>Add threshold checking to your CI/CD pipeline:</p> <p>GitHub Actions example:</p> <pre><code>- name: Check security thresholds\n  run: |\n    # Configure threshold file based on environment\n    if [[ \"${{ github.ref }}\" == \"refs/heads/main\" ]]; then\n      # Use production thresholds for main branch\n      cp production-threshold.yml threshold.yml\n    else\n      # Use development thresholds for other branches\n      cp development-threshold.yml threshold.yml\n    fi\n\n    # Apply threshold check\n    saf threshold -i scan-results.json -t threshold.yml\n    THRESHOLD_RESULT=$?\n\n    # Record result\n    if [ $THRESHOLD_RESULT -eq 0 ]; then\n      echo \"\u2705 Security scan passed threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n    else\n      echo \"\u274c Security scan failed to meet threshold requirements\" | tee -a $GITHUB_STEP_SUMMARY\n      # Fail the workflow when thresholds are not met\n      exit $THRESHOLD_RESULT\n    fi\n</code></pre> <p>GitLab CI example:</p> <pre><code>threshold_check:\n  stage: verify\n  script:\n    - |\n      # Configure threshold file based on environment\n      if [[ \"${CI_COMMIT_BRANCH}\" == \"main\" ]]; then\n        # Use production thresholds for main branch\n        cp production-threshold.yml threshold.yml\n      else\n        # Use development thresholds for other branches\n        cp development-threshold.yml threshold.yml\n      fi\n\n      # Apply threshold check\n      saf threshold -i scan-results.json -t threshold.yml\n      THRESHOLD_RESULT=$?\n\n      # Record result\n      if [ $THRESHOLD_RESULT -eq 0 ]; then\n        echo \"\u2705 Security scan passed threshold requirements\"\n      else\n        echo \"\u274c Security scan failed to meet threshold requirements\"\n        # Fail the job when thresholds are not met\n        exit $THRESHOLD_RESULT\n      fi\n</code></pre>"},{"location":"tasks/thresholds-configuration/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Version control all threshold configurations to track changes over time</li> <li>Implement a review process for threshold modifications, especially exceptions</li> <li>Document all control exceptions with clear justification and expiration dates</li> <li>Use progressively stricter thresholds moving from development to production</li> <li>Gradually increase threshold requirements over time as security posture improves</li> <li>Regularly review threshold compliance reports to identify systemic issues</li> <li>Update thresholds when new security controls or compliance requirements emerge</li> </ul>"},{"location":"tasks/thresholds-configuration/#verification-steps","title":"Verification Steps","text":"<ol> <li>Test your threshold configuration with a known scan result</li> </ol> <pre><code># Test against an existing result file\nsaf threshold -i scan-results.json -t threshold.yml\necho $?\n</code></pre> <ol> <li>Verify that appropriate thresholds are being applied in different environments</li> </ol> <pre><code># Check which threshold file is being used in your pipeline\ncat threshold.yml\n</code></pre> <ol> <li>Validate exception handling by testing with scan results containing known exceptions</li> </ol> <pre><code># Run with debug output to see detailed decision making\nsaf threshold -i scan-results.json -t threshold.yml --debug\n</code></pre>"},{"location":"tasks/thresholds-configuration/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Threshold always fails regardless of configuration Verify the format of your threshold.yml file and ensure it follows the correct schema Exceptions not being recognized Check that control IDs match exactly with those in scan results SAF-CLI not recognizing the threshold file Ensure you're using the latest version of SAF-CLI with <code>npm update -g @mitre/saf</code> CI/CD pipeline ignoring threshold failures Verify that the pipeline is configured to properly use the exit code from saf threshold Inconsistent threshold behavior Check for multiple threshold configurations being applied and standardize where needed"},{"location":"tasks/thresholds-configuration/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Integrate with GitHub Actions to automatically enforce thresholds in GitHub workflows</li> <li>Integrate with GitLab CI to automatically enforce thresholds in GitLab pipelines</li> <li>Define custom scanning profiles to better align with your threshold requirements</li> <li>Implement reporting procedures for threshold violations</li> </ul>"},{"location":"tasks/thresholds-configuration/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Compliance Integration</li> <li>Risk Assessment Model</li> <li>Threshold Integration</li> <li>Security Workflows</li> </ul>"},{"location":"tasks/token-management/","title":"Token Management","text":""},{"location":"tasks/token-management/#overview","title":"Overview","text":"<p>Security Emphasis</p> <p>Secure token management is critical for maintaining the security integrity of your Kubernetes scanning operations. This task implements best practices for generating, using, and rotating short-lived tokens to minimize the risk of credential compromise.</p> <p>This task guides you through implementing secure token management for Kube CINC Secure Scanner. By following this approach, you'll create ephemeral, least-privilege access tokens for scanning operations that automatically expire after use.</p> <p>Time to complete: 20-30 minutes</p> <p>Security risk: \ud83d\udd34 High - Involves creation and management of authentication credentials</p> <p>Security approach: Implements ephemeral credentials with time-based expiration, least-privilege access controls, and secure token delivery mechanisms</p>"},{"location":"tasks/token-management/#security-architecture","title":"Security Architecture","text":"Understanding Permission Layers <p>Token management for container scanning involves multiple security layers:</p> <p>1. Token Generation Permissions * Control: Who can create authentication tokens for service accounts * Risk area: Unrestricted token generation could lead to unauthorized cluster access * Mitigation: Limit token creation to authorized administrators or automated systems with strict controls</p> <p>2. Token Usage Permissions * Control: What the token can access within the Kubernetes API * Risk area: Overly permissive tokens could grant excessive access * Mitigation: Bind tokens to service accounts with precisely scoped RBAC permissions</p> <p>3. Token Storage &amp; Transmission * Control: How tokens are stored, transmitted, and protected * Risk area: Token exposure could lead to credential theft * Mitigation: Implement secure storage, encrypted transmission, and automatic token expiration</p>"},{"location":"tasks/token-management/#security-prerequisites","title":"Security Prerequisites","text":"<ul> <li> Kubernetes cluster with TokenRequest API enabled (v1.22+)</li> <li> Service accounts and RBAC roles created (see RBAC Setup)</li> <li> Administrative access to generate tokens</li> <li> Understanding of Kubernetes RBAC and authentication mechanisms</li> </ul>"},{"location":"tasks/token-management/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"tasks/token-management/#step-1-understanding-token-types","title":"Step 1: Understanding Token Types","text":"<p>Security Consideration</p> <p>Different token types have different security properties and lifetimes. Short-lived tokens are strongly preferred.</p> <p>Kubernetes supports several token types:</p> <ol> <li>Service Account Tokens (pre-v1.24): Long-lived tokens stored in secrets</li> <li>TokenRequest API Tokens (v1.22+): Short-lived tokens with configurable expiration</li> <li>Bound Service Account Tokens: Tokens bound to specific audiences and use cases</li> </ol> <p>For security reasons, we'll use the TokenRequest API to generate short-lived tokens.</p>"},{"location":"tasks/token-management/#step-2-generate-short-lived-tokens","title":"Step 2: Generate Short-Lived Tokens","text":"<p>Security Consideration</p> <p>Always set an appropriate expiration time based on the expected duration of the scanning operation.</p> <ol> <li>Generate a token with a 15-minute expiration:</li> </ol> <pre><code># Create a token that expires in 15 minutes\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\necho $TOKEN\n</code></pre> <ol> <li>For automated scripts, save the token securely:</li> </ol> <pre><code># Save token to a protected file with restricted permissions\necho $TOKEN &gt; scanner-token.txt\nchmod 600 scanner-token.txt\n</code></pre>"},{"location":"tasks/token-management/#step-3-create-a-secure-kubeconfig-file","title":"Step 3: Create a Secure Kubeconfig File","text":"<p>Security Consideration</p> <p>Kubeconfig files contain sensitive credentials and should be protected accordingly.</p> <ol> <li>Generate a kubeconfig file using the token:</li> </ol> <pre><code># Get cluster information\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Create the kubeconfig file\ncat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: scanner-namespace\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${TOKEN}\nEOF\n\n# Set proper permissions\nchmod 600 scanner-kubeconfig.yaml\n</code></pre>"},{"location":"tasks/token-management/#step-4-implement-token-rotation","title":"Step 4: Implement Token Rotation","text":"<p>Security Consideration</p> <p>Automated token rotation ensures that tokens are regularly refreshed, limiting the exposure window.</p> <ol> <li>Create a shell script for token rotation:</li> </ol> <pre><code>#!/bin/bash\n# token-rotation.sh\n\n# Set variables\nSERVICE_ACCOUNT=\"scanner-sa\"\nNAMESPACE=\"scanner-namespace\"\nDURATION=\"15m\"\nKUBECONFIG_PATH=\"./scanner-kubeconfig.yaml\"\n\n# Generate new token\necho \"Generating new token for ${SERVICE_ACCOUNT}...\"\nNEW_TOKEN=$(kubectl create token ${SERVICE_ACCOUNT} -n ${NAMESPACE} --duration=${DURATION})\n\n# Get cluster information\nSERVER=$(kubectl config view --minify --output=jsonpath='{.clusters[0].cluster.server}')\nCA_DATA=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')\n\n# Update kubeconfig file\necho \"Updating kubeconfig file at ${KUBECONFIG_PATH}...\"\ncat &gt; ${KUBECONFIG_PATH} &lt;&lt; EOF\napiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\n    server: ${SERVER}\n    certificate-authority-data: ${CA_DATA}\n  name: scanner-cluster\ncontexts:\n- context:\n    cluster: scanner-cluster\n    namespace: ${NAMESPACE}\n    user: scanner-user\n  name: scanner-context\ncurrent-context: scanner-context\nusers:\n- name: scanner-user\n  user:\n    token: ${NEW_TOKEN}\nEOF\n\n# Set secure permissions\nchmod 600 ${KUBECONFIG_PATH}\n\necho \"Token rotation completed successfully.\"\necho \"Token will expire in ${DURATION}.\"\n</code></pre> <ol> <li>Make the script executable:</li> </ol> <pre><code>chmod +x token-rotation.sh\n</code></pre>"},{"location":"tasks/token-management/#step-5-implement-token-management-in-cicd-pipelines","title":"Step 5: Implement Token Management in CI/CD Pipelines","text":"<p>Security Consideration</p> <p>CI/CD pipelines should generate fresh tokens for each run to maintain security isolation between pipeline executions.</p> <p>GitHub Actions example:</p> <pre><code>jobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Generate Kubernetes token\n        id: generate-token\n        run: |\n          # Create token directly within the workflow\n          TOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\n\n          # Store token as a step output (masked in logs)\n          echo \"::add-mask::$TOKEN\"\n          echo \"token=$TOKEN\" &gt;&gt; $GITHUB_OUTPUT\n\n      - name: Create kubeconfig\n        run: |\n          # Use token from previous step\n          TOKEN=\"${{ steps.generate-token.outputs.token }}\"\n\n          # Create kubeconfig file\n          cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n          apiVersion: v1\n          kind: Config\n          preferences: {}\n          clusters:\n          - cluster:\n              server: ${{ secrets.CLUSTER_SERVER }}\n              certificate-authority-data: ${{ secrets.CLUSTER_CA }}\n            name: scanner-cluster\n          contexts:\n          - context:\n              cluster: scanner-cluster\n              namespace: scanner-namespace\n              user: scanner-user\n            name: scanner-context\n          current-context: scanner-context\n          users:\n          - name: scanner-user\n            user:\n              token: ${TOKEN}\n          EOF\n\n          chmod 600 scanner-kubeconfig.yaml\n\n      - name: Run scan with token\n        run: |\n          KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n scanner-namespace\n          # Additional scanning commands...\n</code></pre> <p>GitLab CI example:</p> <pre><code>generate_token:\n  stage: prepare\n  script:\n    - |\n      # Generate token\n      TOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\n\n      # Save token securely for other jobs\n      echo \"SCANNER_TOKEN=${TOKEN}\" &gt;&gt; tokens.env\n  artifacts:\n    reports:\n      dotenv: tokens.env\n\nsecurity_scan:\n  stage: scan\n  needs: [generate_token]\n  script:\n    - |\n      # Create kubeconfig with token from previous job\n      cat &gt; scanner-kubeconfig.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Config\n      preferences: {}\n      clusters:\n      - cluster:\n          server: ${CLUSTER_SERVER}\n          certificate-authority-data: ${CLUSTER_CA_DATA}\n        name: scanner-cluster\n      contexts:\n      - context:\n          cluster: scanner-cluster\n          namespace: scanner-namespace\n          user: scanner-user\n        name: scanner-context\n      current-context: scanner-context\n      users:\n      - name: scanner-user\n        user:\n          token: ${SCANNER_TOKEN}\n      EOF\n\n      chmod 600 scanner-kubeconfig.yaml\n\n      # Run scan with token\n      KUBECONFIG=scanner-kubeconfig.yaml kubectl get pods -n scanner-namespace\n      # Additional scanning commands...\n</code></pre>"},{"location":"tasks/token-management/#step-6-implement-secure-token-storage-for-non-pipeline-use-cases","title":"Step 6: Implement Secure Token Storage for Non-Pipeline Use Cases","text":"<p>Security Consideration</p> <p>For operations outside CI/CD pipelines, token storage requires additional security measures.</p> <ol> <li>Use environment variables with limited scope:</li> </ol> <pre><code># Set token as environment variable for the current process only\nexport KUBE_TOKEN=\"$(kubectl create token scanner-sa -n scanner-namespace --duration=15m)\"\n\n# Use with kubectl\nkubectl --token=\"$KUBE_TOKEN\" get pods -n scanner-namespace\n</code></pre> <ol> <li>For systems requiring persistent token storage, use a secrets management system:</li> </ol> <pre><code># Example with HashiCorp Vault (if installed)\nvault kv put secret/scanner-tokens/token value=\"$(kubectl create token scanner-sa -n scanner-namespace --duration=60m)\"\n\n# Later retrieve the token\nTOKEN=$(vault kv get -field=value secret/scanner-tokens/token)\n</code></pre>"},{"location":"tasks/token-management/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Generate new tokens for each scanning operation</li> <li>Set appropriate token expiration times (15-60 minutes maximum)</li> <li>Never store tokens in source code repositories</li> <li>Implement proper file permissions (600 or more restrictive) for files containing tokens</li> <li>Use dedicated service accounts with least-privilege RBAC</li> <li>Store tokens in secure, ephemeral locations</li> <li>Implement token rotation for long-running operations</li> <li>Always use HTTPS for API communications</li> <li>Log token creation and usage for auditing purposes</li> <li>Mask tokens in logs and console output</li> <li>Delete token files immediately after use</li> </ul>"},{"location":"tasks/token-management/#verification-steps","title":"Verification Steps","text":"<ol> <li>Verify token expiration</li> </ol> <pre><code># Create token with short expiration\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=1m)\n\n# Use the token immediately\nkubectl --token=$TOKEN get pods -n scanner-namespace\n\n# Wait for token to expire\nsleep 65\n\n# This should fail with an authentication error\nkubectl --token=$TOKEN get pods -n scanner-namespace\n</code></pre> <ol> <li>Verify token permissions</li> </ol> <pre><code># Generate token\nTOKEN=$(kubectl create token scanner-sa -n scanner-namespace --duration=5m)\n\n# Should succeed (assuming proper RBAC)\nkubectl --token=$TOKEN get pods -n scanner-namespace\n\n# Should fail (assuming proper RBAC)\nkubectl --token=$TOKEN get pods -n kube-system\n</code></pre> <ol> <li>Check token security in kubeconfig</li> </ol> <pre><code># Verify file permissions\nls -la scanner-kubeconfig.yaml\n# Should show: -rw------- (600 permissions)\n</code></pre>"},{"location":"tasks/token-management/#troubleshooting","title":"Troubleshooting","text":"Issue Solution 'create token' command not found Upgrade to Kubernetes 1.24+ or use alternative token generation methods Token expired errors Increase token duration slightly or optimize scanning process for faster completion Permission denied with token Verify the service account has appropriate RBAC permissions Tokens visible in CI/CD logs Use secret masking features in your CI/CD platform to prevent token exposure Cannot authenticate with token Check that the token format is correct and hasn't been corrupted during transfer"},{"location":"tasks/token-management/#next-steps","title":"Next Steps","text":"<p>After completing this task, consider:</p> <ul> <li>Implement RBAC setup to align with token permissions</li> <li>Integrate with GitHub Actions using secure token generation</li> <li>Integrate with GitLab CI using secure token generation</li> <li>Configure kubectl for secure operations</li> </ul>"},{"location":"tasks/token-management/#related-security-considerations","title":"Related Security Considerations","text":"<ul> <li>Kubernetes Authentication Methods</li> <li>Ephemeral Credentials</li> <li>Least Privilege Principle</li> <li>Secure Transport</li> </ul>"},{"location":"tokens/","title":"Token Management","text":"<p>Directory Inventory</p> <p>See the Tokens Directory Inventory for a complete listing of files and resources in this directory.</p> <p>This guide covers the creation, usage, and lifecycle management of Kubernetes tokens for secure InSpec scanning.</p>"},{"location":"tokens/#token-types","title":"Token Types","text":""},{"location":"tokens/#short-lived-tokens-recommended","title":"Short-Lived Tokens (Recommended)","text":"<p>Short-lived tokens are created on-demand and expire automatically:</p> <pre><code># Create a token with default expiration (1 hour)\nkubectl create token inspec-scanner -n inspec-test\n\n# Create a token with custom expiration\nkubectl create token inspec-scanner -n inspec-test --duration=30m\n</code></pre> <p>Benefits:</p> <ul> <li>Automatic expiration</li> <li>No token storage/cleanup required</li> <li>Reduced risk if token is exposed</li> </ul>"},{"location":"tokens/#bound-service-account-tokens","title":"Bound Service Account Tokens","text":"<p>For automated pipelines, you can create bound service account tokens:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: scanner-token\n  namespace: inspec-test\n  annotations:\n    kubernetes.io/service-account.name: inspec-scanner\n    kubernetes.io/service-account.expiration: \"86400\"  # 24 hours in seconds\ntype: kubernetes.io/service-account-token\n</code></pre> <p>Benefits:</p> <ul> <li>Configurable expiration</li> <li>Can be rotated with Kubernetes secrets rotation</li> <li>Compatible with older Kubernetes tooling</li> </ul>"},{"location":"tokens/#token-generation-in-cicd-pipelines","title":"Token Generation in CI/CD Pipelines","text":""},{"location":"tokens/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>stages:\n  - scan\n\nvariables:\n  KUBE_NAMESPACE: inspec-test\n\ncreate_token:\n  stage: scan\n  script:\n    - TOKEN=$(kubectl create token inspec-scanner -n $KUBE_NAMESPACE)\n    - echo \"SCAN_TOKEN=$TOKEN\" &gt;&gt; scan_credentials.env\n  artifacts:\n    reports:\n      dotenv: scan_credentials.env\n\nrun_scan:\n  stage: scan\n  needs: [create_token]\n  script:\n    - echo \"$SCAN_TOKEN\" &gt; token.txt\n    - ./run_scan.sh token.txt\n  artifacts:\n    reports:\n      scan: scan-results.json\n</code></pre>"},{"location":"tokens/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>jobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Generate Token\n        id: generate-token\n        run: |\n          TOKEN=$(kubectl create token inspec-scanner -n inspec-test)\n          echo \"::set-output name=token::$TOKEN\"\n\n      - name: Run Scan\n        run: |\n          echo \"${{ steps.generate-token.outputs.token }}\" &gt; token.txt\n          ./run_scan.sh token.txt\n</code></pre>"},{"location":"tokens/#token-security-best-practices","title":"Token Security Best Practices","text":"<ol> <li>Short Expiration: Use the shortest practical token expiration</li> <li>Just-in-Time Creation: Generate tokens when needed, not in advance</li> <li>Secure Storage: Store tokens in secure CI/CD variables or secrets</li> <li>Mask in Logs: Ensure tokens are masked in CI/CD logs</li> <li>Single-Use: Use each token only once, then discard</li> <li>Audience Restriction: If possible, restrict token audience</li> </ol>"},{"location":"tokens/#token-expiration-testing","title":"Token Expiration Testing","text":"<p>Test token expiration to ensure your system handles it gracefully:</p> <pre><code># Create a token with short expiration\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test --duration=30s)\n\n# Save token to a file\necho \"$TOKEN\" &gt; test-token.txt\n\n# Use token immediately (should work)\nKUBECONFIG=&lt;your-config&gt; K8S_AUTH_TOKEN=$(cat test-token.txt) inspec exec ...\n\n# Wait for expiration\nsleep 35\n\n# Try again (should fail)\nKUBECONFIG=&lt;your-config&gt; K8S_AUTH_TOKEN=$(cat test-token.txt) inspec exec ...\n</code></pre>"},{"location":"tokens/#token-audit-and-troubleshooting","title":"Token Audit and Troubleshooting","text":""},{"location":"tokens/#decoding-tokens","title":"Decoding Tokens","text":"<pre><code># Get the token\nTOKEN=$(kubectl create token inspec-scanner -n inspec-test)\n\n# Decode token payload (middle section)\necho $TOKEN | cut -d. -f2 | base64 -d 2&gt;/dev/null | jq .\n</code></pre> <p>This shows token metadata including:</p> <ul> <li>Expiration time</li> <li>Subject (service account)</li> <li>Audience</li> <li>Issuer</li> </ul>"},{"location":"tokens/#verifying-token-privileges","title":"Verifying Token Privileges","text":"<pre><code># Use auth can-i to check permissions with a token\nkubectl auth can-i get pods --namespace=inspec-test --token=$TOKEN\n\n# Check specific resource access\nkubectl auth can-i create pods/exec --namespace=inspec-test --token=$TOKEN --resource-name=target-pod\n</code></pre>"},{"location":"tokens/#references","title":"References","text":"<ul> <li>Kubernetes Authentication Documentation</li> <li>Managing Service Account Tokens</li> <li>Token Request API</li> </ul>"},{"location":"tokens/inventory/","title":"Tokens Directory Inventory","text":"<p>This document provides a directory overview of the token management resources and documentation.</p>"},{"location":"tokens/inventory/#directory-contents","title":"Directory Contents","text":"<p>The tokens directory contains documentation for creating and managing Kubernetes tokens for secure container scanning:</p> <ul> <li>README.md: Original documentation (being migrated to this structure)</li> <li>index.md: Main MkDocs documentation page for token management</li> </ul>"},{"location":"tokens/inventory/#token-management-features","title":"Token Management Features","text":"<p>This directory covers token management best practices:</p> <ul> <li>Token Types: Comparison of short-lived tokens vs. bound service account tokens</li> <li>Token Generation: Methods for generating tokens in different environments</li> <li>CI/CD Integration: Examples of token usage in GitLab CI and GitHub Actions</li> <li>Security Practices: Guidelines for secure token handling</li> <li>Token Testing: Techniques for testing token expiration and validity</li> <li>Auditing and Troubleshooting: Methods for debugging token issues</li> </ul>"},{"location":"tokens/inventory/#security-focus","title":"Security Focus","text":"<p>The documentation emphasizes secure token management:</p> <ul> <li>Using the shortest practical token expiration times</li> <li>Just-in-time token creation workflows</li> <li>Secure storage of tokens in CI/CD pipelines</li> <li>Token masking in logs to prevent exposure</li> <li>Single-use token patterns</li> <li>Token audience restrictions</li> </ul>"},{"location":"tokens/inventory/#related-resources","title":"Related Resources","text":"<ul> <li>Service Accounts</li> <li>RBAC Configuration</li> <li>Kubeconfig Configuration</li> <li>Security Overview</li> </ul>"},{"location":"utilities/","title":"Utilities and Tools","text":"<p>This section contains documentation for various utilities and tools that support the Secure CINC Auditor Kubernetes Container Scanning solution.</p>"},{"location":"utilities/#overview","title":"Overview","text":"<p>The utilities documentation provides information about supporting tools and utilities that enhance the development, documentation, and usage of the scanning solution. These utilities are not core to the scanning functionality but provide valuable support for developers and users working with the system.</p> <p>The current focus is on documentation tools, particularly for converting legacy ASCII diagrams to Mermaid-based diagrams for better visualization and maintenance. Additional utilities may be added to this section as they are developed.</p>"},{"location":"utilities/#available-utilities","title":"Available Utilities","text":"<p>The following utilities are currently documented:</p> <ul> <li>ASCII to Mermaid Conversion - Tools and guidance for converting ASCII diagrams to Mermaid diagrams</li> </ul>"},{"location":"utilities/#future-additions","title":"Future Additions","text":"<p>We plan to add documentation for additional utilities in the future, including:</p> <ul> <li>Documentation validation scripts</li> <li>Testing utilities</li> <li>Configuration generators</li> <li>Report formatting tools</li> </ul>"},{"location":"utilities/#contributing","title":"Contributing","text":"<p>If you have developed a utility that would be useful for the project, please see the Contributing Guide for information on how to submit it for inclusion in the project.</p>"},{"location":"utilities/ascii-to-mermaid/","title":"ASCII to Mermaid Diagram Conversion","text":"<p>This document demonstrates the conversion of ASCII diagrams to Mermaid diagrams for better visualization in the documentation.</p>"},{"location":"utilities/ascii-to-mermaid/#example-1-basic-workflow","title":"Example 1: Basic Workflow","text":""},{"location":"utilities/ascii-to-mermaid/#original-ascii-diagram","title":"Original ASCII Diagram","text":"<pre><code>+--------+     +---------------+     +----------------+\n| Start  |----&gt;| Create RBAC   |----&gt;| Generate Token |\n+--------+     +---------------+     +----------------+\n                                           |\n                                           v\n+--------+     +---------------+     +----------------+\n|  End   |&lt;----| Run Results   |&lt;----| Execute Scan   |\n+--------+     +---------------+     +----------------+\n</code></pre>"},{"location":"utilities/ascii-to-mermaid/#converted-mermaid-diagram","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart LR\n    A[Start] --&gt; B[Create RBAC]\n    B --&gt; C[Generate Token]\n    C --&gt; D[Execute Scan]\n    D --&gt; E[Run Results]\n    E --&gt; F[End]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:2px\n    style F fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"utilities/ascii-to-mermaid/#example-2-container-relationships","title":"Example 2: Container Relationships","text":""},{"location":"utilities/ascii-to-mermaid/#original-ascii-diagram_1","title":"Original ASCII Diagram","text":"<pre><code>+------------------------------------------+\n| Pod                                      |\n|  +-------------+     +---------------+   |\n|  | Application |&lt;---&gt;| Sidecar       |   |\n|  | Container   |     | Scanner       |   |\n|  +-------------+     +---------------+   |\n|         |                  |             |\n|         v                  v             |\n|  +-----------------------------------+   |\n|  | Shared Process Namespace          |   |\n|  +-----------------------------------+   |\n+------------------------------------------+\n</code></pre>"},{"location":"utilities/ascii-to-mermaid/#converted-mermaid-diagram_1","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart TD\n    subgraph Pod\n        A[Application Container] &lt;--&gt; B[Sidecar Scanner]\n        A --&gt; C[Shared Process Namespace]\n        B --&gt; C\n    end\n\n    style A fill:#bbf,stroke:#333,stroke-width:2px\n    style B fill:#bfb,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px</code></pre>"},{"location":"utilities/ascii-to-mermaid/#example-3-approach-decision-tree","title":"Example 3: Approach Decision Tree","text":""},{"location":"utilities/ascii-to-mermaid/#original-ascii-diagram_2","title":"Original ASCII Diagram","text":"<pre><code>                 +------------------+\n                 | Container Type?  |\n                 +------------------+\n                         |\n          +--------------+---------------+\n          |                              |\n          v                              v\n+------------------+            +------------------+\n| Standard         |            | Distroless       |\n+------------------+            +------------------+\n          |                              |\n          v                              v\n+------------------+            +------------------+\n| Kubernetes API   |            | Debug Available? |\n| Approach         |            +------------------+\n+------------------+                     |\n                             +-----------+----------+\n                             |                      |\n                             v                      v\n                    +------------------+   +------------------+\n                    | Debug Container  |   | Sidecar         |\n                    | Approach         |   | Approach        |\n                    +------------------+   +------------------+\n</code></pre>"},{"location":"utilities/ascii-to-mermaid/#converted-mermaid-diagram_2","title":"Converted Mermaid Diagram","text":"<pre><code>flowchart TD\n    A{Container Type?} --&gt;|Standard| B[Kubernetes API Approach]\n    A --&gt;|Distroless| C{Debug Available?}\n    C --&gt;|Yes| D[Debug Container Approach]\n    C --&gt;|No| E[Sidecar Approach]\n\n    style A fill:#fbb,stroke:#333,stroke-width:2px\n    style B fill:#bfb,stroke:#333,stroke-width:2px\n    style C fill:#fbb,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px</code></pre>"},{"location":"utilities/ascii-to-mermaid/#conversion-benefits","title":"Conversion Benefits","text":"<p>Converting ASCII diagrams to Mermaid offers several advantages:</p> <ol> <li>Improved readability - Mermaid diagrams are more visually appealing and easier to read</li> <li>Theme compatibility - Mermaid diagrams adapt to light/dark themes automatically</li> <li>Maintainability - Mermaid syntax is more structured and easier to modify</li> <li>Interactive features - Diagrams can be made interactive with clickable elements</li> <li>Consistency - Unified diagram style across the documentation</li> </ol>"},{"location":"utilities/ascii-to-mermaid/#conversion-process","title":"Conversion Process","text":"<p>When converting ASCII to Mermaid:</p> <ol> <li>Identify the core elements and relationships in the ASCII diagram</li> <li>Choose the appropriate Mermaid diagram type (flowchart, sequence, etc.)</li> <li>Map each ASCII element to its Mermaid counterpart</li> <li>Add styling to improve visual clarity</li> <li>Test the diagram in both light and dark modes</li> </ol>"},{"location":"utilities/ascii-to-mermaid/#example-syntax-comparison","title":"Example Syntax Comparison","text":""},{"location":"utilities/ascii-to-mermaid/#ascii-syntax-difficult-to-maintain","title":"ASCII Syntax (difficult to maintain)","text":"<pre><code>+--------+     +---------------+\n| Start  |----&gt;| Middle Step   |\n+--------+     +---------------+\n                      |\n                      v\n               +---------------+\n               | End Step      |\n               +---------------+\n</code></pre>"},{"location":"utilities/ascii-to-mermaid/#mermaid-syntax-structured-and-maintainable","title":"Mermaid Syntax (structured and maintainable)","text":"<pre><code>flowchart TD\n    A[Start] --&gt; B[Middle Step]\n    B --&gt; C[End Step]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C fill:#f9f,stroke:#333,stroke-width:2px\n</code></pre> <p>Which renders as:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Middle Step]\n    B --&gt; C[End Step]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style C fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"utilities/inventory/","title":"Utilities Directory Contents","text":"<p>This page provides an inventory of all files in the utilities section of the documentation.</p>"},{"location":"utilities/inventory/#files-in-this-directory","title":"Files in this Directory","text":"File Description index.md Overview of utilities and tools ascii-to-mermaid.md Guide for converting ASCII diagrams to Mermaid format"},{"location":"utilities/inventory/#related-links","title":"Related Links","text":"<ul> <li>Contributing Guide</li> <li>Project Documentation</li> <li>Documentation Tools</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/","title":"MkDocs Link Fixer - Enhancement Proposal","text":""},{"location":"utilities/mkdocs-link-fixer-proposal/#overview","title":"Overview","text":"<p>The current <code>fix-links-simple.sh</code> script provides a foundation for a potentially valuable tool for the broader MkDocs community. This document outlines a proposal to enhance and extend this script into a full-featured solution for maintaining documentation cross-references during reorganizations.</p>"},{"location":"utilities/mkdocs-link-fixer-proposal/#problem-statement","title":"Problem Statement","text":"<p>Documentation reorganizations frequently lead to broken cross-references, especially in large projects. When files are moved, renamed, or restructured (particularly when transitioning from flat structures to nested ones), maintaining correct internal links becomes challenging. This is a common pain point across the MkDocs ecosystem.</p>"},{"location":"utilities/mkdocs-link-fixer-proposal/#current-solution","title":"Current Solution","text":"<p>Our current <code>fix-links-simple.sh</code> script provides:</p> <ul> <li>Detection and fixing of standard Markdown links</li> <li>Support for directory-style links (with trailing slashes)</li> <li>Mapping-based approach for link transformations</li> <li>Detailed metrics and reporting</li> <li>Support for dry-run preview</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#enhancement-vision","title":"Enhancement Vision","text":""},{"location":"utilities/mkdocs-link-fixer-proposal/#core-functionality-improvements","title":"Core Functionality Improvements","text":"<ol> <li>MkDocs Configuration Integration</li> <li>Parse <code>mkdocs.yml</code> to understand the navigation structure</li> <li>Auto-generate mappings based on the navigation hierarchy</li> <li> <p>Support navigation structure changes between versions</p> </li> <li> <p>Dynamic Mapping Generation</p> </li> <li>Detect common patterns (like <code>dir.md</code> \u2192 <code>dir/index.md</code>) automatically</li> <li>Generate mappings by scanning directory structure</li> <li> <p>Option to auto-detect moved files using git history</p> </li> <li> <p>Extensible Path Strategies</p> </li> <li>Support different link path strategies (relative vs. absolute)</li> <li>Handle MkDocs' specific URL handling and path normalization</li> <li> <p>Support various permalink styles</p> </li> <li> <p>Enhanced Reporting</p> </li> <li>Generate HTML reports with clickable links</li> <li>Provide visualization of link changes</li> <li> <p>Integration with MkDocs build process (as a plugin)</p> </li> <li> <p>Cross-Repository Support</p> </li> <li>Handle documentation spread across multiple repositories</li> <li> <p>Support for versioned documentation</p> </li> <li> <p>Interactive Mode</p> </li> <li>Prompt for confirmation on complex changes</li> <li> <p>Suggest fixes for ambiguous cases</p> </li> <li> <p>Advanced Features</p> </li> <li>Link validity checking against live site</li> <li>Support for API documentation integration</li> <li>Support for multiple documentation formats (Markdown, reStructuredText)</li> </ol>"},{"location":"utilities/mkdocs-link-fixer-proposal/#technical-implementation-options","title":"Technical Implementation Options","text":"<ol> <li>Standalone Tool</li> <li>Create a proper Python package installable via pip</li> <li>Add proper command-line interface with argparse</li> <li> <p>Include comprehensive documentation</p> </li> <li> <p>MkDocs Plugin</p> </li> <li>Create a plugin that runs during the build process</li> <li>Add hooks for pre-build and post-build phases</li> <li> <p>Integrate with MkDocs' internal link processing</p> </li> <li> <p>CI/CD Integration</p> </li> <li>Package as a GitHub Action for CI/CD workflows</li> <li>Automate documentation maintenance in PRs</li> </ol>"},{"location":"utilities/mkdocs-link-fixer-proposal/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"utilities/mkdocs-link-fixer-proposal/#phase-1-foundation-1-2-months","title":"Phase 1: Foundation (1-2 months)","text":"<ul> <li>Rewrite script in Python for better maintainability and cross-platform support</li> <li>Implement proper command-line interface</li> <li>Add unit tests for core functionality</li> <li>Create basic documentation</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#phase-2-advanced-features-2-3-months","title":"Phase 2: Advanced Features (2-3 months)","text":"<ul> <li>Add MkDocs configuration parsing</li> <li>Implement dynamic mapping generation</li> <li>Add interactive mode</li> <li>Enhance reporting with HTML output</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#phase-3-integration-1-2-months","title":"Phase 3: Integration (1-2 months)","text":"<ul> <li>Develop MkDocs plugin version</li> <li>Create GitHub Action</li> <li>Add CI/CD integration examples</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#phase-4-community-engagement-ongoing","title":"Phase 4: Community Engagement (Ongoing)","text":"<ul> <li>Submit to MkDocs community resources</li> <li>Share on documentation forums</li> <li>Create a dedicated repository with contribution guidelines</li> <li>Collect and implement community feedback</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#resource-requirements","title":"Resource Requirements","text":"<ul> <li>Development time: 4-7 months (part-time)</li> <li>Testing environments for various MkDocs configurations</li> <li>Documentation hosting</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#benefits","title":"Benefits","text":"<ul> <li>Reduce maintenance burden for documentation reorganizations</li> <li>Improve documentation quality by maintaining correct cross-references</li> <li>Enhance MkDocs ecosystem with specialized tooling</li> <li>Potential to become a standard tool in documentation maintenance workflows</li> </ul>"},{"location":"utilities/mkdocs-link-fixer-proposal/#next-steps","title":"Next Steps","text":"<ol> <li>Seek feedback on this proposal from the team</li> <li>Evaluate resource availability for initial development</li> <li>Create a prototype Python implementation</li> <li>Test with our existing documentation to validate approach</li> </ol>"},{"location":"utilities/mkdocs-link-fixer-proposal/#references","title":"References","text":"<ul> <li>Current <code>fix-links-simple.sh</code> script</li> <li>MkDocs Documentation</li> <li>MkDocs Plugins</li> <li>Python-Markdown Extension Development</li> </ul>"}]}